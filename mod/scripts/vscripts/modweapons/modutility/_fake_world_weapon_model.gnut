untyped
global function FakeWorldModelForWeapon_Init

global function FakeWorldModel_CreateForWeapon
global function FakeWorldModel_DestroyForWeapon

global function FakeWorldModel_AddModToAutoReplaceModel

struct FakeWeaponModelReplace
{
	string modName
	asset model
	string attachment
	float humanScale // modelscale when used by non-titans
	float titanScale // modelscale when used by titans
	bool hideOrgWeapon
}

struct
{
	table<entity, bool> weaponsHiddenByAutoThink
    table<entity, entity> weaponFakeProp

	// settings table
	table< string, array<FakeWeaponModelReplace> > replacementModelSettings
} file

void function FakeWorldModelForWeapon_Init()
{
    // adding fake model for fake weapons
	RegisterSignal( "DestroyFakeModel" )
	AddCallback_OnClientConnected( OnClientConnected )
}

void function OnClientConnected( entity player )
{
    thread FakeWeaponModelModsThink( player )
}

void function FakeWeaponModelModsThink( entity player )
{
	player.EndSignal( "OnDestroy" )

    while ( true )
    {
        // try to create ourselves a fake weapon model if we have titan weapon active
        // also hide that weapon
        WaitFrame( true ) // bypass script fps limit for better visual

        if ( !IsAlive( player ) )
            continue

        array<entity> weapons
        weapons.extend( player.GetMainWeapons() )
        weapons.extend( player.GetOffhandWeapons() )
 
		foreach ( entity weapon in weapons )
		{
			if ( !( weapon in file.weaponsHiddenByAutoThink ) )
			{
				if ( WeaponHasReplacementModel( weapon ) && ShouldCurrentWeaponHideOrgWeapon( weapon ) )
				{
					//print( "trying to hide it!" )
					weapon.kv.rendermode = 4
					weapon.kv.renderamt = 0
					file.weaponsHiddenByAutoThink[ weapon ] <- true
					thread TrackWeaponAutoHidden( player, weapon )// restore weapon visibility on owner death
				}
			}
			else
			{
				if ( !WeaponHasReplacementModel( weapon ) || !ShouldCurrentWeaponHideOrgWeapon( weapon ) )
				{
					weapon.kv.rendermode = 0
					weapon.kv.renderamt = 255
					delete file.weaponsHiddenByAutoThink[ weapon ]
				}
			}
		}

		entity activeWeapon = player.GetActiveWeapon()
		if ( IsValid( activeWeapon ) )
		{
			if ( WeaponHasReplacementModel( activeWeapon ) )
			{
				//print( "we got pilot's active titan weapon: " + string( activeWeapon ) )
				if ( !( activeWeapon in file.weaponFakeProp ) )
					file.weaponFakeProp[ activeWeapon ] <- null

				if ( !IsValid( file.weaponFakeProp[ activeWeapon ] ) )
				{
					entity fakeWeapon = FakeWorldModel_CreateForWeapon( activeWeapon, GetCurrentWeaponReplacementModel( activeWeapon ), GetCurrentWeaponReplacementModelAttachment( activeWeapon ), false )
					fakeWeapon.kv.modelscale = GetCurrentWeaponReplacementModelScale( activeWeapon )
					file.weaponFakeProp[ activeWeapon ] = fakeWeapon
				}
			}
		}
	}
}

// restore weapon visibility on owner death
void function TrackWeaponAutoHidden( entity owner, entity weapon )
{
	owner.EndSignal( "OnDestroy" )
	weapon.EndSignal( "OnDestroy" )

	OnThreadEnd
	(
		function(): ( owner, weapon )
		{
			if ( IsValid( weapon ) )
			{
				if ( weapon in file.weaponsHiddenByAutoThink )
				{
					weapon.kv.rendermode = 0
					weapon.kv.renderamt = 255
					delete file.weaponsHiddenByAutoThink[ weapon ]
				}
			}
		}
	)

	owner.WaitSignal( "OnDeath" )
}

entity function FakeWorldModel_CreateForWeapon( entity weapon, asset model, string attachment = "PROPGUN", bool hideOrgWeapon = true )
{
    //print( "RUNNING FakeWorldModel_CreateForWeapon()" )
	entity owner = weapon.GetWeaponOwner()
	//print( "weapon owner: " + string( owner ) )
	if ( !IsValid( owner ) )
		return
	if ( owner.LookupAttachment( attachment ) == -1 )
		return
    
	entity prop = CreatePropDynamic( model, owner.GetOrigin(), owner.GetAngles() )
	prop.SetParent( owner, attachment )
	prop.Highlight_SetInheritHighlight( true ) // setup highlight
	//print( "Creating fake model!" )

	thread TrackFakeModelLifeTime( weapon, owner, prop, hideOrgWeapon )

    return prop
}

void function TrackFakeModelLifeTime( entity weapon, entity owner, entity prop, bool hideOrgWeapon )
{
	// this hides original weapon
	if ( hideOrgWeapon )
	{
		weapon.kv.rendermode = 4
		weapon.kv.renderamt = 0
	}

	prop.EndSignal( "OnDestroy" )

	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	weapon.Signal( "DestroyFakeModel" )
	weapon.EndSignal( "OnDestroy" )
	weapon.EndSignal( "DestroyFakeModel" )

	OnThreadEnd
	(
		function(): ( weapon, prop, hideOrgWeapon )
		{
			// restore weapon visibility
			if ( IsValid( weapon ) && hideOrgWeapon )
			{
				weapon.kv.rendermode = 0
                weapon.kv.renderamt = 255
			}

			if ( IsValid( prop ) )
			{
				//print( "Destroying fake model!" )
				prop.Destroy()
			}
		}
	)

	while ( true )
	{
		entity activeWeapon = owner.GetActiveWeapon()
		if ( weapon.IsWeaponOffhand() ) // our fake model's owner is offhand weapon
		{
			if ( !IsValid( activeWeapon ) )
				return
			if ( activeWeapon != weapon ) // weapon changed!
				return
		}
		else // our fake model's owner is main weapon
		{
			if ( !IsValid( activeWeapon ) )
				return
			if ( activeWeapon.IsWeaponOffhand() ) // active weapon is offhand!
			{
				// check main weapon visiblility
				var keepMainWeaponModel = activeWeapon.GetWeaponInfoFileKeyField( "offhand_keep_primary_in_hand" )
				if ( keepMainWeaponModel == null || !keepMainWeaponModel )
					return
			}
			else if ( activeWeapon != weapon )  // weapon changed!
				return
		}

		//WaitFrame()
		WaitFrame( true ) // bypass script fps limit for better visual
	}
}

void function FakeWorldModel_DestroyForWeapon( entity weapon )
{
    weapon.Signal( "DestroyFakeModel" ) // stop TrackFakeModelLifeTime() thread
}

void function FakeWorldModel_AddModToAutoReplaceModel( string weaponName, string modName, asset model, string attachment, float humanScale, float titanScale, bool hideOrgWeapon )
{
	if ( !( weaponName in file.replacementModelSettings ) )
		file.replacementModelSettings[ weaponName ] <- []
	
	FakeWeaponModelReplace settings
	settings.modName = modName
	settings.model = model
	settings.attachment = attachment
	settings.humanScale = humanScale
	settings.titanScale = titanScale
	settings.hideOrgWeapon = hideOrgWeapon
	file.replacementModelSettings[ weaponName ].append( settings )
}

bool function WeaponHasReplacementModel( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	if ( !( weaponName in file.replacementModelSettings ) )
		return false
	
	array<string> mods = weapon.GetMods()
	foreach ( settings in file.replacementModelSettings[ weaponName ] )
	{
		if ( mods.contains( settings.modName ) )
			return true
	}

	// found nothing
	return false
}

asset function GetCurrentWeaponReplacementModel( entity weapon )
{
	if ( !WeaponHasReplacementModel( weapon ) )
		return $""
	
	asset model
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()
	foreach ( settings in file.replacementModelSettings[ weaponName ] )
	{
		if ( mods.contains( settings.modName ) )
		{
			model = settings.model
			break
		}
	}

	return model
}

string function GetCurrentWeaponReplacementModelAttachment( entity weapon )
{
	if ( !WeaponHasReplacementModel( weapon ) )
		return ""
	
	string attachment
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()
	foreach ( settings in file.replacementModelSettings[ weaponName ] )
	{
		if ( mods.contains( settings.modName ) )
		{
			attachment = settings.attachment
			break
		}
	}

	return attachment
}

float function GetCurrentWeaponReplacementModelScale( entity weapon )
{
	if ( !WeaponHasReplacementModel( weapon ) )
		return 1.0
	
	float scale
	entity owner = weapon.GetWeaponOwner()
	bool ownerIsTitan = IsValid( owner ) && owner.IsTitan()
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()
	foreach ( settings in file.replacementModelSettings[ weaponName ] )
	{
		if ( mods.contains( settings.modName ) )
		{
			if ( ownerIsTitan )
				scale = settings.titanScale
			else
				scale = settings.humanScale
			break
		}
	}

	return scale
}

bool function ShouldCurrentWeaponHideOrgWeapon( entity weapon )
{
	if ( !WeaponHasReplacementModel( weapon ) )
		return true
	
	bool hideOrgWeapon
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()
	foreach ( settings in file.replacementModelSettings[ weaponName ] )
	{
		if ( mods.contains( settings.modName ) )
		{
			hideOrgWeapon = settings.hideOrgWeapon
			break
		}
	}

	return hideOrgWeapon
}