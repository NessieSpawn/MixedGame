untyped

global function ExtraAISpawner_Init

// generic spawn
global function ExtraSpawner_SpawnDropShip // this has featured spectre and stalker spawns, though stalkers can't be set to crouch state on finishing zipline drop
global function ExtraSpawner_SpawnDropPod
// weapon switch think
global function ExtraSpawner_OnEnemyChanged_SwitchToHeavyArmorWeapon

// non-infantry npc spawn
global function ExtraSpawner_SpawnNPCInDropPod
// specialist squads
global function ExtraSpawner_SpawnSpecialistGruntDropShip
global function ExtraSpawner_SpawnSpecialistGruntDropPod
// prowler squad: 2 cqb prowler with 3 small prowlers
global function ExtraSpawner_SpawnProwlerSquadDropPod
// stronger stalker: harder to be dismembered, no faster headshot kills, no more one-critical-hit overload, always overload on death if not getting headshot
global function ExtraSpawner_SpawnOverloadedStalkerDropShip // may seem bad because stalkers can't be set to crouch state on finishing zipline drop
global function ExtraSpawner_SpawnOverloadedStalkerDropPod
global function ExtraSpawner_SetUpOverloadedStalker

// titan spawn
global function ExtraSpawner_SpawnTitan
global function ExtraSpawner_SpawnTitanBT
global function ExtraSpawner_SpawnBossTitan
// utility
global function ExtraSpawner_NPCTitanDrops
global function ExtraSpawner_SetNPCPilotEmbarkedTitanNuke
global function ExtraSpawner_EmbarkedNPCTitanRodeoCounter
global function ExtraSpawner_StopNPCTitanRodeoCounter
global function ExtraSpawner_ScriptedNPCTitanCoreAbility
global function ExtraSpawner_StopNPCTitanCoreAbility
// modded titan registering func
global function ExtraSpawner_RegisterToTitanSpawnList
global function ExtraSpawner_RegisterToBossTitanSpawnList
global function ExtraSpawner_AddScriptedNPCTitanCoreThink

// scripted spawn
global function ExtraSpawner_SpawnGunShip

// pilot-related spawn
global function ExtraSpawner_SpawnPilotElite
global function ExtraSpawner_SpawnPilotCanEmbark
global function ExtraSpawner_SpawnTitanWithPilot
// utility
global function ExtraSpawner_ScriptedNPCPilotTacticalAbility
global function ExtraSpawner_StopNPCPilotTacticalAbility
// registering new ability func
global function ExtraSpawner_AddScriptedNPCPilotAbilityThink

// these settings should be done in prematch, don't do it right after levelLoad
// npc weapons setting func
global function ExtraSpawner_SetNPCWeapons
global function ExtraSpawner_SetNPCSecondaryWeapons // needs AI behavior that included SelectSchedule_SwitchWeapon to work
global function ExtraSpawner_SetNPCAntiTitanWeapons
global function ExtraSpawner_SetNPCGrenadeWeapons
global function ExtraSpawner_SetNPCExtraWeaponMods // mods added by this func will be applied to npcs
// set up funcs
global function ExtraSpawner_ApplyNPCWeapons
global function ExtraSpawner_StartUpdatingNPCWeaponBodyGroup // vanilla missing behavior
global function ExtraSpawner_ApplyNPCGrenadeWeapon // grenade have to be given before DispatchSpawn()
global function ExtraSpawner_ApplyNPCExtraWeaponMods
global function ExtraSpawner_SetUpNPCPilot

// wrapped care package functions
global function ExtraSpawner_SpawnCarePackageToGetWeapons
global function ExtraSpawner_SpawnCarePackageToRefillAmmo
// these settings should be done in prematch, don't do it right after levelLoad
// care package weapons setting func
global function ExtraSpawner_SetCarePackageWeapons
global function ExtraSpawner_SetCarePackageWeaponMods
global function ExtraSpawner_SetCarePackageWeaponModsMultiple
// raw care package function
global function ExtraSpawner_SpawnCarePackage
// carepackage callbacks
global function AddEntityCallback_OnUseCarePackage
global function RemoveEntityCallback_OnUseCarePackage

// tick reaper funcs
global function ExtraSpawner_SpawnReaperCanLaunchTicks
global function ExtraSpawner_SetUpNukeDeathReaper
global function ExtraSpawner_ReaperTickLaunchThink

// npc handlers
// default handlers
global function ExtraSpawner_SquadHandler
global function ExtraSpawner_TitanHandler
global function ExtraSpawner_PilotHandler
global function ExtraSpawner_ReaperHandler
// handler overrides
global function ExtraSpawner_SetSquadHandlerFunc
global function ExtraSpawner_SetNPCHandlerFunc
// disabling default handlers
global function ExtraSpawner_StopDefaultHandler // can't stop squad handler. maybe we need to store squad in a table like dropships?


// settings func
global function ExtraSpawner_SetNPCDamageHistoryLifeTime
global function ExtraSpawner_SetNPCPilotBulletDamageScale
global function ExtraSpawner_SetNPCPilotMaxDPSTaken
global function ExtraSpawner_SetProwlerMeleeDamageScale

// shared utility
global function ExtraSpawner_IsNPCSpawnedFromExtraSpawner
global function ExtraSpawner_IsSquadFromExtraSpawner

// debug
const bool EXTRA_SPAWNER_DEBUG = false

#if EXTRA_SPAWNER_DEBUG
global function PrintPrimaryAttackSignal
#endif // EXTRA_SPAWNER_DEBUG

// these consts are no need to change
const asset CAREPACKAGE_MODEL = $"models/vehicle/escape_pod/escape_pod.mdl"

// hornet model is easier to be hit than straton
// so we'd better pick a random one for balancing
const array<asset> GUNSHIP_VALID_MODELS =
[
	$"models/vehicle/straton/straton_imc_gunship_01.mdl",
	$"models/vehicle/hornet/hornet_fighter.mdl",
]
// gunship trail
const table<string, asset> GUNSHIP_FLIGHT_TRAIL_EFFECTS = 
{
	["L_WING_TIP"]		= $"veh_contrails_01",
	["R_WING_TIP"]		= $"veh_contrails_01",
}
// gunship jet
const table<string, asset> GUNSHIP_JET_BURST_EFFECTS = 
{
	//["L_exhaust_rear_1"]	= $"veh_hornet_jet_full", // not very noticeable
	//["R_exhaust_rear_1"]	= $"veh_hornet_jet_full", // not very noticeable
	["L_exhaust_rear_1"]	= $"veh_jetwash_exit_eng_blast",
	["R_exhaust_rear_1"]	= $"veh_jetwash_exit_eng_blast",
}
// gunship sound
const string GUNSHIP_JET_BURST_SOUND = "coop_scr_militiaintro_dropshipflyin_jetwash"
const float GUNSHIP_JET_BURST_SOUND_COOLDOWN = 3.5 // don't want sound to be played very often

// vanilla never store any damage histroy for npcs, here I do it for fun
// note that this is used as default value, actual value can be modified through ExtraSpawner_SetNPCDamageHistoryLifeTime()
const float NPC_HEALTH_HISTORY_FALLOFF_END = 3.0 // like npcs titans, we may need to scale down damage histroy saving time

// modifiable consts

// npc damage

// npc pilot health
const int NPC_PILOT_MAX_HEALTH = 750
const int NPC_PILOT_MAX_HEALTH_BOSS = 1000

// npc pilot ability
const float NPC_PILOT_MOVE_SPEED_SCALE = 1.25

// damage dealt by pilot multiplyer
// this is now served as default value, can be modified by other files through ExtraSpawner_SetNPCPilotBulletDamageScale()
// we may enable npc headshots and in that case, needs to reduce pilot damage dealt
const float NPC_PILOT_BULLET_DAMAGE_MULTIPLIER = 2.0

// pilot specific damage adjustments
// hardcode version
/*
const int PLAYER_TITAN_MELEE_DAMAGE_NPC_PILOT = 100
const int NPC_TITAN_MELEE_DAMAGE_NPC_PILOT = 300
const int TITAN_SOWRD_DAMAGE_NPC_PILOT = 250
const int TITAN_STEPPING_ON_DAMAGE_NPC_PILOT = 250
*/

// graph capped version
// WIP

// DPS versions
const int NPC_PILOT_MAX_DAMAGE_TAKEN_PER_SECOND = 300 // pilots will only take 300 dmg per second

// damage dealt by prowler multiplyer
// base damage for MP: claw: 80, pounce: 100
// this is now served as default value, can be modified by other files through ExtraSpawner_SetProwlerMeleeDamageScale()
const float PROWLER_MELEE_DAMAGE_MULTIPLIER = 0.5
// damage dealt by prowler to heavy armor units multiplyer
// base damage for MP: claw: 60-80, pounce: 100
// this is now served as default value, can be modified by other files through ExtraSpawner_SetProwlerMeleeDamageScale()
const float PROWLER_MELEE_DAMAGE_MULTIPLIER_HEAVYARMOR = 6.0

// care package
const float CARE_PACKAGE_MESSAGE_INTERVAL = 3.0 // prevent care package spamming message

// basically medium animation pilots!
const array<asset> NPC_PILOT_ALLOWED_MODELS = 
[ 
	// note that only sp pilots and grunt models have proper animation for a npc
	// now leaving only sp pilot models
	// reverted. mp pilot model is good enough for using
	// sp model is now saved exclusively for boss titan spawns
	//$"models/humans/pilots/pilot_medium_stalker_m.mdl", // has been used to fake boss kane
	//$"models/humans/pilots/pilot_medium_stalker_f.mdl", // not uses anywhere, but I think leaving only grapple pilot model is enough
	$"models/humans/pilots/pilot_medium_geist_m.mdl", 
	$"models/humans/pilots/pilot_medium_geist_f.mdl", 
	//$"models/humans/pilots/pilot_medium_reaper_m.mdl", // has been used to fake boss viper
	//$"models/humans/pilots/pilot_medium_reaper_f.mdl", // has been uses to fake boss slone
	/*
	$"models/humans/pilots/sp_medium_geist_f.mdl", 
	$"models/humans/pilots/sp_medium_reaper_m.mdl", 
	$"models/humans/pilots/sp_medium_stalker_m.mdl", 
	*/
	// now leaving only pilot models, for others maybe spawn with their unique titans( like jack in bt, ash in ronin )
	/*
	$"models/humans/grunts/mlt_grunt_lmg.mdl", 
	$"models/humans/grunts/imc_grunt_lmg.mdl", 
	$"models/humans/grunts/imc_grunt_shield_captain.mdl", 
	$"models/Humans/heroes/imc_hero_ash.mdl", 
	$"models/Humans/heroes/imc_hero_blisk.mdl", 
	$"models/humans/heroes/mlt_hero_jack.mdl", 
	$"models/humans/heroes/mlt_hero_sarah.mdl", 
	*/
]

// this array is hardcoded. it only contains models that included "pete_agent.mdl"( mostly SP pilot models )
// if pilot has been setup with model in this array, they'll be change to "behavior_pilot_elite_assassin" which makes them able to switch weapon

// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
// guess I'll remove all sp pilot disembarking/ejecting case...
const array<asset> NPC_PILOT_SWITCH_WEAPON_ALLOWED_MODELS =
[
	/*
	$"models/humans/pilots/sp_medium_geist_f.mdl", 
	$"models/humans/pilots/sp_medium_reaper_m.mdl", 
	$"models/humans/pilots/sp_medium_stalker_m.mdl", 
	*/
]

// this array is hardcoded. it only contains models that included "pete_core.mdl"( most human models except for light and heavy pilots )
// if a pilot spawned with other models, they should always go into ExtraSpawner_SpawnTitanWithPilot() instead of ExtraSpawner_SpawnPilotCanEmbark()
const array<asset> NPC_PILOT_ALL_VALID_MODELS =
[
	// temp stub, until I have time to implement SP model pack mod
]

// for ExtraSpawner_SpawnTitan() picking random titans
struct TitanSpawnStruct
{
	string setFile = ""
	string aiSet = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	// after being embarked by npcs
	string embarkedAiSet = ""
	string embarkedBehavior = ""
	string embarkedTitle = ""

	void functionref( entity ) loadoutFunction = null
	// team skin
	int imcSkinIndex = -1
	int mltSkinIndex = -1
}

// for ExtraSpawner_SpawnBossTitan() picking random titans
struct BossTitanSpawnStruct
{
	string bossName = ""

	string setFile = ""
	string aiSet = ""
	string behavior = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	string bossTitle = ""
	string pilotTitle = ""
	asset characterModel = $""

	void functionref( entity ) loadoutFunction = null
	// skin
	int skinIndex = -1
	int decalIndex = -1
}

// after being embarked by npcs
struct EmbarkedNPCTitanStruct
{
	string embarkedAiSet = ""
	string embarkedBehavior = ""
	string embarkedTitle = ""
}

// vanguard is the chassis that spawn with random loadout
// BT model do have animations for them
// here we store setfile so we can use OverwriteLoadoutWithDefaultsForSetFile() to get loadouts
// and we'll need to store their unique behavior selector, loadout function, ETC
// don't want to add specific spawn logic to allow vanguard choose a certain weapon or registering new weapons for them... that will be too complicated
struct NPCVanguardLoadout
{
	string setFile
	string behaviorSelector
	void functionref( entity ) loadoutFunction // leave this empty means we'll use OverwriteLoadoutWithDefaultsForSetFile() to get loadouts
	array<int> lockedAbilities // make some ability won't change on giving default loadout( this doesn't affect loadoutFunction )
	bool disableRocketPod // this is something funny: titan_buddy.mdl's "back" bodygroup don't have doomed state, it is actually hiding rocket pods. we can use it for fun
	bool useUpgradeCore // change to shield-recharge-only upgrade core
}

struct NPCVanguardPilot
{
	string titanTitle
	string pilotTitle // can't use localized string!
	asset pilotModel
	bool neverEjects = false // if this pilot model isn't suitable for npc combat, we can make them never eject at all
}

struct
{
	// modifiable variables( through functions )
	// npc weapons, should we add a struct to set up mods for them?
	table< string, array<string> > npcMainWeaponsTable
	table< string, array<string> > npcSecondaryWeaponsTable
	table< string, array<string> > npcAntiTitanWeaponsTable
	table< string, array<string> > npcGrenadeWeaponsTable
	table< string, array<string> > npcExtraWeaponModsTable
	// npc titan settings
	table<entity, EmbarkedNPCTitanStruct> soulEmbarkedSettings
	// for ExtraSpawner_SpawnTitan() picking random titans
	table<string, TitanSpawnStruct> titanSpawnList
	// for ExtraSpawner_SpawnBossTitan() picking random titans
	table<string, BossTitanSpawnStruct> bossTitanSpawnList
	// for BossLoadout_Vanguard() picking random loadouts
	array<NPCVanguardLoadout> npcVanguardLoadouts
	array<NPCVanguardPilot> npcVanguardPilots
	// npc handler func
	void functionref( array<entity> ) squadHandlerFunc
	table< string, void functionref( entity ) > npcHandlerFuncs
	// care package, now allowing every weapon to have a custom mod array
	array<string> carePackageWeapons
	table< string, array<string> > carePackageWeaponMods

	// in-file only variables
	// care package, for limiting player care package usages
	array<entity> carePackageUsedPlayers = []
	table< entity, array<void functionref( entity ent, entity package )> > entityCarePackageUsedCallbacks
	table< entity, float > playerLastCarePackageNotifiedTime // prevent care package spamming message
	// for marking the npc as spawn from this file
	table<entity, bool> npcSpawnFromExtraSpawner
	// for marking the npc as one of prowler squad
	table<entity, bool> isProwlerSquadmate
	// scripted npc dialogue
	table<entity, float> npcDialogueNextAllowedTimeOnPlayer
	// gunship forced model for replacement ship spawn
	// this is kinda weird logic... could've reset models in ExtraSpawner_SpawnGunShip()
	//table<entity, asset> gunshipForcedSpawnModel
	// for handling gunship's jet burst sound
	table<entity, float> gunshipJetBurstSoundAllowedTime
	// vanilla never store any damage histroy for npcs, here I do it for fun
	float npcDamageHistoryLifeTime = NPC_HEALTH_HISTORY_FALLOFF_END
	// for fake minimap icon system
	table<entity, entity> npcOwnedFakeMapIconEnt
	// shared minimap think with minion, attached ents ETC.
	table<entity, bool> entEnabledMinimapIcon
	// npc damage multiplier
	table<entity, float> npcPilotBulletDamageScale
	table<entity, int> npcPilotMaxDPSTaken
	table<entity, float> prowlerMeleeDamageScale
	table<entity, float> prowlerMeleeDamageScaleHeavyArmor
	// for updating tick's projectile model, minimap icon stuffs
	table<entity, bool> fragDroneProjectileUpdatedModel
	// for marking this npc squad as spawn from this file
	array<string> npcSquadFromExtraSpawner
	// scripted titan core behavior
	table<string, void functionref( entity titan, entity coreWeapon )> scriptedNPCTitanCoreThink
	// scripted npc pilot behavior
	table<string, void functionref( entity pilot, entity abilityWeapon )> scriptedNPCPilotAbilityThink
	table<entity, bool> npcPilotInScriptedAnim
	table<entity, bool> npcPilotActivatedCloak
	array<entity> npcFakeDecoyEntArray
	table<entity, float> npcPilotPhaseHealthThreshold
	// npc attacking management
	table< entity, array<int> > npcDisabledAttackCapabilityFlags
	// npc execution management
	array<entity> npcVanguardChassisTitan
} file

void function ExtraAISpawner_Init()
{
	if ( IsLobby() ) // prevent unable to enter lobby
		return

	// intilize
	InitCarePackageDefaultSettings()
	InitDefaultNPCWeapons()
	InitDefaultTitanList()
	InitDefaultBossTitanList()
	InitDefaultNPCHandlerFunctions()
	InitDefaultScriptedNPCTitanCore()
	InitDefaultScriptedNPCPilotTactical()
	
	// prowler
	ProwlerPrecache()
	// turret
	TurretPrecache()
	// care package
	RegisterSignal( "PlayerUsedCarePackage" ) // for some grunt mode classes regen their ability?
	PrecacheModel( CAREPACKAGE_MODEL )
	// specialist grunts
	PrecacheModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )
	// npc bt
	PrecacheModel( $"models/titans/buddy/titan_buddy.mdl" )
	// npc handlers
	RegisterSignal( "StopDefaultHandler" )
	// npc titan think
	RegisterSignal( "EmbarkedNPCTitanRodeoCounter" )
	RegisterSignal( "ScriptedNPCTitanCoreAbility" )
	// npc pilot think
	RegisterSignal( "ScriptedNPCPilotTacticalAbility" )
	// gunship 
	RegisterSignal( "GunshipJetBurstEffect" )
	GunshipPrecache()
	// npc weapon bodygroup update
	RegisterSignal( "StartUpdatingNPCWeaponBodyGroup" )
	// npc pilot embarking
	RegisterSignal( "StandUnboardedTitan" )
	// npc weapon switch
	RegisterSignal( "ScriptedWeaponSwitch" )

	AddCallback_OnClientConnected( OnClientConnected )
	// this should be in _ai_pilots.gnut
	//RegisterSignal( "ForceStartMove" ) // the signal as been deleted
	
	AddCallback_OnNpcPilotBecomesTitan( OnNpcPilotBecomesTitan )
	AddCallback_OnNpcTitanBecomesPilot( OnNpcTitanBecomesPilot )
	// modified callback in _ai_pilots.gnut
	AddCallback_OnNPCPilotStartsEmbarkSequence( OnNPCPilotStartsEmbarkSequence )
	
	AddCallback_OnNPCKilled( OnNPCKilled )

	AddCallback_IsValidMeleeExecutionTarget( ExtraSpawner_IsValidExecutionTarget )

	// if npc titan has a pilot inside, reset it's melee damageSourceId
	AddDamageCallbackSourceID( eDamageSourceId.auto_titan_melee, ApplyNormalMeleeIdToNPCTitan )

	// npc damages
	AddDamageFinalCallback( "npc_pilot_elite", NPCPilotDamageAdjustments ) // don't let stepping on or some titan weapon easily kill them
	AddDamageByCallback( "npc_pilot_elite", NPCPilotDamageModifier )

	// npc prowler: scale damage depend on model scale
	AddDamageCallbackSourceID( eDamageSourceId.prowler_melee, ProwlerMeleeDamageModifier )

	// convert imc stalkers to white ones
	// this is hardcode and not vanilla behavior.. just want to add some funny stuff		
	AddSpawnCallback( "npc_stalker", OnStalkerSpawned )

	// pick random gunship model
	// this is hardcoded because hornet model is easier to be hit than straton
	// using team-based model is bad, better pick a random one
	// this is kinda weird logic... could've reset models in ExtraSpawner_SpawnGunShip()
	//AddSpawnCallback( "npc_gunship", OnGunshipSpawned )
	
	// show on minimap if it's spawned by this file
	// we can't handle ticks spawned by grunts, let's just remove all of minimap think about these entities
	//AddSpawnCallback( "npc_dropship", OnDropshipSpawned )
	//AddSpawnCallback( "npc_drone", OnDroneSpawned )

	// this behavior only exists with modified mp_weapon_frag_drone.nut
	// other branches could remove it
	//AddSpawnCallback( "npc_frag_drone", OnTickSpawned )

	// try to set prowlers not alwaysalert, perhaps it can make them start wandering around?
	AddSpawnCallback( "npc_prowler", OnProwlerSpawned )

	// add script minimap icon management for ticks
	// also updates tick can's model
	// this callback is from modified _ai_superspectre.nut
	AddCallback_OnReaperLaunchedFragDroneSpawned( OnLaunchedFragDroneSpawned )

	// crash handle for later we supports leeching?
	AddCallback_EntityChangedTeam( "npc_super_spectre", OnReaperChangeTeam )

	// for debugging
	#if EXTRA_SPAWNER_DEBUG
		MeleeSyncedNPC_EnableAll_Init()
		ExtraSpawner_SetNPCSecondaryWeapons( "npc_pilot_elite", ["mp_weapon_autopistol", "mp_weapon_semipistol"] )
		ExtraSpawner_SetNPCAntiTitanWeapons( "npc_soldier", ["mp_weapon_defender"] )

		AddClientCommandCallback( "killallspawnernpc", CC_KillAllNPCsFromExtraSpawner )
		AddClientCommandCallback( "pilotandtitan", CC_SpawnPilotAndTitan )
		AddClientCommandCallback( "titanwithpilot", CC_SpawnTitanWithPilot )
		AddClientCommandCallback( "tickreaper", CC_SpawnReaperCanLaunchTicks )
		AddClientCommandCallback( "gunship", CC_SpawnGunShip )
		//AddClientCommandCallback( "assassinpilot", CC_SpawnAssassinPilot ) // shouldn't be used because we've removed npc_pilot_elite_assassin stuffs
		//AddClientCommandCallback( "specialistgrunt", CC_SpawnSpecialistGrunt )
		AddClientCommandCallback( "pilot", CC_SpawnPilotElite )
		AddClientCommandCallback( "bosstitan", CC_SpawnBossTitan )
		AddClientCommandCallback( "bosstitan_intro", CC_SpawnBossTitanWithIntro )
		//AddClientCommandCallback( "pistolgrunt", CC_SpawnTestPistolGrunt )
		//AddClientCommandCallback( "fakespectre", CC_SpawnFakeMLTSpectre )
		AddClientCommandCallback( "gruntdroppod", CC_SpawnGruntDroppod )
		//AddClientCommandCallback( "npcweapon_bodygrouptest", CC_DoNPCWeaponBodyGroupTestSpawn )
		AddClientCommandCallback( "overloadedstalkers", CC_SpawnOverloadedStalkers )
	#endif // EXTRA_SPAWNER_DEBUG
}

// GENERIC SPAWN SETTINGS
void function ExtraSpawner_SetUpSpawnedNPC( entity npc )
{
	if ( ExtraSpawner_IsNPCSpawnedFromExtraSpawner( npc ) ) // has setup once?
		return
	
	file.npcSpawnFromExtraSpawner[ npc ] <- true
	AddEntityCallback_OnPostDamaged( npc, StoreDamageHistoryForNPC )
}

bool function ExtraSpawner_IsNPCSpawnedFromExtraSpawner( entity npc )
{
	return npc in file.npcSpawnFromExtraSpawner
}

// wrapped function that mark the squad as extra spawner spawned
string function ExtraSpawner_MakeMarkedSquadName( int team, string squadMsg )
{
	string squad = MakeSquadName( team, squadMsg )
	file.npcSquadFromExtraSpawner.append( squad )

	return squad
}

bool function ExtraSpawner_IsSquadFromExtraSpawner( string squadname )
{
	return file.npcSquadFromExtraSpawner.contains( squadname )
}

// vanilla never store any damage histroy for npcs, here I do it for fun
// basically same setup as one in PlayerTookDamage()
void function StoreDamageHistoryForNPC( entity npc, var damageInfo )
{
	// npc titan is handled by themselves( very short lifetime though, player has 12s but npc titan only has 4s )
	// but why does dropships also do so?
	if ( npc.IsTitan() || npc.GetClassName() == "npc_dropship" )
		return
	
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	vector attackerOrigin = Vector( 0, 0, 0 )
	if ( IsValid( attacker ) )
		attackerOrigin = attacker.GetOrigin()
	
	// killshot for npcs is already added by other scripts when postdamage
	//float damageAmount = DamageInfo_GetDamage( damageInfo )
	//bool isKillShot = (damageAmount >= npc.GetHealth())
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	//if ( isKillShot )
	//	damageType = (damageType | DF_KILLSHOT)

	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	array<string> weaponMods = GetWeaponModsFromDamageInfo( damageInfo )

	StoreDamageHistoryAndUpdate( npc, file.npcDamageHistoryLifeTime, DamageInfo_GetDamage( damageInfo ), attackerOrigin, damageType, damageSourceId, attacker, weaponMods )
}

void function ExtraSpawner_SetNPCDamageHistoryLifeTime( float lifeTime )
{
	file.npcDamageHistoryLifeTime = lifeTime
}

void function OnClientConnected( entity player )
{
	// scripted npc dialogue
	file.npcDialogueNextAllowedTimeOnPlayer[ player ] <- 0.0
	// care package
	file.playerLastCarePackageNotifiedTime[ player ] <- 0.0
}

void function OnStalkerSpawned( entity stalker )
{
	// only handle stalkers spawned from this file
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( stalker ) )
		return
	
	int team = stalker.GetTeam()
	if ( team == TEAM_IMC )
	{
		stalker.SetValueForModelKey( $"models/Robots/stalker/robot_stalker.mdl" )
		// the problem is we can't handle dropship condition, may break their animation
		// maybe just modify aisettings file?
		// EDIT: no, it's all good. DispatchSpawn() is where this callback called, animation is done after that
		stalker.SetModel( $"models/Robots/stalker/robot_stalker.mdl" )
	}
}

// this is kinda weird logic... could've reset models in ExtraSpawner_SpawnGunShip()
/*
void function OnGunshipSpawned( entity gunship )
{
	// only handle gunships spawned from this file
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( gunship ) )
		return
	
	asset gunshipModel = $""
	// gunship may have a specific model picked
	// because if they played an intro, we'll need to spawn a new gunship and they should keep the same model
	// we'll use that
	if ( gunship in file.gunshipForcedSpawnModel )
		gunshipModel = file.gunshipForcedSpawnModel[ gunship ]
	else // otherwise we just pick a random one
		gunshipModel = GUNSHIP_VALID_MODELS[ RandomInt( GUNSHIP_VALID_MODELS.len() ) ]

	if ( gunshipModel != $"" )
	{
		gunship.SetValueForModelKey( gunshipModel )
		gunship.SetModel( gunshipModel )
	}
}
*/

void function OnDropshipSpawned( entity dropship )
{
	string squad = expect string( dropship.kv.squadname )
	// only handle dropships spawned from this file
	// marked by squads or entity itself
	if ( !ExtraSpawner_IsSquadFromExtraSpawner( squad ) && !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( dropship ) )
		return
	
	AddMinimapForNPC( dropship ) // show on enemy minimap
}

void function OnDroneSpawned( entity drone )
{
	string squad = expect string( drone.kv.squadname )
	// only handle drones spawned from this file
	// marked by squads or entity itself
	// NOTE: if drone spawned by npc, squad setup needs modified _ai_drone.gnut
	if ( !ExtraSpawner_IsSquadFromExtraSpawner( squad ) && !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( drone ) )
		return
	
	AddMinimapForNPC( drone ) // show on enemy minimap
}

void function OnTickSpawned( entity tick )
{
	string squad = expect string( tick.kv.squadname )
	// only handle ticks spawned from this file
	// marked by squads or entity itself
	// NOTE: if tick spawned by npc, squad setup needs modified mp_weapon_frag_drone.nut
	if ( !ExtraSpawner_IsSquadFromExtraSpawner( squad ) && !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( tick ) )
		return
	
	AddMinimapForNPC( tick ) // show on enemy minimap
}

void function OnLaunchedFragDroneSpawned( entity reaper, entity nade, entity fragDrone, string droneSettings )
{
	if ( !IsValid( reaper ) ) // reaper can be destroyed before frag drone can arm
		return

	bool ownerReaperSpawnedByExtraSpawer = false
	// drone can still be projectile 
	if ( IsValid( nade ) && !( nade in file.fragDroneProjectileUpdatedModel ) )
	{
		entity ownerReaper = nade.GetOwner() // nades have ownership
		// ensure this reaper is spawned by extra spawner!
		if ( IsValid( ownerReaper ) && ExtraSpawner_IsNPCSpawnedFromExtraSpawner( ownerReaper ) )
		{
			// modified for better models, hardcoded for now
			if ( droneSettings != "npc_frag_drone" ) // not sp ticks?
				nade.SetModel( $"models/weapons/sentry_frag/sentry_frag_proj.mdl" ) // should use sentry frag drone model
			file.fragDroneProjectileUpdatedModel[ nade ] <- true // add mark so we don't update model again on next call
		}
	}
	
	// removed minimap icon think. there'll be too many dots on minimap and we can't handle ticks spawned by grunts
	/*
	if ( IsValid( fragDrone ) )
	{
		// for ticks themselves, use squad to identify whether they're spawned by extra spawner or not
		string squad = expect string( fragDrone.kv.squadname )
		if ( ExtraSpawner_IsSquadFromExtraSpawner( squad ) ) // do spawned by extra spawner!
		{
			//print( "tick: " + string( fragDrone ) )
			//print( "have squad from extra spawner!" )
			// find owner reaper
			entity ownerReaper
			foreach ( reaper in GetNPCArrayByClass( "npc_super_spectre" ) )
			{
				if ( reaper.kv.squadname == squad )
				{
					ownerReaper = reaper
					break
				}
			}
			//print( "ownerReaper: " + string( reaper ) )
			// start setup
			ExtraSpawner_SetUpSpawnedNPC( fragDrone ) // mark this tick as spawned by extra spawner
			if ( !IsValid( ownerReaper ) || EntHasMinimapIconEnabled( ownerReaper ) )
				AddMinimapForNPC( fragDrone ) // add minimap icon tracking if their owner reaper has icon, or owner reaper has been destroyed
		}
	}
	*/
}

void function OnReaperChangeTeam( entity reaper )
{
	// maybe we should handle all reapers, but in this file all the stuffs are handled only for extra spawner npcs
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( reaper ) )
		return

	if ( reaper.ai.activeMinionEntArrayID > 0 )
	{
		foreach ( entity ent in GetScriptManagedEntArray( reaper.ai.activeMinionEntArrayID ) )
		{
			// should kill all their owned ticks on changing team
			// otherwise reaper can have ticks from different team in their squad
			// which can crash the server
			if ( IsValid( ent ) ) 
			{
				if ( ent.IsNPC() && ent.ai.fragDroneArmed )
					ent.Signal( "SuicideSpectreExploding" )
				else // minion still a grenade, or not armed ready yet... just destroy
				{
					if ( ent.IsProjectile() )
						ent.Destroy()
					else if ( ent.IsNPC() && !ent.ai.fragDroneArmed )
						ent.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
				}
			}
		}
	}
}

void function OnProwlerSpawned( entity prowler )
{
	// try to set prowlers not alwaysalert, perhaps it can make them start wandering around?
	if ( ExtraSpawner_IsNPCSpawnedFromExtraSpawner( prowler ) )
		prowler.kv.alwaysalert = 0
}

void function ProwlerPrecache()
{
	// don't precache corpses again, or game's existing model will become errors!
    PrecacheModel($"models/creatures/prowler/r2_prowler.mdl")
}

void function TurretPrecache()
{
	PrecacheModel( ROCKET_TURRET_MODEL )
}

void function GunshipPrecache()
{
	foreach ( attachment, effect in GUNSHIP_FLIGHT_TRAIL_EFFECTS )
		PrecacheParticleSystem( effect )
	foreach ( attachment, effect in GUNSHIP_JET_BURST_EFFECTS )
		PrecacheParticleSystem( effect )
}

// this is default settings, modders can change later
void function InitCarePackageDefaultSettings()
{
	// carepackage weapons
	// new grunt mode: only contains launchers
	file.carePackageWeapons =
	[
		"mp_weapon_epg", 
		"mp_weapon_softball", 
		"mp_weapon_pulse_lmg", 
		"mp_weapon_smr" 
	]

	// anti-titan
	file.carePackageWeaponMods["mp_weapon_arc_launcher"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_arc_launcher" ]
	file.carePackageWeaponMods["mp_weapon_mgl"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_mgl" ]
	file.carePackageWeaponMods["mp_weapon_rocket_launcher"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_rocket_launcher" ]
	file.carePackageWeaponMods["mp_weapon_defender"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_defender" ]

	// pistol
	file.carePackageWeaponMods["mp_weapon_autopistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_autopistol" ]
	file.carePackageWeaponMods["mp_weapon_semipistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_semipistol" ]
	file.carePackageWeaponMods["mp_weapon_smart_pistol"] <- [] 
	file.carePackageWeaponMods["mp_weapon_wingman"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_wingman" ]
	file.carePackageWeaponMods["mp_weapon_wingman_n"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", ]
	file.carePackageWeaponMods["mp_weapon_shotgun_pistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", ] 

	// sniper
	file.carePackageWeaponMods["mp_weapon_doubletake"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "ricochet" ]
	file.carePackageWeaponMods["mp_weapon_sniper"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "ricochet", "pas_fast_swap", "burn_mod_sniper" ]
	file.carePackageWeaponMods["mp_weapon_dmr"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads" ] 
	
	// rifle
	file.carePackageWeaponMods["mp_weapon_vinson"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_rspn101"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_rspn101_og"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_g2"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_hemlok"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 

	// smg
	file.carePackageWeaponMods["mp_weapon_car"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_alternator_smg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_hemlok_smg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_r97"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 

	// launcher
	file.carePackageWeaponMods["mp_weapon_epg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 
	file.carePackageWeaponMods["mp_weapon_softball"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 
	file.carePackageWeaponMods["mp_weapon_smr"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "burn_mod_smr" ] 
	file.carePackageWeaponMods["mp_weapon_pulse_lmg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 

	// lmg
	file.carePackageWeaponMods["mp_weapon_lmg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "redline_sight" ] 
	file.carePackageWeaponMods["mp_weapon_lstar"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "redline_sight", "reloadanimtest" ] // will have a halfed reload animation! 
	file.carePackageWeaponMods["mp_weapon_esaw"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "redline_sight" ] 
}

void function InitDefaultNPCWeapons()
{
	// pilot weapons
	array<string> pilotMainWeapons =
	[ // try to make this all anti-titans? or grenadiers idk
		"mp_weapon_rspn101_og", 
		"mp_weapon_r97", 
		"mp_weapon_car",
		//"mp_weapon_alternator_smg", // pistol animation, works bad on pilots
		"mp_weapon_vinson",
		//"mp_weapon_epg",
		//"mp_weapon_smr",
		//"mp_weapon_defender",
		//"mp_weapon_mgl",
		//"mp_weapon_rocket_launcher",
	]
	array<string> pilotAntiTitanWeapons = 
	[ 
		//"mp_weapon_defender", 
		"mp_weapon_rocket_launcher",
		"mp_weapon_mgl",
		"mp_weapon_arc_launcher", // modded, they can now be used by npcs
		"mp_weapon_defender",
	]

	// grunt weapons
	array<string> gruntMainWeapons =
	[
		"mp_weapon_r97", 
		"mp_weapon_rspn101", 
		"mp_weapon_lmg", 
		"mp_weapon_dmr",
	]

	// spectre weapons
	array<string> spectreMainWeapons =
	[
		"mp_weapon_mastiff", 
		"mp_weapon_doubletake", 
		"mp_weapon_hemlok_smg",
	]

	// stalker weapons
	array<string> stalkerMainWeapons =
	[
		"mp_weapon_mastiff", 
		"mp_weapon_hemlok_smg",
		//"mp_weapon_lstar", // vanilla don't have this
		"mp_weapon_doubletake", 
	]

	// pilot
	file.npcMainWeaponsTable[ "npc_pilot_elite" ] <- pilotMainWeapons
	file.npcAntiTitanWeaponsTable[ "npc_pilot_elite" ] <- pilotAntiTitanWeapons
	// grunt
	file.npcMainWeaponsTable[ "npc_soldier" ] <- gruntMainWeapons
	// spectre
	file.npcMainWeaponsTable[ "npc_spectre" ] <- spectreMainWeapons
	// stalker
	file.npcMainWeaponsTable[ "npc_stalker" ] <- stalkerMainWeapons
}

void function InitDefaultTitanList()
{
	// ion
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"ion",											// spawn name. unique
		"titan_atlas_stickybomb",						// setFile
		"npc_titan_auto_atlas_stickybomb",				// aiSet
		"execution_ion",								// executionRef
		// after being embarked by npcs
		"npc_titan_atlas_stickybomb",					// embarkedAiSet
		"behavior_titan",								// embarkedBehavior
		"#NPC_TITAN_ATLAS_STICKYBOMB",					// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		3												// mlt team skinIndex
	)

	// scorch
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"scorch",										// spawn name. unique
		"titan_ogre_meteor",							// setFile
		"npc_titan_auto_ogre_meteor",					// aiSet
		"execution_scorch",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_ogre_meteor",						// embarkedAiSet
		"behavior_titan_ogre_meteor",					// embarkedBehavior
		"#NPC_TITAN_OGRE_METEOR",						// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		9												// mlt team skinIndex
	)

	// northstar
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"northstar",									// spawn name. unique
		"titan_stryder_sniper",							// setFile
		"npc_titan_auto_stryder_sniper",				// aiSet
		"execution_northstar",							// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_stryder_sniper",						// embarkedAiSet
		"behavior_titan_sniper",						// embarkedBehavior
		"#NPC_TITAN_STRYDER_SNIPER",					// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		3												// mlt team skinIndex
	)

	// ronin
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"ronin",										// spawn name. unique
		"titan_stryder_leadwall",						// setFile
		"npc_titan_auto_stryder_leadwall",				// aiSet
		"execution_ronin",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_stryder_leadwall",					// embarkedAiSet
		"behavior_titan_shotgun",						// embarkedBehavior
		"#NPC_TITAN_STRYDER_LEADWALL",					// embarkedTitle
		null, 											// no loadout function
		-1,												// imc team skinIndex, -1 means don't reset
		3												// mlt team skinIndex
	)

	// tone
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"tone",											// spawn name. unique
		"titan_atlas_tracker",							// setFile
		"npc_titan_auto_atlas_tracker",					// aiSet
		"execution_tone",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_atlas_tracker",						// embarkedAiSet
		"behavior_titan_long_range",					// embarkedBehavior
		"#NPC_TITAN_ATLAS_TRACKER",						// embarkedTitle
		null, 											// no loadout function
		-1,												// imc team skinIndex, -1 means don't reset
		1												// mlt team skinIndex
	)

	// legion
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"legion",										// spawn name. unique
		"titan_ogre_minigun",							// setFile
		"npc_titan_auto_ogre_minigun",					// aiSet
		"execution_legion",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_ogre_minigun",						// embarkedAiSet
		"behavior_titan_ogre_minigun",					// embarkedBehavior
		"#NPC_TITAN_OGRE_MINIGUN",						// embarkedTitle
		NPCLegionLoadout, 								// loadout function: change core weapon
		1,												// imc team skinIndex
		3												// mlt team skinIndex
	)

	// monarch
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"monarch",										// spawn name. unique
		"titan_atlas_vanguard",							// setFile
		"npc_titan_auto_atlas_vanguard",				// aiSet
		"execution_vanguard",							// executionRef, kit execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_atlas_vanguard",						// embarkedAiSet
		"behavior_titan",								// embarkedBehavior
		"#NPC_TITAN_ATLAS_VANGUARD",					// embarkedTitle
		NPCMonarchLoadout, 								// loadout function: change core weapon
		-1,												// imc team skinIndex, -1 means don't reset
		3												// mlt team skinIndex
	)

	// brute
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"brute",										// spawn name. unique
		"titan_stryder_sniper",							// setFile. titan_stryder_rocketeer isn't implemented good enough for MP usage, using sniper instead. loadout handled by loadoutFunction
		"npc_titan_auto_stryder_sniper",				// aiSet, rocketeer stryder don't have a autotitan aiSet
		"execution_northstar_prime",					// executionRef, this one don't require weapons
		// after being embarked by npcs
		"npc_titan_stryder_rocketeer",					// embarkedAiSet
		"behavior_titan_rocketeer",						// embarkedBehavior
		"#NPC_TITAN_STRYDER_ROCKET",					// embarkedTitle
		NPCBruteLoadout,								// loadout function
		6,												// imc team skinIndex
		8												// mlt team skinIndex
	)

	// bison
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"bison",										// spawn name. unique
		"titan_ogre_meteor",							// setFile
		"npc_titan_auto_ogre_scorch_prime",				// aiSet
		"execution_scorch_prime",						// executionRef, this one don't require weapons
		// after being embarked by npcs
		"npc_titan_ogre_fighter",						// embarkedAiSet, core aiset handled by titan core
		"behavior_titan_melee",							// embarkedBehavior, core behavior handled by titan core
		"#NPC_TITAN_OGRE_FIGHTER",						// embarkedTitle
		NPCBisonLoadout
		// for prime titans, skin settings leave in loadout function
	)

	// modded weapon titans
	// brute4
	/*
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"brute4_modded",								// spawn name. unique
		"titan_stryder_sniper",							// setFile
		"npc_titan_auto_stryder_northstar_prime",		// aiSet
		"execution_northstar_prime",					// executionRef, this one don't require weapons
		// after being embarked by npcs
		"npc_titan_stryder_rocketeer",					// embarkedAiSet
		"behavior_titan_shotgun",						// embarkedBehavior, hover ability is bind together with "behavior_titan_rocketeer", use shotgun instead
		"#NPC_TITAN_AUTO_ATLAS_ROCKETEER",				// embarkedTitle
		NPCBrute4Loadout
		// for prime titans, skin settings leave in loadout function
	)
	*/

	// archon
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"archon_modded",								// spawn name. unique
		"titan_atlas_stickybomb",						// setFile
		"npc_titan_auto_atlas_ion_prime",				// aiSet
		"execution_ion_prime",							// executionRef. fixed npc ion using prime executions by temporary taking away their laser core ;)
		// after being embarked by npcs
		"npc_titan_atlas_stickybomb",					// embarkedAiSet
		"behavior_titan",								// embarkedBehavior
		"#NPC_TITAN_AUTO_STRYDER_ARC",					// embarkedTitle
		NPCArchonLoadout
		// for prime titans, skin settings leave in loadout function
	)
}
//

// generic core replace for npc atlas titans: they cannot use upgrade core
// upgrade core has been scripted, this just exists here for we might use
const array<string> NPC_ATLAS_TITAN_VALID_CORE =
[
	"mp_titancore_laser_cannon",
	"mp_titancore_salvo_core",
]

void function NPCAtlasTitanCoreReplace( entity titan )
{
	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	string newCoreWeapon = NPC_ATLAS_TITAN_VALID_CORE[ RandomInt( NPC_ATLAS_TITAN_VALID_CORE.len() ) ]
	titan.GiveOffhandWeapon( newCoreWeapon, OFFHAND_EQUIPMENT )
}

// generic core replace for npc ogre titans: they cannot use smart core
// smart core has been scripted, this just exists here for we might use
void function NPCOgreTitanCoreReplace( entity titan )
{
	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT )
}

// upgrade core setup for npc usage
// needs modified mp_titancore_upgrade.nut
// skipping stage 2 upgrades because that stage has nothing useful for npcs to use
// and add superior chassis for the forth upgrade( pretty difficult for a npc to do so )
const array<int> NPC_UPGRADE_CORE_STAGE1_PASSIVES =
[
	ePassives.PAS_VANGUARD_CORE1, // arc rounds
	ePassives.PAS_VANGUARD_CORE2, // missile racks
]

const array<int> NPC_UPGRADE_CORE_STAGE2_PASSIVES =
[
	ePassives.PAS_VANGUARD_CORE7, // multi-target missiles
	ePassives.PAS_VANGUARD_CORE9, // xo-16 battle rifle
]

// gets applied at forth upgrade
const array<int> NPC_UPGRADE_CORE_STAGE3_PASSIVES =
[
	ePassives.PAS_VANGUARD_CORE8, // superior chassis
]

void function NPCUpgradeCoreSetUp( entity titan )
{
	entity coreWeapon = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	if ( IsValid( coreWeapon ) )
	{
		// not a good idea to use weapon for stroing modified upgrades--- they can be easily destroyed
		/*
		UpgradeCore_SetWeaponUpgradePassive( coreWeapon, 0, NPC_UPGRADE_CORE_STAGE1_PASSIVES[ RandomInt( NPC_UPGRADE_CORE_STAGE1_PASSIVES.len() ) ] ) // first upgrade
		UpgradeCore_SetWeaponUpgradePassive( coreWeapon, 1, NPC_UPGRADE_CORE_STAGE2_PASSIVES[ RandomInt( NPC_UPGRADE_CORE_STAGE2_PASSIVES.len() ) ] ) // second upgrade
		UpgradeCore_SetWeaponUpgradePassive( coreWeapon, 3, NPC_UPGRADE_CORE_STAGE3_PASSIVES[ RandomInt( NPC_UPGRADE_CORE_STAGE3_PASSIVES.len() ) ] ) // forth upgrade
		*/
		UpgradeCore_SetTitanUpgradePassive( titan, 0, NPC_UPGRADE_CORE_STAGE1_PASSIVES[ RandomInt( NPC_UPGRADE_CORE_STAGE1_PASSIVES.len() ) ] ) // first upgrade
		UpgradeCore_SetTitanUpgradePassive( titan, 1, NPC_UPGRADE_CORE_STAGE2_PASSIVES[ RandomInt( NPC_UPGRADE_CORE_STAGE2_PASSIVES.len() ) ] ) // second upgrade
		UpgradeCore_SetTitanUpgradePassive( titan, 3, NPC_UPGRADE_CORE_STAGE3_PASSIVES[ RandomInt( NPC_UPGRADE_CORE_STAGE3_PASSIVES.len() ) ] ) // forth upgrade
	}
}

void function NPCLegionLoadout( entity titan )
{
	// npc cannot use smart core, change to flame core
	// has been changed to use scripted core ability handle
	//NPCOgreTitanCoreReplace( titan )
}

void function NPCMonarchLoadout( entity titan )
{
	// npc cannot use upgrade core, change to salvo core or laser core
	//NPCAtlasTitanCoreReplace( titan )
	// upgrade core has been scripted, we needs to setup
	NPCUpgradeCoreSetUp( titan )
}

// modded titan loadout functions
void function NPCBruteLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream", ["brute_rocket", "disable_run_and_gun_server"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex"] )
	// Utility
	titan.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_ANTIRODEO )
	//Offence
	// we have buffed quad rocket that have higher projectile speed and can make npcs do explosion damage
	// no need to use multi-targeting missile( which extra_spawner branch uses )
	//titan.GiveOffhandWeapon( "mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE )
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

	//titan.SetBehaviorSelector( "behavior_titan_rocketeer" ) // default behavior, being set after embarking
	// title should be setup by npc pilot's spawn func
	//titan.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ROCKET" )

	entity soul = titan.GetTitanSoul()
	//if ( IsValid( soul ) )
	//	MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // required for executions behave nicely

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

void function NPCBisonLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon, npc bison is not smart enough, give them a main weapon
	titan.GiveWeapon( "mp_titanweapon_triplethreat", ["bison_triplethreat"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield", "molting_dome", "bison_dome"] )
	//Tactical
	//titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ANTIRODEO )
	//Offence
	//titan.GiveOffhandWeapon( "mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster", "fd_twin_cluster"] )
	titan.GiveOffhandWeapon( "mp_titanweapon_homing_rockets", OFFHAND_ORDNANCE, ["burn_mod_titan_homing_rockets", "fighter_rockets"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["berserker_core"] )
	//Melee
	// gives 10% damage reduction, changes titan's melee damageSourceId
	// npc melee damage is handled by aiSettings
	titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE, ["bison_punch_npc"] )

	// title should be setup by npc pilot's spawn func
	//titan.SetTitle( "#NPC_TITAN_AUTO_OGRE_FIGHTER" )

	// execution_scorch_prime don't require weapons, no need to fix

	//Bison have damage reduction
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		soul.SetPreventCrits( true )

	// camo for prime titans
	titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
	titan.SetCamo( 31 ) // default is white. best camo for bison

	int team = titan.GetTeam()
	if ( team == TEAM_IMC )
		titan.SetCamo( 19 ) // shadow
	if ( team == TEAM_MILITIA )
		titan.SetCamo( 1 ) // forest

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

void function NPCBrute4Loadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream", ["brute4_quad_rocket"])
	//Defence
	titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield"] )
	//Tactical
	titan.GiveOffhandWeapon( "mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO, ["brute4_cluster_payload"] )
	//Offence
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["brute4_barrage_core"] )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

	// title should be setup by npc pilot's spawn func
	//titan.SetTitle( "#NPC_TITAN_AUTO_ATLAS_ROCKETEER" )

	// execution_northstar_prime don't require weapons, no need to fix

	// camo for prime titans
	int team = titan.GetTeam()
	if ( team == TEAM_IMC )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 19 ) // shadow
	}
	if ( team == TEAM_MILITIA )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 1 ) // forest
	}

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

void function NPCArchonLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon ( "mp_titanweapon_arc_cannon", ["archon_arc_cannon"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["archon_shock_shield"] )
	//Tactical
	titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node"] )
	//Offence
	titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball"] )
	//Titan Core
	// normally, non-ogre npc titans can't use flame core variant cause they're missing anim events
	// try to fix in their scripts
	// temp disabled until I fix it's npc damage stuffs, now using laser core
	//titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["archon_storm_core"] )
	titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )

	// title should be setup by npc pilot's spawn func
	//titan.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ARC" )

	entity soul = titan.GetTitanSoul()
	//if ( IsValid( soul ) )
		//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // required for executions behave nicely

	// camo for prime titans
	int team = titan.GetTeam()
	if ( team == TEAM_IMC )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 19 ) // shadow
	}
	if ( team == TEAM_MILITIA )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 1 ) // forest
	}

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

void function OnNPCKilled( entity victim, entity attacker, var damageInfo )
{
	// debug
	//if ( victim.GetClassName() == "npc_pilot_elite" )
	//	print( "NPC PILOT KILLED! by: " + string( attacker ) )

	// we only handle npcs spawn from this file!
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( victim ) )
		return

	// manually do some score event
	if ( ShouldCreateScoreEventForNPCKilled( victim, attacker ) )
	{
		string scoreEvent = ExtraSpawner_GetNPCScoreEvent( victim )
		if ( scoreEvent != "" )
			AddPlayerScore( attacker, scoreEvent, victim )
	}

	// npc pilot killed battle chatter
	if ( victim.GetClassName() == "npc_pilot_elite"
		 || ( victim.IsTitan() && TitanHasNpcPilot( victim ) ) )
	{
		TryNPCPilotKilledChatter( attacker )
	}
}

// keep the same check as _base_gametype.gnut, PlayerOrNPCKilled() does!
bool function ShouldCreateScoreEventForNPCKilled( entity victim, entity attacker )
{
	if ( !victim.IsNPC() )
		return false
	
	if ( !attacker.IsPlayer() )
		return false

	//if ( ent.GetTeam() != attacker.GetTeam() )
	// adding friendlyfire support!
	if ( ( victim.GetTeam() != attacker.GetTeam() || FriendlyFire_IsEnabled() )
		 && ( victim != attacker && victim.GetBossPlayer() != attacker ) )
		return true

	return false
}

// for npcs those are not handled by OnNPCKilled(), do a extra score event( such as gunship and npc pilot )
string function ExtraSpawner_GetNPCScoreEvent( entity ent )
{
	string scoreEvent = ""

	string className = ent.GetClassName()

	if ( className == "npc_pilot_elite" )
		scoreEvent = "EliminatePilot"

	if ( className == "npc_gunship" )
		scoreEvent = "FlyerKill" // vanilla don't have "Killed Gunship" events, guess this is good enough

	// Player ejecting triggers this without the extra check
	if ( ent.IsTitan() )
	{
		if ( TitanHasNpcPilot( ent ) ) // pilot was killed without ejecting
			scoreEvent = "EliminatePilot"
	}

	return scoreEvent
}

bool function TryNPCPilotKilledChatter( entity attacker )
{
	if ( attacker.IsPlayer() && !attacker.IsTitan() )
	{
		TryPilotKillChatter( attacker ) // shared from _battle_chatter.gnut
		return true
	}

	return false
}

const float CORE_EXPIRE_TIME_GRACE_PERIOD = 3.0 // if titan still have anim active after core ends, we also wants to handle it

bool function ExtraSpawner_IsValidExecutionTarget( entity attacker, entity target )
{
	// fake decoy ent
	if ( EntIsNPCFakeDecoy( target ) )
		return false

	// npc vanguard titan
	// don't execute each other, no animation for doing that
	if ( file.npcVanguardChassisTitan.contains( attacker ) && file.npcVanguardChassisTitan.contains( target ) )
		return false
	
	// only handle those who spawn from this file
	// attacker case
	if ( ExtraSpawner_IsNPCSpawnedFromExtraSpawner( attacker ) )
	{
		if ( attacker.IsTitan() ) 
		{
			// vanguard chassis shouldn't execute players due their victim animation don't have suitable attachment
			bool targetIsPlayer = IsValid( target ) && target.IsPlayer()
			if ( file.npcVanguardChassisTitan.contains( attacker ) && targetIsPlayer )
				return false
		}
	}

	// target case
	if ( ExtraSpawner_IsNPCSpawnedFromExtraSpawner( target ) )
	{
		if ( target.IsTitan() ) 
		{
			entity soul = target.GetTitanSoul()
			if ( IsValid( soul ) )
			{
				// npc target with core active can have bad animation while being executed
				// usually happens for salvo core, but laser core seems working well? why?
				// this cannot be solved by adding target.Anim_Stop() in _melee_synced_titan.gnut
				// i don't know if it's a good idea to make them unable to be executed, just handle here
				bool titanCoreInUse = TitanCoreInUse( target )
				// also handle anim recover time for scripted core abilities
				float timeSinceCoreExpire = Time() - SoulTitanCore_GetExpireTime( soul )
				bool titanCoreEndGracePeriod = timeSinceCoreExpire > 0 && timeSinceCoreExpire <= CORE_EXPIRE_TIME_GRACE_PERIOD
				//print( "titanCoreEndGracePeriod: " + string( titanCoreEndGracePeriod ) )
				// assume this means titan is using some core ability that scripted their animation
				if ( ( titanCoreInUse || titanCoreEndGracePeriod ) && target.Anim_IsActive() )
					return false
			}

			// vanguard chassis shouldn't be executed by players for balancing they can't execute player
			bool attackerIsPlayer = IsValid( attacker ) && attacker.IsPlayer()
			if ( file.npcVanguardChassisTitan.contains( target ) && attackerIsPlayer )
				return false
		}

		// npc pilot elite case
		// don't allow execute them if they're doing any scripted animation
		if ( target.GetClassName() == "npc_pilot_elite" )
		{
			// scripted anim
			if ( ( target in file.npcPilotInScriptedAnim ) && file.npcPilotInScriptedAnim[ target ] )
				return false
		}
	}

	return true // default is returning true, let other callbacks go through
}

// using functions in enum_utility.gnut
// allow appending new passive
int PAS_BOSS_TITAN_EXECUTION

void function InitDefaultBossTitanList()
{
	// using functions in enum_utility.gnut
	// allow appending new passive
	// so we can make titans get battery reward without changing their executionref( which ePassives.PAS_VANGUARD_COREMETER does )
	PAS_BOSS_TITAN_EXECUTION = RegisterPassive( "pas_boss_titan_execution" )
	MeleeSyncedTitan_AddBatteryRewardTitanPassives( PAS_BOSS_TITAN_EXECUTION )

	// slone
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"slone",										// spawn name. unique
		"Slone",										// boss name
		"titan_atlas_stickybomb",						// setFile
		"npc_titan_atlas_stickybomb",					// aiSet
		"behavior_titan",								// titan behavior
		"execution_ion_prime",							// executionRef. was using execution_vanguard_kit beacuse npc ion can't use prime executions, now prime execution has been fixed by temporary taking away their laser core ;)
		"#BOSSNAME_SLONE",								// boss title
		"斯隆",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_medium_reaper_f.mdl",		// character model, use mp pilot model: pulse blade female
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for boss that has no pilot model for mp
		7,												// skin index
		11												// decal index
	)

	// kane
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"kane",											// spawn name. unique
		"Kane",											// boss name
		"titan_ogre_meteor",							// setFile
		"npc_titan_ogre_meteor",						// aiSet
		"behavior_titan_ogre_meteor",					// titan behavior
		"execution_scorch_prime",						// executionRef
		"#BOSSNAME_KANE",								// boss title
		"肯恩",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_medium_stalker_m.mdl",		// character model, use mp pilot model: holopilot male
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for boss that has no pilot model for mp
		3,												// skin index
		1												// decal index
	)

	// viper
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"viper",										// spawn name. unique
		"Viper",										// boss name
		"titan_stryder_sniper",							// setFile
		"npc_titan_stryder_sniper",						// aiSet
		"behavior_titan_sniper",						// titan behavior
		"execution_northstar_prime",					// executionRef
		"#BOSSNAME_VIPER",								// boss title
		"毒蛇",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_medium_reaper_m.mdl",		// character model, use mp pilot model: pulse blade male
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for boss that has no pilot model for mp
		5,												// skin index
		10												// decal index
	)

	// ash
	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"ash",											// spawn name. unique
		"Ash",											// boss name
		"titan_stryder_leadwall",						// setFile
		"npc_titan_stryder_leadwall",					// aiSet
		"behavior_titan_shotgun",						// titan behavior
		"execution_ronin_prime",						// executionRef
		"#BOSSNAME_ASH",								// boss title
		"艾許",											// pilot title. can't use localized string
		$"models/Humans/heroes/imc_hero_ash.mdl",		// character model
		//BossLoadout_Generic_IMCBoss, 					// generic loadout function for imc boss
		BossLoadout_Generic_NoModelForMP,				// weird intro animation, make them never eject
		6,												// skin index
		10												// decal index
	)

	// richter
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"richter",										// spawn name. unique
		"Richter",										// boss name
		"titan_atlas_tracker",							// setFile
		"npc_titan_atlas_tracker",						// aiSet
		"behavior_titan_long_range",					// titan behavior
		"execution_tone_prime",							// executionRef
		"#BOSSNAME_RICHTER",							// boss title
		"里赫特",										// pilot title. can't use localized string
		$"models/humans/pilots/pilot_heavy_drex_m.mdl",		// character model, use mp pilot model: cloak male
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for boss that has no pilot model for mp
		4,												// skin index
		13												// decal index
	)

	// blisk
	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"blisk",										// spawn name. unique
		"Blisk",										// boss name
		"titan_ogre_minigun",							// setFile
		"npc_titan_ogre_minigun",						// aiSet
		"behavior_titan_ogre_minigun",					// titan behavior
		"execution_legion_prime",						// executionRef
		"#BOSSNAME_BLISK",								// boss title
		"布里斯克",										// pilot title. can't use localized string
		$"models/Humans/heroes/imc_hero_blisk.mdl",		// character model
		//BossLoadout_Blisk, 								// loadout function: change core weapon
		BossLoadout_Generic_NoModelForMP,				// weird intro animation, make them never eject
		8,												// skin index
		12												// decal index
	)

	// jack
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"jack",											// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_buddy",									// setFile
		"npc_titan_vanguard",							// aiSet. was using npc_titan_buddy but it won't show health bar
		"behavior_titan",								// titan behavior
		"execution_bt",									// executionRef
		"#PATCH_PILOT2",								// boss title. was using #NPC_BT_NAME but it's not very identical as other boss
		"傑克",											// pilot title. can't use localized string
		$"models/humans/heroes/mlt_hero_jack.mdl",		// character model
		BossLoadout_Jack, 								// loadout function
		-1,												// skin index, -1 means don't reset
		-1												// decal index, -1 means don't reset
	)

	// sarah
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"sarah",										// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_buddy",									// setFile
		"npc_titan_vanguard",							// aiSet. was using npc_titan_buddy but it won't show health bar
		"behavior_titan",								// titan behavior
		"execution_bt",									// executionRef
		"#FACTION_LEADER_NAME_SARAH",					// boss title
		"莎拉",											// pilot title. can't use localized string
		$"models/humans/heroes/mlt_hero_sarah.mdl",		// character model
		BossLoadout_Sarah, 								// loadout function
		2,												// skin index
		0												// decal index
	)

	/*
	// sarah, monarch variant
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"sarah_monarch",								// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_atlas_vanguard",							// setFile
		"npc_titan_atlas_vanguard_boss_fd",				// aiSet
		"behavior_titan",								// titan behavior
		"execution_vanguard_kit",						// executionRef
		"#FACTION_LEADER_NAME_SARAH",					// boss title
		"莎拉",											// pilot title. can't use localized string
		$"models/humans/heroes/mlt_hero_sarah.mdl",		// character model
		BossLoadout_SarahMonarch, 						// loadout function
		-1,												// skin index, -1 means don't reset
		-1												// decal index, -1 means don't reset
	)
	*/

	// vanguard
	// vanguard is the chassis that spawn with random loadout
	InitNPCVanguardLoadouts()
	// not doing it in normal titans because it has unique aiSet and bad embark animation...
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"vanguard",										// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_buddy",									// setFile
		"npc_titan_vanguard",							// aiSet. was using npc_titan_buddy but it won't show health bar
		"behavior_titan",								// titan behavior, we'll need to update it in loadout function, here's just a placeholder( since we've enabled core ability for them, changed from "behavior_titan_buddy" to "behavior_titan" )
		"execution_bt",									// executionRef
		"#NPC_PILOT",									// boss title. here's just a placeholder, we update it in loadout function. was #NPC_TITAN_VANGUARD_SP but we should use pilot name instead of titan's
		"鐵馭",											// pilot title. we update it in loadout function
		$"",											// character model. leaving empty, we update it in loadout function
		BossLoadout_Vanguard, 							// loadout function
		1,												// skin index
		0												// decal index
	)

	// fake gates. don't know what kind of titan she pilots, just for fun
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"gates",										// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_atlas_vanguard",							// setFile
		"npc_titan_atlas_vanguard_boss_fd",				// aiSet
		"behavior_titan_long_range",					// titan behavior
		"execution_tone_prime",							// executionRef, was using execution_vanguard_kit
		"#NPC_GATES_NAME",								// boss title
		"蓋茨",											// pilot title. can't use localized string
		$"models/humans/pilots/sp_medium_geist_f.mdl",	// character model
		BossLoadout_Gates, 								// loadout function
		-1,												// skin index, -1 means don't reset
		-1												// decal index, -1 means don't reset
	)

	// fake bear. don't know what kind of titan he pilots, just for fun
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"bear",											// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_atlas_vanguard",							// setFile
		"npc_titan_atlas_vanguard",						// aiSet
		"behavior_titan_shotgun",						// titan behavior
		"execution_vanguard_kit",						// executionRef
		"#NPC_BEAR_NAME",								// boss title
		"貝爾",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_heavy_roog_m.mdl",	// character model
		BossLoadout_Bear, 								// loadout function
		TITAN_SKIN_INDEX_CAMO,							// skin index, -1 means don't reset
		-1												// decal index, -1 means don't reset
	)
}
//

// generic loadout function for boss that has no pilot model for mp
void function BossLoadout_Generic_NoModelForMP( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// disable their ejecting, so players won't easily notice that they have no proper model
		TitanHealth_SetSoulNPCPilotEjectDelay( soul, -1 ) // -1 means never eject
	}

	// boss titan rewards themselves a battery on performing execution
	BossLoadout_ExecutionGivesBattery( titan )

	// nuke. imc titans do nuke
	// they never ejects, just save here for fun
	ExtraSpawner_SetNPCPilotEmbarkedTitanNuke( titan )
}

// generic loadout function for imc boss
void function BossLoadout_Generic_IMCBoss( entity titan )
{
	// boss titan rewards themselves a battery on performing execution
	BossLoadout_ExecutionGivesBattery( titan )

	// nuke. imc titans do nuke
	ExtraSpawner_SetNPCPilotEmbarkedTitanNuke( titan )
}

// give themselves a battery on performing execution and faster core regen
// note that this requires modified _melee_synced_titan.gnut, it checks passives instead of hardcoding ref
void function BossLoadout_ExecutionGivesBattery( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// soul holds titan passives
		//GivePassive( soul, ePassives.PAS_VANGUARD_COREMETER ) // rewards battery on execution, but this changes execution animation
		// using functions in enum_utility.gnut
		// allow appending new passive
		// so we can make titans get battery reward without changing their executionref( which ePassives.PAS_VANGUARD_COREMETER does )
		GivePassive( soul, PAS_BOSS_TITAN_EXECUTION )
		GivePassive( soul, ePassives.PAS_VANGUARD_DOOM ) // this might be fun? so boss titans won't waste their battery from executions

		// atlas specific execution animation
		// not very necessary. we've reworked _melee_synced_titan.gnut to make battery check depending on passives
		//if ( GetSoulTitanSubClass( soul ) == "atlas" )
		//	soul.soul.titanLoadout.titanExecution = "execution_vanguard_kit" // this might be setup by settings func, here's to re-exam
	}
}

void function BossLoadout_Blisk( entity titan )
{
	// generic loadout function for imc boss
	BossLoadout_Generic_IMCBoss( titan )
	
	// npc cannot use smart core, change to flame core
	// has been changed to use scripted core ability handle
	//NPCOgreTitanCoreReplace( titan )
}

void function BossLoadout_Jack( entity titan )
{
	// game behavior settings
	NPCVanguard_SetUpTitan( titan )

	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...

	// boss titan rewards themselves a battery on performing execution
	//BossLoadout_ExecutionGivesBattery( titan )
	BossLoadout_Generic_NoModelForMP( titan ) // make them never eject, with basic setups for a boss titan

	// re-assign weapons
	// updated, now using NPC vanguard's random loadout!
	// updated 2: use modified mp_titanweapon_xo16_shorty as primary weapon
	/*
	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	//titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["arc_rounds"] ) // use the arc-rounds monarch xo16
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard" ) // removed arc rounds
	*/
	titan.GetOffhandWeapon( OFFHAND_SPECIAL ).AddMod( "slow_recovery_vortex" ) // fix weapon mod
	titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "upgradeCore_MissileRack_Vanguard" ) // fix mod: lock on heavy armor target only
	titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability
	
	//NPCVanguard_GiveLoadout( titan )

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

void function BossLoadout_Sarah( entity titan )
{
	// game behavior settings
	NPCVanguard_SetUpTitan( titan )

	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...

	// boss titan rewards themselves a battery on performing execution
	//BossLoadout_ExecutionGivesBattery( titan )
	BossLoadout_Generic_NoModelForMP( titan ) // make them never eject, with basic setups for a boss titan

	// re-assign weapons
	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	// removing healing electric smoke
	//titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["battle_rifle", "battle_rifle_icon", "fd_vanguard_utility_2"] )
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["battle_rifle", "battle_rifle_icon"] )

	// add back multi-targeting missile for sarah because we've removed vanguard expedition loadout
	// is that really needed? can npcs use them well? or it will be a bit too overpowered?
	// idk, guess I'll use cluster missile now
	titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	//titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["missile_racks"] )
	//titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "upgradeCore_MissileRack_Vanguard" ) // fix mod: lock on heavy armor target only
	titan.GiveOffhandWeapon( "mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

	titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
	titan.GiveOffhandWeapon( "mp_titanweapon_heat_shield", OFFHAND_SPECIAL )
	
	// add salvo core for them, we've tried to fix npc usage
	// works weird but still good enough to use, I think... laser core shouldn't be used for npcs though
	// removing it! use no-upgrading upgrade core might be enough, in NPCVanguard_SetUpTitan() we changed their max shield value to 2500
	//titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability
	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	//titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
	NPCVanguard_UpgradeCore( titan )

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

void function BossLoadout_SarahMonarch( entity titan )
{
	// game behavior settings
	//entity soul = titan.GetTitanSoul()
	//if ( IsValid( soul ) )
	//	PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )	// disable earnmeter smoke availability, they already have electric smoke
	
	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...

	// boss titan rewards themselves a battery on performing execution
	//BossLoadout_ExecutionGivesBattery( titan )
	BossLoadout_Generic_NoModelForMP( titan ) // make them never eject, with basic setups for a boss titan

	// re-assign weapons
	titan.GetMainWeapons()[0].SetMods( ["battle_rifle", "battle_rifle_icon", "fd_vanguard_utility_2"] )
	
	//titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	//titan.GiveOffhandWeapon( "mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE, ["upgradeCore_MissileRack_Vanguard"] )
	titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "missile_racks" )
	
	titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
	//titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_SPECIAL, ["energy_field_energy_transfer"] )
	titan.GiveOffhandWeapon( "mp_titanweapon_heat_shield", OFFHAND_SPECIAL )
	
	titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_smoke", OFFHAND_ANTIRODEO )

	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	titan.GiveOffhandWeapon( "mp_titancore_amp_core", OFFHAND_EQUIPMENT, ["npc_bt_balance"] )
	//titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )

	// may needs to update spawn loadout
	TitanLoadoutDef spawnLoadout = titan.ai.titanSpawnLoadout
}

// NPC vanguard loadouts, hardcoded!
void function InitNPCVanguardLoadouts()
{
	// loadout setup
	// have removed all behavior selector changes to disable core ability
	// instead, make them able to recharge shield over time
	// reverted. remove shield regen, still use core ability( all burst core )
	NPCVanguardLoadout emptyLoadout

	// expedition
	// removed for now. we have too many titans using xo-16( gunships also using xo-16 firing sound )
	// can adding back if we want core ability back. weapons doesn't really matter
	/*
	NPCVanguardLoadout expeditionLoadout = clone emptyLoadout
	expeditionLoadout.setFile = "titan_buddy"
	//expeditionLoadout.behaviorSelector = "behavior_titan"
	expeditionLoadout.loadoutFunction = VanguardExpeditionLoadout
	file.npcVanguardLoadouts.append( expeditionLoadout )
	*/

	// ion
	NPCVanguardLoadout ionLoadout = clone emptyLoadout
	ionLoadout.setFile = "titan_atlas_stickybomb"
	ionLoadout.behaviorSelector = "behavior_titan"
	// add laser core for vanguard because we've tried to fix npc usage
	// welp, should keep them banned... npc vanguard have firing spot and won't discard core meter after using
	ionLoadout.lockedAbilities = [OFFHAND_EQUIPMENT] // BT can't use laser core
	file.npcVanguardLoadouts.append( ionLoadout )

	// tone
	NPCVanguardLoadout toneLoadout = clone emptyLoadout
	toneLoadout.setFile = "titan_atlas_tracker"
	toneLoadout.behaviorSelector = "behavior_titan_long_range"
	// add salvo core for vanguard because we've tried to fix npc usage
	// welp, should keep them banned... npc vanguard have weird firing spot and won't discard core meter after using
	// but it's not that bad compare to laser core, guess I'll keep it for sarah
	toneLoadout.lockedAbilities = [OFFHAND_EQUIPMENT] // BT can't use salvo core
	file.npcVanguardLoadouts.append( toneLoadout )

	// ronin
	NPCVanguardLoadout roninLoadout = clone emptyLoadout
	roninLoadout.setFile = "titan_stryder_leadwall"
	roninLoadout.behaviorSelector = "behavior_titan_shotgun"
	roninLoadout.lockedAbilities = [OFFHAND_MELEE, OFFHAND_EQUIPMENT] // BT might be able to use fixed sword core? but it looks hacky, remove for now
	roninLoadout.disableRocketPod = true // ronin loadout doesn't require rocket pods, hide them on model
	roninLoadout.useUpgradeCore = true // change to shield-recharge-only upgrade core for fun
	file.npcVanguardLoadouts.append( roninLoadout )

	// northstar
	NPCVanguardLoadout northstarLoadout = clone emptyLoadout
	northstarLoadout.setFile = "titan_stryder_sniper"
	northstarLoadout.behaviorSelector = "behavior_titan_long_range" // they can't use "behavior_titan_sniper"
	// reworked here: use modified loadout for northstar: particle wall, tether trap and cluster missile
	//northstarLoadout.loadoutFunction = null
	//northstarLoadout.lockedAbilities = [OFFHAND_EQUIPMENT] // BT can't use hover abilities, but we need to safe for them because tether trap is tactical ability, having together with electric smoke will crash
	northstarLoadout.loadoutFunction = VanguardNorthstarLoadout
	file.npcVanguardLoadouts.append( northstarLoadout )

	// brute
	NPCVanguardLoadout bruteLoadout = clone emptyLoadout
	bruteLoadout.setFile = "titan_stryder_sniper" // titan_stryder_rocketeer isn't implemented good enough for MP usage, using sniper instead. loadout handled by loadoutFunction
	bruteLoadout.behaviorSelector = "behavior_titan_shotgun" // they can't use "behavior_titan_rocketeer"
	bruteLoadout.loadoutFunction = VanguardBruteLoadout
	file.npcVanguardLoadouts.append( bruteLoadout )

	// legion
	NPCVanguardLoadout legionLoadout = clone emptyLoadout
	legionLoadout.setFile = "titan_ogre_minigun"
	legionLoadout.behaviorSelector = "behavior_titan_ogre_minigun"
	// smart core has been scripted for npc titan to use
	// maybe ban them because most of the core ability isn't usable for npc vanguard
	// but I want to keep it valid, just for fun?
	//legionLoadout.lockedAbilities = [OFFHAND_EQUIPMENT] // smart core is not added for npc usage from native code
	legionLoadout.disableRocketPod = true // legion loadout doesn't require rocket pods, hide them on model
	file.npcVanguardLoadouts.append( legionLoadout )

	// scorch
	NPCVanguardLoadout scorchLoadout = clone emptyLoadout
	scorchLoadout.setFile = "titan_ogre_meteor"
	scorchLoadout.behaviorSelector = "behavior_titan_ogre_meteor"
	// add flame core for vanguard because we've tried to fix npc usage
	// welp, should keep them banned... npc vanguard usually fail to fire, unless they randomized to a proper ACT_SPECIAL_ATTACK animation
	// EDIT: add back because I want various core ability for them
	//scorchLoadout.lockedAbilities = [OFFHAND_EQUIPMENT] // BT can't use flame core
	scorchLoadout.disableRocketPod = true // scorch loadout doesn't require rocket pods, hide them on model
	file.npcVanguardLoadouts.append( scorchLoadout )

	// archon
	NPCVanguardLoadout archonLoadout = clone emptyLoadout
	archonLoadout.setFile = "titan_atlas_stickybomb"
	archonLoadout.behaviorSelector = "behavior_titan"
	archonLoadout.loadoutFunction = VanguardArchonLoadout
	file.npcVanguardLoadouts.append( archonLoadout )

	// embarked pilot setup
	NPCVanguardPilot emptyPilot

	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...

	// droz
	NPCVanguardPilot drozPilot = clone emptyPilot
	drozPilot.titanTitle = "#NPC_DROZ_NAME"
	drozPilot.pilotTitle = "德羅"
	drozPilot.pilotModel = $"models/humans/pilots/sp_medium_reaper_m.mdl"
	drozPilot.neverEjects = true // weird intro animation, make them never eject
	file.npcVanguardPilots.append( drozPilot )

	// davis
	NPCVanguardPilot davisPilot = clone emptyPilot
	davisPilot.titanTitle = "#NPC_DAVIS_NAME"
	davisPilot.pilotTitle = "戴維斯"
	davisPilot.pilotModel = $"models/humans/pilots/sp_medium_stalker_m.mdl"
	davisPilot.neverEjects = true // weird intro animation, make them never eject
	file.npcVanguardPilots.append( davisPilot )

	// bear
	// now dedicated to new boss titan, removed
	/*
	NPCVanguardPilot bearPilot = clone emptyPilot
	bearPilot.titanTitle = "#NPC_BEAR_NAME"
	bearPilot.pilotTitle = "貝爾"
	bearPilot.pilotModel = $"models/humans/pilots/pilot_heavy_roog_m.mdl"
	bearPilot.neverEjects = true // don't have suitable model for MP, make him never eject
	file.npcVanguardPilots.append( bearPilot )
	*/

	// gates
	// has it's own boss titan so this is unused
	/*
	NPCVanguardPilot gatesPilot = clone emptyPilot
	gatesPilot.titanTitle = "#NPC_GATES_NAME"
	gatesPilot.pilotTitle = "蓋茨"
	gatesPilot.pilotModel = $"models/humans/pilots/sp_medium_geist_f.mdl"
	gatesPilot.neverEjects = true // weird intro animation, make them never eject
	file.npcVanguardPilots.append( gatesPilot )
	*/
}

void function BossLoadout_Vanguard( entity titan )
{
	// generic setup for vanguard, this one replaces pilot
	NPCVanguard_SetUpTitan( titan, true )
	//NPCVanguard_EnableShieldRegen( titan ) // removed regen shield since we've added core abilities again

	// boss titan rewards themselves a battery on performing execution
	//BossLoadout_ExecutionGivesBattery( titan )
	BossLoadout_Generic_NoModelForMP( titan ) // make them never eject, with basic setups for a boss titan

	// start giving loadout
	NPCVanguard_GiveLoadout( titan )
}

// generic setup for all npc vanguard chassis titan
void function NPCVanguard_SetUpTitan( entity titan, bool replacePilot = false )
{
	// require a unique squad to spawn AIClass titan_buddy
	// because all titan_buddy will be assigned to the same "bt" squad
	// if we spawn an enemy buddy titan we'll crash
	string squad = ExtraSpawner_MakeMarkedSquadName( titan.GetTeam(), UniqueString( "_buddy" ) )
	SetSquad( titan, squad )

	// make them always alert so they don't holster weapon after warpfall
	// welp, seems they already got this due to setups in CommonNPCTitanOnSpawned()
	// don't know why it don't work
	titan.kv.alwaysalert = 1

	// pick a random pilot setting!
	NPCVanguardPilot pickedPilot = file.npcVanguardPilots[ RandomInt( file.npcVanguardPilots.len() ) ]
	if ( replacePilot )
	{
		titan.SetTitle( pickedPilot.titanTitle ) // update titan title
	}

	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// setup shield. they don't have weak points so no need to increase health
		soul.SetShieldHealth( 0 )
		soul.SetShieldHealthMax( 2500 )

		// update seated pilot settings
		if ( replacePilot )
		{
			soul.soul.seatedNpcPilot.title = pickedPilot.pilotTitle
			soul.soul.seatedNpcPilot.modelAsset = pickedPilot.pilotModel
			if ( pickedPilot.neverEjects )
				TitanHealth_SetSoulNPCPilotEjectDelay( soul, -1 ) // -1 means never eject
		}

		PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )	// disable earnmeter smoke availability, they already have electric smoke
		// here has been reworked: we mark file.npcVanguardChassisTitan for them
		// in that case, they can't execute player titan and players can't execute them
		// npc executing each other is possible
		// reason why they can't execute player: their execution victim animation don't have camera attachment, which is pretty bad for players
		// reason why player can't execute them: for balancing they can't execute player
		// formerly nobody can execute them is because their victim animation don't have AE_MELEE_KILLED or other things a MP titan animation should have
		// it's now worked around with more modifications in _melee_synced_titan.gnut
		//MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // cannot execute BT, they don't have enough animations
		Rodeo_SetTitanRodeoSequenceEnabled( titan, false ) // bt don't have battery on hatch, don't allow removing
		MeleeSyncedTitan_SetSoulDoRandomExecution( soul, true ) // execution_bt is already random with bt, this is for random classic execution
	}

	// mark as vanguard chassis titan
	file.npcVanguardChassisTitan.append( titan )
}

const float NPC_VANGUARD_SHIELD_REGEN_DELAY = 6.0 // taken from titan_buddy.set( sp uses 3.0 )
const float NPC_VANGUARD_SHIELD_REGEN_TIME = TITAN_SHIELD_REGEN_TIME * 0.4 // scale down because npc vanguard class only have 1000 max shield( sp uses 2.0 )

void function NPCVanguard_EnableShieldRegen( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanHealth_SetSoulEnableShieldRegen( soul, true )
		TitanHealth_SetSoulShieldRegenDelay( soul, NPC_VANGUARD_SHIELD_REGEN_DELAY )
		TitanHealth_SetSoulShieldRegenTime( soul, NPC_VANGUARD_SHIELD_REGEN_TIME )
		//TitanHealth_SetSoulShieldDamageReductionScale( soul, 0.7 )
	}
}

void function NPCVanguard_GiveLoadout( entity titan )
{
	NPCVanguardLoadout pickedLoadout = file.npcVanguardLoadouts[ RandomInt( file.npcVanguardLoadouts.len() ) ]
	// update behavior first, so loadout functions can modify it
	if ( pickedLoadout.behaviorSelector != "" )
		titan.SetBehaviorSelector( pickedLoadout.behaviorSelector )
	// modified loadout case
	if ( pickedLoadout.loadoutFunction != null )
		pickedLoadout.loadoutFunction( titan )
	else // vanilla loadout case
	{
		TitanLoadoutDef titanLoadout
    	titanLoadout.setFile = pickedLoadout.setFile
		OverwriteLoadoutWithDefaultsForSetFile( titanLoadout )
		// manually apply loadout! only weapons are needed
		// directly modify this struct is all good
		//TakeAllWeapons( titan ) // never remove all weapons, only replace them if we have other weapon assigned
		
		// first we start removing
		// to avoid titan can have multiple weapon at the same usage or multiple smart ammo weapons
		bool hasPrimaryReplace = titanLoadout.primary != ""
		bool hasOrdnanceReplace = titanLoadout.ordnance != "" && !pickedLoadout.lockedAbilities.contains( OFFHAND_ORDNANCE )
		bool hasSpecialReplace = titanLoadout.special != "" && !pickedLoadout.lockedAbilities.contains( OFFHAND_SPECIAL )
		bool hasAntirodeoReplace = titanLoadout.antirodeo != "" && !pickedLoadout.lockedAbilities.contains( OFFHAND_ANTIRODEO )
		bool hasEquipmentReplace = titanLoadout.coreAbility != "" && !pickedLoadout.lockedAbilities.contains( OFFHAND_EQUIPMENT )
		bool hasMeleeReplace = titanLoadout.melee != "" && !pickedLoadout.lockedAbilities.contains( OFFHAND_MELEE )

		if ( hasPrimaryReplace )
		{
			foreach ( entity weapon in titan.GetMainWeapons() )
				titan.TakeWeaponNow( weapon.GetWeaponClassName() )
		}
		if ( hasOrdnanceReplace )
			titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
		if ( hasSpecialReplace )
			titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
		if ( hasAntirodeoReplace )
			titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
		if ( hasEquipmentReplace )
			titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
		if ( hasMeleeReplace )
			titan.TakeOffhandWeapon( OFFHAND_MELEE )
		
		// we start giving weapon after all replaced weapons removed
		if ( hasPrimaryReplace )
		{
			titanLoadout.primaryMods.removebyvalue( "" ) // primaryMods can have invalid values
			titan.GiveWeapon( titanLoadout.primary, titanLoadout.primaryMods )
		}
		if ( hasOrdnanceReplace )
			titan.GiveOffhandWeapon( titanLoadout.ordnance, OFFHAND_ORDNANCE, titanLoadout.ordnanceMods )
		if ( hasSpecialReplace )
			titan.GiveOffhandWeapon( titanLoadout.special, OFFHAND_SPECIAL, titanLoadout.specialMods )
		if ( hasAntirodeoReplace )
			titan.GiveOffhandWeapon( titanLoadout.antirodeo, OFFHAND_ANTIRODEO, titanLoadout.antirodeoMods )
		if ( hasEquipmentReplace )
			titan.GiveOffhandWeapon( titanLoadout.coreAbility, OFFHAND_EQUIPMENT )
		else // core ability unchanged, we're still using burst core
		{
			if ( pickedLoadout.useUpgradeCore ) // shield recharge only upgradecore
				NPCVanguard_UpgradeCore( titan )
			else
				titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability
		}
		if ( hasMeleeReplace )
			titan.GiveOffhandWeapon( titanLoadout.melee, OFFHAND_MELEE )
	}

	// funny case: hide rocket pod model if our loadout weapons won't use it
	if ( pickedLoadout.disableRocketPod )
	{
		int bodyGroupIndex = titan.FindBodyGroup( "back" )
		if ( bodyGroupIndex > -1 )
			titan.SetBodygroup( bodyGroupIndex, 1 ) // "buddy_titan_back_d_lod0.smd"
	}
}

void function NPCVanguard_BodygroupSetUp( entity titan )
{
	// might be funny to add battery_cap_center and battery_cap_outer for them? though I don't know what exact is that
	// EDIT: these two is enabled by default, it was used for SP where cooper inserts first two batteries for bt
	// maybe I can set these bodygroup to blank state when they're at low health? that's an useless detail again
	/*
	int bodyGroupIndex = titan.FindBodyGroup( "battery_cap_center" )
	if ( bodyGroupIndex > -1 )
		titan.SetBodygroup( bodyGroupIndex, 0 ) // "buddy_titan_battery_cap_center.smd"
	bodyGroupIndex = titan.FindBodyGroup( "battery_cap_outer" )
	if ( bodyGroupIndex > -1 )
		titan.SetBodygroup( bodyGroupIndex, 0 ) // "buddy_titan_battery_cap_outer.smd"
	*/
}

// give them a upgrade core without any upgrades, and change upgradeCount to 3
void function NPCVanguard_UpgradeCore( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		soul.SetTitanSoulNetInt( "upgradeCount", 3 )

	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT )
}

// loadout functions for vanguard
void function VanguardExpeditionLoadout( entity titan )
{
	// re-assign weapons
	// "mp_titanweapon_xo16_shorty" has been modified to add npc usage, no need to change weapon
	/*
	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	//titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["arc_rounds"] ) // use the arc-rounds monarch xo16
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard" ) // removed arc rounds
	*/

	titan.GetOffhandWeapon( OFFHAND_SPECIAL ).AddMod( "slow_recovery_vortex" ) // fix weapon mod
	titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "upgradeCore_MissileRack_Vanguard" ) // fix mod: lock on heavy armor target only
	titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability
}

void function VanguardNorthstarLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon( "mp_titanweapon_sniper" )
	//Defence. tether trap is utility ability and it can't be used together with electric smoke, just assign it to utility slot, and give a defense ability
	titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL )
	// Utility
	titan.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ANTIRODEO )
	//Offence
	titan.GiveOffhandWeapon( "mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )
	//Titan Core. leaving it unchanged, vanguard can't use hover
	//titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
	titan.GiveOffhandWeapon( "mp_titancore_amp_core", OFFHAND_EQUIPMENT, ["npc_bt_balance"] )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
}

void function VanguardBruteLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream", ["brute_rocket", "disable_run_and_gun_server"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex"] )
	// Utility. leaving it unchanged, vanguard can't use hover
	//titan.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_smoke", OFFHAND_ANTIRODEO )
	//Offence
	// we have buffed quad rocket that have higher projectile speed and can make npcs do explosion damage
	// no need to use multi-targeting missile( which extra_spawner branch uses )
	//titan.GiveOffhandWeapon( "mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE )
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley"] )
	//Titan Core. leaving it unchanged, vanguard can't use hover
	// EDIT: maybe change it to upgrade core with no upgrading?( only recharges shield. max shield increased to 2500 in NPCVanguard_SetUpTitan() )
	//titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
	//titan.GiveOffhandWeapon( "mp_titancore_amp_core", OFFHAND_EQUIPMENT, ["npc_bt_balance"] )
	NPCVanguard_UpgradeCore( titan )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
}

void function VanguardArchonLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon ( "mp_titanweapon_arc_cannon", ["archon_arc_cannon"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["archon_shock_shield"] )
	//Tactical
	titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node"] )
	//Offence
	titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball"] )
	//Titan Core
	// upgrade core that only recharges shield. max shield increased to 2500 in NPCVanguard_SetUpTitan()
	NPCVanguard_UpgradeCore( titan )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
}

void function BossLoadout_Gates( entity titan )
{
	// welp, there's something way too weird: pilots can sometimes play their intro animation???? emitting to the dropship sound that everyone could hear
	// happens after I adding holopilot and cloak ability for them. after disabling capability to attack, their animation went weird
	// guess I'll remove all boss titan disembarking/ejecting case...
	
	// boss titan rewards themselves a battery on performing execution
	//BossLoadout_ExecutionGivesBattery( titan )
	BossLoadout_Generic_NoModelForMP( titan ) // make them never eject, with basic setups for a boss titan

	// re-assign weapons
	titan.TakeWeaponNow( "mp_titanweapon_xo16_vanguard" )
	titan.GiveWeapon( "mp_titanweapon_sticky_40mm", ["extended_ammo"] )

	titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	// npcs has "npc_min_burst" "8", but can it affect total firing count without "pas_tone_rockets"? idk, let's just add it
	titan.GiveOffhandWeapon( "mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE, ["pas_tone_rockets"] )

	//titan.GetOffhandWeapon( OFFHAND_SPECIAL ).AddMod( "energy_field_energy_transfer" ) // note that due it's setfile is misisng npc_explosion_damage, npcs can't use it properly
	titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex"] )

	titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_phase_dash", OFFHAND_ANTIRODEO )

	// npc cannot use upgrade core, change to salvo core or laser core
	//NPCAtlasTitanCoreReplace( titan )
	// now only use laser core because we've add salvo core for sarah
	// EDIT: sarah salvo core has been removed, now only use salvo core because we've added laser core for archon
	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	//titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
	titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
}

void function BossLoadout_Bear( entity titan )
{
	// bear don't have suitable model for MP, make him never eject
	// boss titan rewards themselves a battery on performing execution
	//BossLoadout_ExecutionGivesBattery( titan )
	BossLoadout_Generic_NoModelForMP( titan ) // make them never eject, with basic setups for a boss titan

	// re-assign weapons
	titan.TakeWeaponNow( "mp_titanweapon_xo16_vanguard" )
	titan.GiveWeapon( "mp_titanweapon_leadwall", ["pas_ronin_weapon"] )

	titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ANTIRODEO )

	// setup custom upgrades
	// first upgrade: missile racks
	UpgradeCore_SetTitanUpgradePassive( titan, 0, ePassives.PAS_VANGUARD_CORE2 ) 
	// second upgrade: maelstrom
	UpgradeCore_SetTitanUpgradePassive( titan, 1, ePassives.PAS_VANGUARD_CORE5 )
	// third upgrade: multi-targeting missiles
	UpgradeCore_SetTitanUpgradePassive( titan, 2, ePassives.PAS_VANGUARD_CORE7 )
	// forth upgrade: superior chassis
	UpgradeCore_SetTitanUpgradePassive( titan, 3, ePassives.PAS_VANGUARD_CORE8 )

	// setup camo
	titan.SetCamo( 130 ) // Lockdown Binary
}

void function InitDefaultNPCHandlerFunctions()
{
	file.squadHandlerFunc = ExtraSpawner_SquadHandler
	file.npcHandlerFuncs[ "npc_pilot_elite" ] <- ExtraSpawner_PilotHandler
	file.npcHandlerFuncs[ "npc_titan" ] <- ExtraSpawner_TitanHandler
	file.npcHandlerFuncs[ "npc_super_spectre" ] <- ExtraSpawner_ReaperHandler
}

void functionref( entity ) function GetNPCHandlerForClass( string className )
{
	if ( !( className in file.npcHandlerFuncs ) )
		return null
	return file.npcHandlerFuncs[ className ]
}

void function ExtraSpawner_SetNPCWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcMainWeaponsTable ) )
		file.npcMainWeaponsTable[ npcClass ] <- []
	file.npcMainWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCSecondaryWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcSecondaryWeaponsTable ) )
		file.npcSecondaryWeaponsTable[ npcClass ] <- []
	file.npcSecondaryWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCAntiTitanWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcAntiTitanWeaponsTable ) )
		file.npcAntiTitanWeaponsTable[ npcClass ] <- []
	file.npcAntiTitanWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCGrenadeWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcGrenadeWeaponsTable ) )
		file.npcGrenadeWeaponsTable[ npcClass ] <- []
	file.npcGrenadeWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCExtraWeaponMods( string npcClass, array<string> mods )
{
	if ( !( npcClass in file.npcExtraWeaponModsTable ) )
		file.npcExtraWeaponModsTable[ npcClass ] <- []
	file.npcExtraWeaponModsTable[ npcClass ] = mods
}

void function ExtraSpawner_SetCarePackageWeapons( array<string> weapons )
{
	file.carePackageWeapons = weapons
}

// this can only set a single weapon's mod
void function ExtraSpawner_SetCarePackageWeaponMods( string weaponName, array<string> weaponMods )
{
	if ( !( weaponName in file.carePackageWeaponMods ) )
		file.carePackageWeaponMods[weaponName] <- weaponMods
	else
		file.carePackageWeaponMods[weaponName] = weaponMods
}

// this will reset the whole table
void function ExtraSpawner_SetCarePackageWeaponModsMultiple( table< string, array<string> > weaponModsTable )
{
	file.carePackageWeaponMods = weaponModsTable
}

void function ExtraSpawner_RegisterToTitanSpawnList( string spawnName, string setFile, string aiSet, string executionRef = "", string embarkedAiSet = "", string embarkedBehavior = "", string embarkedTitle = "", void functionref( entity ) loadoutFunction = null, int imcSkinIndex = -1, int mltSkinIndex = -1 )
{
	// spawn name needs to be unique
	if ( spawnName in file.titanSpawnList )
	{
		print( "[EXTRA SPAWNER] Titan with name \"" + spawnName + "\" has already been registered!" )
		return
	}

	TitanSpawnStruct newStruct
	newStruct.setFile = setFile
	newStruct.aiSet = aiSet
	newStruct.executionRef = executionRef // funny with MeleeSyncedNPC
	// after being embarked by npcs
	newStruct.embarkedAiSet = embarkedAiSet
	newStruct.embarkedBehavior = embarkedBehavior
	newStruct.embarkedTitle = embarkedTitle
	// loadout
	newStruct.loadoutFunction = loadoutFunction
	// skin
	newStruct.imcSkinIndex = imcSkinIndex
	newStruct.mltSkinIndex = mltSkinIndex

	file.titanSpawnList[ spawnName ] <- newStruct
	print( "[EXTRA SPAWNER] Registered titan spawn: " + spawnName )
}

void function ExtraSpawner_RegisterToBossTitanSpawnList( string spawnName, string bossName, string setFile, string aiSet, string behavior = "", string executionRef = "", string bossTitle = "", string pilotTitle = "", asset characterModel = $"", void functionref( entity ) loadoutFunction = null, int skinIndex = -1, int decalIndex = -1 )
{
	// spawn name needs to be unique
	if ( spawnName in file.bossTitanSpawnList )
	{
		print( "[EXTRA SPAWNER] Boss titan with name \"" + spawnName + "\" has already been registered!" )
		return
	}

	BossTitanSpawnStruct newStruct
	newStruct.bossName = bossName
	newStruct.setFile = setFile
	newStruct.aiSet = aiSet
	newStruct.behavior = behavior
	newStruct.executionRef = executionRef // funny with MeleeSyncedNPC
	newStruct.bossTitle = bossTitle
	newStruct.pilotTitle = pilotTitle
	newStruct.characterModel = characterModel
	// loadout
	newStruct.loadoutFunction = loadoutFunction
	// skin
	newStruct.skinIndex = skinIndex
	newStruct.decalIndex = decalIndex

	file.bossTitanSpawnList[ spawnName ] <- newStruct
	print( "[EXTRA SPAWNER] Registered Boss titan spawn: " + spawnName )
}

void function ExtraSpawner_SetNPCPilotEmbarkedTitanNuke( entity titan )
{
	NPC_SetNuclearPayload( titan )

	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// modified functions in sh_titan.gnut
		// make damage same as player's titan does, with longer explosion duration
		// EDIT: scale down explosion duration and damage so we don't receive weird visual effect
		TitanEject_SetSoulNukeExplosionDamageOverride(
			soul, 			// current soul
			10, 			// explosion count
			1.0, 			// explosion duration. was 1.5
			60, 			// damage. was 75
			2150, 			// damage heavy armor. was 2500
			350, 			// inner radius
			600, 			// outer radius
			SF_ENVEXPLOSION_MASK_BRUSHONLY,		// explosion flags
			0,				// explosion force
			DF_RAGDOLL | DF_EXPLOSION,			// script damage flags
			damagedef_nuclear_core				// damage source
		)
	}
}

// disable any sensing: dont let AI get enemies. Don't do trigger checks
// mainly used for scripted npc stuffs
void function ExtraSpawner_DisableSensingForNPC( entity npc, bool invulnerable = false, bool hide = false, bool freeze = false )
{
	npc.SetEfficientMode( true )
	npc.SetTouchTriggers( false )
	npc.SetAimAssistAllowed( false )

	if ( invulnerable )
	{
		npc.SetInvulnerable()
		npc.SetNoTarget( true ) // notarget bind together with invulnerablility
	}
	if ( hide )
	{
		npc.Hide()
		HideName( npc )
		RemoveMinimapForNPC( npc )
	}
	if ( freeze )
	{
		if ( !npc.IsFrozen() )
			npc.Freeze()
	}
}

void function ExtraSpawner_RestoreSensingForNPC( entity npc, bool vulnerable = false, bool show = false, bool unfreeze = false )
{
	npc.SetEfficientMode( false )
	npc.SetTouchTriggers( true )
	npc.SetAimAssistAllowed( true )

	if ( vulnerable )
	{
		npc.ClearInvulnerable()
		npc.SetNoTarget( false )
	}
	if ( show )
	{
		npc.Show()
		ShowName( npc )
		AddMinimapForNPC( npc )
	}
	if ( unfreeze )
	{
		if ( npc.IsFrozen() )
			npc.Unfreeze()
	}
}

void function ExtraSpawner_SetSquadHandlerFunc( void functionref( array<entity> ) handler )
{
	file.squadHandlerFunc = handler
}

void function ExtraSpawner_SetNPCHandlerFunc( string npcClass, void functionref( entity ) handler )
{
	if ( !( npcClass in file.npcHandlerFuncs ) )
		file.npcHandlerFuncs[ npcClass ] <- null
	file.npcHandlerFuncs[ npcClass ] = handler
}

// utility for handling assault target
bool function IsValidNPCAssaultTarget( entity ent )
{
	// got killed but still valid?
	if ( !IsAlive( ent ) )
		return false

	// is flight target?
	if ( IsAirFlightTarget( ent ) )
		return false

	// cannot be targeted?
	if ( ent.GetNoTarget() ) 
		return false

	// is invulnerable?
	if ( ent.IsInvulnerable() )
		return false

	// been cloaked?
	if ( IsCloaked( ent ) )
		return false

	// doing phase shift?
	if ( ent.IsPhaseShifted() )
		return false
	
	// npc
	if ( ent.IsNPC() )
	{
		// titan
		if ( ent.IsTitan() )
		{
			// is hot dropping?
			if ( ent.e.isHotDropping )
				return false
		}
	}

	// all checks passed
	return true
}

// should never assault any flight target
bool function IsAirFlightTarget( entity ent )
{
	if ( IsAirDrone( ent ) )
		return true
	if ( IsGunship( ent ) )
		return true

	return false
}

array<entity> function FindNPCAssaultHeavyArmorTargets_FailSafeToAllTargets( array<entity> targetsToSearch )
{
	array<entity> validTargets

	bool foundHeavyArmorTarget = false
	// first searching: heavy armor target
	foreach ( entity ent in targetsToSearch )
	{
		// general check
		if ( !IsValidNPCAssaultTarget( ent ) )
			continue

		if ( ent.GetArmorType() == ARMOR_TYPE_HEAVY )
		{
			validTargets.append( ent )
			foundHeavyArmorTarget = true
		}
	}
	// failsafe: can't find any heavyarmor target!
	if ( !foundHeavyArmorTarget )
	{
		// use all targets instead
		foreach ( entity ent in targetsToSearch )
		{
			// general check
			if ( !IsValidNPCAssaultTarget( ent ) )
				continue

			validTargets.append( ent )
		}
	}

	return validTargets
}

// npc titan specific: prefer assault to other titans
array<entity> function FindNPCTitanAssaultTargets( array<entity> targetsToSearch )
{
	array<entity> validTargets

	bool foundTitanTarget = false
	foreach ( entity ent in targetsToSearch )
	{
		if ( !IsValidNPCAssaultTarget( ent ) )
			continue

		if ( ent.IsTitan() )
		{
			validTargets.append( ent )
			foundTitanTarget = true
		}
	}

	// can't find any titan target! prefer finding heavy armor targets
	if ( !foundTitanTarget )
		return FindNPCAssaultHeavyArmorTargets_FailSafeToAllTargets( targetsToSearch )

	return validTargets
}


// can't stop squad handler. maybe we need to store squad stuffs into a table
void function ExtraSpawner_StopDefaultHandler( entity npc )
{
	npc.Signal( "StopDefaultHandler" )
}

//------------------------------------------------------
// for debugging
#if EXTRA_SPAWNER_DEBUG
bool function CC_KillAllNPCsFromExtraSpawner( entity player, array<string> args )
{
	foreach ( entity npc, bool spawnFrom in file.npcSpawnFromExtraSpawner )
	{
		if ( IsAlive( npc ) )
			npc.Die()
	}

	return true
}

bool function CC_SpawnPilotAndTitan( entity player, array<string> args )
{   
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	string spawnName = ""
	if ( args.len() > 0 )
		spawnName = args[0]
	// if spawn name invalid, we will spawn a random titan

    Point dropPoint = GetTitanReplacementPoint( player )
	thread ExtraSpawner_SpawnPilotCanEmbark( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args, 1 ), spawnName )
	return true
}

bool function CC_SpawnTitanWithPilot( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	string spawnName = ""
	if ( args.len() > 0 )
		spawnName = args[0]
	// if spawn name invalid, we will spawn a random titan

    Point dropPoint = GetTitanReplacementPoint( player )
	thread ExtraSpawner_SpawnTitanWithPilot( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args, 1 ), spawnName )
	return true
}

bool function CC_SpawnReaperCanLaunchTicks( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	Point dropPoint = GetTitanReplacementPoint( player )
    thread ExtraSpawner_SpawnReaperCanLaunchTicks( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
    return true
}

bool function CC_SpawnGunShip( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	Point dropPoint = GetTitanReplacementPoint( player )
    thread ExtraSpawner_SpawnGunShip( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
    return true
}

// shouldn't be used because we've removed npc_pilot_elite_assassin stuffs
/*
bool function CC_SpawnAssassinPilot( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity pilot = CreateNPC( "npc_pilot_elite", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_AISettings( pilot, "npc_pilot_elite_assassin" )

	// many things below should have a reference in _ai_pilots.gnut, for npc pilots ejecting
	asset modelAsset = NPC_PILOT_ALLOWED_MODELS[ RandomInt(NPC_PILOT_ALLOWED_MODELS.len()) ]
	pilot.SetValueForModelKey( modelAsset )
	pilot.SetModel( modelAsset )//

	ExtraSpawner_SetUpSpawnedNPC( pilot ) // generic setup for any npc in this file
	DispatchSpawn( pilot ) // don't do delayed dispatchSpawn()
	pilot.SetModel( modelAsset )
	ExtraSpawner_SetUpNPCPilot( pilot )

	return true
}
*/

bool function CC_SpawnSpecialistGrunt( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity grunt = CreateNPC( "npc_soldier", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_AISettings( grunt, "npc_soldier_drone_summoner" )
	SetSpawnOption_Weapon( grunt, "mp_weapon_pulse_lmg" )

	ExtraSpawner_SetUpSpawnedNPC( grunt ) // generic setup for any npc in this file
	DispatchSpawn( grunt ) // don't do delayed dispatchSpawn()

	grunt.SetModel( $"models/robots/spectre/imc_spectre.mdl" )

	return true
}

bool function CC_SpawnPilotElite( entity player, array<string> args )
{   
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	
	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
   
	entity pilot = ExtraSpawner_SpawnPilotElite( pos, rot, GetPlayerAISpawnTeam( player, args ) )
    //TakeAllWeapons( pilot )
	//pilot.GiveWeapon( "mp_titanweapon_arc_cannon", ["archon_arc_cannon"] )
	//pilot.GiveWeapon( "mp_weapon_defender" )
	//pilot.GiveWeapon( "mp_weapon_pulse_lmg" )
	//pilot.GiveWeapon( "mp_weapon_hemlok" )
	return true
}

bool function CC_SpawnBossTitan( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) )
	{
		if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
			return false
	}

	if ( args.len() == 0 ) // boss titan require a specific spawn name to spawn from console
		return true

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	int team = GetPlayerAISpawnTeam( player, args, 1 ) //RandomIntRange( 2, 4 )

	string bossType = args[0].tolower()
	ExtraSpawner_SpawnBossTitan( pos, rot, team, bossType )

	return true
}

bool function CC_SpawnBossTitanWithIntro( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) )
	{
		if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
			return false
	}

	if ( args.len() == 0 )
		return true

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	int team = TEAM_BOTH

	string bossType = args[0].tolower()
	ExtraSpawner_SpawnBossTitan( pos, rot, team, bossType, TITAN_MERC )

	return true
}

bool function CC_SpawnTestPistolGrunt( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity grunt = CreateNPC( "npc_soldier", GetPlayerAISpawnTeam( player, args ), pos, rot )
	grunt.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll switch to pistol if needed
	//SetSpawnOption_Weapon( grunt, "mp_weapon_smart_pistol" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_wingman" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_autopistol" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_semipistol" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_alternator_smg" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_wingman_n" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_shotgun_pistol" )
	SetSpawnOption_Weapon( grunt, "mp_weapon_shotgun_doublebarrel_tfo" )

	ExtraSpawner_SetUpSpawnedNPC( grunt ) // generic setup for any npc in this file
	DispatchSpawn( grunt ) // don't do delayed dispatchSpawn()

	//grunt.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
	grunt.GetMainWeapons()[0].AddMod( "projectile_shotgun_npc" )

	//grunt.SetModel( $"models/robots/spectre/imc_spectre.mdl" )

	return true
}

bool function CC_SpawnFakeMLTSpectre( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >

	entity spectre = CreateNPC( "npc_spectre", GetPlayerAISpawnTeam( player, args ), pos, rot )
	//SetSpawnOption_Weapon( spectre, "mp_weapon_pulse_lmg" )
	spectre.SetBehaviorSelector( "behavior_stalker" ) // so they don't do spectre specific behaviors, which they're missing animations
	spectre.EnableNPCMoveFlag( NPCMF_PREFER_SPRINT ) // can stalker sprint?
	spectre.DisableNPCFlag( NPC_CROUCH_COMBAT ) // pistol activity don't have crouch animations, disable crouch combat

	ExtraSpawner_SetUpSpawnedNPC( spectre ) // generic setup for any npc in this file
	DispatchSpawn( spectre )

	spectre.SetShieldHealthMax( 5000 )
	spectre.SetShieldHealth( 5000 )
	spectre.SetMaxHealth( 5000 )
	spectre.SetHealth( 5000 )
	// use stalker head
	spectre.SetModel( $"models/Robots/stalker/robot_stalker.mdl" )
	spectre.SetNPCMoveSpeedScale( 1.5 ) // stalkers always walk, make them do it faster
	//thread PrintColdWarNPCPrimaryAttack( spectre )
	//thread PrintPrimaryAttackSignal( spectre )

	return true
}

void function PrintColdWarNPCPrimaryAttack( entity npc )
{
	npc.EndSignal( "OnDeath" )
	npc.EndSignal( "OnDestroy" )

	int lastAmmo
	while ( true )
	{
		int currentAmmo
		entity activeWeapon = npc.GetActiveWeapon()
		if ( IsValid( activeWeapon ) )
			currentAmmo = activeWeapon.GetWeaponPrimaryClipCount()

		if ( lastAmmo != currentAmmo )
			print( "currentAmmo: " + string( currentAmmo ) )
		lastAmmo = currentAmmo
		WaitFrame()
	}
}

// npc themselves don't receive primary attack signal...
void function PrintPrimaryAttackSignal( entity npc )
{
	npc.EndSignal( "OnDeath" )
	npc.EndSignal( "OnDestroy" )

	while ( true )
	{
		table result = WaitSignal( npc, "OnPrimaryAttack" )
		//entity weapon = npc.GetActiveWeapon()
		//table result = WaitSignal( weapon, "OnPrimaryAttack" )
		print( "=========================================" )
		print( "OnPrimaryAttack signal print" )
		foreach ( key, value in result )
		{
			print( "key: " + string( key ) )
			print( "value: " + string( value ) )
		}
		print( "=========================================" )
	}
}

bool function CC_SpawnGruntDroppod( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	
	vector pos = GetPlayerCrosshairOrigin( player ) - < 0, 0, 40 > // needs offset for droppod landing
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >

	thread ExtraSpawner_SpawnSpecialistGruntDropPod( pos, rot, GetPlayerAISpawnTeam( player, args ), "npc_soldier", "npc_soldier_sidearm" )

	return true
}

bool function CC_DoNPCWeaponBodyGroupTestSpawn( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >

	entity grunt = CreateNPC( "npc_soldier", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_Weapon( grunt, "mp_weapon_rspn101_og" )

	ExtraSpawner_SetUpSpawnedNPC( grunt ) // generic setup for any npc in this file
	DispatchSpawn( grunt ) // don't do delayed dispatchSpawn()

	//grunt.SetModel( $"models/robots/spectre/imc_spectre.mdl" )
	entity weapon = grunt.GetActiveWeapon()
	print( "grunt weapon: " + string( weapon ) )
	thread DEBUG_UpdateNPCWeaponBodyGroup( grunt )

	return true
}

void function DEBUG_UpdateNPCWeaponBodyGroup( entity grunt )
{
	grunt.EndSignal( "OnDeath" )
	grunt.EndSignal( "OnDestroy" )

	while ( true )
	{
		entity weapon = grunt.GetActiveWeapon()
		if ( IsValid( weapon ) )
		{
			int bodyGroupIndex = weapon.FindBodyGroup( "sight_aog_r1" )
			if ( bodyGroupIndex > -1 )
				weapon.SetBodygroup( bodyGroupIndex, 1 )
		}

		WaitFrame()
	}
}

bool function CC_SpawnOverloadedStalkers( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	
	vector pos = GetPlayerCrosshairOrigin( player ) - < 0, 0, 40 > // needs offset for droppod landing
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >

	thread ExtraSpawner_SpawnOverloadedStalkerDropPod( pos, rot, GetPlayerAISpawnTeam( player, args ) )
	return true
}

// utility
int function GetPlayerAISpawnTeam( entity player, array<string> args, int validArgIndex = 0 )
{
	int team = TEAM_UNASSIGNED
	if( IsFFAGame() )
		team = TEAM_BOTH // so this ai won't have any teammates
    else
		team = GetOtherTeam( player.GetTeam() )

	if( args.len() > validArgIndex )
	{
		if( args[validArgIndex] == "sameteam" ) // spawn as teammate
			team = player.GetTeam()
	}

	return team
}
#endif // EXTRA_SPAWNER_DEBUG

//------------------------------------------------------

// copied from cl_replacement_titan_hud.gnut
void function HotDrop_Spawnpoint( vector origin, int team, float impactTime, bool hasFriendlyWarning = false, int damageDef = -1 )
{
	array<entity> targetEffects = []
	vector surfaceNormal = < 0, 0, 1 >

	int index = GetParticleSystemIndex( $"P_ar_titan_droppoint" )

	if( hasFriendlyWarning || FriendlyFire_IsEnabled() ) // also warn friendly players, if we enabled friendly fire...
	{
		entity effectFriendly = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
		SetTeam( effectFriendly, team )
		EffectSetControlPointVector( effectFriendly, 1, FRIENDLY_COLOR_FX )
		effectFriendly.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
		effectFriendly.DisableHibernation()
		targetEffects.append( effectFriendly )
	}

	entity effectEnemy = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
	SetTeam( effectEnemy, team )
	EffectSetControlPointVector( effectEnemy, 1, ENEMY_COLOR_FX )
	effectEnemy.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	effectEnemy.DisableHibernation()
	targetEffects.append( effectEnemy )

	// so enemy npcs will mostly avoid them
	entity damageAreaInfo
	if ( damageDef > -1 )
	{
		damageAreaInfo = CreateEntity( "info_target" )
		DispatchSpawn( damageAreaInfo )
		damageAreaInfo.SetOrigin( origin )
		int dangerousTeam = FriendlyFire_IsEnabled() ? TEAM_INVALID : team // add friendlyfire support: if we enabled friendlyfire, this dangerous area will work for friendly npcs
		AI_CreateDangerousArea_DamageDef( damageDef, damageAreaInfo, dangerousTeam, true, true )
	}

	wait impactTime

	// clean up
	foreach( entity targetEffect in targetEffects )
	{
		if ( IsValid( targetEffect ) )
			EffectStop( targetEffect )
	}
	if ( IsValid( damageAreaInfo ) )
		damageAreaInfo.Destroy()
}

void function ExtraSpawner_ApplyNPCWeapons( entity npc, bool replaceAllWeapons = true, bool applyMods = true )
{
	string className = npc.GetClassName()

	array<string> mainWeapons
	array<string> secondaryWeapons
	array<string> antiTitanWeapons
	if ( className in file.npcMainWeaponsTable )
		mainWeapons = file.npcMainWeaponsTable[ className ]
	if ( className in file.npcSecondaryWeaponsTable )
		secondaryWeapons = file.npcSecondaryWeaponsTable[ className ]
	if ( className in file.npcAntiTitanWeaponsTable )
		antiTitanWeapons = file.npcAntiTitanWeaponsTable[ className ]

	if ( mainWeapons.len() == 0 && antiTitanWeapons.len() == 0 ) // no valid weapons
		return

	// take off existing main weapons, or sometimes they'll have a archer
	if ( replaceAllWeapons ) // only take all weapons if we're doing replacement.
	{
		foreach ( entity weapon in npc.GetMainWeapons() )
			npc.TakeWeaponNow( weapon.GetWeaponClassName() )
	}
	else // if we're not doing weapon replace, npc shouldn't take more than 3 weapons
	{
		if ( npc.GetMainWeapons().len() == 3 )
			return
	}

	// main weapon
	bool giveMainWeapon = mainWeapons.len() > 0
	bool giveSecondaryWeapon = secondaryWeapons.len() > 0
	if ( !replaceAllWeapons && npc.GetMainWeapons().len() >= 1 ) // npc already have a weapon and we disabled replace!
	{
		giveMainWeapon = false // don't give main weapon again
		giveSecondaryWeapon = false // here we also don't want to replace secondary
	}
	if ( giveMainWeapon )
	{
		string weaponName = mainWeapons[ RandomInt( mainWeapons.len() ) ]
		npc.GiveWeapon( weaponName )
		npc.SetActiveWeaponByName( weaponName )
	}
	// secondary
	if ( giveSecondaryWeapon ) // secondary weapon needs npc to have SelectSchedule_SwitchWeapon in their behavior to work
		npc.GiveWeapon( secondaryWeapons[ RandomInt( secondaryWeapons.len() ) ] )

	// anti-titan
	bool giveAntiTitanWeapon = antiTitanWeapons.len() > 0
	if ( giveAntiTitanWeapon )
		npc.GiveWeapon( antiTitanWeapons[ RandomInt( antiTitanWeapons.len() ) ] )

	if ( applyMods )
		ExtraSpawner_ApplyNPCExtraWeaponMods( npc ) // add extra weapon mods

	// also make them use heavy armor weapon
	npc.SetEnemyChangeCallback( ExtraSpawner_OnEnemyChanged_SwitchToHeavyArmorWeapon )
	// start updating weapon bodygroup
	ExtraSpawner_StartUpdatingNPCWeaponBodyGroup( npc )
}

// best way to update bodygroups... because some npc may switch weapon and SetEnemyChangeCallback() can't handle it
void function ExtraSpawner_StartUpdatingNPCWeaponBodyGroup( entity npc )
{
	thread StartUpdatingNPCWeaponBodyGroup_Threaded( npc )
}

void function StartUpdatingNPCWeaponBodyGroup_Threaded( entity npc )
{
	npc.EndSignal( "OnDestroy" )
	npc.Signal( "StartUpdatingNPCWeaponBodyGroup" )
	npc.EndSignal( "StartUpdatingNPCWeaponBodyGroup" )

	entity lastPrimaryWeaponEnt
	while ( true )
	{
		entity activeWeapon = npc.GetActiveWeapon()
		if ( IsValid( activeWeapon ) )
		{
			if ( activeWeapon != lastPrimaryWeaponEnt ) // weapon changed?
			{
				// debug
				//print( "NPC active weapon changed!" )
				UpdateNPCWeaponBodyGroup( npc )
			}
		}

		lastPrimaryWeaponEnt = activeWeapon

		WaitFrame()
	}
}

// ttf2 currently have up to 9 bodygroups for a weapon
const int WEAPON_BODYGROUP_MAX_COUNT = 9

void function UpdateNPCWeaponBodyGroup( entity npc )
{
	entity weapon = npc.GetActiveWeapon()
	if ( IsValid( weapon ) )
	{
		for ( int i = 0; i < WEAPON_BODYGROUP_MAX_COUNT; i++ )
		{
			string bodyGroupNum = string( i + 1 )
			string bodyGroupName = "bodygroup" + bodyGroupNum + "_name"
			string bodyGroupSet = "bodygroup" + bodyGroupNum + "_set"

			local currentBodyGroup = weapon.GetWeaponInfoFileKeyField( bodyGroupName )
			//print( "currentBodyGroup: " + currentBodyGroup )
			if ( currentBodyGroup == null )
				continue
			expect string( currentBodyGroup )
			
			int bodyGroupIndex = weapon.FindBodyGroup( currentBodyGroup )
			//print( "bodyGroupIndex: " + string( bodyGroupIndex ) )
			if ( bodyGroupIndex == -1 )
				continue
			
			int stateCount = weapon.GetBodyGroupModelCount( bodyGroupIndex )
			int newBodyGroup = weapon.GetWeaponSettingInt( eWeaponVar[ bodyGroupSet ] )
			//print( "newBodyGroup: " + string( newBodyGroup ) )
			if ( newBodyGroup > stateCount - 1 )
				continue

			// all checks passed, update bodygroup
			weapon.SetBodygroup( bodyGroupIndex, newBodyGroup )
		}
	}
}

// grenade have to be given before DispatchSpawn()
void function ExtraSpawner_ApplyNPCGrenadeWeapon( entity npc )
{
	string className = npc.GetClassName()
	array<string> grenadeWeapons
	if ( className in file.npcGrenadeWeaponsTable )
		grenadeWeapons = file.npcGrenadeWeaponsTable[ className ]

	if ( grenadeWeapons.len() == 0 ) // no valid weapons
		return

	npc.kv.grenadeWeaponName = grenadeWeapons[ RandomInt( grenadeWeapons.len() ) ] // this mainly controlls which grenade npc will equip
	//print( "npc.kv.grenadeWeaponName: " + npc.kv.grenadeWeaponName )
}

void function ExtraSpawner_ApplyNPCExtraWeaponMods( entity npc )
{
	string className = npc.GetClassName()

	array<string> modsToApply
	if ( className in file.npcExtraWeaponModsTable )
		modsToApply = file.npcExtraWeaponModsTable[ className ]

	if ( modsToApply.len() == 0 ) // no valid mods
		return

	foreach ( entity weapon in npc.GetMainWeapons() )
	{
		array<string> validMods = GetWeaponMods_Global( weapon.GetWeaponClassName() )
		foreach ( string mod in modsToApply )
		{
			if ( !validMods.contains( mod ) ) // this weapon don't have such a mod!
				continue

			// mods might be incompatible with each other, needs to try-catch
			try
			{
				weapon.AddMod( mod )
			}
			catch (ex)
			{
				// if we added a mod that conflicts with other mod, try to remove it
				weapon.RemoveMod( mod )
			}
		}
	}
}

// npcs will do this callback on player titan transfer
void function ExtraSpawner_OnEnemyChanged_SwitchToHeavyArmorWeapon( entity guy )
{
	// general checks
	guy.Signal( "ScriptedWeaponSwitch" ) // end last SwitchWeaponAfterAnimationDone() thread
	if ( !IsAlive( guy ) )
		return

	// every npc has this, but we'll save ones who have better proficiency
	if ( int( guy.kv.WeaponProficiency ) < eWeaponProficiency.VERYGOOD )
		SetProficiency( guy )

	// frozen npc won't update weapon
	if ( guy.IsFrozen() )
		return

	// changing to non-enemy state won't update weapon
	entity enemy = guy.GetEnemy()
	if ( !IsAlive( enemy ) )
		return

	array<entity> weapons = guy.GetMainWeapons()
	// do we have a weapon to switch to?
	if ( weapons.len() < 2 )
		return

	entity activeWeapon = guy.GetActiveWeapon()
	if ( !IsValid( activeWeapon ) ) // must be disabled weapon, no need to do following checks
		return

	string activeWeaponName = activeWeapon.GetWeaponClassName()
	bool antiTitanActive = activeWeapon != weapons[0] && !activeWeapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )

	bool isHeavyArmorTarget = enemy.GetArmorType() == ARMOR_TYPE_HEAVY

	string weaponToChange = ""
	if ( isHeavyArmorTarget )
	{
		// move antiTitanActive checks inside: we can ignore checks if antititan is already active
		// but we shouldn't run "else if ( antiTitanActive )" case to make grunts switch off AT weapon
		if ( antiTitanActive )
		{
			//print( "AT weapon already active for: " + string( guy ) )
			return
		}
		// first try to find an appropriate weapon
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			if ( activeWeaponName == className ) // already holding this weapon
				continue
			bool isMainWeapon = weapon == weapons[0]
			bool isAntiTitan = !weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
			// debug
			//print( string( weapon ) + " isAntiTitan: " + string( isAntiTitan ) )
			if ( isAntiTitan && !isMainWeapon )
			{
				weaponToChange = className
				break
			}
		}
	}
	else if ( antiTitanActive ) // light unit, switch off anti-titans
	{
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			if ( activeWeaponName == className ) // already holding this weapon
				continue
			bool isMainWeapon = weapon == weapons[0]
			bool isAntiTitan = !weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required )
			// debug
			//print( string( weapon ) + " isAntiTitan: " + string( isAntiTitan ) )
			if ( isMainWeapon || !isAntiTitan )
			{
				weaponToChange = className
				break
			}
		}
	}
 
	if ( weaponToChange == "" )
		return

	if ( guy.Anim_IsActive() ) // may have animation playing?
		thread SwitchWeaponAfterAnimationDone( guy, weaponToChange, isHeavyArmorTarget )
	else
		ScriptedNPCWeaponSwitch( guy, weaponToChange, isHeavyArmorTarget )
}

void function ScriptedNPCWeaponSwitch( entity guy, string weaponToChange, bool isHeavyArmorTarget = false )
{
	guy.SetActiveWeaponByName( weaponToChange )
	// debug
	//print( "weaponToChange: " + weaponToChange )

	// grunt specific: do dialogue(vanilla missing this in grunt_chatter_mp.rpak)
	if ( IsGrunt( guy ) && isHeavyArmorTarget )
	{
		string dialogueType = "bc_switchingToAT"
		string dialoguePrefix = "diag_imc_grunt"
		float dialogueRange = GRUNT_CHATTER_MP_RANGE
		int gruntVariants = 6 // 1~6
		int dialogueVariants = 2 // 1~2
		float debounce = 20.0
		// charge rifle specific
		if ( weaponToChange == "mp_weapon_defender" )
			dialogueType = "bc_usingChargeRifle"
		TryGruntDialogue( guy, dialogueType, dialoguePrefix, dialogueRange, gruntVariants, dialogueVariants, debounce )
	}
}

void function SwitchWeaponAfterAnimationDone( entity guy, string weaponToChange, bool isHeavyArmorTarget = false )
{
	guy.EndSignal( "OnDeath" )
	guy.EndSignal( "OnDestroy" )

	guy.Signal( "ScriptedWeaponSwitch" )
	guy.EndSignal( "ScriptedWeaponSwitch" )

	WaittillAnimDone( guy )
	ScriptedNPCWeaponSwitch( guy, weaponToChange, isHeavyArmorTarget )
}

// grunt dialogue is mostly a format of prefix + gruntNum + "_" + type + "_0" + dialogueNum
void function TryGruntDialogue( entity guy, string dialogueType, string dialoguePrefix, float dialogueRange, int gruntVariants, int dialogueVariants, float debounce = 20.0 )
{
	string gruntNum = string( RandomInt( gruntVariants ) + 1 )
	string dialogueNum = string( RandomInt( dialogueVariants ) + 1 )
	string builtDialogue = dialoguePrefix + gruntNum + "_" + dialogueType + "_0" + dialogueNum

	return TryScriptedNPCDialogue( guy, builtDialogue, dialogueRange, debounce )
}

void function TryScriptedNPCDialogue( entity guy, string dialogue, float dialogueRange, float debounce )
{
	array<entity> playersInRange
	foreach ( entity player in GetPlayerArray_Alive() )
	{
		if ( Distance( player.GetOrigin(), guy.GetOrigin() ) < dialogueRange )
			playersInRange.append( player )
	}

	foreach ( entity player in playersInRange )
		TryScriptedNPCDialogueOnPlayer( player, guy, dialogue, debounce )
}

// scripted npc dialogue, simply just emit a sound for npc
bool function TryScriptedNPCDialogueOnPlayer( entity player, entity guy, string dialogue, float debounce )
{
	// limit checks
	if ( Time() < file.npcDialogueNextAllowedTimeOnPlayer[ player ] )
		return false

	//print( "NPC " + string( guy ) + " is playing scripted dialogue: " + dialogue + " to player: " + string( player ) )

	// only needs to play dialogue to specific player
	EmitSoundOnEntityOnlyToPlayer( guy, player, dialogue )

	file.npcDialogueNextAllowedTimeOnPlayer[ player ] = Time() + debounce
	thread TrackDialogueSpeakerDeath( guy, dialogue, debounce )
	return true
}

void function TrackDialogueSpeakerDeath( entity guy, string dialogue, float debounce )
{
	guy.EndSignal( "OnDestroy" )
	guy.EndSignal( "OnDeath" )
	table results = {
		waitTilDialogueEnd = false
	}

	OnThreadEnd
	(
		function(): ( guy, dialogue, results )
		{
			if ( IsValid( guy ) )
			{
				if ( !results.waitTilDialogueEnd )
					StopSoundOnEntity( guy, dialogue )
			}
		}
	)

	wait debounce // max wait time
	results.waitTilDialogueEnd = true // mark as we ended dialogue properly
}

// this array is hardcoded, it contains all npcs that can show themselves on map
// from cl_minimap.nut
// if we handled a npc that can't create it's minimap icon, we create a fake icon using other npcs
const array<string> MAP_ICON_VAILD_NPC_CLASS =
[
	"npc_titan",
	"npc_soldier",
	"npc_spectre",
	"npc_stalker",
	"npc_super_spectre",
	"npc_drone_rocket",
	"npc_frag_drone",
	"npc_drone",
	"npc_dropship",
	"npc_turret_sentry",
	"npc_drone",
]

// there's something special for not harmful npcs... like marvin
// we don't create fake npc for them even when they don't have map icon
const array<string> MAP_ICON_DISABLED_NPC_CLASS =
[
	"npc_marvin",
]

// npcs within this table will add different offset for their fake map icon
const table<string, vector> NPC_FAKE_MAP_ICON_OFFSET =
{
	["npc_prowler"]		= < 0, 0, 100 > // prowlers has special hull type, needs change offset
}

// npc minimap setup
void function AddMinimapForNPC( entity guy, bool friendlyOnly = false )
{
	if ( !IsAlive( guy ) )
		return
	
	// map
	SetUpGenericNPCMiniMapIcon( guy, friendlyOnly )
	SetUpGamemodeSpecificMiniMapIcon( guy )
	
	// fake map icon check
	// we also enable map icon for them
	entity mapIconEnt = GetNPCFakeMinimapIconEnt( guy )
	if ( IsValid( mapIconEnt ) )
		SetUpGenericNPCMiniMapIcon( mapIconEnt, friendlyOnly )
}

// setup for modded npcs
void function AddMinimapForNPC_FailsafeToCreateFakeMapIcon( entity guy )
{
	string className = guy.GetClassName()
	if ( MAP_ICON_VAILD_NPC_CLASS.contains( className ) )
		AddMinimapForNPC( guy )
	else if ( !MAP_ICON_DISABLED_NPC_CLASS.contains( className ) ) // ents in this array never gets setup
	{
		// using a hacky way: add a tracked npc as fake npc
		if ( className in NPC_FAKE_MAP_ICON_OFFSET )
			CreateNPCAsFakeMapIconForNPC( guy, "npc_soldier", "ORIGIN", < 0, 0, 180 >, NPC_FAKE_MAP_ICON_OFFSET[ className ] )
		else
			CreateNPCAsFakeMapIconForNPC( guy, "npc_soldier" )
	}
}

void function SetUpGenericNPCMiniMapIcon( entity mapIcon, bool friendlyOnly = false )
{
	// map
	if ( friendlyOnly ) // show for friendly ONLY
	{
		int friendlyTeam = mapIcon.GetTeam()
		mapIcon.Minimap_AlwaysShow( friendlyTeam, null )
		foreach ( entity player in GetPlayerArrayOfTeam( friendlyTeam ) )
			mapIcon.Minimap_AlwaysShow( 0, player )
	}
	else
	{
		mapIcon.Minimap_AlwaysShow( TEAM_IMC, null )
		mapIcon.Minimap_AlwaysShow( TEAM_MILITIA, null )
		foreach ( entity player in GetPlayerArray() )
			mapIcon.Minimap_AlwaysShow( 0, player )
	}
	mapIcon.Minimap_SetHeightTracking( true )

	// in-file checks
	entity mapIconOwner = GetFakeMinimapIconOwner( mapIcon )
	if ( IsValid( mapIconOwner ) ) // consider this is a fake mapicon, we track their owner instead
		mapIcon = mapIconOwner
	
	if ( !( mapIcon in file.entEnabledMinimapIcon ) )
		file.entEnabledMinimapIcon[ mapIcon ] <- false // init
	file.entEnabledMinimapIcon[ mapIcon ] = true // mark as we've enabled map icon for this entity
}

bool function EntHasMinimapIconEnabled( entity mapIcon )
{
	if ( !( mapIcon in file.entEnabledMinimapIcon ) )
		return false
	
	return file.entEnabledMinimapIcon[ mapIcon ]
}

void function SetUpGamemodeSpecificMiniMapIcon( entity guy )
{
	if ( GAMETYPE == AI_TDM ) // eMinimapObject_npc.AI_TDM_AI only works for attrition! though not very necessary
	{
		// can be found in cl_gamemode_aitdm.nut
		const array<string> AITDM_VALID_MINIMAP_NPCS =
		[
			"npc_soldier",
			"npc_spectre",
			"npc_stalker",
			"npc_super_spectre"
		]
		if ( AITDM_VALID_MINIMAP_NPCS.contains( guy.GetClassName() ) )
			guy.Minimap_SetCustomState( eMinimapObject_npc.AI_TDM_AI )
	}
}

void function RemoveMinimapForNPC( entity guy, bool enemyOnly = false )
{
	//print( "RUNNING RemoveMinimapForNPC() for " + string( guy ) )

	if ( !IsAlive( guy ) )
		return
	
	// map
	DisableNPCMiniMapIcon( guy, enemyOnly )

	// fake map icon check
	// we also remove map icon for them
	entity mapIconEnt = GetNPCFakeMinimapIconEnt( guy )
	if ( IsValid( mapIconEnt ) )
		DisableNPCMiniMapIcon( mapIconEnt, enemyOnly )
}

void function DisableNPCMiniMapIcon( entity mapIcon, bool enemyOnly = false )
{
	if ( enemyOnly ) // hide from enemy team ONLY
	{
		int friendlyTeam = mapIcon.GetTeam()
		if ( !IsFFAGame() )
			mapIcon.Minimap_Hide( GetOtherTeam( friendlyTeam ), null )
		foreach ( entity player in GetPlayerArrayOfEnemies( friendlyTeam ) )
			mapIcon.Minimap_Hide( 0, player )
	}
	else // hide from all team
	{
		mapIcon.Minimap_Hide( TEAM_IMC, null )
		mapIcon.Minimap_Hide( TEAM_MILITIA, null )
		foreach ( entity player in GetPlayerArray() )
			mapIcon.Minimap_Hide( 0, player )
	}
	mapIcon.Minimap_SetHeightTracking( false )

	// in-file checks
	entity mapIconOwner = GetFakeMinimapIconOwner( mapIcon )
	if ( IsValid( mapIconOwner ) ) // consider this is a fake mapicon, we track their owner instead
		mapIcon = mapIconOwner
	
	if ( mapIcon in file.entEnabledMinimapIcon )
		file.entEnabledMinimapIcon[ mapIcon ] = false // mark as we've disabled map icon for this entity
}

// set up a titan without have to make a npc pilot embarking it
// can't use localized string as pilotTitle, because pilot disembarking will and reset autotitan's title
void function ExtraSpawner_SetUpTitanSeatedPilot( entity titan, int pilotHealth = NPC_PILOT_MAX_HEALTH, int pilotWeaponProficiency = eWeaponProficiency.PERFECT, asset pilotModel = $"", string pilotTitle = "鐵馭" )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return

	entity pilot = ExtraSpawner_SpawnPilotElite( titan.GetOrigin(), < 0, 0, 0 >, titan.GetTeam() )
	// this destroys pilot
	NpcPilotBecomesTitan( pilot, titan )

	// do some override settings
	if ( pilotModel != $"" ) // if specific model given, we override model with that
		titanSoul.soul.seatedNpcPilot.modelAsset		= pilotModel
	if ( pilotTitle != "" )
		titanSoul.soul.seatedNpcPilot.title				= pilotTitle
	titanSoul.soul.seatedNpcPilot.proficiency			= pilotWeaponProficiency
	titanSoul.soul.seatedNpcPilot.health				= pilotHealth
}

// npc pilot embarking npc titans
void function SetTitanSoulEmbarkedSettings( entity titan, string aiSet, string behavior, string title )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	EmbarkedNPCTitanStruct newStruct

	if ( aiSet != "" )
		newStruct.embarkedAiSet = aiSet
	if ( behavior != "" )
		newStruct.embarkedBehavior = behavior
	if ( title != "" )
		newStruct.embarkedTitle = title

	if ( !( soul in file.soulEmbarkedSettings ) )
		file.soulEmbarkedSettings[ soul ] <- newStruct
	else
		file.soulEmbarkedSettings[ soul ] = newStruct
}

void function ApplySoulSettingsForNpcPilotEmbarking( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	EmbarkedNPCTitanStruct embarkedSettings

	if ( soul in file.soulEmbarkedSettings )
		embarkedSettings = file.soulEmbarkedSettings[ soul ]

	string newAiSet = embarkedSettings.embarkedAiSet
	string newBehavior = "behavior_sp_auto_titan" // default is become smarter than mp titans
	if ( embarkedSettings.embarkedBehavior != "" )
		newBehavior = embarkedSettings.embarkedBehavior
	string newTitle = ""
	if ( embarkedSettings.embarkedTitle != "" )
		newTitle = embarkedSettings.embarkedTitle
	else  // default is use print name
	{
		try // have to try-catch this since not all modded titans has GetSoulPlayerSettings() ( like for bisons )
		{
			string settings = GetSoulPlayerSettings( soul )
			var maintainTitle = Dev_GetPlayerSettingByKeyField_Global( settings, "keep_title_on_autotitan" )
			if ( maintainTitle != null && maintainTitle == 1 )
				newTitle = expect string( GetPlayerSettingsFieldForClassName( settings, "printname" ) )
		}
		catch( ex ) {}
	}

	// guess there's no need to update model and bodygroup
	// may cause issue for rodeoing...
	// changing a titan's aisetting and behavior after dispatchSpawn() won't update their model and bodygroup
	//asset modelName = titan.GetModelName() // maybe they're prime titans or something, save them to prevent changing aiSettings mess things up
	//int fullBodygroup = titan.GetFullBodygroup() // also save bodygroup

	if ( newAiSet != "" ) // can't find a new aisetting
		titan.SetAISettings( newAiSet )
	if ( newBehavior != "" )
		titan.SetBehaviorSelector( newBehavior )
	if ( newTitle != "" )
		titan.SetTitle( newTitle )
	
	//titan.SetModel( modelName ) // recover model
	//titan.SetFullBodygroup( fullBodygroup ) // recover bodygroup. hitData is still in titan's settings so no worries
}

// utilities end

// copied from _ai_gamemodes, make them compatible with more settings
void function ExtraSpawner_SpawnDropShip( vector pos, vector rot, int team, string content, int count, void functionref( array<entity> guys ) squadHandler = null )
{  
	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_dropship_squad" ) )

	entity functionref( int team, vector origin, vector angles ) spawnFunc = GetDropshipSpawnFunc( content )
	if ( spawnFunc == null )
	{
		print( "[EXTRA SPAWNER] No Valid dropship spawn function for: " + content )
		return
	}

	CallinData drop
	drop.origin			= pos
	drop.yaw			= rot.y
	drop.dist			= 768
	drop.team			= team
	drop.squadname		= squad
	SetDropTableSpawnFuncs( drop, spawnFunc, count )
	SetCallinStyle( drop, eDropStyle.ZIPLINE_NPC )
  
	thread RunDropshipDropoff( drop )
	
	WaitSignal( drop, "OnDropoff" )
	
	array<entity> guys = GetNPCArrayBySquad( squad )
	
	foreach ( guy in guys )
	{
		ExtraSpawner_ApplyNPCWeapons( guy )
		// no need to setup ai here...
		//guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

entity functionref( int, vector, vector ) function GetDropshipSpawnFunc( string content )
{
	switch ( content )
	{
		case "npc_soldier":
			return CreateSoldier_GrenadeSetup
		case "npc_spectre":
			return CreateSpectre_GrenadeSetup
		case "npc_stalker":
			return CreateStalker_GrenadeSetup
	}
	
	return null
}

// these are exact the same as CreateXXX() stuffs in _ai_spawn.gnut, but added ExtraSpawner_ApplyNPCGrenadeWeapon()
entity function CreateSoldier_GrenadeSetup( int team, vector origin, vector angles )
{
	entity npc = CreateSoldier( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

	ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file

	return npc
}

entity function CreateSpectre_GrenadeSetup( int team, vector origin, vector angles )
{
	entity npc = CreateSpectre( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

	ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file

	return npc
}

entity function CreateStalker_GrenadeSetup( int team, vector origin, vector angles )
{
	entity npc = CreateStalker( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

	ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file

	return npc
}
//

void function ExtraSpawner_SpawnDropPod( vector pos, vector rot, int team, string content, void functionref( array<entity> guys ) squadHandler = null, int droppodFlags = 0 )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, droppodFlags )
	
	// wait for launch
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_droppod_squad" ) )
	array<entity> guys
	for ( int i = 0; i < SQUAD_SIZE; i++ )
	{
		entity npc = CreateNPC( content, team, pos, <0,0,0> )
		ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

		ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file
		DispatchSpawn( npc )

		SetSquad( npc, squad )
		
		ExtraSpawner_ApplyNPCWeapons( npc )
		
		npc.SetParent( pod, "ATTACH", true )
		
		// no need to setup ai here...
		//npc.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guys.append( npc )
	}

	ActivateFireteamDropPod( pod, guys )

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

// default handler!
// tells infantry where to go
// In vanilla there seem to be preset paths ai follow to get to the other teams vone and capture it
// AI can also flee deeper into their zone suggesting someone spent way too much time on this
void function ExtraSpawner_SquadHandler( array<entity> guys )
{
	int team = guys[0].GetTeam()
	bool hasHeavyArmorWeapon = false // let's check if guys has heavy armor weapons
	foreach ( entity guy in guys )
	{
		if ( hasHeavyArmorWeapon ) // found heavy armor weapon
			break

		foreach ( entity weapon in guy.GetMainWeapons() )
		{
			if ( !weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required ) )
			{
				hasHeavyArmorWeapon = true
				break
			}
		}
	}
	//print( "hasHeavyArmorWeapon: " + string( hasHeavyArmorWeapon ) )

	array<entity> points
	vector point

	// Setup AI
	foreach ( guy in guys )
	{
		// add map
		//AddMinimapForNPC( guy )
		// if we can't handle this npc's map, generate fake map icon ent for them
		// welp this can't be handled properly, there're something like prowlers always rotates their attachments
		// reworked to add less offset, rotate map icon npc to upside-down
		AddMinimapForNPC_FailsafeToCreateFakeMapIcon( guy )

		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		if ( hasHeavyArmorWeapon ) // squads won't flee if they got heavy armor weapon
			guy.DisableNPCFlag( NPC_ALLOW_FLEE )

		guy.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	}

	wait 3 // initial wait before guys disembark from droppod

	// Every 5 - 15 secs get a closest target and go to them
	while ( true )
	{
		WaitFrame() // wait a frame each loop

		// remove dead guys
		ArrayRemoveDead( guys )
		foreach ( guy in guys )
		{
			// check leechable guys
			if ( guy.GetTeam() != team )
				guys.removebyvalue( guy )
		}
		// Stop func if our squad has been killed off
		if ( guys.len() == 0 )
			return

		// Get point and send our whole squad to it
		points = [] // clean up last pointS
		array<entity> pointsToSearch = []
		// try to find from npc targets
		pointsToSearch.extend( GetNPCArrayOfEnemies( team ) )
		// try to find from alive player targets
		pointsToSearch.extend( GetPlayerArrayOfEnemies_Alive( team ) )

		// start searching
		foreach ( entity ent in pointsToSearch )
		{
			// general check
			if ( !IsValidNPCAssaultTarget( ent ) )
				continue

			// infantry specific
			// only search for targets with light armor if we don't have proper weapon
			if ( !hasHeavyArmorWeapon && ent.GetArmorType() == ARMOR_TYPE_HEAVY )
				continue

			points.append( ent )
		}

		ArrayRemoveDead( points ) // remove dead targets
		if ( points.len() == 0 ) // can't find any points here
			continue

		// get nearest enemy and send our full squad to it
		entity enemy = GetClosest2D( points, guys[0].GetOrigin() )
		if ( !IsAlive( enemy ) )
			continue
		point = enemy.GetOrigin()

		// get clamped pos for first guy of guys
		vector ornull clampedPos = NavMesh_ClampPointForAI( point, guys[0] )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )

		foreach ( guy in guys )
		{
			if ( IsAlive( guy ) )
				guy.AssaultPoint( clampedPos )
		}

		// remove random wait to make them more aggresive?
		// never do it. too many assault point can make them move really silly
		wait RandomFloatRange(5.0,15.0)
	}
}

entity function ExtraSpawner_SpawnTitan( vector pos, vector rot, int team, bool doHotDrop = true, void functionref( entity titan ) titanHandler = null, string spawnName = "" )
{
	array<string> registeredTitans
	foreach ( string titanName, TitanSpawnStruct titanStruct in file.titanSpawnList )
		registeredTitans.append( titanName )

	// can't find any titan
	if ( registeredTitans.len() <= 0 )
		return

	string setFile = ""
	string aiSet = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	// after being embarked
	string embarkedAiSet = ""
	string embarkedBehavior = ""
	string embarkedTitle = ""
	void functionref( entity ) loadoutFunction = null
	// team skin
	int imcSkinIndex = -1
	int mltSkinIndex = -1

	// get a registered titan
	// leaving spawn name to "" meaning we'll pick a random one
	// we also try to pick a random titan if given spawn name not found
	if ( spawnName == "" || !registeredTitans.contains( spawnName ) )
		spawnName = registeredTitans[ RandomInt( registeredTitans.len() ) ]

	TitanSpawnStruct currentTitan = file.titanSpawnList[ spawnName ]
	setFile 			= currentTitan.setFile
	aiSet 				= currentTitan.aiSet
	executionRef 		= currentTitan.executionRef
	embarkedAiSet 		= currentTitan.embarkedAiSet
	embarkedBehavior 	= currentTitan.embarkedBehavior
	embarkedTitle 		= currentTitan.embarkedTitle
	loadoutFunction		= currentTitan.loadoutFunction
	imcSkinIndex 		= currentTitan.imcSkinIndex
	mltSkinIndex 		= currentTitan.mltSkinIndex

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiSet )
    titan.ai.titanSpawnLoadout.setFile = setFile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	ExtraSpawner_SetUpSpawnedNPC( titan ) // generic setup for any npc in this file
	DispatchSpawn( titan )

	// set up embarked behavior
	SetTitanSoulEmbarkedSettings( titan, embarkedAiSet, embarkedBehavior, embarkedTitle )

	// update team specific skin
	if ( team == TEAM_IMC && imcSkinIndex > -1 )
		titan.SetSkin( imcSkinIndex )
	if ( team == TEAM_MILITIA && mltSkinIndex > -1 )
		titan.SetSkin( mltSkinIndex )

	// titan won't have a soul until they DispatchSpawn()
	if ( executionRef != "" )
		titan.GetTitanSoul().soul.titanLoadout.titanExecution = executionRef
	if ( loadoutFunction != null ) // modded titan!!
		loadoutFunction( titan )

	if ( titanHandler != null )
		thread titanHandler( titan )
	else if ( GetNPCHandlerForClass( "npc_titan" ) != null )
		thread GetNPCHandlerForClass( "npc_titan" )( titan )
	
	if ( doHotDrop )
		thread ExtraSpawner_NPCTitanDrops( titan )

	return titan
}

entity function ExtraSpawner_SpawnBossTitan( vector pos, vector rot, int team, string spawnName = "", int titanType = TITAN_AUTO )
{
	array<string> registeredTitans
	foreach ( string titanName, BossTitanSpawnStruct titanStruct in file.bossTitanSpawnList )
		registeredTitans.append( titanName )

	// can't find any titan
	if ( registeredTitans.len() <= 0 )
		return

	string bossName = ""

	string setFile = ""
	string aiSet = ""
	string behavior = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	string bossTitle = ""
	string pilotTitle = ""
	asset characterModel = $""
	
	void functionref( entity ) loadoutFunction = null
	int skinIndex = -1
	int decalIndex = -1

	// get a registered titan
	// leaving spawn name to "" meaning we'll pick a random one
	// we also try to pick a random titan if given spawn name not found
	if ( spawnName == "" || !registeredTitans.contains( spawnName ) )
		spawnName = registeredTitans[ RandomInt( registeredTitans.len() ) ]

	BossTitanSpawnStruct currentTitan = file.bossTitanSpawnList[ spawnName ]
	bossName			= currentTitan.bossName
	setFile 			= currentTitan.setFile
	aiSet 				= currentTitan.aiSet
	behavior 			= currentTitan.behavior
	executionRef 		= currentTitan.executionRef
	bossTitle 			= currentTitan.bossTitle
	pilotTitle			= currentTitan.pilotTitle
	characterModel 		= currentTitan.characterModel

	loadoutFunction		= currentTitan.loadoutFunction
	skinIndex 			= currentTitan.skinIndex
	decalIndex 			= currentTitan.decalIndex

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiSet )

	// setup boss
	titan.ai.bossCharacterName = bossName
	titan.ai.bossTitanType = titanType // set to TITAN_MERC before DispatchSpawn() will play a intro

    titan.ai.titanSpawnLoadout.setFile = setFile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	// we'll do intro, hide on spawn
	if ( titanType == TITAN_MERC )
	{
		HideName( titan )
		titan.Hide()
	}

	ExtraSpawner_SetUpSpawnedNPC( titan ) // generic setup for any npc in this file
	DispatchSpawn( titan )

	if ( skinIndex > -1 )
		titan.SetSkin( skinIndex )
	if ( decalIndex > -1 )
		titan.SetDecal( decalIndex ) // nose art
	// titan won't have a soul until they DispatchSpawn()
	entity titanSoul = titan.GetTitanSoul()
	if ( executionRef != "" )
		titan.GetTitanSoul().soul.titanLoadout.titanExecution = executionRef

	// set up embarked behavior, we may feature npc pilot disembarking in future?
	// these settings gets applied by ExtraSpawner_SetUpTitanSeatedPilot()
	SetTitanSoulEmbarkedSettings( titan, aiSet, behavior, bossTitle )

	// pilot settings!
	// apply everything that has been setup in this function to titan
	ExtraSpawner_SetUpTitanSeatedPilot( 
		titan, 
		NPC_PILOT_MAX_HEALTH_BOSS, 
		eWeaponProficiency.PERFECT, 
		characterModel, 
		pilotTitle 
	)

	// merc boss titan behavior
	if ( titanType == TITAN_MERC )
	{
		// amped behavior
		// health settings. 4x health, 75% damage reduction ≈ 16x health, without annoying health bar
		titan.SetMaxHealth( titan.GetMaxHealth() * 4 )
		titan.SetHealth( titan.GetMaxHealth() )
		MpBossTitan_SetDamageScale( titan, 1.5 ) // they can deal higher damage
		MpBossTitan_SetDamageReductionScale( titan, 0.75 )
		// attack settings
		titan.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
		titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false ) // disable synced melee behavior, we use melee_synced_npc
		// core ability
		TitanHealth_SetTitanCoreBuilderMultiplier( titan, 5.0 ) // want them get core abilities faster
	}
	else // normal embarked titan behavior
		ExtraSpawner_SetUpNPCEmbarkedTitan( titan )

	// loadout function should run after all setup done, so we can modify them
	if ( loadoutFunction != null ) // modded titan!!
		loadoutFunction( titan )

	// we'll do intro, show again after DispatchSpawn(). ShowName() is handled in intro
	if ( titanType == TITAN_MERC )
		titan.Show()

	// titan handler
	if ( GetNPCHandlerForClass( "npc_titan" ) != null )
		thread GetNPCHandlerForClass( "npc_titan" )( titan )
	
	// titan spawn with intro don't have to hotdrop
	if ( titanType != TITAN_MERC )
		thread ExtraSpawner_NPCTitanDrops( titan )

	return titan
}

const float TITANFALL_WARNING_DURATION = 5.0
void function ExtraSpawner_NPCTitanDrops( entity titan, bool standUp = true )
{
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	TitanLoadoutDef loadout = titan.ai.titanSpawnLoadout
	const string regularTitanfallAnim = "at_hotdrop_drop_2knee_turbo"

	string animation = regularTitanfallAnim
	int team = titan.GetTeam()
	vector origin = titan.GetOrigin()
	vector angles = titan.GetAngles()

	// warpfall
	// methods taken from _replacement_titans.gnut
	bool hasWarpfall = loadout.passive3 == "pas_warpfall"
	if ( hasWarpfall || Flag( "LevelHasRoof" ) )
	{
		animation = "at_hotdrop_drop_2knee_turbo_upgraded"

		// we're trying to warpfall an existing titan
		// we don't want to show the titan nor destroy it... so we try to hide it

		// mark as hotdropping so other functions can get different result. cleaned up by NPCTitanHotdrops()
		titan.e.isHotDropping = true

		if ( !titan.IsFrozen() )
			titan.Freeze()
		titan.NotSolid()
		titan.Hide()
		HideName( titan )
		RemoveMinimapForNPC( titan )
		// move it to the sky so player won't notice it's here
		titan.SetOrigin( origin + < 0, 0, 25000 > )
		// needs to temp stop physics so it won't drop to ground due to gravity
		// needs a parent or we can't clear its StopPhysics() state( which gets cleared on ClearParent() )
		entity titanParentInfo = CreateEntity( "info_target" )
		titanParentInfo.kv.spawnflags = SF_INFOTARGET_ALWAYS_TRANSMIT_TO_CLIENT // needs to transmit to client or networked entities can't parent with it
		titanParentInfo.SetOrigin( origin + < 0, 0, 25000 > )
		DispatchSpawn( titanParentInfo )
		titan.SetVelocity( Vector( 0, 0, 0 ) )
		titan.SetParent( titanParentInfo )
		//titan.StopPhysics() // can't be cleared. don't know how projectiles do that after HandleDisappearingParent

		// dont let AI titan get enemies while dropping. Don't do trigger checks, become invulnerable
		// cleanup handled by NPCTitanHotdrops()
		ExtraSpawner_DisableSensingForNPC( titan, true )

		asset model = titan.GetModelName()
		Attachment warpAttach = GetAttachmentAtTimeFromModel( model, animation, "offset", origin, angles, 0 )

		float impactTime = GetHotDropImpactTime( titan, animation )

		float diff = 0.0

		float warningDuration = impactTime
		if ( !hasWarpfall ) // this means the level requested the warpfall
		{
			float regularImpactTime = GetHotDropImpactTime( titan, regularTitanfallAnim ) - (WARPFALL_SOUND_DELAY + WARPFALL_FX_DELAY)
			diff = ( regularImpactTime - impactTime )
			impactTime = regularImpactTime

			warningDuration = GetHotDropImpactTime( titan, regularTitanfallAnim )
		}
		// fake spawnTime to the time they actually starts thinking, so we don't get bad killreplay view
		titan.ai.spawnTime = Time() + diff + WARPFALL_SOUND_DELAY + WARPFALL_FX_DELAY

		// friendly warning
		foreach ( entity player in GetPlayerArrayOfTeam( team ) )
			Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", origin.x, origin.y, origin.z, Time() + warningDuration )
		// enemy warning
		thread HotDrop_Spawnpoint( origin, team, warningDuration, false, damagedef_titan_fall )

		EmitSoundAtPosition( team, origin, "Titan_3P_Warpfall_CallIn" )

		wait diff
		wait WARPFALL_SOUND_DELAY

		// modified here: all these fx should never hibernate on client-side...
		// prevent it play again after watching replay or when player getting close
		//PlayFX( TURBO_WARP_FX, warpAttach.position + Vector(0,0,-104), warpAttach.angle )
		entity warpFX = PlayFX( TURBO_WARP_FX, warpAttach.position + Vector(0,0,-104), warpAttach.angle )
		warpFX.FXEnableRenderAlways()
		warpFX.DisableHibernation()
		EmitSoundAtPosition( team, origin, "Titan_3P_Warpfall_Start" )

		wait WARPFALL_FX_DELAY

		// in _replacement_titans.gnut titan spawns here
		// restore physics
		titan.ClearParent()
		if ( IsValid( titanParentInfo ) )
			titanParentInfo.Destroy()
		// restore visibility
		titan.ClearInvulnerable() // not cleaned by NPCTitanHotdrops() but was added by ExtraSpawner_DisableSensingForNPC(), needs to clean up
		if ( titan.IsFrozen() )
			titan.Unfreeze()
		titan.Solid()
		titan.Show()
		ShowName( titan )
		AddMinimapForNPC( titan )
		// move it back to ground
		titan.SetOrigin( origin )

		// modified here: all these fx should never hibernate on client-side...
		// prevent it play again after watching replay or when player getting close
		//thread PlayFXOnEntity( TURBO_WARP_COMPANY, titan, "offset" )
		entity warpFXOnTitan = PlayFXOnEntity( TURBO_WARP_COMPANY, titan, "offset" )
		warpFXOnTitan.FXEnableRenderAlways()
		warpFXOnTitan.DisableHibernation()
	}
	else // titanfall
	{
		float impactTime = GetHotDropImpactTime( titan, animation )
		// friendly warning
		foreach ( entity player in GetPlayerArrayOfTeam( team ) )
			Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", origin.x, origin.y, origin.z, Time() + impactTime )
		// enemy warning
		thread HotDrop_Spawnpoint( origin, team, impactTime, false, damagedef_titan_fall )
	}

	float impactTime = GetHotDropImpactTime( titan, animation )
	thread NPCTitanHotdrops( titan, standUp, animation )
	wait impactTime // bubble shield creates at impactTime - 0.1, we wait full impact time here

	// vanilla missing behavior: we shouldn't target npc titan in a bubble shield
	thread MonitorNPCTitanTargetingInBubbleShield( titan )

	titan.WaitSignal( "TitanHotDropComplete" )
	// debug
	//print( "NPCTitanHotdrops finished!" )
}

const float NPC_BUBBLE_FAILSAFE_DELAY = 3.0
void function MonitorNPCTitanTargetingInBubbleShield( entity titan )
{
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	entity soul = titan.GetTitanSoul()
	if( !IsValid( soul ) )
		return
	
	// find bubble shield
	WaitEndFrame() // wait for next frame so we won't be cleared notarget by NPCTitanHotdrops()
	float maxWait = Time() + NPC_BUBBLE_FAILSAFE_DELAY
	entity bubbleShield
	while ( Time() < maxWait )
	{
		bubbleShield = soul.soul.bubbleShield
		// debug
		//print( "bubbleShield: " + string( bubbleShield ) )
		if ( IsValid( bubbleShield ) )
			break

		WaitFrame()
	}
	if ( !IsValid( bubbleShield ) )
		return

	titan.SetNoTarget( true )
	// debug
	//print( "Awaiting titan bubble run out!" )
	WaitSignal( bubbleShield, "OnDestroy" )
	titan.SetNoTarget( false )
	// debug
	//print( "Titan bubble has been destroyed!" )
}

entity function ExtraSpawner_SpawnTitanBT( vector pos, vector rot, int team, void functionref( entity titan ) titanHandler = null )
{
	foreach ( entity player in GetPlayerArray() )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	
	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, "npc_titan_buddy")
	//SetSpawnOption_NPCTitan( titan, TITAN_HENCH ) // mp don't need boss titan setting
    titan.ai.titanSpawnLoadout.setFile = "titan_buddy"
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	ExtraSpawner_SetUpSpawnedNPC( titan ) // generic setup for any npc in this file
	DispatchSpawn( titan )

	// require a unique squad to spawn AIClass titan_buddy
	// because all titan_buddy will be assigned to the same "bt" squad
	// if we spawn an enemy buddy titan we'll crash
	string squad = ExtraSpawner_MakeMarkedSquadName( titan.GetTeam(), UniqueString( "_buddy" ) )
	SetSquad( titan, squad )

	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard" )
	titan.GetOffhandWeapon( OFFHAND_SPECIAL ).AddMod( "slow_recovery_vortex" ) // fix mod
	titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "upgradeCore_MissileRack_Vanguard" ) // fix mod: lock on heavy armor target only
	titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability
	//titan.SetSkin(1) // sarah skin

	if ( titanHandler != null )
		thread titanHandler( titan )
	else if ( GetNPCHandlerForClass( "npc_titan" ) != null )
		thread GetNPCHandlerForClass( "npc_titan" )( titan )

	thread ExtraSpawner_NPCTitanDrops( titan )

	return titan
}

entity function ExtraSpawner_SpawnTitanWithPilot( vector pos, vector rot, int team, string spawnName = "" )
{
	entity titan = ExtraSpawner_SpawnTitan( pos, rot, team, false, null, spawnName )

	// this enables every behavior a pilot embarked titan can have
	ExtraSpawner_SetUpTitanSeatedPilot( titan )

	// manually do hotdrop after setup done
	thread ExtraSpawner_NPCTitanDrops( titan )

	return titan
}

void function ExtraSpawner_SpawnNPCInDropPod( vector pos, vector rot, int team, string content, int amount, void functionref( array<entity> guys ) squadHandler = null )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // fast dissolving, try not to stuck npcs inside
	
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_droppod_squad" ) )
	array<entity> guys
	for ( int i = 0; i < amount; i++ )
	{
		entity spawnNpc = CreateNPC( content, team, pos, rot )

		ExtraSpawner_SetUpSpawnedNPC( spawnNpc ) // generic setup for any npc in this file
		DispatchSpawn( spawnNpc ) // never delay dispatchSpawn()

		SetSquad( spawnNpc, squad )

		spawnNpc.SetParent( pod, "ATTACH", true )
		guys.append( spawnNpc )
	}

	// if npcs spawned from here, we assume they don't have deploy animations, just clear parent for them
	thread DropPodActiveThink( pod )
	foreach ( entity guy in guys )
	{
		if ( IsAlive( guy ) )
			guy.ClearParent()
	}

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

void function ExtraSpawner_SpawnSpecialistGruntDropShip( vector pos, vector rot, int team, string content, int count, string leaderAiSet = "npc_soldier_drone_summoner", int leaderHealth = 350, void functionref( array<entity> guys ) squadHandler = null )
{  
	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_dropship_squad" ) )

	entity functionref( int team, vector origin, vector angles ) spawnFunc = GetDropshipSpawnFunc( content )
	if ( spawnFunc == null )
	{
		print( "[EXTRA SPAWNER] No Valid dropship spawn function for: " + content )
		return
	}

	CallinData drop
	drop.origin			= pos
	drop.yaw			= rot.y
	drop.dist			= 768
	drop.team			= team
	drop.squadname		= squad
	// setup spawnFucs
	drop.npcSpawnFuncs.append( 
		entity function( int team, vector origin, vector angles ) : ( leaderAiSet )
		{
			return CreateSpecialistGrunt_NonSetup( team, origin, angles, leaderAiSet )
		}
	)
	// others are normal spawn functions
	for ( int i = 0; i < count - 1; i++ ) 
		drop.npcSpawnFuncs.append( spawnFunc )

	SetCallinStyle( drop, eDropStyle.ZIPLINE_NPC )
  
	thread RunDropshipDropoff( drop )
	
	WaitSignal( drop, "OnDropoff" )
	
	array<entity> guys = GetNPCArrayBySquad( squad )
	
	foreach ( int i, guy in guys )
	{
		bool isLeader = i == 0 // leader always spawn first, have to set here
		if ( isLeader )
		{
			SetUpSpecialistGrunt( guy, leaderAiSet )
			guy.SetMaxHealth( leaderHealth )
			guy.SetHealth( leaderHealth )
		}

		// hardcoded here, setup grunt weapon specific
		bool sniperGrunt = isLeader && leaderAiSet == "npc_soldier_sidearm"
		bool guardGrunt = isLeader && leaderAiSet == "npc_soldier_pve_eliteguard"
		bool replaceAllWeapons = !sniperGrunt && !guardGrunt
		//print( "sniperGrunt: " + string( sniperGrunt ) )
		ExtraSpawner_ApplyNPCWeapons( guy, replaceAllWeapons )

		// no need to setup ai here...
		//guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

// spawn a normal specialist grunt here, we setup them up later, since DispatchSpawn() is done in CreateNPCSForDropship()
entity function CreateSpecialistGrunt_NonSetup( int team, vector origin, vector angles, string aiSet )
{
	entity npc = CreateNPC( "npc_soldier", team, origin, angles )
	SetSpawnOption_AISettings( npc, aiSet )

	bool specialistGrunt = aiSet == "npc_soldier_drone_summoner"
	bool changeGrenade = !specialistGrunt
	//print( "specialistGrunt: " + string( sniperGrunt ) )
	if ( changeGrenade )
		ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()
	
	return npc
}

void function ExtraSpawner_SpawnSpecialistGruntDropPod( vector pos, vector rot, int team, string content, string leaderAiSet = "npc_soldier_drone_summoner", int leaderHealth = 350, void functionref( array<entity> guys ) squadHandler = null, int droppodFlags = 0 )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, droppodFlags ) // eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS

	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_droppod_squad" ) )
	array<entity> guys
	for ( int i = 0; i < SQUAD_SIZE; i++ )
	{
		bool isLeader = i == 0 // leader always spawn first, have to set here
		entity npc
		if ( isLeader ) // specialist as leader
			npc = ExtraSpawner_SpawnSpecialistGrunt( pos, <0,0,0>, team, leaderAiSet, leaderHealth )
		else
		{
			npc = CreateNPC( content, team, pos, <0,0,0> )
			ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

			ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file
			DispatchSpawn( npc )
		}

		SetSquad( npc, squad )
		// hardcoded here, setup grunt weapon specific
		bool sniperGrunt = isLeader && leaderAiSet == "npc_soldier_sidearm"
		bool guardGrunt = isLeader && leaderAiSet == "npc_soldier_pve_eliteguard"
		bool replaceAllWeapons = !sniperGrunt && !guardGrunt
		//print( "sniperGrunt: " + string( sniperGrunt ) )
		ExtraSpawner_ApplyNPCWeapons( npc, replaceAllWeapons )
		
		npc.SetParent( pod, "ATTACH", true )
		
		// no need to setup ai here...
		//npc.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guys.append( npc )
	}
		
	ActivateFireteamDropPod( pod, guys )

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

entity function ExtraSpawner_SpawnSpecialistGrunt( vector pos, vector rot, int team, string aiSet = "npc_soldier_drone_summoner", int maxHealth = 350 )
{
	entity npc = CreateSpecialistGrunt_NonSetup( team, pos, rot, aiSet )

	ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file
	DispatchSpawn( npc )

	SetUpSpecialistGrunt( npc, aiSet )

	npc.SetMaxHealth( maxHealth )
	npc.SetHealth( maxHealth )

	return npc
}


const array<string> SPECIALIST_VALID_DRONETYPES = 
[ 
	"npc_drone_beam", 
	"npc_drone_rocket", 
	"npc_drone_plasma" 
]

// removed pistol usage
/*
const array<string> SNIPER_VALID_SIDEARMS =
[
	"mp_weapon_semipistol",
	"mp_weapon_autopistol",
	"mp_weapon_shotgun_pistol",
	// wingmans needs damage buff(respawn messed up)
	"mp_weapon_wingman_n",
	"mp_weapon_wingman",
]
*/

// removed weapon mods for elite guard, safe to use const array
const array<string> ELITE_GUARD_VALID_WEAPONS =
[
	//"mp_weapon_smart_pistol", // temp remove?
	"mp_weapon_alternator_smg",
	"mp_weapon_shotgun_pistol",
	"mp_weapon_wingman_n",
]

void function SetUpSpecialistGrunt( entity npc, string aiSet )
{
	// hardcoded here..
	int team = npc.GetTeam()
	switch( aiSet )
	{
		case "npc_soldier_drone_summoner": // drone summoner grunt
			if ( team == TEAM_MILITIA )
			{
				//npc.SetModel( $"models/humans/heroes/mlt_hero_barker.mdl" )
				npc.SetModel( $"models/humans/grunts/mlt_grunt_smg.mdl" ) // these grunts carrying radio on back, good for drone grunts
			}
			else
			{
				//npc.SetModel( $"models/humans/heroes/imc_hero_marder.mdl" )
				npc.SetModel( $"models/humans/grunts/imc_grunt_smg.mdl" ) // these grunts carrying radio on back, good for drone grunts
			}
			
			npc.SetTitle( "#NPC_SPECIALIST" )
			npc.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll throw grenade more often
			// modified signal in _ai_drone.gnut, vanilla won't register it
			npc.Signal( "ForceStopDroneSpawn" ) // stop it's drone spawn think

			string droneType = SPECIALIST_VALID_DRONETYPES[ RandomInt( SPECIALIST_VALID_DRONETYPES.len() ) ]
			thread DroneGruntThink( npc, droneType ) // force set it again
			// rifle grunt model already has a backpack
			//HACK_DroneGruntModel( npc ) // modified in _ai_spawn_content.gnut, attach fake backpack for drone grunt
			break

		case "npc_soldier_shield_captain": // shield captain
			npc.SetModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )

			npc.SetTitle( "#NPC_SOLDIER_SHIELD_CAPTAIN" )
			npc.Signal( "ForceStopShield" ) // stop it's shield
			// force set them again here
			npc.DisableNPCFlag( NPC_ALLOW_FLEE | NPC_ALLOW_HAND_SIGNALS | NPC_USE_SHOOTING_COVER | NPC_CROUCH_COMBAT )
			thread WaitForShieldCaptainDrop( npc ) // start shield after being clear parented
			break

		case "npc_soldier_sidearm": // sniper grunt
			//npc.SetAISettings( "npc_soldier_shield_captain" ) // re-assign aiset to shield captain: higher damage threshold
			//npc.Signal( "ForceStopShield" ) // stop it's shield
			if ( team == TEAM_MILITIA )
				npc.SetModel( $"models/humans/grunts/mlt_grunt_lmg.mdl" )
			else
				npc.SetModel( $"models/humans/grunts/imc_grunt_lmg.mdl" )

			npc.SetTitle( "狙擊步兵" )
			// behavior_sp_soldier has been reworked
			// other specialist grunt using it will switch to AT weapons...
			// there's a solution to assign sidearm for every specialist grunt
			// but I'd prefer removing weapon switch, leaving only more frequent grenade toss( because weapon switch is bad for other specialist grunts, takes more time to react close enemy )
			//npc.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll switch to pistol if needed
			npc.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
			npc.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll throw grenade more often

			// special weapons, hardcoded!
			// take off existing main weapons, or sometimes they'll have a archer
			foreach ( entity weapon in npc.GetMainWeapons() )
				npc.TakeWeaponNow( weapon.GetWeaponClassName() )
			npc.GiveWeapon( "mp_weapon_sniper", ["threat_scope"] ) // removed "pve_elite". we've added npc weapon bodygroup update, can add a scope for fun
			npc.SetActiveWeaponByName( "mp_weapon_sniper" )

			// removed pistol usage
			//string sideArmName = SNIPER_VALID_SIDEARMS[ RandomInt( SNIPER_VALID_SIDEARMS.len() ) ]
			//entity sideArm = npc.GiveWeapon( sideArmName, ["silencer"] ) // we've added npc weapon bodygroup update, can use silencer now( needs weapon files to be modified )
			//sideArm.AddMod( "npc_sniper_grunt" ) // removed, which is overpowered

			// removed special weapon usage
			//npc.EnableNPCFlag( NPC_NO_WEAPON_DROP ) // due sniper grunts have specific weapon, make them never drop weapons
			//npc.DisableNPCFlag( NPC_CROUCH_COMBAT ) // pistol activity don't have crouch animations, disable crouch combat

			break

		case "npc_soldier_pve_eliteguard": // elite guard grunt
			if ( team == TEAM_MILITIA )
				npc.SetModel( $"models/humans/grunts/mlt_grunt_shotgun.mdl" )
			else
				npc.SetModel( $"models/humans/grunts/imc_grunt_shotgun.mdl" )

			npc.SetTitle( "菁英護衛" )
			npc.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
			npc.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll throw grenade more often

			// this should be a external const, but we can't assign mods if it being a const
			// now we remove shotgun_doublebarrel, could make use of consts
			/*
			table< string, array<string> > guardValidWeaponMods
			guardValidWeaponMods["mp_weapon_smart_pistol"] <- []
			guardValidWeaponMods["mp_weapon_alternator_smg"] <- []
			guardValidWeaponMods["mp_weapon_shotgun_doublebarrel_tfo"] <- ["projectile_shotgun_npc"] // modified shotgun variant that only suitable for npcs
			// we've removed sniper grunt pistols, add primary pistols for elite guard
			guardValidWeaponMods["mp_weapon_shotgun_pistol"] <- []
			guardValidWeaponMods["mp_weapon_wingman_n"] <- []
			*/

			// special weapons, hardcoded!
			// take off existing main weapons, or sometimes they'll have a archer
			foreach ( entity weapon in npc.GetMainWeapons() )
				npc.TakeWeaponNow( weapon.GetWeaponClassName() )

			// removed special weapon usage
			/*
			// assign specific weapon and mods
			array<string> validWeapons
			foreach ( weapon, mods in guardValidWeaponMods )
				validWeapons.append( weapon )

			string weaponToChoose = validWeapons[ RandomInt( validWeapons.len() ) ]
			array<string> mods = guardValidWeaponMods[ weaponToChoose ]
			npc.GiveWeapon( weaponToChoose, mods )
			npc.SetActiveWeaponByName( weaponToChoose )

			npc.EnableNPCFlag( NPC_NO_WEAPON_DROP ) // elite guard grunts never drops weapon because they have npc specific weapons
			npc.DisableNPCFlag( NPC_CROUCH_COMBAT ) // pistol activity don't have crouch animations, disable crouch combat
			*/

			// const array version
			string weaponName = ELITE_GUARD_VALID_WEAPONS[ RandomInt( ELITE_GUARD_VALID_WEAPONS.len() ) ]
			entity weapon = npc.GiveWeapon( weaponName )

			npc.DisableNPCFlag( NPC_CROUCH_COMBAT ) // pistol activity don't have crouch animations, disable crouch combat

			break
	}
}

void function WaitForShieldCaptainDrop( entity npc )
{
	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )

	WaitFrame() // wait for npc being set into dropship
	while( IsValid( npc.GetParent() ) )
		WaitFrame()

	thread ActivatePersonalShield( npc )
}

// prowler squad: 2 cqb prowler with 3 small prowlers
void function ExtraSpawner_SpawnProwlerSquadDropPod( vector pos, vector rot, int team, void functionref( array<entity> guys ) squadHandler = null )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // fast dissolving, try not to stuck prowlers inside

	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_droppod_squad" ) )
	array<entity> guys
	for ( int i = 0; i < 5 ;i++ )
	{
		// 3 small prowlers and 2 normal prowlers
		entity npc = CreateNPC( "npc_prowler", team, pos, <0,0,0> )

		float prowlerScale = RandomFloatRange( 0.5, 0.7 )
		if ( i >= 2 ) // small prowlers
			npc.kv.modelscale = prowlerScale

		ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file
		DispatchSpawn( npc )

		if ( i < 2 ) // normal prowlers
			npc.SetBehaviorSelector( "behavior_prowler_cqb" ) // better behavior
		else // small prowlers, scale health
		{
			npc.SetMaxHealth( npc.GetMaxHealth() * prowlerScale )
			npc.SetHealth( npc.GetMaxHealth() )
		}

		SetSquad( npc, squad )
		
		npc.SetParent( pod, "ATTACH", true )
		guys.append( npc )

		file.isProwlerSquadmate[ npc ] <- true // mark the prowler as prowler squadmate, for handling it's damage scale
	}
	
	// if npcs spawned from here, we assume they don't have deploy animations, just clear parent for them
	thread DropPodActiveThink( pod )
	foreach ( entity guy in guys )
	{
		if ( IsAlive( guy ) )
			guy.ClearParent()
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

// stronger stalker: harder to be dismembered, no faster headshot kills, no more one-critical-hit overload, always overload on death if not getting headshot
void function ExtraSpawner_SpawnOverloadedStalkerDropShip( vector pos, vector rot, int team, int count, void functionref( array<entity> guys ) squadHandler = null )
{  
	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_dropship_squad" ) )

	entity functionref( int team, vector origin, vector angles ) spawnFunc = CreateOverloadedStalker

	CallinData drop
	drop.origin			= pos
	drop.yaw			= rot.y
	drop.dist			= 768
	drop.team			= team
	drop.squadname		= squad
	SetDropTableSpawnFuncs( drop, spawnFunc, count )
	SetCallinStyle( drop, eDropStyle.ZIPLINE_NPC )
  
	thread RunDropshipDropoff( drop )
	
	WaitSignal( drop, "OnDropoff" )
	
	array<entity> guys = GetNPCArrayBySquad( squad )
	
	foreach ( guy in guys )
	{
		ExtraSpawner_ApplyNPCWeapons( guy )
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

entity function CreateOverloadedStalker( int team, vector origin, vector angles )
{
	entity npc = CreateStalker( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()
	ExtraSpawner_SetUpOverloadedStalker( npc ) // setup stronger behavior

	ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file

	return npc
}

void function ExtraSpawner_SpawnOverloadedStalkerDropPod( vector pos, vector rot, int team, void functionref( array<entity> guys ) squadHandler = null, int droppodFlags = 0 )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, droppodFlags )
	
	// wait for launch
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_droppod_squad" ) )
	array<entity> guys
	for ( int i = 0; i < SQUAD_SIZE; i++ )
	{
		entity npc = CreateNPC( "npc_stalker", team, pos, <0,0,0> )
		ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

		ExtraSpawner_SetUpSpawnedNPC( npc ) // generic setup for any npc in this file
		DispatchSpawn( npc )
		ExtraSpawner_SetUpOverloadedStalker( npc ) // setup stronger behavior

		SetSquad( npc, squad )
		
		ExtraSpawner_ApplyNPCWeapons( npc )
		
		npc.SetParent( pod, "ATTACH", true )
		guys.append( npc )
	}

	ActivateFireteamDropPod( pod, guys )

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

void function ExtraSpawner_SetUpOverloadedStalker( entity stalker )
{
	// setup hitgroup
	AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_HEAD, 0.7 ) // stalkers don't take extra damage from headshot, but dies if head taken enough damage
	AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_LEFTARM, 0.35 ) // isn't a necessary bodygroup, disabling their synced melee ability after lost
	AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_RIGHTARM, 0.8 ) // modified body dismemberment. this removes their weapon and melee, makes them almost unharmful
	AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_LEFTLEG, 0.6 ) // starts crawling on losing a leg
	AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_RIGHTLEG, 0.6 ) // starts crawling on losing a leg

	// setup gear overload
	AiStalker_SetGearOverloadOnHitRequiredHealthPercent( stalker, 0.25 ) // only able to be overloaded at very low health
	AiStalker_SetUpGearOverloadOnDeath(
		stalker,
		true,		// alwaysOverloadOnDeath
		true,		// noOverloadOnHeadshot
		false		// onlyOverloadOnKilledByTitans
	)

	// setup damaged behavior
	AiStalker_SetStaggerRequiredHealthPercent( stalker, STALKER_STAGGER_DAMAGE_DISABLED ) // never stagger upon taking damage
	AiStalker_SetHealthPercentOnTransitionToCrawl( stalker, STALKER_MAINTAIN_HEALTH_ON_TRANSITION_TO_CRAWL ) // maintain current health on start crawling
	AiStalker_SetCrawlLifeTime( 
		stalker, 
		8.0,		// lifeSupportDuration
		16.0,		// maxDeathTime
		true		// useLastAttackerToSelfTerminate
	)

	// debug behavior setup
	#if EXTRA_SPAWNER_DEBUG
		AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_HEAD, 0.0 )
		AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_LEFTARM, 0.0 )
		AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_RIGHTARM, 0.0 )
		AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_LEFTLEG, 0.0 )
		AiStalker_SetDismemberHitGroupRequiredDamage( stalker, HITGROUP_RIGHTLEG, 0.0 )

		AiStalker_SetGearOverloadOnHitRequiredHealthPercent( stalker, 0.5 )
		AiStalker_SetUpGearOverloadOnDeath(
			stalker,
			true,		// alwaysOverloadOnDeath
			true,		// noOverloadOnHeadshot
			false		// onlyOverloadOnKilledByTitans
		)
	#endif
}

void function ExtraSpawner_SpawnGunShip( vector pos, vector rot, int team )
{
	// though animation can add some offset to gunship, it's still needed we add more
	// otherwise they can collide with map obstacles very often
	pos += < 0, 0, 500 >

	// pick an random model and we keep using it for current gunship spawn think
	asset gunshipModel = GUNSHIP_VALID_MODELS[ RandomInt( GUNSHIP_VALID_MODELS.len() ) ]

	// first gunship: only for playing animation
	// its a hack! gunship after animation stops thinking for some reason
	// needs to spawn a new one
	entity animGunship = CreateNPC( "npc_gunship", team, pos, rot )
	// for other files can recognize this is a gunship that only used for playing animation
	// removing. "npc_gunship_scripted" is a separented class, not the same as "npc_gunship"
	//SetSpawnOption_AISettings( animGunship, "npc_gunship_scripted" )
	HideName( animGunship ) // this gunship will be deleted soon, never show it's name
	
	ExtraSpawner_SetUpSpawnedNPC( animGunship ) // generic setup for any npc in this file. adding this mark so we can update gunship's model on their spawn
	// this is kinda weird logic... now reset model in our function
	// no need to update model keyvalues
	//file.gunshipForcedSpawnModel[ animGunship ] <- gunshipModel // assign forced model
	animGunship.SetModel( gunshipModel )
	DispatchSpawn( animGunship )
	animGunship.SetModel( gunshipModel ) // update collision after spawn

	// do some funny stuff: fake icon
	entity animGunshipIcon = CreatePropScriptAsFakeMapIconForNPC( animGunship, "REF", eMinimapObject_prop_script.FW_BUILDSITE_SHIELDED )

	// setup visual
	SetDefaultMPEnemyHighlight( animGunship )
	AddMinimapForNPC( animGunship ) // only dropships can show on map though, gunships are not trakced by client

	// dont let AI titan get enemies while flying. Don't do trigger checks, become invulnerable
	ExtraSpawner_DisableSensingForNPC( animGunship, true )
	// handled by DelayedDestroyAnimGunship()
	//animGunship.NotSolid()
	if ( IsValid( animGunshipIcon ) )
		animGunshipIcon.Destroy()

	// fly in
	thread PlayAnim( animGunship, "st_AngelCity_IMC_Win_ComeIn" ) // flying anim
	// warp effect
	thread WarpInEffectGunship( animGunship )
    WaittillAnimDone( animGunship )

	vector offset = < 0, 0, -30 > // actual spawnpoint is not identical as animation's origin( doesn't really affects )
	vector spawnpoint = animGunship.GetOrigin() + offset
	vector spawnang = animGunship.GetAngles()

	// replacement gunship
	// its a hack! gunship after animation stops thinking for some reason
	// needs to spawn a new one
	if ( !IsValid( animGunship ) ) // if gunship already destroyed for some reason
		return // don't run following replacement code
	//gunship.Destroy() // might be a little weird because it's trail gonna disappear immediately
	// now using delayed destroy, so we can wait for trail fadeout normally
	thread DelayedDestroyAnimGunship( animGunship )

	// spawning new gunship for combating( their behavior is bad though, almost never attack anybody )
	entity gunship = CreateNPC( "npc_gunship", team, spawnpoint, spawnang )
	// dropship dogfighter version... abandoned, they're not smart enough
	/*
	entity gunship = CreateNPC( "npc_dropship", team, spawnpoint, spawnang )
	SetSpawnOption_AISettings( gunship, "npc_dropship_dogfighter" )
	gunship.SetBehaviorSelector( "behavior_gunship" )
	*/

	// setup accruacy
	gunship.kv.WeaponProficiency = eWeaponProficiency.VERYGOOD // turrets inherit weapon proficiency from gunship
	gunship.kv.AccuracyMultiplier = 1.5 // higher accuracy because they're flying around. turrets inherit it's accuracy

	ExtraSpawner_SetUpSpawnedNPC( gunship ) // generic setup for any npc in this file. adding this mark so we can update gunship's model on their spawn
	// this is kinda weird logic... now reset model in our function
	// no need to update model keyvalues
	//file.gunshipForcedSpawnModel[ gunship ] <- gunshipModel // assign forced model
	gunship.SetModel( gunshipModel )
	DispatchSpawn( gunship )
	gunship.SetModel( gunshipModel ) // update collision after spawn

	// visual effect
	gunship.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
	SetDefaultMPEnemyHighlight( gunship )
	// we've added fake icon system
	//AddMinimapForNPC( gunship ) // only dropships can show on map though, gunships are not trakced by client
	CreatePropScriptAsFakeMapIconForNPC( gunship, "REF", eMinimapObject_prop_script.FW_BUILDSITE_SHIELDED )

	// attach turrets to them for attacking!
	TakeAllWeapons( gunship )
	
	// a gunship always have a turret weapon
	table< string, asset > gunshipValidWeaponAndModel
	gunshipValidWeaponAndModel["mp_weapon_gunship_turret"] <- PLASMA_TURRET_MODEL // was HITSCAN_TURRET_MODEL, but it's barrel don't look nice enough for XO16 firing sound
	// then they'll pick an weapon from launcher or missile
	// temp not enabled. gunship_launcher can make them unable to hit each other, which is pretty bad
	/*
	if ( CoinFlip() )
		gunshipValidWeaponAndModel["mp_weapon_gunship_launcher"] <- PLASMA_TURRET_MODEL
	else
		gunshipValidWeaponAndModel["mp_weapon_gunship_missile"] <- ROCKET_TURRET_MODEL
	*/
	gunshipValidWeaponAndModel["mp_weapon_gunship_missile"] <- ROCKET_TURRET_MODEL

	const array<string> validAttachments = ["L_turret_attach", "R_turret_attach"]

	// assign specific weapon and mods
	array<string> validWeapons
	foreach ( weapon, mods in gunshipValidWeaponAndModel )
		validWeapons.append( weapon )

	foreach ( string attachment in validAttachments )
	{
		if ( validWeapons.len() == 0 ) // no valid weapons left?
			break
		string turretWeapon = validWeapons[ RandomInt( validWeapons.len() ) ]
		asset turretModel = gunshipValidWeaponAndModel[ turretWeapon ]
		validWeapons.removebyvalue( turretWeapon ) // one gunship shouldn't have two same weapons
		
		CreateTurretForGunship( gunship, attachment, turretWeapon, turretModel )
	}

	// start trail effect
	thread GunshipFlightTrailEffect( gunship )
	// enemy changed callback
	gunship.SetEnemyChangeCallback( OnEnemyChanged_Gunship )
}

// based on DeployTurret() in mp_ability_turretweapon.nut
entity function CreateTurretForGunship( entity gunship, string attachment, string weapon = "mp_weapon_gunship_turret", asset turretModel = $"" )
{
	entity turret = CreateEntity( "npc_turret_sentry" )
	SetSpawnOption_AISettings( turret, "npc_turret_sentry" )

	turret.SetOwner( gunship ) // disable collision with gunship so they can shoot bullets through
	turret.ai.preventOwnerDamage = true
	turret.StartDeployed()

	SetTeam( turret, gunship.GetTeam() )
	EmitSoundOnEntity( turret, "Boost_Card_SentryTurret_Deployed_3P" )
	turret.Highlight_SetInheritHighlight( true ) // setup highlight

	DispatchSpawn( turret )
	// update model after dispatchSpawn
	// never do model update after parented, will instantly crash the game
	if ( turretModel != $"" )
	{
		turret.SetValueForModelKey( turretModel )
		turret.SetModel( turretModel )
	}
	// attach to gunship
	turret.SetParent( gunship, attachment )
	turret.SetOrigin( <0, 0, 1> ) // offset from attachment

	// change weapon
	TakeAllWeapons( turret )
	turret.GiveWeapon( weapon )
	turret.SetActiveWeaponByName( weapon )

	// currently turret is bind together with gunship and cannot be destroyed
	HideName( turret )
	turret.SetInvulnerable()
	turret.SetNoTarget( true )
	turret.SetNoTargetSmartAmmo( true )
	turret.SetAimAssistAllowed( false )
	turret.NotSolid()
	//turret.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY // this will also hide all effects that may play on it
	SentryTurretStopLaser( turret ) // modified function in _ai_turret_sentry.gnut, stop laser effect

	// gunship life tracker
	thread GunshipTurretThink( turret, gunship )
	thread TrackTurretOwnerGunshipDeath( turret, gunship )
	// unused behavior
	//thread DestroyOnDeathDelayed( turret, 0.15 )

	return turret
}

// sync everything with the gunship
void function GunshipTurretThink( entity turret, entity gunship )
{
	turret.EndSignal( "OnDestroy" )
	gunship.EndSignal( "OnDestroy" )
	while ( true )
	{
		if ( turret.GetTitle() != gunship.GetTitle() )
			turret.SetTitle( gunship.GetTitle() )

		if ( turret.GetEnemy() != gunship.GetEnemy() )
		{
			if ( !IsValid( gunship.GetEnemy() ) )
				turret.ClearEnemy()
			else
				turret.SetEnemy( gunship.GetEnemy() )
		}

		if ( turret.kv.WeaponProficiency != gunship.kv.WeaponProficiency )
			turret.kv.WeaponProficiency = gunship.kv.WeaponProficiency
		if ( turret.kv.AccuracyMultiplier != gunship.kv.AccuracyMultiplier )
			turret.kv.AccuracyMultiplier = gunship.kv.AccuracyMultiplier
		
		wait 0.25 // same wait as GunshipThink() does
	}
}

void function TrackTurretOwnerGunshipDeath( entity turret, entity gunship )
{
	turret.EndSignal( "OnDestroy" )
	WaitSignal( gunship, "OnDeath", "OnDestroy" )
	turret.Destroy()
}

void function DestroyOnDeathDelayed( entity turret, float delay )
{
	turret.EndSignal( "OnDestroy" )
	turret.WaitSignal( "OnDeath" )

	wait delay

	// TODO: explosion or other FX
	turret.Destroy()
}

// from _evac.gnut, my own function with some tweak
void function WarpInEffectGunship( entity gunship )
{
	gunship.EndSignal( "OnDestroy" )
	gunship.Hide() // this still shows it's lights
	//gunship.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY

	float sfxWait = 0.1
	float totalTime = WARPINFXTIME
	float preWaitTime = 0.16 // give it some time so it's actually playing anim, and we can get it's "origin" attatch
	string sfx = "dropship_warpin"

	wait preWaitTime

	int attach = gunship.LookupAttachment( "origin" )
	vector origin = gunship.GetAttachmentOrigin( attach )
	vector angles = gunship.GetAttachmentAngles( attach )

	gunship.Show()
	//gunship.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	entity fx = PlayFX( FX_GUNSHIP_CRASH_EXPLOSION_ENTRANCE, origin, angles )
	fx.FXEnableRenderAlways()
	fx.DisableHibernation()

	wait sfxWait
	EmitSoundAtPosition( TEAM_UNASSIGNED, origin, sfx )

	wait totalTime - sfxWait
}

void function DelayedDestroyAnimGunship( entity animGunship )
{
	animGunship.EndSignal( "OnDestroy" )
	animGunship.Hide() // this still shows it's lights, but trail also needed to show
	animGunship.kv.CollisionGroup = 0
	animGunship.NotSolid()
	if ( !animGunship.IsFrozen() ) // anti-crash for post-match cleanup condition( which will freeze all npcs )
		animGunship.Freeze() // freeze gunship so it can't move

	wait 0.8 // wait for trail fadeout normally
	animGunship.Destroy()
}

void function GunshipFlightTrailEffect( entity gunship )
{
	array<entity> fxs
	foreach ( attachment, effect in GUNSHIP_FLIGHT_TRAIL_EFFECTS )
		fxs.append( PlayLoopFXOnEntity( effect, gunship, attachment, null, null, ENTITY_VISIBLE_TO_EVERYONE ) )
	// make them have infinite fadedist like dogfighter trails( the diffence is those trails are played by client-side )
	foreach ( fx in fxs )
		fx.DisableHibernation()

	OnThreadEnd
	(
		function(): ( fxs )
		{
			foreach ( fx in fxs )
			{
				if ( IsValid( fx ) )
					EffectStop( fx )
			}
		}
	)

	WaitSignal( gunship, "OnDestroy" ) // gunship gets destroyed once they died
}

void function OnEnemyChanged_Gunship( entity gunship )
{
	GunshipJetBurstEffect( gunship )
}

// jet burst effect for gunship
void function GunshipJetBurstEffect( entity gunship )
{
	//print( "RUNNING GunshipJetBurstEffect()" )
	thread GunshipJetBurstEffect_Threaded( gunship )
}

// stop last played jet effect when we starting a new one
void function GunshipJetBurstEffect_Threaded( entity gunship )
{
	gunship.Signal( "GunshipJetBurstEffect" )
	gunship.EndSignal( "GunshipJetBurstEffect" )

	array<entity> fxs
	foreach ( attachment, effect in GUNSHIP_JET_BURST_EFFECTS )
		fxs.append( PlayFXOnEntity( effect, gunship, attachment ) )
	// make them have infinite fadedist like dogfighter trails( the diffence is those trails are played by client-side )
	foreach ( fx in fxs )
		fx.DisableHibernation()

	// do sound
	if ( !( gunship in file.gunshipJetBurstSoundAllowedTime ) )
		file.gunshipJetBurstSoundAllowedTime[ gunship ] <- 0.0
	if ( Time() > file.gunshipJetBurstSoundAllowedTime[ gunship ] )
	{
		EmitSoundOnEntity( gunship, GUNSHIP_JET_BURST_SOUND )
		file.gunshipJetBurstSoundAllowedTime[ gunship ] = Time() + GUNSHIP_JET_BURST_SOUND_COOLDOWN
	}

	OnThreadEnd
	(
		function(): ( fxs )
		{
			foreach ( fx in fxs )
			{
				if ( IsValid( fx ) )
					EffectStop( fx )
			}
		}
	)

	WaitSignal( gunship, "OnDestroy" ) // gunship gets destroyed once they died
}

void function ExtraSpawner_SpawnPilotCanEmbark( vector pos, vector rot, int team, string spawnName = "" )
{
	// spawns a npc pilot that can use invalid model, we handle them with SpawnPilotCanEmbark_FailSafeToSpawnTitan()
	entity pilot = ExtraSpawner_SpawnPilotElite( pos, rot, team, null, false )
	// failsafe case: pilot's model is not good for MP usage, we'll spawn a titan directly
	if ( SpawnPilotCanEmbark_FailSafeToSpawnTitan( pilot, pos, rot, team, spawnName ) )
		return
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	pilot.EnableNPCFlag( NPC_IGNORE_ALL ) // so they will mostly try to embark, clean it up later
	ExtraSpawner_StopDefaultHandler( pilot ) // stop pilot's default handler, so they'll try embarking first
	// attach to a droppod
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // for fast dissolving
	pilot.SetParent( pod, "ATTACH", true )
	// disable any sensing: dont let AI get enemies. Don't do trigger checks
	ExtraSpawner_DisableSensingForNPC( pilot, true, true, true )

	thread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	wait 3 // send titan a little bit later
	entity titan = ExtraSpawner_SpawnTitanForPilot( pilot, pos, rot, spawnName )
	// now using my own embarking function
	local embarkSet = FindBestEmbarkForNpcAnim( pilot, titan ) // passing a same embark set
	pilot.SetNPCMoveSpeedScale( 1.8 ) // want this pilot run to titan's start point faster
	// no longer needs thread off because we've reworked it
	//thread NpcPilotRunsToEmbarkTitan( pilot, titan, embarkSet ) // passing the same embark set
	NpcPilotRunsToEmbarkTitan( pilot, titan, embarkSet, false ) // passing the same embark set, don't waitthread

	thread ForceStartTitan( titan, pilot, 10 ) // to fit ownerLifeTimeCheck(), if pilot died we stand the titan
	thread PilotSpawnProtection( pilot, titan, 20 ) // at least don't let players kill pilots while their titans're not landing

	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd( 
		function(): ( pilot, titan )
		{
			if( !IsAlive( titan ) )
				return
			if( !IsAlive( pilot ) )
			{
				// pilot died for some reason... force start titan ignoring ForceStartTitan()'s delay
				// deprecated. no need to manually do this
				//thread StandUnboardedTitan( titan )
				return
			}
		}
	)

	float podLaunchTime = expect float( GetDropPodAnimDuration() )
	wait podLaunchTime - 2.5 // wait for pod launch complete( wait 0.5s more )

	// activate pod, releasing the pilot, don't clear it's invulerability because it's handled by PilotSpawnProtection()
	ExtraSpawner_RestoreSensingForNPC( pilot, false, true, true )
	ActivateFireteamDropPod( pod, [ pilot ] )

	NpcPilotSetPetTitan( pilot, titan )
	titan.WaitSignal( "TitanHotDropComplete" )
	
	// no longer needs thread off because we've reworked it
	//waitthread NpcPilotRunsToEmbarkTitan( pilot, titan, embarkSet ) // passing the same embark set
	NpcPilotRunsToEmbarkTitan( pilot, titan, embarkSet, false ) // passing the same embark set, don't waitthread
	thread NpcPilotEmbarksTitan( pilot, titan )
}

// if pilot don't have valid model for npc usage, we need to spawn a titan without embarking think
bool function SpawnPilotCanEmbark_FailSafeToSpawnTitan( entity spawnedPilot, vector pos, vector rot, int team, string spawnName )
{
	// stub
	return false
}

void function StandUnboardedTitan( entity titan )
{
	titan.Signal( "StandUnboardedTitan" )
	titan.EndSignal( "StandUnboardedTitan" )
	titan.EndSignal( "OnDestroy" )

	waitthread WaitForHotdropToEnd( titan )

	titan.Anim_Stop() // stop current animation
	waitthread PlayAnimGravity( titan, "at_hotdrop_quickstand" )
	// adding here: mark the titan as stand
	SetStanceStand( titan.GetTitanSoul() )

	titan.ClearInvulnerable()
}

entity function ExtraSpawner_SpawnPilotElite( vector pos, vector rot, int team, void functionref( entity pilot ) pilotHandler = null, bool mpValidModelOnly = true )
{
	entity pilot = CreateNPC( "npc_pilot_elite", team, pos, rot )//CreateNPC( "npc_soldier", team, pos, rot )
	ExtraSpawner_ApplyNPCGrenadeWeapon( pilot ) // grenade have to be given before DispatchSpawn()

	ExtraSpawner_SetUpSpawnedNPC( pilot ) // generic setup for any npc in this file
	DispatchSpawn( pilot ) // don't delayed dispatchSpawn()

	// give weapons
	ExtraSpawner_ApplyNPCWeapons( pilot )
	// update model before setup
	asset modelAsset = NPC_PILOT_ALLOWED_MODELS[ RandomInt( NPC_PILOT_ALLOWED_MODELS.len() ) ]
	pilot.SetModel( modelAsset )

	pilot.SetMaxHealth( NPC_PILOT_MAX_HEALTH )
	pilot.SetHealth( NPC_PILOT_MAX_HEALTH )
	pilot.SetTitle( "鐵馭" ) // "#NPC_PILOT", using a localized string will cause auto-titan's title to be wrong

	// main setup for npc pilots spawn from this file
	ExtraSpawner_SetUpNPCPilot( pilot )

	return pilot
}

void function ExtraSpawner_SetUpNPCPilot( entity pilot, void functionref( entity pilot ) pilotHandler = null )
{
	// in-file variables init
	file.npcPilotInScriptedAnim[ pilot ] <- false

	pilot.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE ) // hardcoded!
	pilot.DisableNPCFlag( NPC_ALLOW_FLEE | NPC_ALLOW_HAND_SIGNALS ) // disable flee and meaningless hand signals

	pilot.SetNPCMoveSpeedScale( NPC_PILOT_MOVE_SPEED_SCALE ) // want pilots move faster
	pilot.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot perfectly
	//pilot.kv.WeaponProficiency = eWeaponProficiency.VERYGOOD // bit nerfed

	// setup highlight
	pilot.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
	SetDefaultMPEnemyHighlight( pilot )
	Highlight_SetEnemyHighlight( pilot, "enemy_player" )

	// some pilot model don't have "pete_agent.mdl" included, which means they can't change to their secondary weapon
	// "behavior_pilot_elite_assassin" has been reworked. it's the same as normal pilot behavior, but with SelectSchedule_SwitchWeapon added
	// we change to "behavior_pilot_elite_assassin" if this model is ideal for switch weapon
	if ( NPC_PILOT_SWITCH_WEAPON_ALLOWED_MODELS.contains( pilot.GetModelName() ) )
	{
		// debug
		/*
		print( "Updating pilot to assassin behavior!" )
		print( "=====PILOT WEAPONS=====" )
		foreach ( entity weapon in pilot.GetMainWeapons() )
			print( weapon)
		*/

		// we've removed grunt weapon switch... also disable pilot's
		//pilot.SetBehaviorSelector( "behavior_pilot_elite_assassin" )
	}

	// disabled SelectSchedule_SwitchWeapon in their behavior, since pilot model not included "pete_agent.mdl", no animations for switching to pistols
	pilot.SetEnemyChangeCallback( ExtraSpawner_OnEnemyChanged_SwitchToHeavyArmorWeapon )
	// start tactical ability think
	AssignTacticalAbilityForNPCPilot( pilot )
	ExtraSpawner_ScriptedNPCPilotTacticalAbility( pilot )

	// start updating bodygroup
	// this will handle npc pilot disembarking/ejecting case
	ExtraSpawner_StartUpdatingNPCWeaponBodyGroup( pilot )

	// pilots are bit special, start handler in setup func
	if ( pilotHandler != null )
		thread pilotHandler( pilot )
	else if ( GetNPCHandlerForClass( "npc_pilot_elite" ) != null )
		thread GetNPCHandlerForClass( "npc_pilot_elite" )( pilot )
}

// assign random tactical ability
void function AssignTacticalAbilityForNPCPilot( entity pilot )
{
	array<string> validAbilities
	foreach ( weaponName, thinkFunc in file.scriptedNPCPilotAbilityThink )
		validAbilities.append( weaponName )

	if ( validAbilities.len() > 0 )
		pilot.GiveOffhandWeapon( validAbilities[ RandomInt( validAbilities.len() ) ], OFFHAND_SPECIAL )
}

// ability settings
void function ExtraSpawner_ScriptedNPCPilotTacticalAbility( entity pilot )
{
	thread ScriptedNPCPilotTacticalAbility_Threaded( pilot )
}

void function ScriptedNPCPilotTacticalAbility_Threaded( entity pilot )
{
	pilot.Signal( "ScriptedNPCPilotTacticalAbility" )
	pilot.EndSignal( "ScriptedNPCPilotTacticalAbility" )
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	// attempting embark, don't use abilities
	// this means we needs to call ExtraSpawner_ScriptedNPCPilotTacticalAbility() again if we tried to use NpcPilotStopRunsToEmbark() or NpcPilotStopEmbarkAttempts()
	pilot.EndSignal( "NpcPilotRunsToEmbarkTitan" )
	pilot.EndSignal( "NpcPilotEmbarksTitan" ) 

	while ( true )
	{
		entity abilityWeapon = pilot.GetOffhandWeapon( OFFHAND_SPECIAL )
		if ( IsValid( abilityWeapon ) )
		{
			string abilityWeaponName = abilityWeapon.GetWeaponClassName()
			if ( abilityWeaponName in file.scriptedNPCPilotAbilityThink )
			{
				//print( "RUNNING scripted tactical ability for pilot!" )
				waitthread file.scriptedNPCPilotAbilityThink[ abilityWeaponName ]( pilot, abilityWeapon ) // continue looping until core weapon gets destroyed or something
			}
		}

		WaitFrame()
	}
}

void function ExtraSpawner_StopNPCPilotTacticalAbility( entity pilot )
{
	pilot.Signal( "ScriptedNPCPilotTacticalAbility" )
}

void function InitDefaultScriptedNPCPilotTactical()
{
	// cloak
	RegisterSignal( "NPCPilotActivatesCloak" )
	RegisterSignal( "CloakTimeOut" )
	ExtraSpawner_AddScriptedNPCPilotAbilityThink( "mp_ability_cloak", NPCPilotCloakThink )

	// stim
	RegisterSignal( "NPCPilotActivatesStim" )
	ExtraSpawner_AddScriptedNPCPilotAbilityThink( "mp_ability_heal", NPCPilotStimThink )

	// holopilot
	ExtraSpawner_AddScriptedNPCPilotAbilityThink( "mp_ability_holopilot", NPCPilotHoloPilotThink )

	// phase shift
	RegisterSignal( "NPCPilotActivatesPhaseShift" )
	RegisterSignal( "PilotWantsToPhase" )
	ExtraSpawner_AddScriptedNPCPilotAbilityThink( "mp_ability_shifter", NPCPilotPhaseShiftThink )
}

void function ExtraSpawner_AddScriptedNPCPilotAbilityThink( string abilityWeaponName, void functionref( entity pilot, entity abilityWeapon ) thinkFunc )
{
	if ( !( abilityWeaponName in file.scriptedNPCPilotAbilityThink ) )
		file.scriptedNPCPilotAbilityThink[ abilityWeaponName ] <- thinkFunc
	else
		file.scriptedNPCPilotAbilityThink[ abilityWeaponName ] = thinkFunc
}

// scripted ability thinks
const float NPC_PILOT_CLOAK_REST_TIME_BETWEEN_USE = 1.5 // if pilot has more than one charge for ability, do some rest
const float NPC_PILOT_CLOAK_RECENT_DAMAGE_TIME = 1.5 // if pilot taken damage within this time, they won't do cloak
const float NPC_PILOT_CLOAK_COMBAT_DIST_2D = 1000 // if pilot has a pilot enemy within this range they can see, consider them already combating... don't cloak
const float NPC_PILOT_CLOAK_ACTIVATE_DIST_2D = 2200 // if pilot has an enemy within this range, they'll activate cloak while approaching
const float NPC_PILOT_CLOAK_ACTIVATE_DIST_2D_AGAINST_TITAN = 1700

void function NPCPilotCloakThink( entity pilot, entity abilityWeapon )
{
	// EndSignals() should been set by ScriptedNPCPilotTacticalAbility_Threaded()

	abilityWeapon.EndSignal( "OnDestroy" )
	while ( true )
	{
		// get uses before we set to cooldown
		int useTimes = GetWeaponNPCBurstCount( abilityWeapon )
		for ( int i = 0; i < useTimes; i++ )
		{
			if ( i > 0 ) // not first use?
				wait NPC_PILOT_CLOAK_REST_TIME_BETWEEN_USE // add bit rest

			// wait until pilot approaching enemy( with enemy in their weapon range and no damage taken recently )
			bool firstLoop = true
			while ( true )
			{
				if ( !firstLoop )
					WaitFrame()
				firstLoop = false

				if ( pilot.Anim_IsActive() ) // doing scripted anim!
					continue

				if ( Time() - GetNPCLastDamageTime( pilot ) < NPC_PILOT_CLOAK_RECENT_DAMAGE_TIME ) // recent taking damage!
					continue

				entity enemy = pilot.GetEnemy()
				if ( IsAlive( enemy ) )
				{
					// wait till enemy is in safe range, cloak to approach them
					float dist2D = Distance2D( pilot.GetOrigin(), enemy.GetOrigin() )

					float activationDist = NPC_PILOT_CLOAK_ACTIVATE_DIST_2D
					if ( enemy.IsTitan() )
						activationDist = NPC_PILOT_CLOAK_ACTIVATE_DIST_2D_AGAINST_TITAN
					if ( enemy.IsTitan() || enemy.IsNPC() ) // npcs or player titan target
					{
						if ( dist2D <= activationDist )
						{
							//if ( pilot.CanSee( enemy ) ) // cloak once pilot can see their enemy
							//	break
							break // always cloak on engaging npc targets
						}
					}
					else // player pilot target
					{
						// cloak only when pilot not in close range, or when they can't see enemy
						// removed CanSee enemy checks, only check for distance( because their sights are pretty silly )
						//if ( ( !pilot.CanSee( enemy ) || dist2D > NPC_PILOT_CLOAK_COMBAT_DIST_2D ) && dist2D <= activationDist )
						if ( dist2D > NPC_PILOT_CLOAK_COMBAT_DIST_2D && dist2D <= activationDist )
							break
					}
				}
			}

			waitthread NPCPilotActivatesCloak( pilot, abilityWeapon )
		}

		// cooldown between next use
		WeaponWaitForRandomNPCRest( abilityWeapon )
	}
}

float function GetNPCLastDamageTime( entity guy )
{
	if ( guy.e.recentDamageHistory.len() > 0 )
		return guy.e.recentDamageHistory[0].time // return newest damage time

	return 0.0 // no damage taken yet
}

const float NPC_PILOT_CLOAK_STOP_ATTACK_TIME_FRAC = 0.35 // don't attack at the start of cloak ability
const float NPC_PILOT_CLOAK_BROKE_INTERNAL = 0.0 // pilot firing weapon within this frac of cloak duration won't break their cloak

const float NPC_PILOT_DECLOAK_REQUIRED_CHARGE_FRACTION = 0.75 // have to hardcode for charge weapons... mostly for charge rifle. if pilot charges their weapon to this fraction, break cloak
const float NPC_PILOT_CLOAK_BROKE_INTERNAL_CHARGE = 0.0 // pilot charge weapon within this frac of cloak duration won't break their cloak

void function NPCPilotActivatesCloak( entity pilot, entity weapon )
{
	// endSignal inherit from NPCPilotCloakThink()
	/*
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	weapon.EndSignal( "OnDestroy" )
	*/
	pilot.Signal( "NPCPilotActivatesCloak" )
	pilot.EndSignal( "NPCPilotActivatesCloak" )

	float duration = weapon.GetWeaponSettingFloat( eWeaponVar.fire_duration )
	EnableCloak( pilot, duration ) // function in player_cloak.nut has been reworked, can handle npc usage

	// vanilla won't flicker npc on taking damage, do it manually
	file.npcPilotActivatedCloak[ pilot ] <- true
	AddEntityCallback_OnFinalDamaged( pilot, OnCloakNPCPilotDamaged )

	float startTime = Time()
	float endTime = Time() + duration
	// first few seconds pilot won't shoot, then they will
	DisableNPCAttackCapability( pilot, true, false ) // they can still melee

	// use OnThreadEnd() to ensure things have been cleaned up
	table<string, bool> cleanUpTable
	cleanUpTable["removeFinalDamageCallback"] <- false
	cleanUpTable["restoreAttackCapability"] <- false
	cleanUpTable["restoreEnemyMapIcon"] <- false

	if ( EntHasMinimapIconEnabled( pilot ) )
		RemoveMinimapForNPC( pilot, true ) // remove from enemy minimap
	else
		cleanUpTable["restoreEnemyMapIcon"] = true // mark as no need to restore map icon

	// EDIT: "decloakOnShoot" won't work at all!
	//table<string, bool> results
	//results["cloakEndByTime"] <- false

	OnThreadEnd
	(
		//function(): ( pilot, cleanUpTable, results )
		function(): ( pilot, cleanUpTable )
		{
			// don't know why sometimes they won't be remove callback...
			if ( IsValid( pilot ) )
			{
				if ( !cleanUpTable["removeFinalDamageCallback"] )
					RemoveEntityCallback_OnFinalDamaged( pilot, OnCloakNPCPilotDamaged )
				if ( !cleanUpTable["restoreAttackCapability"] )
					RestoreNPCAttackCapability( pilot )
				if ( !cleanUpTable["restoreEnemyMapIcon"] )
					AddMinimapForNPC( pilot )

				// EDIT: "decloakOnShoot" won't work at all!
				/*
				if ( !results["cloakEndByTime"] ) // this must means pilot triggered "decloakOnShoot"
					NPCPilotDeCloakFlicker( pilot ) // do a fake flicker
				*/

				delete file.npcPilotActivatedCloak[ pilot ]
			}
		}
	)

	// first few seconds pilot won't shoot, then they will
	// or they will start shooting once taken damage
	float noFireDuration = duration * NPC_PILOT_CLOAK_STOP_ATTACK_TIME_FRAC
	waitthread WaitTillTimeOutOrDamaged( pilot, noFireDuration )

	RestoreNPCAttackCapability( pilot )
	cleanUpTable["restoreAttackCapability"] = true

	float timeLeft = duration - ( Time() - startTime )
	pilot.EndSignal( "CloakTimeOut" )
	thread NPCPilotCloakTimer( pilot, timeLeft )
	// EDIT: "decloakOnShoot" won't work at all!
	//thread NPCPilotCloakTimer( pilot, timeLeft + 0.1 ) // timeout. add 0.1s more before signaling out "CloakTimeOut", for we can get cloak ended properly or not
	
	// wait for pilot firing weapon
	// welp, it seems like npcs won't fire "OnPrimaryAttack" signal
	// guess we'll check pilot's primary weapon ammo instead
	// add "CloakTimeOut" as EndSignal
	/*
	while ( Time() < endTime )
	{
		var results = WaitSignal( pilot, "CloakTimeOut", "OnPrimaryAttack" )
		string receivedSignal = expect string( results.signal )
		//print( "receivedSignal: " + receivedSignal )
		// for "OnPrimaryAttack", we need to check whether the weapon will break cloak or not
		if ( receivedSignal == "OnPrimaryAttack" && "activator" in results )
		{
			entity signaledWeapon = expect entity( results.activator )
			if ( WeaponInterruptsCloak( signaledWeapon ) )
			{
				DisableCloak( pilot, 0.5 ) // disable cloak after firing, same fadeout as player one does
				break
			}
		}
		else if ( receivedSignal == "CloakTimeOut" ) // timeout
			break // just break
	}
	*/
	// ammo check version
	// no need to handle endTime(), we already got NPCPilotCloakTimer() to handle that
	// can't get charge rifle firing
	// now workaround with decloakOnShoot in aiSetFile
	// EDIT: "decloakOnShoot" won't work at all!
	// now workaround with charge frac checks
	float checkStartTime = Time() + ( duration * NPC_PILOT_CLOAK_BROKE_INTERNAL )
	float chargeCheckStartTime = Time() + ( duration * NPC_PILOT_CLOAK_BROKE_INTERNAL_CHARGE )
	table<entity, int> pilotWeaponAmmoCount
	while ( true )
	{
		// init weapons
		foreach ( entity weapon in pilot.GetMainWeapons() )
		{
			if ( !( weapon in pilotWeaponAmmoCount ) )
				pilotWeaponAmmoCount[ weapon ] <- GetWeaponAmmoOrClipCount( weapon )
		}

		// have to hardcode for charge weapons...
		// npc never reduces weapon's ammo stockpile count
		// which means we can't get charge rifle's firing
		entity activeWeapon = pilot.GetActiveWeapon()
		bool shouldBreakCloak = false
		if ( IsValid( activeWeapon ) && activeWeapon.IsChargeWeapon() && !activeWeapon.IsWeaponOffhand() )
		{
			if ( Time() > chargeCheckStartTime ) // cloak break check start
			{
				// debug
				/*
				print( "activeWeapon: " + string( activeWeapon ) )
				print( "chargeFrac: " + string( activeWeapon.GetWeaponChargeFraction() ) )
				*/

				if ( activeWeapon.GetWeaponChargeFraction() >= NPC_PILOT_DECLOAK_REQUIRED_CHARGE_FRACTION ) // charge weapon about to fire!
					shouldBreakCloak = true // break cloak
			}
			/*
			else // debug
				print( "cloaked firing check not started yet" )
			*/
		}
		else // normal weapon case
		{
			if ( Time() > checkStartTime ) // cloak break check start
			{
				foreach ( entity weapon, int ammoSinceLastUpdate in pilotWeaponAmmoCount )
				{
					// debug
					/*
					if ( weapon == activeWeapon )
					{
						print( "weapon: " + string( weapon ) )
						print( "pilotWeaponAmmoCount[ weapon ]: " + string( pilotWeaponAmmoCount[ weapon ] ) )
						print( "GetWeaponAmmoOrClipCount( weapon ): " + string( GetWeaponAmmoOrClipCount( weapon ) ) )
						print( "ammoSinceLastUpdate: " + string( ammoSinceLastUpdate ) )
					}
					*/

					if ( GetWeaponAmmoOrClipCount( weapon ) < ammoSinceLastUpdate ) // firing weapon!
					{
						shouldBreakCloak = true // break cloak
						break
					}
				}
			}
			/*
			else // debug
				print( "cloaked firing check not started yet" )
			*/
		}

		// break cloak if we have marked it
		if ( shouldBreakCloak )
			break

		// update clip for next check
		foreach ( entity weapon in pilot.GetMainWeapons() )
			pilotWeaponAmmoCount[ weapon ] = GetWeaponAmmoOrClipCount( weapon )
		
		WaitFrame()
	}

	DisableCloak( pilot, 0.5 ) // disable cloak after firing, same fadeout as player one does

	// EDIT: "decloakOnShoot" won't work at all!
	/*
	wait timeLeft // wait for cloak timer end
	results["cloakEndByTime"] = true // mark as we ended cloak by time, not by "decloakOnShoot"
	*/

	RemoveEntityCallback_OnFinalDamaged( pilot, OnCloakNPCPilotDamaged )
	cleanUpTable["removeFinalDamageCallback"] = true
}

// search for valid ammo or clip count
// welp this don't make sense, npc never reduces their weapon's ammo stockpile count
int function GetWeaponAmmoOrClipCount( entity weapon )
{
	try // some weapon don't have ammo clip, mostly not for humansized weapons though
	{
		if ( weapon.GetWeaponSettingInt( eWeaponVar.ammo_clip_size ) <= 0 ) // not using ammo clip!!!
			return weapon.GetWeaponPrimaryAmmoCount()
		else
			return weapon.GetWeaponPrimaryClipCount()
	}
	catch(ex) {}

	return 0 // no ammo clip found
}

// this is a fake flicker
// EDIT: "decloakOnShoot" won't work at all!
// removing this
/*
void function NPCPilotDeCloakFlicker( entity pilot )
{
	pilot.SetCanCloak( true )
	pilot.SetCloakDuration( 0, 0.05, 0.5 )
	// use cloak fadeIn as flicker is enough
	//pilot.SetCloakFlicker( 0.5, 0.65 )
	DisableCloak( pilot, 0.5 ) // do decloak sound and end looping sound thread
}
*/

void function OnCloakNPCPilotDamaged( entity pilot, var damageInfo )
{
	// don't know why sometimes they won't be remove callback...
	// add a defensive fix
	if ( !( pilot in file.npcPilotActivatedCloak ) )
		return

	if ( DamageInfo_GetDamage( damageInfo ) > 0 )
		pilot.SetCloakFlicker( 0.5, 0.65 )
}

void function WaitTillTimeOutOrDamaged( entity ent, float timeOut )
{
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "OnDamaged" )

	wait timeOut
}

// wait till pilot cloak runs out then do signal
// welp this won't work well... change to check cloak duration, so we can get "decloakOnShoot" in aiSetFile
// EDIT: "decloakOnShoot" won't work at all!
void function NPCPilotCloakTimer( entity pilot, float duration )
{
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )

	wait duration
	pilot.Signal( "CloakTimeOut" )

	// EDIT: "decloakOnShoot" won't work at all!
	/*
	float endTime = Time() + duration
	while ( Time() < endTime ) // max timer think
	{
		if ( !IsCloaked( pilot ) ) // decloak due to "decloakOnShoot" in aiSetFile
			break
		WaitFrame()
	}

	pilot.Signal( "CloakTimeOut" )
	*/
}

void function DisableNPCAttackCapability( entity guy, bool disableRangedAttack = true, bool disableMelee = true, bool disableMovement = false )
{
	if ( guy in file.npcDisabledAttackCapabilityFlags ) // this means npc has already disabled attack and not getting restored!
		return // don't do anything

	file.npcDisabledAttackCapabilityFlags[ guy ] <- [] // init

	// ranged attack( gun fire )
	if ( disableRangedAttack )
	{
		if ( guy.GetCapabilityFlag( bits_CAP_MOVE_SHOOT ) )
		{
			guy.SetCapabilityFlag( bits_CAP_MOVE_SHOOT, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_MOVE_SHOOT )
		}
		if ( guy.GetCapabilityFlag( bits_CAP_AIM_GUN ) )
		{
			guy.SetCapabilityFlag( bits_CAP_AIM_GUN, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_AIM_GUN )
		}
		if ( guy.GetCapabilityFlag( bits_CAP_WEAPON_RANGE_ATTACK1 ) )
		{
			guy.SetCapabilityFlag( bits_CAP_WEAPON_RANGE_ATTACK1, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_WEAPON_RANGE_ATTACK1 )
			// HACK for charged weapons: they can still fire after charge end
			// welp this can't fix....
			/*
			entity activeWeapon = guy.GetActiveWeapon()
			if ( IsValid( activeWeapon ) && activeWeapon.IsChargeWeapon() && !activeWeapon.IsWeaponOffhand() )
				activeWeapon.SetWeaponChargeFraction( 0.0 ) // clear charge
			*/
		}
	}

	// melee
	if ( disableMelee )
	{
		if ( guy.GetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1 ) ) // uncharged
		{
			guy.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_INNATE_MELEE_ATTACK1 )
		}
		if ( guy.GetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK2 ) ) // charged
		{
			guy.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK2, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_INNATE_MELEE_ATTACK2 )
		}
		if ( guy.GetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK ) )
		{
			guy.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_SYNCED_MELEE_ATTACK )
		}
	}

	// movement
	if ( disableMovement )
	{
		if ( guy.GetCapabilityFlag( bits_CAP_MOVE_TRAVERSE ) )
		{
			guy.SetCapabilityFlag( bits_CAP_MOVE_TRAVERSE, false )
			file.npcDisabledAttackCapabilityFlags[ guy ].append( bits_CAP_MOVE_TRAVERSE )
		}
	}
}

void function RestoreNPCAttackCapability( entity guy )
{
	if ( !( guy in file.npcDisabledAttackCapabilityFlags ) ) // this means we haven't disable this npc's attack
		return // don't do anything

	// restore any capability flag we disabled in DisableNPCAttackCapability()
	foreach ( int flag in file.npcDisabledAttackCapabilityFlags[ guy ] )
		guy.SetCapabilityFlag( flag, true )

	delete file.npcDisabledAttackCapabilityFlags[ guy ] // clean up
}

const float NPC_PILOT_STIM_REST_TIME_BETWEEN_USE = 1.0 // if pilot has more than one charge for ability, do some rest
const float NPC_PILOT_STIM_COMBAT_DIST_2D = 2100 // if pilot has enemy within this range, do stim to approach them( tried 2650 but seems not good )
// removing these checks. we added health regen so activate stim without thinking isn't very bad
// adding back these again, if pilot already have max health these checks should still apply
const float NPC_PILOT_STIM_REQUIRED_VELOCITY = 100 * NPC_PILOT_MOVE_SPEED_SCALE // have to be running before activating stim( base value was 130, which is kinda difficult to reach )
const float NPC_PILOT_STIM_CHASE_STOP_DIST_2D = 400 + NPC_PILOT_STIM_REQUIRED_VELOCITY // if pilot too close to their enemy, there's no need to use stim for approaching. they'll stop chasing once reached chaseStopDist
const float NPC_PILOT_STIM_CHASE_STOP_DIST_2D_HEAVYARMOR = 800 + NPC_PILOT_STIM_REQUIRED_VELOCITY * 1.5
const float NPC_PILOT_STIM_ADVANCED_CHECK_HEALTH_FRAC = 0.75 // if pilot's health reaching this frac, skip velocity and minium dist checks

void function NPCPilotStimThink( entity pilot, entity abilityWeapon )
{
	// EndSignals() should been set by ScriptedNPCPilotTacticalAbility_Threaded()

	abilityWeapon.EndSignal( "OnDestroy" )
	while ( true )
	{
		// get uses before we set to cooldown
		int useTimes = GetWeaponNPCBurstCount( abilityWeapon )
		//print( "useTimes: " + string( useTimes ) )
		vector lastTickPos
		bool lastTickOnGround
		for ( int i = 0; i < useTimes; i++ )
		{
			if ( i > 0 ) // not first use?
				wait NPC_PILOT_STIM_REST_TIME_BETWEEN_USE // add bit rest

			bool firstLoop = true
			while ( true )
			{
				lastTickPos = pilot.GetOrigin()
				lastTickOnGround = pilot.IsOnGround()
				if ( !firstLoop )
					WaitFrame()
				firstLoop = false

				if ( pilot.Anim_IsActive() ) // doing scripted anim!
					continue

				// not standing still, or using cover
				// an npc walking on ground always count as 0 velocity
				// use dist to calculate instead
				//print( "pilot.IsOnGround(): " + string( pilot.IsOnGround() ) )
				//print( "Length( pilot.GetVelocity() ): " + string( Length( pilot.GetVelocity() ) ) )

				// removing these checks. we added health regen so activate stim without thinking isn't very bad
				// adding back these again, if pilot already have max health these checks should still apply
				if ( GetHealthFrac( pilot ) > NPC_PILOT_STIM_ADVANCED_CHECK_HEALTH_FRAC )
				{
					bool onGround = lastTickOnGround && pilot.IsOnGround()
					float vel = Length( pilot.GetOrigin() - lastTickPos ) / 0.1
					//print( "vel: " + string( vel ) )
					//if ( !pilot.IsOnGround() || Length( pilot.GetVelocity() ) < NPC_PILOT_STIM_REQUIRED_VELOCITY )
					if ( !onGround || vel < NPC_PILOT_STIM_REQUIRED_VELOCITY )
						continue

					entity enemy = pilot.GetEnemy()
					if ( IsAlive( enemy ) )
					{
						// wait till enemy is in range or pilot sees an enemy
						float dist2D = Distance2D( pilot.GetOrigin(), enemy.GetOrigin() )
						float stopDist = NPC_PILOT_STIM_CHASE_STOP_DIST_2D
						if ( enemy.GetArmorType() == ARMOR_TYPE_HEAVY )
							stopDist = NPC_PILOT_STIM_CHASE_STOP_DIST_2D_HEAVYARMOR
						if ( dist2D <= stopDist ) // too close!
							continue
						if ( pilot.CanSee( enemy ) || dist2D < NPC_PILOT_STIM_COMBAT_DIST_2D )
							break
					}
				}
				else
				{
					// simple check version
					entity enemy = pilot.GetEnemy()
					if ( IsAlive( enemy ) )
					{
						// wait till enemy is in range
						float dist2D = Distance2D( pilot.GetOrigin(), enemy.GetOrigin() )
						if ( dist2D < NPC_PILOT_STIM_COMBAT_DIST_2D )
							break
					}
				}
			}

			// start stim think
			waitthread NPCPilotActivatesStim( pilot, abilityWeapon )
		}

		// cooldown between next use
		WeaponWaitForRandomNPCRest( abilityWeapon )
	}
}

// bit higher speed because npc don't get health regen and wallrun speed boost
// EDIT: add health regen because they really can't use it well... scale down speed severity
const float NPC_PILOT_STIM_SPEED_BOOST_SEVERITY = 0.45 // no-time-extention version uses 0.65
const float NPC_PILOT_STIM_USE_TIME_EXTENTION = 1.5 // pilots can't use stim well... extend their use time for some bit
const float NPC_PILOT_STIM_HEALTH_REGEN_FRAC = 0.4 // pilot will regen health by this frac over stim use time
// reworked: taking damage will reduce regen rate but won't stop regen
//const float NPC_PILOT_STIM_REGEN_STOP_DURATION = 2.0 // taking damage will stop health regen for this time
const float NPC_PILOT_STIM_REGEN_REDUCTION_DURATION = 1.5 // taking damage will reduce health regen rate for this time
const float NPC_PILOT_STIM_REGEN_REDUCTION = 0.5 // health regen rate is reduced by this frac if recently taking damage

// needs modified sh_stim.gnut, with some tweak to make npcs use it
void function NPCPilotActivatesStim( entity pilot, entity weapon )
{
	// endSignal inherit from NPCPilotStimThink()
	/*
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	weapon.EndSignal( "OnDestroy" )
	*/
	pilot.Signal( "NPCPilotActivatesStim" )
	pilot.EndSignal( "NPCPilotActivatesStim" )

	float duration = weapon.GetWeaponSettingFloat( eWeaponVar.fire_duration ) * NPC_PILOT_STIM_USE_TIME_EXTENTION

	StimPlayer( pilot, duration, NPC_PILOT_STIM_SPEED_BOOST_SEVERITY )

	// adding health regen
	//wait duration
	float endTime = Time() + duration
	const float tickRate = 0.2 // npc think don't need very accurate value
	while ( Time() < endTime )
	{
		// reworked: taking damage will reduce regen rate but won't stop regen
		//if ( Time() - GetNPCLastDamageTime( pilot ) >= NPC_PILOT_STIM_REGEN_STOP_DURATION )
		//{
			int healthRegenRate = int( ( float( pilot.GetMaxHealth() ) * NPC_PILOT_STIM_HEALTH_REGEN_FRAC ) / ( duration / tickRate ) )
			if ( Time() - GetNPCLastDamageTime( pilot ) < NPC_PILOT_STIM_REGEN_REDUCTION_DURATION )
				healthRegenRate = int( float( healthRegenRate ) * ( 1.0 - NPC_PILOT_STIM_REGEN_REDUCTION ) )
			//print( "healthRegenRate: " + string( healthRegenRate ) )
			pilot.SetHealth( min( pilot.GetMaxHealth(), pilot.GetHealth() + healthRegenRate ) )
			//print( "pilot.GetHealth(): " + string( pilot.GetHealth() ) )
			if ( pilot.GetHealth() == pilot.GetMaxHealth() )
			{
				ClearRecentDamageHistory( pilot )
				ClearLastAttacker( pilot )
			}
		//}

		wait tickRate
	}
}

const float NPC_PILOT_HOLOPILOT_REST_TIME_BETWEEN_USE = 3.5 // if pilot has more than one charge for ability, do some rest
const float NPC_PILOT_HOLOPILOT_COMBAT_DIST_2D = 1500 // if pilot can see an enemy within this range, let them project hologram
const float NPC_PILOT_HOLOPILOT_MAX_WAIT = 6.5 // if pilot has finished cooldown but no valid enemy within this time, always project hologram

const int NPC_PILOT_DECOY_HEALTH = 50
const float NPC_PILOT_DECOY_TIMEOUT = DECOY_DURATION

void function NPCPilotHoloPilotThink( entity pilot, entity abilityWeapon )
{
	// EndSignals() should been set by ScriptedNPCPilotTacticalAbility_Threaded()

	abilityWeapon.EndSignal( "OnDestroy" )
	while ( true )
	{
		// get uses before we set to cooldown
		int useTimes = GetWeaponNPCBurstCount( abilityWeapon )
		//print( "useTimes: " + string( useTimes ) )
		for ( int i = 0; i < useTimes; i++ )
		{
			if ( i > 0 ) // not first use?
				wait NPC_PILOT_HOLOPILOT_REST_TIME_BETWEEN_USE // add bit rest

			// with a bit timeout
			float maxWait = Time() + NPC_PILOT_HOLOPILOT_MAX_WAIT
			bool firstLoop = true
			while ( Time() < maxWait )
			{
				if ( !firstLoop )
					WaitFrame()
				firstLoop = false

				if ( pilot.Anim_IsActive() ) // doing scripted anim!
					continue

				entity enemy = pilot.GetEnemy()
				if ( IsAlive( enemy ) )
				{
					// wait till enemy is in range or pilot sees an enemy
					float dist2D = Distance2D( pilot.GetOrigin(), enemy.GetOrigin() )
					if ( pilot.CanSee( enemy ) || dist2D < NPC_PILOT_HOLOPILOT_COMBAT_DIST_2D )
						break
				}
			}

			// project hologram
			CreateNPCDecoyEnt( pilot, NPC_PILOT_DECOY_HEALTH, NPC_PILOT_DECOY_TIMEOUT )
		}

		// cooldown between next use
		WeaponWaitForRandomNPCRest( abilityWeapon )
	}
}

// create a npc entity as fake decoy
// actually can be used for players
entity function CreateNPCDecoyEnt( entity npc, int health = 50, float timeOut = -1 )
{
	string decoyClass = "npc_pilot_elite" // was using npc_soldier, but pilots don't have dialogue, which is better
	string decoyAISet = "npc_pilot_elite" // was using npc_soldier
	if ( npc.IsNPC() )
	{
		decoyClass = npc.GetClassName()
		decoyAISet = npc.GetAISettingsName()
	}
	int friendlyTeam = npc.GetTeam()

	vector spawnAngle = < 0, npc.GetAngles().y, 0 > // no rotation
	// taken from mp_ability_holopilot
	float displacementDistance = 30.0
	vector forwardVector = AnglesToForward( spawnAngle ) * displacementDistance
	vector spawnPos = npc.GetOrigin() + forwardVector

	entity decoy = CreateNPC( decoyClass, friendlyTeam, spawnPos, spawnAngle )
	SetSpawnOption_AISettings( decoy, decoyAISet )
	SetSpawnOption_SquadName( decoy, npc.kv.squadname )
	if ( ExtraSpawner_IsNPCSpawnedFromExtraSpawner( npc ) )
		ExtraSpawner_SetUpSpawnedNPC( decoy )
	
	// npc model take hold from T-pose and non-alert state
	thread DelayedShowNPCDecoy( decoy )
	
	DispatchSpawn( decoy )

	// update model
	decoy.SetModel( npc.GetModelName() )
	decoy.SetVelocity( npc.GetVelocity() )
	// taken from mp_ability_holopilot
	PutEntityInSafeSpot( decoy, npc, null, npc.GetOrigin(), decoy.GetOrigin() )

	// setup
	decoy.SetOwner( npc ) // try to avoid collision?
	decoy.SetMaxHealth( health )
	decoy.SetHealth( health ) // won't get one shot by player like normal decoys

	string title = npc.GetTitle()
	if ( npc.IsPlayer() )
		title = npc.GetPlayerName()
	decoy.SetTitle( title )
	decoy.SetNoTargetSmartAmmo( true ) // smart ammo won't target decoy

	// create fake weapon prop
	entity weaponProp
	if ( npc.IsTitan() ) // titans: try to assign first weapon to decoy
	{
		TakeAllWeapons( decoy )
		if ( npc.GetMainWeapons().len() > 0 )
			weaponProp = CreatemWeaponPropForDecoy( npc.GetMainWeapons()[0] )
	}
	else // try to assign active weapon
	{
		entity activeWeapon = npc.GetActiveWeapon()
		if ( !IsValid( activeWeapon ) ) // npc owner don't have a weapon... make decoy use their own weapon
			activeWeapon = decoy.GetActiveWeapon()
		
		TakeAllWeapons( decoy )
		if ( IsValid( activeWeapon ) )
			weaponProp = CreatemWeaponPropForDecoy( activeWeapon )
	}
	if ( IsValid( weaponProp ) )
		weaponProp.SetParent( decoy, "PROPGUN" )

	decoy.SetHologram() // Make this NPC a hologram. It will generate hologram impact effects when hit
	decoy.SetPassThroughThickness( 0 )
	decoy.kv.CollisionGroup = 0 // they can still block hitscan weapon and hulls though
	//decoy.kv.solid = SOLID_HITBOXES // mess things up
	decoy.kv.contents = (int(decoy.kv.contents) | CONTENTS_NOGRAPPLE)

	AddEntityCallback_OnDamaged( decoy, OnNPCDecoyDamaged )
	AddEntityCallback_OnPostDamaged( decoy, OnNPCDecoyPostDamaged )

	// try to inherit enemy highlight
	string highlightAsset = GetHighlightAssetNameFromEnt( npc )
	if ( highlightAsset != "" )
		Highlight_SetEnemyHighlight( decoy, highlightAsset ) 
	Highlight_SetFriendlyHighlight( decoy, "friendly_player_decoy" )
	//print( "GetHighlightAssetNameFromEnt( npc ): " + GetHighlightAssetNameFromEnt( npc ) )

	EmitSoundOnEntityToTeam( decoy, "holopilot_loop", friendlyTeam ) //loopingSound
	EmitSoundOnEntityToEnemies( decoy, "holopilot_loop_enemy", friendlyTeam ) ///loopingSound
	
	// behavior
	RemoveMinimapForNPC( decoy ) // don't show on minimap for any team, that's the way to identify them
	DisableNPCAttackCapability( decoy, true, true, true ) // disable attacking and traverse
	// don't drop any weapon, no pain
	decoy.EnableNPCFlag( NPC_NO_WEAPON_DROP | NPC_NO_PAIN | NPC_NO_GESTURE_PAIN )
	// don't do dangerous area displacement
	decoy.EnableNPCMoveFlag( NPCMF_DISABLE_DANGEROUS_AREA_DISPLACEMENT | NPCMF_IGNORE_CLUSTER_DANGER_TIME | NPCMF_PREFER_SPRINT )
	decoy.SetCanBeMeleeExecuted( false ) 

	thread NPCDecoyLifeTime( decoy, weaponProp, timeOut )
	file.npcFakeDecoyEntArray.append( decoy )

	return decoy
}

entity function CreatemWeaponPropForDecoy( entity weapon )
{
	entity owner = weapon.GetWeaponOwner()
	asset modelName = weapon.GetModelName()

	// player owned weapon will get their FP model when using GetModelName()...
	bool ownerIsPlayer = IsValid( owner ) && owner.IsPlayer()
	if ( ownerIsPlayer )
	{
		// create a weapon drop and get it's model if so
		string weaponName = weapon.GetWeaponClassName()
		entity tempWeapon = CreateWeaponEntityByNameWithPhysics( weaponName, owner.GetOrigin(), <0,0,0> )
		modelName = tempWeapon.GetModelName()
		tempWeapon.Destroy()
	}

	entity prop = CreatePropDynamic( modelName )
	prop.Highlight_SetInheritHighlight( true ) // setup highlight
	prop.NotSolid()
	// no need to track lifetime because prop owner won't be player

	return prop
}

void function DelayedShowNPCDecoy( entity decoy )
{
	decoy.EndSignal( "OnDestroy" )

	decoy.kv.VisibilityFlags = 0 // disable any model light stuffs
	HideName( decoy )
	WaitFrame() // take hold from T-posing

	ShowName( decoy )
	decoy.SetNameVisibleToFriendly( false ) // try to avoid friendly player targeting them
	WaitFrame() // take hold from casual state

	decoy.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	// flicker like player decoy
	NPCDecoyFlicker( decoy )
}

bool function EntIsNPCFakeDecoy( entity ent )
{
	return file.npcFakeDecoyEntArray.contains( ent )
}

void function OnNPCDecoyDamaged( entity decoy, var damageInfo )
{
	// don't show indicator on damaging decoy
	DamageInfo_AddCustomDamageType( damageInfo, DF_NO_INDICATOR )
	// flicker like player decoy
	NPCDecoyFlicker( decoy, 0.25 )
}

// this is a fake flicker
void function NPCDecoyFlicker( entity decoy, float duration = 0.5 )
{
	decoy.SetCanCloak( true )
	decoy.SetCloakDuration( 0, 0.05, duration )
	// use cloak fadeIn as flicker is enough
	//decoy.SetCloakFlicker( duration, duration * 1.3 )
}

void function OnNPCDecoyPostDamaged( entity decoy, var damageInfo )
{
	// never dies. if gonna die, clear any damage history so nobody will get score
	// add playerOneShot effect to be more like normal decoy
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	bool attackerIsPlayer = IsValid( attacker ) && attacker.IsPlayer()
	if ( attackerIsPlayer || ( DamageInfo_GetDamage( damageInfo ) >= decoy.GetHealth() ) )
	{
		ClearRecentDamageHistory( decoy )
		ClearLastAttacker( decoy )
		DamageInfo_SetDamage( damageInfo, decoy.GetHealth() - 1 )
		// die to self damage, skip death callbacks, maintain force(don't really work though)
		if ( IsAlive( decoy ) )
		{
			//DisableCloak( player, 0 ) // manually disable any flicker because we won't call AbilityCloak_OnDeath() in player_cloak.nut
			decoy.Die( decoy, decoy, { damageSourceId = eDamageSourceId.round_end, force = DamageInfo_GetDamageForce( damageInfo ) } )
		}
	}
}

string function GetHighlightAssetNameFromEnt( entity ent )
{
	int entHighlightId = ent.Highlight_GetState( 2 ) // HIGHLIGHT_CONTEXT_ENEMY = 2
	foreach ( assetName, highlightStruct in shGlobal.highlight )
	{
		if ( highlightStruct.highlightId == entHighlightId )
			return assetName
	}

	return "" // default
}

void function NPCDecoyLifeTime( entity decoy, entity weaponProp, float timeOut = -1 )
{
	decoy.EndSignal( "OnDestroy" )
	decoy.EndSignal( "OnDeath" ) // end on health run out

	OnThreadEnd
	(
		function(): ( decoy, weaponProp )
		{
			if ( IsValid( decoy ) )
			{
				// prevent meeting up attacking event during death animation, and don't want a weapon floating in air during dissolving
				// this is just a defensive fix, decoy uses prop as their holding weapon
				TakeAllWeapons( decoy )
				StopSoundOnEntity( decoy, "holopilot_loop" )
				StopSoundOnEntity( decoy, "holopilot_loop_enemy" )

				decoy.NotSolid()
				decoy.SetInvulnerable()
				decoy.Dissolve( ENTITY_DISSOLVE_CHAR, Vector( 0, 0, 0 ), 500 )
			}
			if ( IsValid( weaponProp ) )
				weaponProp.Dissolve( ENTITY_DISSOLVE_CHAR, Vector( 0, 0, 0 ), 500 )
		}
	)

	WaitEndFrame() // wait for RegisterForDamageDeathCallbacks() to end
	decoy.SetDeathNotifications( false ) // don't run any death callbacks
	
	if ( timeOut > 0 )
		wait timeOut // end on time out
	else
		WaitForever()
}

void function NPCPilotPhaseShiftThink( entity pilot, entity abilityWeapon )
{
	// EndSignals() should been set by ScriptedNPCPilotTacticalAbility_Threaded()

	abilityWeapon.EndSignal( "OnDestroy" )
	while ( true )
	{
		// get uses before we set to cooldown
		int useTimes = GetWeaponNPCBurstCount( abilityWeapon )
		//print( "useTimes: " + string( useTimes ) )
		for ( int i = 0; i < useTimes; i++ )
		{
			// start phase shift think: phase out of danger when taking massive damage
			waitthread NPCPilotActivatesPhaseShift( pilot, abilityWeapon )
		}

		// cooldown between next use
		WeaponWaitForRandomNPCRest( abilityWeapon )
	}
}

const float NPC_PILOT_PHASE_MASSIVE_DAMAGE_FRAC = 0.4 // if health about to take this amount of damage, phase out of danger
// npc pilots can't use shift well, give them some speed boost based on health left
const float NPC_PILOT_PHASE_SPEED_BOOST_SEVERITY_MIN = 0.3 // first version uses 0.65, no-time-extention version uses 0.35
const float NPC_PILOT_PHASE_SPEED_BOOST_SEVERITY_MAX = 0.6 // first version uses 1.35, no-time-extention version uses 0.8
const float NPC_PILOT_PHASE_USE_TIME_EXTENTION = 1.25 // pilots can't use phase shift well... extend their use time for some bit( was using 1.5 which might be annoying? )

void function NPCPilotActivatesPhaseShift( entity pilot, entity weapon )
{
	// endSignal inherit from NPCPilotPhaseShiftThink()
	/*
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	weapon.EndSignal( "OnDestroy" )
	*/
	pilot.Signal( "NPCPilotActivatesPhaseShift" )
	pilot.EndSignal( "NPCPilotActivatesPhaseShift" )

	// update health threshold
	file.npcPilotPhaseHealthThreshold[ pilot ] <- GetHealthFrac( pilot ) - NPC_PILOT_PHASE_MASSIVE_DAMAGE_FRAC
	if ( file.npcPilotPhaseHealthThreshold[ pilot ] <= 0 )
		file.npcPilotPhaseHealthThreshold[ pilot ] = 0 // will phase on killshot

	AddEntityCallback_OnFinalDamaged( pilot, OnPhaseShiftNPCPilotDamaged )
	table<string, bool> cleanUpTable
	cleanUpTable["removeFinalDamageCallback"] <- false
	cleanUpTable["restoreAttackCapability"] <- true // default is we're not disabling attack capability, no need to restore in OnThreadEnd()

	OnThreadEnd
	(
		function(): ( pilot, cleanUpTable )
		{
			if ( IsValid( pilot ) )
			{
				// don't know why sometimes they won't be remove callback... resulting become invulnerable
				if ( !cleanUpTable["removeFinalDamageCallback"] )
					RemoveEntityCallback_OnFinalDamaged( pilot, OnPhaseShiftNPCPilotDamaged )
				if ( !cleanUpTable["restoreAttackCapability"] )
					RestoreNPCAttackCapability( pilot )
				delete file.npcPilotPhaseHealthThreshold[ pilot ]
			}
		}
	)

	var results = pilot.WaitSignal( "PilotWantsToPhase" ) // wait for damage callback to signal stuff
	float healthFracLeft = expect float( results.healthFracLeft )
	if ( healthFracLeft <= 0 )
		healthFracLeft = 0
	float duration = weapon.GetWeaponSettingFloat( eWeaponVar.fire_duration ) * NPC_PILOT_PHASE_USE_TIME_EXTENTION
	PhaseShift( pilot, 0.0, duration )
	// vanilla missing npc behavior: needs to clear humansized npc enemy on phase
	// and they're still able to attack, needs to clear their attack capability
	if ( IsValid( pilot.GetEnemy() ) )
		pilot.ClearEnemy()
	DisableNPCAttackCapability( pilot, true, true ) // disable both melee and ranged attack
	cleanUpTable["restoreAttackCapability"] = false // mark as we need to clean up stuffs

	// npc pilots can't use shift well, give them some speed boost to get out of danger
	float effectSeverity = NPC_PILOT_PHASE_SPEED_BOOST_SEVERITY_MIN + ( ( 1.0 - healthFracLeft ) * ( NPC_PILOT_PHASE_SPEED_BOOST_SEVERITY_MAX - NPC_PILOT_PHASE_SPEED_BOOST_SEVERITY_MIN ) )
	//print( "effectSeverity: " + string( effectSeverity ) )
	StatusEffect_AddTimed( pilot, eStatusEffect.speed_boost, NPC_PILOT_STIM_SPEED_BOOST_SEVERITY, duration, 0.0 )

	//pilot.WaitSignal( "StopPhaseShift" ) // wait for current phase to end. this will make thread sometimes can't stop!
	wait duration // wait for fire duration to end
	RemoveEntityCallback_OnFinalDamaged( pilot, OnPhaseShiftNPCPilotDamaged )
	cleanUpTable["removeFinalDamageCallback"] = true
	RestoreNPCAttackCapability( pilot )
	cleanUpTable["restoreAttackCapability"] = true
}

// phase out of danger when:
// reaching max DPS taken
// taking damage over health threshold
// shot will kill pilot
void function OnPhaseShiftNPCPilotDamaged( entity pilot, var damageInfo )
{
	// don't know why sometimes they won't be remove callback... resulting become invulnerable
	// add a defensive check
	if ( !( pilot in file.npcPilotPhaseHealthThreshold ) )
		return

	int damage = int( DamageInfo_GetDamage( damageInfo ) )
	int healthLeft = pilot.GetHealth() - damage
	if ( healthLeft <= 0 ) // this is killshot!
	{
		PilotWantsToPhaseShift( pilot, damageInfo )
		return
	}

	int dpsTaken = int( GetTotalDamageTakenInTime( pilot, 1.0 ) )
	int maxDPSTaken = GetNPCPilotMaxDPSTaken( pilot )

	float healthFrac = GetHealthFrac( pilot )
	float newHealthFrac = float( healthLeft ) / float( pilot.GetMaxHealth() )
	float healthThreshold = file.npcPilotPhaseHealthThreshold[ pilot ]

	if ( dpsTaken >= maxDPSTaken || newHealthFrac <= healthThreshold )
	{
		PilotWantsToPhaseShift( pilot, damageInfo )
	}
}

void function PilotWantsToPhaseShift( entity pilot, var damageInfo )
{
	int damage = int( DamageInfo_GetDamage( damageInfo ) )
	float healthFracLeft = float( pilot.GetHealth() - damage ) / float( pilot.GetMaxHealth() )
	DamageInfo_SetDamage( damageInfo, 0 )

	var signalTable = {
		healthFracLeft = healthFracLeft
	}
	Signal( pilot, "PilotWantsToPhase", signalTable )
}

void function PilotSpawnProtection( entity pilot, entity titan, float duration )
{
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" ) // pilot's titan has been robbed?

	// invulnerability handled by ExtraSpawner_DisableSensingForNPC()
	// don't set again. SetInvulnerable() can stack up, we'll have to clear it twice
	//pilot.SetInvulnerable()
	//pilot.SetNoTarget( true )
	OnThreadEnd(
		function(): ( pilot )
		{
			if( IsAlive( pilot ) )
			{
				//print( "Clearing out pilot spawn protection!" )
				pilot.ClearInvulnerable()
				pilot.SetNoTarget( false )
			}
		}
	)

	// debugging version
	// guess I'll keep it in any case we need it
	float endTime = Time() + duration
	while ( Time() < endTime )
	{
		//print( "pilot notarget state while spawn protection: " + string( pilot.GetNoTarget() ) )
		//print( "pilot disabled dangrous area displacement: " + string( pilot.GetNPCMoveFlag( NPCMF_DISABLE_DANGEROUS_AREA_DISPLACEMENT ) ) )
		WaitFrame()
	}

	//wait duration
	//pilot.ClearInvulnerable() // fixed by reworked ForceStartTitan(): if pilots're killed before titan lands their titan will stuck in the sky!
}

void function ForceStartTitan( entity titan, entity pilot, float delay )
{
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( titan, pilot )
		{
			if ( IsAlive( pilot ) ) // pilot didn't made it to embark. start combating
			{
				if( IsAlive( titan ) )
				{
					titan.SetOwner( pilot )
					NPCFollowsNPC( titan, pilot )
					// shared function from _ai_pilots.gnut
					// pilot will still embark if they reached titan because we're not calling NpcPilotStopEmbarkAttempts()
					NpcPilotStopRunsToEmbark( pilot )
					if( titan.ContextAction_IsBusy() ) // embarking?
						return

					thread StandUnboardedTitan( titan )
				}

				// don't start titan handler. titan will follow the pilot
				ExtraSpawner_StopDefaultHandler( titan )
				if ( GetNPCHandlerForClass( "npc_pilot_elite" ) != null )
					thread GetNPCHandlerForClass( "npc_pilot_elite" )( pilot )
				pilot.SetNPCMoveSpeedScale( NPC_PILOT_MOVE_SPEED_SCALE ) // reset move speed
				pilot.DisableNPCFlag( NPC_IGNORE_ALL ) // pilot also start scan around
			}
			else
			{
				if( IsAlive( titan ) ) // this titan have no owner alive!!
				{
					if( titan.GetTitanSoul().soul.seatedNpcPilot.isValid ) // check embark
						return
					thread StandUnboardedTitan( titan )
				}
			}
		}
	)

	titan.WaitSignal( "TitanHotDropComplete" )
	wait delay
}

entity function ExtraSpawner_SpawnTitanForPilot( entity pilot, vector pos, vector rot, string spawnName = "" )
{
	// reworked to use an existing function
	entity titan = ExtraSpawner_SpawnTitan( pos, rot, pilot.GetTeam(), false, null, spawnName ) // the titan will wait before standing up, and it will use default titan handler
	NpcPilotSetPetTitan( pilot, titan ) // shared function from _ai_pilots.gnut
	thread PetTitanOwnerLifeTimeCheck( titan, pilot ) // avoid titan being stuck in the sky! this happens if pilot died while titan dropping

	// make them be like auto titans
	ExtraSpawner_SetUpPilotOwnedAutoTitan( titan )

	// manually do hotdrop after settings done
	// don't stand up, wait for pilot embark it
	thread ExtraSpawner_NPCTitanDrops( titan, false )

	return titan
}

void function ExtraSpawner_SetUpPilotOwnedAutoTitan( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// same behavior as _titan_npc_behavior.gnut, OnClassChangeBecomePilot() does
		if ( !SoulHasPassive( soul, ePassives.PAS_ENHANCED_TITAN_AI ) )
		{
			entity ordnanceWeapon = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
			if ( IsValid( ordnanceWeapon ) )
				ordnanceWeapon.AllowUse( false )

			entity centerWeapon = titan.GetOffhandWeapon( OFFHAND_TITAN_CENTER )
			if ( IsValid( centerWeapon ) )
				centerWeapon.AllowUse( false )
		}

		// proficiency
		// same as _ai_lethality.gnut, SetTitanAccuracyAndProficiency() does
		if ( SoulHasPassive( soul, ePassives.PAS_ENHANCED_TITAN_AI ) )
		{
			titan.kv.WeaponProficiency = eWeaponProficiency.GOOD
		}
		else
		{
			titan.kv.WeaponProficiency = eWeaponProficiency.AVERAGE
		}
	}

	//titan.SetCanBeMeleeExecuted( true ) // npc synced melee ignores this
	titan.SetBehaviorSelector( "behavior_mp_auto_titan" )
	if ( MeleeSyncedNPC_IsTitanOnlyAllowedToExecuteWithNPCPilot() )
		titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, true ) // restore synced melee for auto-titans
}

void function PetTitanOwnerLifeTimeCheck( entity titan, entity owner )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" )

	table data = {}
	data.dropSuccess <- false

	OnThreadEnd(
		function(): ( titan, data )
		{
			if( data.dropSuccess ) // successfully dropped to ground, maybe it can stand up after owner died
				return
			if( IsValid( titan ) ) 
				titan.Destroy() // ded.
		}
	)

	titan.WaitSignal( "TitanHotDropComplete" )
	data.dropSuccess = true
}

function OnNpcPilotBecomesTitan( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	// only handle titans spawn from this file
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( titan ) )
		return

	ExtraSpawner_SetUpNPCEmbarkedTitan( titan )
	ApplySoulSettingsForNpcPilotEmbarking( titan ) // become smarter, since pilot has control of it

	// kinda annoying to have a info target all around them.
	//titan.SetAISettings( titan.GetAISettingsName() + "_bounty" ) // so they will show up a health bar, letting players know they're npc pilot controled
	//Highlight_ClearEnemyHighlight( titan ) // this resets highlights in modified sh_highlights
	// titan handler
	// already handled by ExtraSpawner_SpawnTitan()
	//if ( GetNPCHandlerForClass( "npc_titan" ) != null )
	//	thread GetNPCHandlerForClass( "npc_titan" )( titan )
}

void function ExtraSpawner_SetUpNPCEmbarkedTitan( entity titan )
{
	// restore weapon usage lock from auto-titan
	entity ordnanceWeapon = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	if ( IsValid( ordnanceWeapon ) )
		ordnanceWeapon.AllowUse( true )

	entity centerWeapon = titan.GetOffhandWeapon( OFFHAND_TITAN_CENTER )
	if ( IsValid( centerWeapon ) )
		centerWeapon.AllowUse( true )

	titan.kv.WeaponProficiency = eWeaponProficiency.VERYGOOD // they can shoot very nice
	//titan.SetCanBeMeleeExecuted( false ) // code synced melee ignores this
	if ( MeleeSyncedNPC_IsTitanOnlyAllowedToExecuteWithNPCPilot() )
		titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false ) // disable synced melee behavior, we use melee_synced_npc
	// soul settings
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanHealth_SetTitanCoreBuilderMultiplier( titan, 2.5 ) // want them get core abilities faster
		PlayerEarnMeter_EnableSoulNPCTitanEarnMeterSmokeUsage( soul, true ) // allow this npc titan use reward electric smoke
	
		// debug only
		#if EXTRA_SPAWNER_DEBUG
			//MeleeSyncedTitan_SetSoulExecutionTargetRequiredHealthFrac( soul, 1.0 ) // titan can execute any target below this health frac( 1.0 means they'll always execute any other titans )
		#endif

		// use npc pilot as it's eject explosion and nuke attacker
		// prevent titan get destroyed before nuke ends and dealing damage to friendly players
		// can't assign to soul.soul.nukeAttacker because it's not gonna be updated when npc pilot ejects...
		TitanEject_SetSoulUseNPCPilotAsExplosionAttacker( soul, true )
		// make npc titan stop moving while ejecting, much like player ejecting
		// make this a setting is to prevent impacting vanilla nuke titan behavior
		TitanEject_SetSoulStopMovingWhileNPCEject( soul, true )
	}

	// start specific think, for anti-rodeo countermeasure
	ExtraSpawner_EmbarkedNPCTitanRodeoCounter( titan )
	// start specific think, for handling core abilities that won't be used by npcs in vanilla
	ExtraSpawner_ScriptedNPCTitanCoreAbility( titan )
}

// Rodeo counter: force inventory smoke to fire when getting rodeo hit recently
//const string RODEO_COUNTER_SMOKE_WEAPON = "mp_titanability_smoke"
const float RODEO_COUNTER_DELAY = 0.5 // titan will wait this amount of time before deploying the smoke
// removing these now, we get from stuffs we setup in "mp_titanability_electric_smoke.txt"
//const float RODEO_COUNTER_COOLDOWN_MIN = 6.0 // next smoke will need at least this amount of time to deploy
//const float RODEO_COUNTER_COOLDOWN_MAX = 10.0

void function ExtraSpawner_EmbarkedNPCTitanRodeoCounter( entity titan )
{
	thread EmbarkedNPCTitanRodeoCounter_Threaded( titan )
}

void function EmbarkedNPCTitanRodeoCounter_Threaded( entity titan )
{
	//print( "RUNNING EmbarkedNPCTitanRodeoCounter()" )
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	titan.Signal( "EmbarkedNPCTitanRodeoCounter" )
	titan.EndSignal( "EmbarkedNPCTitanRodeoCounter" )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnDestroy" )
	// being embarked by player: end npc titan think
	titan.EndSignal( "player_embarks_titan" )

	float beingRodeoedTime = -1
	float lastTickRodeoHitTime = 0
	float smokeDeployAllowedTime = -1

	while ( true )
	{
		WaitFrame() // always wait a frame each loop

		titan = soul.GetTitan() // update titan
		//if ( !TitanHasNpcPilot( titan ) ) // npc pilot become invalid!
		//	return

		entity rodeoPilot = GetRodeoPilot( titan )
		float rodeoHitTime = soul.GetLastRodeoHitTime()
		if ( rodeoHitTime != 0 && lastTickRodeoHitTime == 0 ) // rodeo target updated!
			beingRodeoedTime = Time()
		else if ( rodeoHitTime == 0 ) // rodeo target detached
			beingRodeoedTime = -1
		lastTickRodeoHitTime = rodeoHitTime

		// titan in execution, skip this loop
		if( titan.ContextAction_IsActive() || 
			titan.ContextAction_IsMeleeExecution() || 
			titan.ContextAction_IsMeleeExecutionTarget() )
			continue

		// soul has disabled npc smoke
		if ( !PlayerEarnMeter_IsSoulNPCTitanEarnMeterSmokeUsageEnabled( soul ) )
			continue

		//print( "beingRodeoedTime: " + string( beingRodeoedTime ) )
		// Rodeo counter: force inventory smoke to fire when getting rodeo hit recently
		if ( IsAlive( rodeoPilot ) && beingRodeoedTime != -1 )
		{
			// delay is enough!
			if ( Time() > smokeDeployAllowedTime && Time() > beingRodeoedTime + RODEO_COUNTER_DELAY )
			{
				entity rewardSmoke = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
				if ( IsValid( rewardSmoke ) && rewardSmoke.GetWeaponPrimaryAmmoCount() > 0 )
				{
					WeaponPrimaryAttackParams emptyParams // smoke don't need attack params
					OnWeaponNpcPrimaryAttack_titanability_smoke( rewardSmoke, emptyParams )
					
					// delay next smoke allowed time
					smokeDeployAllowedTime = Time() + GetWeaponNPCRestTime( rewardSmoke )
					
					// ammo management
					rewardSmoke.SetWeaponPrimaryAmmoCount( rewardSmoke.GetWeaponPrimaryAmmoCount() - 1 )
					// when ammo runs out, we take away the weapon
					if ( rewardSmoke.GetWeaponPrimaryAmmoCount() == 0 )
						titan.TakeOffhandWeapon( OFFHAND_INVENTORY )
				}
			}
		}
	}
}

void function ExtraSpawner_StopNPCTitanRodeoCounter( entity titan )
{
	titan.Signal( "EmbarkedNPCTitanRodeoCounter" )
}

// scripted titan core ability
void function ExtraSpawner_ScriptedNPCTitanCoreAbility( entity titan )
{
	thread ScriptedNPCTitanCoreAbility_Threaded( titan )
}

void function ScriptedNPCTitanCoreAbility_Threaded( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	titan.Signal( "ScriptedNPCTitanCoreAbility" )
	titan.EndSignal( "ScriptedNPCTitanCoreAbility" )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnDestroy" )
	// being embarked by player: end npc titan think
	titan.EndSignal( "player_embarks_titan" )

	while ( true )
	{
		entity coreWeapon = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		if ( IsValid( coreWeapon ) )
		{
			string coreWeaponName = coreWeapon.GetWeaponClassName()
			if ( coreWeaponName in file.scriptedNPCTitanCoreThink )
			{
				//print( "RUNNING scripted titan core ability for titan!" )
				waitthread file.scriptedNPCTitanCoreThink[ coreWeaponName ]( titan, coreWeapon ) // continue looping until core weapon gets destroyed or something
			}
		}

		WaitFrame()
	}
}

void function ExtraSpawner_StopNPCTitanCoreAbility( entity titan )
{
	titan.Signal( "ScriptedNPCTitanCoreAbility" )
}

void function ExtraSpawner_AddScriptedNPCTitanCoreThink( string coreWeaponName, void functionref( entity titan, entity coreWeapon ) thinkFunc )
{
	if ( !( coreWeaponName in file.scriptedNPCTitanCoreThink ) )
		file.scriptedNPCTitanCoreThink[ coreWeaponName ] <- thinkFunc
	else
		file.scriptedNPCTitanCoreThink[ coreWeaponName ] = thinkFunc
}

void function InitDefaultScriptedNPCTitanCore()
{
	ExtraSpawner_AddScriptedNPCTitanCoreThink( "mp_titancore_upgrade", NPCTitanUpgradeCoreThink )
	ExtraSpawner_AddScriptedNPCTitanCoreThink( "mp_titancore_siege_mode", NPCTitanSmartCoreThink )
}

// npc upgrade core usage
const float UPGRADE_CORE_ACTIVATE_REQUIRED_SHIELD_FRAC = 0.4 // if shield is below this fraction, titan activates upgrade core
const float UPGRADE_CORE_ACTIVATE_MAX_DELAY = 12.0 // titan will activate upgrade core after this delay, no matter how many shield left
const float UPGRADE_CORE_COOLDOWN_BETWEEN_USE = 5.0 // monarch can be annoying if upgrading too fast, add cooldown

void function NPCTitanUpgradeCoreThink( entity titan, entity coreWeapon )
{
	// EndSignals() should been set by ScriptedNPCTitanCoreAbility_Threaded()

	coreWeapon.EndSignal( "OnDestroy" )
	while ( true )
	{
		// generic wait until core charges
		WaitTillTitanCoreCharge( titan )

		entity soul = titan.GetTitanSoul()
		// wait till shield goes down, or core has been charged for certain time
		float maxWait = Time() + UPGRADE_CORE_ACTIVATE_MAX_DELAY
		while ( Time() < maxWait )
		{
			float shieldFrac = float( soul.GetShieldHealth() ) / float( soul.GetShieldHealthMax() )
			if ( shieldFrac < UPGRADE_CORE_ACTIVATE_REQUIRED_SHIELD_FRAC )
				break

			WaitFrame()
		}

		// run core functions
		// keep firing until we got one valid
		WeaponPrimaryAttackParams emptyParams // upgrade core don't need attackParams
		bool succeeded = false
		while ( !succeeded )
		{
			// wait till titan stops scripted animation
			while ( titan.Anim_IsActive() )
				WaitFrame()
			
			// needs modified mp_titancore_upgrade.nut, or it will crash
			succeeded = bool( OnWeaponPrimaryAttack_UpgradeCore( coreWeapon, emptyParams ) )
			WaitFrame()
		}

		// core used, drain meter
		//thread DrainNPCTitanCoreMeter( titan )

		// cooldown before next core use
		// vanilla doesn't seem like npcs will use rest time for core abilities
		// but monarch can be annoying if upgrading too fast, still add cooldown
		//WeaponWaitForRandomNPCRest( coreWeapon )
		waitthread DrainNPCTitanCoreMeter( titan )
		wait UPGRADE_CORE_COOLDOWN_BETWEEN_USE
	}
}

// npc smart core usage
const float SMART_CORE_ACTIVATE_REQUIRED_EMENY_COUNT = 3 // if more than this amount of enemy heavy armor units attacking us, we activate core
const float SMART_CORE_RECENT_DAMAGE_HISTORY = 3.0 // damage histroy withing this time will consider 
const float SMART_CORE_ACTIVATE_CHECK_HEAVY_ARMOR = 4.0 // after this delay, if titan sees an heavy armor target they'll activate core
const float SMART_CORE_ACTIVATE_MAX_DELAY = 15.0 // after this delay, titan will activate smart core once they sees an enemy

void function NPCTitanSmartCoreThink( entity titan, entity coreWeapon )
{
	// EndSignals() should been set by ScriptedNPCTitanCoreAbility_Threaded()

	coreWeapon.EndSignal( "OnDestroy" )
	while ( true )
	{
		// generic wait until core charges
		WaitTillTitanCoreCharge( titan )

		entity soul = titan.GetTitanSoul()
		float checkHeavyArmorTime = Time() + SMART_CORE_ACTIVATE_CHECK_HEAVY_ARMOR
		float maxWait = Time() + SMART_CORE_ACTIVATE_MAX_DELAY
		while ( Time() < maxWait )
		{
			// wait till enemy move out of attacking range
			entity enemy = titan.GetEnemy()
			if ( IsValid( enemy ) )
			{
				// heavy armor enemy check
				if ( Time() > checkHeavyArmorTime )
				{
					if ( enemy.GetArmorType() == ARMOR_TYPE_HEAVY )
						break
				}
				entity activeWeapon = titan.GetActiveWeapon()
				if ( IsValid( activeWeapon ) )
				{
					float bestRange = activeWeapon.GetWeaponSettingFloat( eWeaponVar.npc_damage_near_distance )
					if ( Distance( titan.GetOrigin(), enemy.GetOrigin() ) > bestRange )
						break // try to run core ability
				}
			}

			// multiple enemy heavy armor units attacking us together
			// EDIT: remove heavy armor unit check
			entity soul = titan.GetTitanSoul()
			array<entity> enemiesAttacking = GetEnemiesAttackingInTime( soul, SMART_CORE_RECENT_DAMAGE_HISTORY )
			int enemyCount = 0
			foreach ( entity attacker in enemiesAttacking )
			{
				// armor type
				//if ( attacker.GetArmorType() == ARMOR_TYPE_HEAVY )
					enemyCount += 1
			}

			//print( "enemyCount: " + string( enemyCount ) )
			if ( enemyCount >= SMART_CORE_ACTIVATE_REQUIRED_EMENY_COUNT )
				break // try to run core ability

			WaitFrame()
		}

		// run core functions
		// keep firing until we got one valid
		WeaponPrimaryAttackParams emptyParams // smart core don't need attackParams
		bool succeeded = false
		while ( !succeeded )
		{
			// wait till titan stops scripted animation
			if ( titan.Anim_IsActive() )
			{
				WaitFrame()
				continue
			}

			// wait till titan sees an enemy
			entity enemy = titan.GetEnemy()
			if ( !IsAlive( enemy ) || !titan.CanSee( enemy ) )
			{
				WaitFrame()
				continue
			}

			// needs modified mp_titancore_siege_mode.nut, or it will crash
			succeeded = bool( OnWeaponPrimaryAttack_titancore_siege_mode( coreWeapon, emptyParams ) )
			WaitFrame()
		}

		// core used, drain meter
		//thread DrainNPCTitanCoreMeter( titan )

		// cooldown before next core use
		// vanilla doesn't seem like npcs will use rest time for core abilities
		// wait for core meter drain out should be good enough
		//WeaponWaitForRandomNPCRest( coreWeapon )
		waitthread DrainNPCTitanCoreMeter( titan )
	}
}

array<entity> function GetEnemiesAttackingInTime( entity ent, float hitTime )
{
	array<entity> enemiesAttacking
	foreach( DamageHistoryStruct attackerInfo in ent.e.recentDamageHistory )
	{
		// timer
		if ( Time() > attackerInfo.time + hitTime )
			continue
		
		entity attacker = attackerInfo.attacker
		// generic check
		if ( !IsValid( attacker ) )
			continue
		// checks for self damage
		if ( attacker == ent )
			continue
		// checks for player owned entities
		if ( attacker == ent.GetBossPlayer() )
			continue
		
		// soul specific checks
		if ( IsSoul( ent ) )
		{
			entity titan = ent.GetTitan()
			if ( IsValid( titan ) )
			{
				// checks for self damage
				if ( attacker == titan )
					continue
				// checks for player owned entities
				if ( attacker == titan.GetBossPlayer() )
					continue
			}
		}

		if ( !enemiesAttacking.contains( attacker ) )
			enemiesAttacking.append( attacker )
	}

	return enemiesAttacking
}

void function WaitTillTitanCoreCharge( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	soul.EndSignal( "OnDestroy" )

	// wait till titan core fully expire first
	while ( IsAlive( titan ) )
	{
		if ( !TitanCoreInUse( titan ) )
			break

		WaitFrame()
	}

	// wait till titan core charge
	while ( IsAlive( titan ) )
	{
		//print( "SoulTitanCore_GetNextAvailableTime( soul ): " + string( SoulTitanCore_GetNextAvailableTime( soul ) ) )
		if ( SoulTitanCore_GetNextAvailableTime( soul ) == 1.0 )
			break

		WaitFrame()
	}
}

void function DrainNPCTitanCoreMeter( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	soul.EndSignal( "OnDestroy" )
	while ( true )
	{
		//print( "soul.GetCoreChargeExpireTime(): " + string( soul.GetCoreChargeExpireTime() ) )
		if ( soul.GetCoreChargeExpireTime() <= Time() )
			break
		WaitFrame()
	}

	//print( "npc titan core drains out" )
	SoulTitanCore_SetNextAvailableTime( soul, 0.0 )
}

void function WeaponWaitForRandomNPCRest( entity weapon )
{
	wait GetWeaponNPCRestTime( weapon )
}

int function GetWeaponNPCBurstCount( entity weapon )
{
	int minBurst = weapon.GetWeaponSettingInt( eWeaponVar.npc_min_burst )
	int maxBurst = weapon.GetWeaponSettingInt( eWeaponVar.npc_max_burst )
	if ( maxBurst <= minBurst ) // anti-crash
		return minBurst
	return RandomIntRange( minBurst, maxBurst + 1 )
}

float function GetWeaponNPCRestTime( entity weapon )
{
	float minRest = weapon.GetWeaponSettingFloat( eWeaponVar.npc_rest_time_between_bursts_min )
	float maxRest = weapon.GetWeaponSettingFloat( eWeaponVar.npc_rest_time_between_bursts_max )
	if ( maxRest <= minRest ) // anti-crash
		return minRest
	return RandomFloatRange( minRest, maxRest )
}

function OnNpcTitanBecomesPilot( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	// only handle titans spawn from this file
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( titan ) )
		return

	// if titan is spawned by extraSpawner, pilot should also be marked
	ExtraSpawner_SetUpSpawnedNPC( pilot ) // generic setup for any npc in this file
	ExtraSpawner_SetUpNPCPilot( pilot ) // also included handler call

	if ( IsValid( titan ) )
	{
		entity titanSoul = titan.GetTitanSoul()
		if( !IsValid( titanSoul ) ) // defensive fix for titan.Destroy() situations
			return

		bool isEjecting = titanSoul.IsEjecting()
		if( isEjecting )
			thread NPCPilotEjectingAnimation( pilot )
		
		// setup disembarked behaviors
		ExtraSpawner_SetUpNPCDisembarkedTitan( titan )

		// kinda annoying to have a info target all around them.
		//string aiSetFile = titan.GetAISettingsName()
		//titan.SetAISettings( aiSetFile.slice( 0, aiSetFile.len() - 7 ) ) // not ejecting, back to normal health bar
		//Highlight_ClearEnemyHighlight( titan ) // this resets highlights in modified sh_highlights
	}
}

void function ExtraSpawner_SetUpNPCDisembarkedTitan( entity titan )
{
	// setup abilities to make them more like mp auto-titans
	ExtraSpawner_SetUpPilotOwnedAutoTitan( titan )

	// soul settings
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		bool isEjecting = soul.IsEjecting() // we don't want to cleanup some stuff if titan is ejecting

		TitanHealth_SetTitanCoreBuilderMultiplier( titan, 1.0 ) // reset core build speed to normal
		PlayerEarnMeter_EnableSoulNPCTitanEarnMeterSmokeUsage( soul, false ) // disable npc titan reward electric smoke usage
		if ( !isEjecting )
		{
			TitanEject_SetSoulUseNPCPilotAsExplosionAttacker( soul, false ) // stop using disembarked npc pilot for nuke
			TitanEject_SetSoulStopMovingWhileNPCEject( soul, false ) // stop ejecting behavior override
		}
	}

	// stop scripted behavior
	ExtraSpawner_StopNPCTitanRodeoCounter( titan )
	ExtraSpawner_StopNPCTitanCoreAbility( titan )
}

// if pilot still not touching ground after this amount of time
// we reset it's animation
const float PILOT_EJECTING_ANIM_FAILSAFE = 8.0
void function NPCPilotEjectingAnimation( entity pilot )
{
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	
	if ( !pilot.ContextAction_IsBusy() )
		pilot.ContextAction_SetBusy() // this can make them stop finding new targets, and make them unable to be executed
	file.npcPilotInScriptedAnim[ pilot ] = true // add a in-file mark

	pilot.Anim_ScriptedPlayActivityByName( "ACT_FALL", true, 0.2 )
	pilot.SetNPCPriorityOverride( 10 ) // npc titans aim bad at mid-air targets. don't let them do so

	OnThreadEnd
	(
		function(): ( pilot )
		{
			if ( IsValid( pilot ) )
			{
				if ( pilot.ContextAction_IsBusy() )
					pilot.ContextAction_ClearBusy()
				file.npcPilotInScriptedAnim[ pilot ] = false
				
				pilot.Anim_Stop()
				if ( IsAlive( pilot ) )
					pilot.ClearNPCPriorityOverride()
			}
		}
	)

	// debug
	float startTime = Time()

	// now changing method: use certain animation
	// failed...
	//pilot.Anim_ScriptedPlayActivityByName( "ACT_FALL", true, 0.2 ) // once tried "ACT_MP_JUMP_FLOAT" but it isn't looped...
	//float animCycle = pilot.GetSequenceDuration( "jump_loop" ) * 0.7 // wait for shorter than anim duration

	float lastAnimPlayedTime = -1
	float failSafeTime = Time() + PILOT_EJECTING_ANIM_FAILSAFE
	while( Time() < failSafeTime )
	{
		// now changing to better think
		// removed. nuke eject can throw them really high and trace to something not necessary
		//if ( IsPilotNearGround( pilot ) )
		if ( pilot.IsOnGround() )
			break

		// anim play think
		// don't know why when using "Anim_ScriptedPlay()", the pilot will just fly away
		// PlayAnim() also don't work.. whatever
		//if ( lastAnimPlayedTime == -1 || ( Time() - lastAnimPlayedTime > animCycle ) )
		//	thread PlayAnim( pilot, "jump_loop" )
		
		WaitFrame()
	}

	// debug
	//print( "pilot eject flight time: " + string( Time() - startTime ) )
}

bool function IsPilotNearGround( entity pilot )
{
	// already on ground
	if ( pilot.IsOnGround() )
		return true

	vector pilotVelocity = pilot.GetVelocity()
	// never consider near ground if pilot is moving upward
	if ( pilotVelocity.z >= 0 )
		return false

	array<entity> ignoreEnts
	// always ignore all npcs and players, try to hit onto ground
	// landing on other entities is all good, anim can be as short as possible
	//ignoreEnts.extend( GetPlayerArray() )
	//ignoreEnts.extend( GetNPCArray() )
	ignoreEnts.append( pilot ) // self no checks

	vector traceStart = pilot.GetOrigin()
	float nextFrameVerticalMove = fabs( pilotVelocity.z ) * 0.15 // bit higher value than one script tick( 0.1s ) 
	// debug
	//print( "nextFrameVerticalMove: " + string( nextFrameVerticalMove ) )
	vector traceEnd = traceStart - < 0, 0, nextFrameVerticalMove >

	TraceResults downTrace = TraceLine( traceStart, traceEnd, ignoreEnts, TRACE_MASK_SHOT, TRACE_COLLISION_GROUP_NONE )
	entity hitEnt = downTrace.hitEnt
	if ( !IsValid( hitEnt ) ) // we cannot trace any entity
		return false

	return true
}

// modified callbacks
void function OnNPCPilotStartsEmbarkSequence( entity pilot, entity titan, var embarkSet )
{
	if ( ExtraSpawner_IsNPCSpawnedFromExtraSpawner( pilot ) )
		RemoveMinimapForNPC( pilot ) // remove minimap icon(currently using fake one) for embarking npc pilots
}

// modified things
//////////////////////////////////////////////////////////

void function ApplyNormalMeleeIdToNPCTitan( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return
    if( !attacker.IsTitan() )
        return
	if( !TitanHasNpcPilot( attacker ) )
		return
	// only handle npcs from this file
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( attacker ) )
		return
	
	// may no need to handle ronin sword, since ronin sometimes try to step on enemies
	int damageSource = eDamageSourceId.melee_titan_punch // default value
	entity meleeWeapon = attacker.GetMeleeWeapon() // melee weapon overrides
	if ( IsValid( meleeWeapon ) )
		damageSource = TitanMelee_GetMeleeDamageSourceIDForWeapon( meleeWeapon ) // modified function in sh_melee_titan.gnut
	
	DamageInfo_SetDamageSourceIdentifier( damageInfo, damageSource )
}

// adjust damages for npc pilots!
void function NPCPilotDamageAdjustments( entity pilot, var damageInfo )
{
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( pilot ) ) // pilot spawning from other files!
		return
	
	if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) ) // force kill damage( trigger_hurt, executions ) shouldn't be handled
		return

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) )
		return
	
	// hardcode version
	/*
	if ( !attacker.IsTitan() )
		return

	// titan step
	if( damageSourceID == damagedef_titan_step ) 
		DamageInfo_SetDamage( damageInfo, TITAN_STEPPING_ON_DAMAGE_NPC_PILOT )

	// titan melee
	if( damageType & DF_MELEE || damageSourceID == eDamageSourceId.auto_titan_melee )
	{
		// player's titan melee
		if ( attacker.IsPlayer() )
		{
			// ronin sword
			if( damageSourceID == eDamageSourceId.melee_titan_sword ) 
				DamageInfo_SetDamage( damageInfo, TITAN_SOWRD_DAMAGE_NPC_PILOT )
			else
				DamageInfo_SetDamage( damageInfo, PLAYER_TITAN_MELEE_DAMAGE_NPC_PILOT )
		}

		// npc's titan melee
		if( attacker.IsNPC() ) 
			DamageInfo_SetDamage( damageInfo, NPC_TITAN_MELEE_DAMAGE_NPC_PILOT )
	}
	*/

	// DPS version
	// guess we can't use damage history for non-player nor soul entity
	// we'll store it manually
	// get DPS( excluded current damage because we store it later )
	int dpsTaken = int( GetTotalDamageTakenInTime( pilot, 1.0 ) )
	int maxDPSTaken = GetNPCPilotMaxDPSTaken( pilot )
	// debug
	//print( "dpsTaken: " + string( dpsTaken ) )
	if ( dpsTaken >= maxDPSTaken )
		DamageInfo_SetDamage( damageInfo, 0 )
	else
	{
		int maxDamage = maxDPSTaken - dpsTaken
		int currentDamage = int( DamageInfo_GetDamage( damageInfo ) )
		DamageInfo_SetDamage( damageInfo, min( currentDamage, maxDamage ) )
	}

	// debug
	//print( "npc pilot modified damage: " + string( DamageInfo_GetDamage( damageInfo ) ) )
}

// settings func
void function ExtraSpawner_SetNPCPilotMaxDPSTaken( entity pilot, int maxDPS )
{
	if ( !( pilot in file.npcPilotMaxDPSTaken ) )
		file.npcPilotMaxDPSTaken[ pilot ] <- NPC_PILOT_MAX_DAMAGE_TAKEN_PER_SECOND

	file.npcPilotMaxDPSTaken[ pilot ] = maxDPS
}

int function GetNPCPilotMaxDPSTaken( entity pilot )
{
	if ( !( pilot in file.npcPilotMaxDPSTaken ) )
		return NPC_PILOT_MAX_DAMAGE_TAKEN_PER_SECOND

	return file.npcPilotMaxDPSTaken[ pilot ]
}

void function NPCPilotDamageModifier( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( attacker ) ) // pilot spawning from other files!
		return
	
	// not a heavy armor target, hit by bullet
	// make npc pilots powerful?
	if ( victim.GetArmorType() != ARMOR_TYPE_HEAVY && DamageInfo_GetCustomDamageType( damageInfo ) & DF_BULLET )
	{
		DamageInfo_ScaleDamage( damageInfo, GetNPCPilotBulletDamageScale( attacker ) )
	}
}

// settings func
void function ExtraSpawner_SetNPCPilotBulletDamageScale( entity pilot, float scale )
{
	if ( !( pilot in file.npcPilotBulletDamageScale ) )
		file.npcPilotBulletDamageScale[ pilot ] <- NPC_PILOT_BULLET_DAMAGE_MULTIPLIER

	file.npcPilotBulletDamageScale[ pilot ] = scale
}

float function GetNPCPilotBulletDamageScale( entity pilot )
{
	if ( !( pilot in file.npcPilotBulletDamageScale ) )
		return NPC_PILOT_BULLET_DAMAGE_MULTIPLIER

	return file.npcPilotBulletDamageScale[ pilot ]
}

void function ProwlerMeleeDamageModifier( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return
	if ( !ExtraSpawner_IsNPCSpawnedFromExtraSpawner( attacker ) ) // prowler spawning from other files!
		return
	
	float damageScale = 1.0

	bool nerfDamage = false
	bool heavyArmorTarget = false
	// prowler's craw damage is 80, pounce damage is 100
	if ( victim.IsPlayer() ) // nerf it's damage agains players
		nerfDamage = true
	if ( victim.IsNPC() )
	{
		// a npc owned by player, do reduce damage
		if ( IsValid( victim.GetBossPlayer() ) )
			nerfDamage = true
		// owner should be related with visibility stuffs( like synced melee ), not adding to this check
		//if ( IsValid( victim.GetOwner() ) )
		//	nerfDamage = true
	}
	if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
		heavyArmorTarget = true

	if ( heavyArmorTarget )
		damageScale *= GetProwlerMeleeDamageScale( attacker, true )
	else if ( nerfDamage )
		damageScale *= GetProwlerMeleeDamageScale( attacker )
	
	if ( victim in file.isProwlerSquadmate ) // prowler squad specific
	{
		float modelScale = float( attacker.kv.modelscale )
		if ( modelScale < 1 )
			damageScale *= modelScale * 0.75 // take less damage from smaller prowlers
	}

	DamageInfo_ScaleDamage( damageInfo, damageScale )
}

void function ExtraSpawner_SetProwlerMeleeDamageScale( entity prowler, float damageScale, float damageHeavyArmorScale = -1 )
{
	if ( !( prowler in file.prowlerMeleeDamageScale ) )
		file.prowlerMeleeDamageScale[ prowler ] <- PROWLER_MELEE_DAMAGE_MULTIPLIER
	file.prowlerMeleeDamageScale[ prowler ] = damageScale

	// default is we don't modify heavy armor damage
	if ( damageHeavyArmorScale > -1 )
	{
		if ( !( prowler in file.prowlerMeleeDamageScaleHeavyArmor ) )
			file.prowlerMeleeDamageScaleHeavyArmor[ prowler ] <- PROWLER_MELEE_DAMAGE_MULTIPLIER_HEAVYARMOR
		file.prowlerMeleeDamageScaleHeavyArmor[ prowler ] = damageHeavyArmorScale
	}
}

float function GetProwlerMeleeDamageScale( entity prowler, bool isHeavyArmorTarget = false )
{
	if ( isHeavyArmorTarget )
	{
		if ( !( prowler in file.prowlerMeleeDamageScaleHeavyArmor ) )
			return PROWLER_MELEE_DAMAGE_MULTIPLIER_HEAVYARMOR

		return file.prowlerMeleeDamageScaleHeavyArmor[ prowler ]
	}

	if ( !( prowler in file.prowlerMeleeDamageScale ) )
		return PROWLER_MELEE_DAMAGE_MULTIPLIER

	return file.prowlerMeleeDamageScale[ prowler ]
}

void function ExtraSpawner_PilotHandler( entity pilot )
{
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	// Signals for controlling
	pilot.Signal( "StopDefaultHandler" )
	pilot.EndSignal( "StopDefaultHandler" )

	int team = pilot.GetTeam()
	array<entity> points

	pilot.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	// show on enemy radar, unfortunatelly cl_minimap won't track npc_pilot_elite
	//AddMinimapForNPC( pilot )
	// using a hacky way: add a tracked npc as fake npc
	CreateNPCAsFakeMapIconForNPC( pilot, "npc_soldier" )

	wait 3 // initial wait before pilots disembark from droppod or drop from ejecting
	
	// Every 5 - 15 secs get a closest target and go to them
	while ( true )
	{	
		WaitFrame() // always wait a frame before each loop

		// check leechable
		if ( pilot.GetTeam() != team )
			return
		
		// Get point and send guy to it
		points = [] // clean up last point
		array<entity> pointsToSearch = []
		// try to find from npc targets
		pointsToSearch.extend( GetNPCArrayOfEnemies( team ) )
		// try to find from alive player targets
		pointsToSearch.extend( GetPlayerArrayOfEnemies_Alive( team ) )

		// start searching
		foreach ( entity ent in pointsToSearch )
		{
			// general check
			if ( !IsValidNPCAssaultTarget( ent ) )
				continue

			points.append( ent )
		}

		ArrayRemoveDead( points ) // remove dead entities
		if ( points.len() == 0 )
			continue

		entity enemy = GetClosest2D( points, pilot.GetOrigin() )
		if ( !IsValid( enemy ) )
			continue
		vector ornull clampedPos = NavMesh_ClampPointForAI( enemy.GetOrigin(), pilot )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )
		pilot.AssaultPoint( clampedPos )

		// remove random wait to make them more aggresive?
		// never do it. too many assault point can make them move really silly
		wait RandomFloatRange( 5.0, 15.0 )
	}
}

void function ExtraSpawner_TitanHandler( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	soul.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" )
	// Signals for controlling
	titan.Signal( "StopDefaultHandler" )
	titan.EndSignal( "StopDefaultHandler" )

	int team = titan.GetTeam()
	array<entity> points

	// show on enemy radar
	AddMinimapForNPC( titan )

	// wait for standup
	while ( soul.GetStance() < STANCE_STANDING )
		WaitFrame()
	titan.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others

	wait 3 // initial wait before titans can move

	// Every 10 - 20 secs get a closest target and go to them
	while ( true )
	{	
		WaitFrame() // always wait a frame before each loop

		// wait for standup
		while ( soul.GetStance() < STANCE_STANDING )
			WaitFrame()

		// check capturable
		if ( titan.GetTeam() != team )
			return
		
		// Get point and send guy to it
		points = [] // clean up last points
		array<entity> pointsToSearch = []
		// try to find from npc targets
		pointsToSearch.extend( GetNPCArrayOfEnemies( team ) )
		// try to find from alive player targets
		pointsToSearch.extend( GetPlayerArrayOfEnemies_Alive( team ) )

		// we mostly search for other titans
		// if there're no valid targets, we prefer using heavy armor targets
		points = FindNPCTitanAssaultTargets( pointsToSearch )

		ArrayRemoveDead( points ) // remove dead entities
		if ( points.len() == 0 ) // no points valid!
			continue

		entity enemy = GetClosest2D( points, titan.GetOrigin() )
		if ( !IsValid( enemy ) )
			continue
		vector ornull clampedPos = NavMesh_ClampPointForAI( enemy.GetOrigin(), titan )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )
		titan.AssaultPoint( clampedPos )

		// remove random wait to make them more aggresive?
		// never do it. too many assault point can make them move really silly
		wait RandomFloatRange( 10.0, 20.0 )
	}
}

const float CARE_PACKAGE_LIFETIME = 30
const float CARE_PACKAGE_WAITTIME = 5
void function ExtraSpawner_SpawnCarePackageToGetWeapons( vector pos, vector rot, float lifeTime = CARE_PACKAGE_LIFETIME, float waitTime = CARE_PACKAGE_WAITTIME )
{
	ExtraSpawner_SpawnCarePackage( pos, rot, CarePackage_GiveWeapon, "獲取武器", lifeTime, waitTime )
}

// care package variant: ammo refill only
void function ExtraSpawner_SpawnCarePackageToRefillAmmo( vector pos, vector rot, float lifeTime = CARE_PACKAGE_LIFETIME, float waitTime = CARE_PACKAGE_WAITTIME )
{
	ExtraSpawner_SpawnCarePackage( pos, rot, CarePackage_RefillAmmo, "補充彈藥", lifeTime, waitTime )
}

void function ExtraSpawner_SpawnCarePackage( vector pos, vector rot, useFunction, string usePrompt, float lifeTime, float waitTime )
{
	//thread DropWeaponAlert( pos, 500, 200 )
	thread CarePackage_SpawnPoint( pos, waitTime + 5 ) // care package takes 5s to drop
	thread ExtraSpawner_SpawnCarePackage_Threaded( pos, rot, useFunction, usePrompt, lifeTime, waitTime )
}

void function ExtraSpawner_SpawnCarePackage_Threaded( vector pos, vector rot, useFunction, string usePrompt, float lifeTime, float waitTime )
{
	wait waitTime

	entity pod = CreateDropPod( pos, <0,0,0> )
	pod.EndSignal( "OnDestroy" )
	Highlight_SetOwnedHighlight( pod, "friendly_ai" )

	//InitFireteamDropPod( pod )

	// it takes 5s to drop
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )
	file.carePackageUsedPlayers.clear() // clean up care package wave

	pod.SetUsable()
	pod.SetUsableByGroup( "pilot" )
	pod.SetUsePrompts( "按住 %use% 以" + usePrompt, "按下 %use% 以" + usePrompt )
	AddCallback_OnUseEntity( pod, useFunction )

	HighlightDropPod( pod )
	pod.SetModel( CAREPACKAGE_MODEL )
    
    wait lifeTime

	//pod.Destroy()
	pod.UnsetUsable() // don't let dissolving pod able to be used
	pod.NotSolid() // clear collision
	DisableDropPodHighlight( pod )
	pod.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
	EmitSoundAtPosition( TEAM_UNASSIGNED, pod.GetOrigin(), "droppod_dissolve" )
}

void function AddEntityCallback_OnUseCarePackage( entity ent, void functionref( entity ent, entity package ) callbackFunc )
{
	if ( !( ent in file.entityCarePackageUsedCallbacks ) )
		file.entityCarePackageUsedCallbacks[ ent ] <- []
	if ( !file.entityCarePackageUsedCallbacks[ ent ].contains( callbackFunc ) )
		file.entityCarePackageUsedCallbacks[ ent ].append( callbackFunc )
}

void function RemoveEntityCallback_OnUseCarePackage( entity ent, void functionref( entity ent, entity package ) callbackFunc )
{
	if ( !( ent in file.entityCarePackageUsedCallbacks ) )
		return
	if ( file.entityCarePackageUsedCallbacks[ ent ].contains( callbackFunc ) )
		file.entityCarePackageUsedCallbacks[ ent ].removebyvalue( callbackFunc )
}

void function RunEntityCallbacks_OnUseCarePackage( entity ent, entity package )
{
	if ( !( ent in file.entityCarePackageUsedCallbacks ) )
		return

	foreach ( callbackFunc in file.entityCarePackageUsedCallbacks[ ent ] )
		callbackFunc( ent, package )
}

// copied from cl_replacement_titan_hud.gnut
void function CarePackage_SpawnPoint( vector origin, float impactTime )
{
	array<entity> targetEffects = []
	vector surfaceNormal = < 0, 0, 1 >

	int index = GetParticleSystemIndex( $"P_ar_titan_droppoint" )

	entity targetEffect = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
	EffectSetControlPointVector( targetEffect, 1, < 0,190,0 > ) // green
	targetEffect.DisableHibernation()

	wait impactTime

	if ( IsValid( targetEffect ) )
		EffectStop( targetEffect )
}

bool function TryCarePackageMessageToPlayer( entity player, string message, bool ignoreTimeLimit = false )
{
	if ( !ignoreTimeLimit )
	{
		float nextMessageAllowedTime = file.playerLastCarePackageNotifiedTime[ player ] + CARE_PACKAGE_MESSAGE_INTERVAL
		if ( nextMessageAllowedTime > Time() )
			return false
	}

	SendHudMessage( player, message, -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1 )
	file.playerLastCarePackageNotifiedTime[ player ] = Time()
	return true
}

function CarePackage_GiveWeapon( pod , player )
{
	expect entity( pod )
	expect entity( player )
	vector pos = player.GetOrigin()

	if( file.carePackageUsedPlayers.contains( player ) )
	{
		//TryCarePackageMessageToPlayer( player, "Once Robbed Weapon from Care Package\nPlease Wait for Next Delivery" )
		TryCarePackageMessageToPlayer( player, "已獲取本次補給艙\n請等待下一輪" )
		return
	}

    //DropModdedWeapons( WEAPONS, pos, MODS )
	if( player.GetMainWeapons().len() == 3 )
		player.DropWeapon( player.GetMainWeapons()[2] ) // was [1], for the newest version, drop the grenadier!
	//GiveModdedWeapons( player, WEAPONS, MODS )
	GiveModdedWeapons( player, file.carePackageWeapons )
	RestorePlayerAmmo( player )

    //TryCarePackageMessageToPlayer( player, "Got Weapon from Care Package", true )
    TryCarePackageMessageToPlayer( player, "已從補給艙獲取武器", true ) // ignore message timer

	file.carePackageUsedPlayers.append( player )
	player.Signal( "PlayerUsedCarePackage" )

	// Added via AddEntityCallback_OnUseCarePackage()
	RunEntityCallbacks_OnUseCarePackage( player, pod )
}

// now allowing every weapon to have a custom mod
void function GiveModdedWeapons( entity player, array<string> weapons )
{
	string weaponName = weapons[ RandomInt(weapons.len()) ]
	array<string> mods = []
	if ( weaponName in file.carePackageWeaponMods )
		mods = file.carePackageWeaponMods[weaponName]
	player.GiveWeapon( weaponName, mods )
	player.SetActiveWeaponByName( weaponName )
}

function CarePackage_RefillAmmo( pod , player )
{
	expect entity( pod )
	expect entity( player )

	if( file.carePackageUsedPlayers.contains( player ) )
	{
		//TryCarePackageMessageToPlayer( player, "Once Refilled Ammo from Care Package\nPlease Wait for Next Delivery" )
		TryCarePackageMessageToPlayer( player, "已獲取本次補給艙\n請等待下一輪" )
		return
	}

	RestorePlayerAmmo( player )
    //TryCarePackageMessageToPlayer( player, "Got Weapon Ammo from Care Package", true )
    TryCarePackageMessageToPlayer( player, "已從補給艙補充彈藥", true ) // ignore message timer

	file.carePackageUsedPlayers.append( player )
	player.Signal( "PlayerUsedCarePackage" )

	// Added via AddEntityCallback_OnUseCarePackage()
	RunEntityCallbacks_OnUseCarePackage( player, pod )
}

void function RestorePlayerAmmo( entity player )
{
	player.SetSuitGrapplePower( 100.0 ) // restore grapple power

	// main weapons
	foreach( entity mainWeapon in player.GetMainWeapons() )
	{
		// this will restore anti-titan's ammo
		try // should do a try-catch for safely adding other classes. no charge-based weapon compatiblity
		{
			// use weapon.GetWeaponSettingInt( eWeaponVar.ammo_stockpile_max ) to get max ammo
			// restore 3 mags version
			int maxAmmo = mainWeapon.GetWeaponSettingInt( eWeaponVar.ammo_stockpile_max )
			/*
			int currentAmmo = mainWeapon.GetWeaponPrimaryAmmoCount()
			int clipAmmo = mainWeapon.GetWeaponPrimaryClipCountMax()
			const float clipsToRestore = 3
			mainWeapon.SetWeaponPrimaryAmmoCount( minint( currentAmmo + ( clipAmmo * clipsToRestore ), maxAmmo ) )
			*/

			// updated, restore all ammo
			//mainWeapon.SetWeaponPrimaryAmmoCount( 9999 )
			mainWeapon.SetWeaponPrimaryAmmoCount( maxAmmo )
		}
		catch(ex){}

		// restore current weapon's clip
		// removed, working weird on large clip weapons and reloading weapons
		/*
		try
		{ 
			mainWeapon.SetWeaponPrimaryClipCount( mainWeapon.GetWeaponPrimaryClipCountMax() ) 
		}
		catch(ex1){}
		*/
	}
	// offhand weapons
	foreach( entity offhand in player.GetOffhandWeapons() )
	{
		// this will restore ordnances
		try // should do a try-catch for safely adding other classes. no charge-based weapon compatiblity
		{
			offhand.SetWeaponPrimaryClipCount( offhand.GetWeaponPrimaryClipCountMax() )
		}
		catch(ex){}
	}
}

void function HighlightWeaponAmped( entity weapon )
{
	if ( weapon.IsLoadoutPickup() )
	{
		Highlight_SetOwnedHighlight( weapon, "sp_loadout_pickup" )
		Highlight_SetNeutralHighlight( weapon, "sp_loadout_pickup" )
	}
	else
	{
		Highlight_SetOwnedHighlight( weapon, "enemy_boss_bounty" )
		Highlight_SetNeutralHighlight( weapon, "enemy_boss_bounty" )
	}
}

void function HighlightDropPod( entity pod )
{
	Highlight_SetOwnedHighlight( pod, "enemy_boss_bounty" )
	Highlight_SetNeutralHighlight( pod, "enemy_boss_bounty" )
}

void function DisableDropPodHighlight( entity pod )
{
	Highlight_ClearOwnedHighlight( pod )
	Highlight_ClearNeutralHighlight( pod )
}

const float REAPER_WARPFALL_DELAY = 4.7 // same as fd does
void function ExtraSpawner_SpawnReaperCanLaunchTicks( vector pos, vector rot, int team, string reaperSettings = "npc_super_spectre_aitdm", string tickSettings = "npc_frag_drone" )
{
	// nessie fix
	float reaperLandTime = REAPER_WARPFALL_DELAY + 1.2 // reaper takes ~1.2s to warpfall
	thread HotDrop_Spawnpoint( pos, team, reaperLandTime, true, damagedef_reaper_fall ) // add friendly warning for this special kind of reaper

	wait REAPER_WARPFALL_DELAY
	entity reaper = CreateSuperSpectre( team, pos, rot )
	reaper.EndSignal( "OnDestroy" )

	// setup spawn
	SetSpawnOption_Warpfall( reaper )
	SetSpawnOption_AISettings( reaper, reaperSettings )
	// make squad so we can identify their tick's spawn source
	string squad = ExtraSpawner_MakeMarkedSquadName( team, UniqueString( "_drone_spawn_reaper" ) )
	SetSpawnOption_SquadName( reaper, squad )
	
	HideName( reaper ) // prevent flash a name onto it
	//local collisionGroup = reaper.kv.CollisionGroup
	local visibilityFlags = reaper.kv.VisibilityFlags
	//reaper.kv.CollisionGroup = 0 // to prevent crosshair detecting it and turns to red/blue( don't really work though )
	//reaper.NotSolid()
	reaper.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY // prevent it's model light shows up

	ExtraSpawner_SetUpSpawnedNPC( reaper ) // generic setup for any npc in this file
	DispatchSpawn( reaper )
	//reaper.kv.CollisionGroup = collisionGroup // restore collision
	//reaper.Solid() // restore crosshair color on aiming at
	reaper.kv.VisibilityFlags = visibilityFlags // restore visibility after warpfall starts in spawncallbacks

	// fake a spawntime to delay replay tracking, hide it's spawn
	reaper.ai.spawnTime = Time() + 0.5

	// reaper highlight
	// sp_enemy_pilot kinda bad, visible through viewmodel
	//Highlight_SetFriendlyHighlight( reaper, "sp_enemy_pilot" )
	Highlight_SetFriendlyHighlight( reaper, "sp_friendly_pilot" ) // vanilla seems using this
	reaper.Highlight_SetParam( 1, 0, HIGHLIGHT_COLOR_FRIENDLY )
	
	reaper.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
	SetDefaultMPEnemyHighlight( reaper )

	// use modified functions in _ai_superspectre.gnut, extremely powerful reaper: they do nuke on death
	ExtraSpawner_SetUpNukeDeathReaper( reaper )

	// reaper handler
	if ( GetNPCHandlerForClass( "npc_super_spectre" ) != null )
		thread GetNPCHandlerForClass( "npc_super_spectre" )( reaper )
	
	// some FD reaper behavior
	reaper.SetAllowSpecialJump( true ) // don't know what this can do, just adding here
	// don't work for reapers. special icon is setup by client-side ClGamemodeFD_Init(), can't use serverside to do that
	//reaper.Minimap_SetObjectScale( 2.0 ) // bigger than normal infantry minimap icon

	reaper.WaitSignal( "WarpfallComplete" )
	ShowName( reaper ) // show name again after drop

	// non-fd mode don't support stational point, write my own one
	//thread ReaperMinionLauncherThink( reaper, tickSettings ) 
	thread ExtraSpawner_ReaperTickLaunchThink( reaper, tickSettings )
}

void function ExtraSpawner_SetUpNukeDeathReaper( entity reaper )
{
	// use modified functions in _ai_superspectre.gnut, extremely powerful reaper: they do nuke on death
	SuperSpectre_AddNukeDeath( reaper ) // force this reaper to nuke on death without having to change aisettings
	SuperSpectre_SetDoNukeBeforeDeath( reaper, true ) // do nuke before actual death, so their highlight and title stuffs won't be removed

	//SuperSpectre_SetDropBatteryOnDeath( reaper, true ) // now supports mp. since they're very powerful, give some reward?
	SuperSpectre_SetNukeDeathThreshold( reaper, 8000 ) // they'll always try to nuke unless taken a damage higher than this value( only NPC nuke can do this )
	SuperSpectre_SetForcedKilledByTitans( reaper, false ) // they won't be disarmed by titans, always try to nuke
	SuperSpectre_SetSelfAsNukeAttacker( reaper, true ) // the nuke's attacker will always be the reaper
	
	SuperSpectre_SetNukeExplosionDamageEffect( 
		reaper, 		// current reaper
		5, 				// explosion count
		0.8, 			// explosion duration, end the nuke before reaper gets destroyed, so it won't deal friendly fire
		85, 			// damage
		700, 			// damage heavy armor
		330, 			// inner radius
		430, 			// outer radius
		SF_ENVEXPLOSION_MASK_BRUSHONLY,		// explosion flags
		50000,			// explosion force
		DF_RAGDOLL | DF_EXPLOSION			// script damage flags
	)

	// tick spawn
	SuperSpectre_SetSpawnerTickExplodeOnOwnerDeath( reaper, true ) // clean up their ticks using a modified way
	//SuperSpectre_SetSpawnerTickMaxCount( reaper, 8 ) // spawn 8 ticks per reaper

	// visual misc
	SuperSpectre_SetDoBodyGroupUpdateOnDamage( reaper, true ) // vanilla removed feature turns to settings: update bodygroup to doomed state( like MP titans ) if taking enough damage
}

void function ExtraSpawner_ReaperTickLaunchThink( entity reaper, string tickType )
{
	// modified: defensive fix for sometimes reaper already entered nuke and we're calling this function
	if ( SuperSpectre_IsReaperDoingNukeSequence( reaper ) )
		return
	//

	reaper.EndSignal( "OnDeath" )
	reaper.EndSignal( "StartedNukeSequence" ) // modified signal: end this thread if reaper has started nuke sequence while still alive

	wait 10 // startup time
	bool lastLaunchSucceeded = false // if we succeeded at last launch, we wait a longer time before next launch
	while ( true )
	{
		if ( lastLaunchSucceeded ) // succeeded launch
		{
			lastLaunchSucceeded = false
			wait RandomFloatRange( 25.0, 40.0 ) // every 25 - 40 secs try to do a tickLaunch, simple right?
		}
		WaitFrame() // keep letting them launch!

		//printt( reaper,"REAPER TICK LAUNCH:", reaper.GetOrigin() )
		waitthread Reaper_LaunchFragDrone_Think( reaper, tickType )
		//printt( reaper,"REAPER END TICK LAUNCH:", reaper.GetOrigin() )
		if ( GetScriptManagedEntArrayLen( reaper.ai.activeMinionEntArrayID ) >= 1 ) // at least launched one tick
			lastLaunchSucceeded = true // mark as succeeded
		while ( GetScriptManagedEntArrayLen( reaper.ai.activeMinionEntArrayID ) > 2 )
			WaitFrame()
	}
}

// Same as SquadHandler, just for reapers
void function ExtraSpawner_ReaperHandler( entity reaper )
{
	reaper.EndSignal( "OnDestroy" )
	reaper.EndSignal( "OnDeath" )
	// Signals for controlling
	reaper.Signal( "StopDefaultHandler" )
	reaper.EndSignal( "StopDefaultHandler" )

	int team = reaper.GetTeam()
	array<entity> points

	// show on enemy radar
	//AddMinimapForNPC( reaper )
	// welp here's one for fun: use prop script icon and bind it with reaper, hide reaper's basic map icon
	entity mapIcon = CreatePropScriptAsFakeMapIconForNPC( reaper, "ORIGIN", eMinimapObject_prop_script.FW_BUILDSITE )
	//mapIcon.Minimap_SetObjectScale( 0.5 ) // don't work though

	// wait for warpfall
	reaper.WaitSignal( "WarpfallComplete" )
	reaper.AssaultSetGoalRadius( 500 ) // goal radius

	wait 3 // initial wait before reapers do startup animation
	
	// Every 10 - 20 secs get a closest target and go to them
	while( true )
	{
		WaitFrame() // always wait before each loop!

		// check leechable
		if ( reaper.GetTeam() != team )
			return

		points = [] // clean up last points
		array<entity> pointsToSearch = []
		// try to find from npc targets
		pointsToSearch.extend( GetNPCArrayOfEnemies( team ) )
		// try to find from alive player targets
		pointsToSearch.extend( GetPlayerArrayOfEnemies_Alive( team ) )

		// we mostly search for heavy armor targets
		// if there're no valid targets, we use all targets instead
		points = FindNPCAssaultHeavyArmorTargets_FailSafeToAllTargets( pointsToSearch )

		ArrayRemoveDead( points ) // remove dead targets
		if ( points.len() == 0 )
			continue

		entity enemy = GetClosest2D( points, reaper.GetOrigin() )
		if ( !IsValid( enemy ) )
			continue
		vector ornull clampedPos = NavMesh_ClampPointForAI( enemy.GetOrigin(), reaper )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )
		reaper.AssaultPoint( clampedPos )

		// remove random wait to make them more aggresive?
		// never do it. too many assault point can make them move really silly
		wait RandomFloatRange( 10.0, 20.0 )
	}
}

// welp this works pretty bad, because spawned npc still have collision with current npc
// to avoid that... try to set this npc to very high into sky, handled by parameter "offset"
// welp that doesn't work well either, attachments are always rotating
// temp find a solution is that we rotate npc to make them upside down, and add very little offset
entity function CreateNPCAsFakeMapIconForNPC( entity npc, string fakeIconNPCClass, string attachment = "ORIGIN", vector angles = < 0, 0, 180 >, vector offset = < 0, 0, -30 > )
{
	entity mapIconNPC = CreateEntity( fakeIconNPCClass )
	mapIconNPC.Freeze() // don't let it do anything

	DispatchSpawn( mapIconNPC )
	TakeAllWeapons( mapIconNPC )

	// handle invulnerablility and freeze inside function
	// this also disables trigger checks and make npc take less CPU load
	ExtraSpawner_DisableSensingForNPC( mapIconNPC, true, false, true )
	// manually handle hide
	mapIconNPC.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY // this can hide model light fx
	mapIconNPC.Hide()
	HideName( mapIconNPC )

	mapIconNPC.SetOwner( npc ) // disable collision against owner, but not good enough
	mapIconNPC.SetParent( npc, attachment )
	mapIconNPC.SetAngles( angles ) // face to ground
	mapIconNPC.SetOrigin( offset ) // so nobody can see them
	mapIconNPC.NotSolid()
	mapIconNPC.kv.CollisionGroup = 0
	mapIconNPC.kv.solid = SOLID_HITBOXES // seems this can make them stop collide with other entity?
	mapIconNPC.StopPhysics()

	SetNPCFakeMinimapIconEnt( npc, mapIconNPC ) // make them related, so Add/RemoveMinimapForNPC() can handle both

	// map
	SetUpGenericNPCMiniMapIcon( mapIconNPC )
	mapIconNPC.Minimap_SetClampToEdge( false ) // npc icon shouldn't clamp
	//mapIconNPC.Minimap_SetHeightTracking( false ) // disable height tracking because they're always underground

	thread TrackNPCLifeTimeForMapIconNPC( mapIconNPC, npc )

	return mapIconNPC
}

void function TrackNPCLifeTimeForMapIconNPC( entity mapIconNPC, entity npc )
{
	mapIconNPC.EndSignal( "OnDestroy" )

	while ( true )
	{
		if ( !IsValid( npc ) ) // by default npc will cleanup it's parent on destroy
			break
		
		// keep updating team
		if ( mapIconNPC.GetTeam() != npc.GetTeam() )
			SetTeam( mapIconNPC, npc.GetTeam() )
		
		// debug
		//GetPlayerArray()[0].SetOrigin( mapIconNPC.GetOrigin() )
		
		WaitFrame()
	}
	mapIconNPC.Destroy()
}

entity function CreatePropScriptAsFakeMapIconForNPC( entity npc, string attachment = "REF", int minimapStateId = eMinimapObject_prop_script.DEFAULT )
{
	entity mapIcon = CreatePropScript( $"models/dev/empty_model.mdl" )
	mapIcon.NotSolid()
	mapIcon.kv.fadedist = 10000 // try not to fade
	mapIcon.DisableHibernation()
	mapIcon.SetOwner( npc ) // sometimes ownership is required
	mapIcon.SetParent( npc, attachment )

	SetNPCFakeMinimapIconEnt( npc, mapIcon ) // make them related, so Add/RemoveMinimapForNPC() can handle both

	// map
	SetUpGenericNPCMiniMapIcon( mapIcon )
	mapIcon.Minimap_SetCustomState( minimapStateId )
	mapIcon.Minimap_SetClampToEdge( false ) // npc icon shouldn't clamp

	thread TrackNPCLifeTimeForMapIconProp( mapIcon, npc )

	return mapIcon
}

void function TrackNPCLifeTimeForMapIconProp( entity mapIcon, entity npc )
{
	mapIcon.EndSignal( "OnDestroy" )

	while ( true )
	{
		if ( !IsValid( npc ) ) // by default npc will cleanup it's parent on destroy
			break
		
		// keep updating team
		if ( mapIcon.GetTeam() != npc.GetTeam() )
			SetTeam( mapIcon, npc.GetTeam() )
		
		WaitFrame()
	}
	mapIcon.Destroy()
}

entity function GetNPCFakeMinimapIconEnt( entity npc )
{
	if ( !( npc in file.npcOwnedFakeMapIconEnt ) )
		return null

	return file.npcOwnedFakeMapIconEnt[ npc ]
}

void function SetNPCFakeMinimapIconEnt( entity npc, entity mapIcon )
{
	if ( !( npc in file.npcOwnedFakeMapIconEnt ) )
		file.npcOwnedFakeMapIconEnt[ npc ] <- null // init

	file.npcOwnedFakeMapIconEnt[ npc ] = mapIcon
}

entity function GetFakeMinimapIconOwner( entity mapIcon )
{
	bool mapIconRegistered = false
	foreach ( npc, otherMapIcon in file.npcOwnedFakeMapIconEnt )
	{
		if ( otherMapIcon == mapIcon )
		{
			mapIconRegistered = true
			break
		}
	}
	// if we can't find this mapIcon entity from table, just return null
	if ( !mapIconRegistered )
		return null
	
	return mapIcon.GetOwner()
}