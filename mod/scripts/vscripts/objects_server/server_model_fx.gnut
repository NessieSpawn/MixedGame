// vanilla don't implement model FX for some entities
// do a server-side fix for them, may cause performance issue but I don't care
// NOTE: health and bodygroup restore checks won't work for now, other things do working fine

global function ServerSide_ModelFX_Init

// debug
const bool SERVER_MODEL_FX_DEBUG = false
const bool SERVER_MODEL_FX_OVERRIDE_DEBUG = false
const bool SERVER_MODEL_REGENERATING_FX_DEBUG = false

// model health fx, simplifed version
global function ServerModelHealthFX_Register
global function ServerModelHealthFX_SetUpForEntity
global function ServerModelHealthFX_CleanUpForEntity

// model fx data, similar to respawn's client-side registering
global function ServerModelFXData_Register
global function ServerModelFXData_AddSpawnFX
global function ServerModelFXData_AddHealthFX
global function ServerModelFXData_SetUpForEntity
global function ServerModelFXData_CleanUpForEntity

// model bodygroup fx 
// this one isn't very accurate compare to model fxs, as it uses only looping case for handling, but is good enough for titan doom cases
global function ServerModelBodyGroupFX_Register
global function ServerModelBodyGroupFX_SetUpForEntity
global function ServerModelBodyGroupFX_CleanUpForEntity

struct ModelHealthFXStruct
{
    float healthFrac
    string attachment
    asset effectName

    bool attachToEnt
    bool loopEffect
    int visibilityFlags

    // HACK for titans
    float doomedHealthFrac

    int index // only exists in this file
}

struct EntOwnedHealthFX
{
    entity effect
    float healthFrac

    // HACK for titans
    bool checkDoomedHealth = false

    int defaultVisibilityFlags
}

struct ModelFXDataStruct_Spawn
{
    string attachment
    asset effectName
    int visibilityFlags

    int index // only exists in this file
}

struct EntOwnedModelFXData_Spawn
{
    entity effect

    int defaultVisibilityFlags
}

struct ModelFXDataStruct_Health
{
    float healthFrac
    string attachment
    asset effectName
    bool overrideEffectsWithSameAttachment
    bool removeOnHealthRestore

    bool attachToEnt
    bool loopEffect
    int visibilityFlags

    // HACK for titans
    float doomedHealthFrac

    int index // only exists in this file
}

struct EntOwnedModelFXData_Health
{
    string dataName

    entity effect
    float healthFrac
    string attachment
    
    // HACK for titans
    bool checkDoomedHealth = false

    int defaultVisibilityFlags
}

struct ModelBodyGroupFXStruct
{
    string bodyGroupName
    int stateIndex
    string attachment
    asset effectName

    bool attachToEnt
    bool loopEffect
    int visibilityFlags

    string sound

    // regenerating effect: never loops, but regenerate after delay
    bool regenerateEffect
    float firstGenerateDelay
    float regenerateRandomWaitMin
    float regenerateRandomWaitMax

    int index // only exists in this file
}

struct EntOwnedBodyGroupFX
{
    entity effect
    string bodyGroupName
    int stateIndex
    bool regenerateEffect = false

    int defaultVisibilityFlags
}

struct
{
    int registeredIndex

    // registering table
    table< asset, array<ModelHealthFXStruct> > registeredModelHealthFXTable

    table< asset, table< string, array<ModelFXDataStruct_Spawn> > > registeredModelFXData_Spawn
    table< asset, table< string, array<ModelFXDataStruct_Health> > > registeredModelFXData_Health

    table< asset, array<ModelBodyGroupFXStruct> > registeredModelBodyGroupFXTable

    // in-file table
    table<entity, bool> entHasSetUpServerModelHealthFX
    table< entity, table<int, EntOwnedHealthFX> > entOwnedModelHealthFXs

    table<entity, bool> entHasSetUpServerModelFXData
    table< entity, table<int, EntOwnedModelFXData_Spawn> > entOwnedModelSpawnFXsFromData
    table< entity, table<int, EntOwnedModelFXData_Health> > entOwnedModelHealthFXsFromData

    table<entity, bool> entHasSetUpServerModelBodyGroupFX
    table< entity, table<int, EntOwnedBodyGroupFX> > entOwnedModelBodyGroupFXs
    table<entity, bool> entIsRegeneratingEffectHelper
    table<entity, bool> regeneratingEffectHelperIsHidden
} file

void function ServerSide_ModelFX_Init()
{
    RegisterSignal( "ModelHealthFX_OwnerTracking" )
    RegisterSignal( "ModelFXData_OwnerTracking" )
    RegisterSignal( "ModelBodyGroupFX_OwnerTracking" )
    // HACK for titans
    AddSoulDeathCallback( OnSoulDeath )
    AddCallback_OnPilotBecomesTitan( OnPilotBecomesTitan )
	AddCallback_OnTitanBecomesPilot( OnTitanBecomesPilot )
}

// HACK for titans: use soul entity for storing everything
// as PilotBecomesTitan() transfers parents
void function OnSoulDeath( entity soul, var damageInfo )
{
    // clean up effects
    if ( soul in file.entHasSetUpServerModelHealthFX )
        ServerModelHealthFX_RemoveEffectsOnEntity( soul )
    if ( soul in file.entHasSetUpServerModelFXData )
    {
        ServerModelFXData_RemoveSpawnFXOnEntity( soul )
        ServerModelFXData_RemoveHealthFXOnEntity( soul )
    }
    if ( soul in file.entHasSetUpServerModelBodyGroupFX )
        ServerModelBodyGroupFX_RemoveEffectsOnEntity( soul, true )
}

void function OnPilotBecomesTitan( entity player, entity titan )
{
    entity soul = player.GetTitanSoul() // soul has been transferred
    if ( !IsValid( soul ) )
        return

    // update callbacks
    if ( soul in file.entHasSetUpServerModelHealthFX )
        AddEntityCallback_OnPostDamaged( player, ServerModelHealthFX_OnEntPostDamage )
    if ( soul in file.entHasSetUpServerModelFXData )
        AddEntityCallback_OnPostDamaged( player, ServerModelFXData_OnEntPostDamage )
    
    // update effects ownership
    if ( soul in file.entOwnedModelHealthFXs )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXs[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( player )
        }
    }
    if ( soul in file.entOwnedModelSpawnFXsFromData )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelSpawnFXsFromData[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( player )
        }
    }
    if ( soul in file.entOwnedModelHealthFXsFromData )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXsFromData[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( player )
        }
    }
    if ( soul in file.entOwnedModelBodyGroupFXs )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelBodyGroupFXs[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( player )
        }
    }
}

void function OnTitanBecomesPilot( entity player, entity titan )
{
    entity soul = titan.GetTitanSoul() // soul has been transferred
    //print( "soul: " + string( soul ) )
    if ( !IsValid( soul ) )
        return

    // update callbacks
    if ( soul in file.entHasSetUpServerModelHealthFX )
    {
        RemoveEntityCallback_OnPostDamaged( player, ServerModelHealthFX_OnEntPostDamage )
        AddEntityCallback_OnPostDamaged( titan, ServerModelHealthFX_OnEntPostDamage )
    }
    if ( soul in file.entHasSetUpServerModelFXData )
    {
        RemoveEntityCallback_OnPostDamaged( player, ServerModelFXData_OnEntPostDamage )
        AddEntityCallback_OnPostDamaged( titan, ServerModelFXData_OnEntPostDamage )
    }

    // update effects ownership
    // seems not working fine.
    // player still can't see effects on their titan after disembarking once, but others could
    // guess it's alright? at least player won't be blinded by too many effects
    // the best method is we re-create effects like client-side does, but whatever
    /*
    if ( soul in file.entOwnedModelHealthFXs )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXs[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( titan )
        }
    }
    if ( soul in file.entOwnedModelSpawnFXsFromData )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelSpawnFXsFromData[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( titan )
        }
    }
    if ( soul in file.entOwnedModelHealthFXsFromData )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXsFromData[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( titan )
        }
    }
    if ( soul in file.entOwnedModelBodyGroupFXs )
    {
        foreach ( index, ownedFXStruct in file.entOwnedModelBodyGroupFXs[ soul ] )
        {
            entity effect = ownedFXStruct.effect
            if ( IsValid( effect ) )
                effect.SetOwner( titan )
        }
    }
    */

    // now try to re-create effects... hopefully it won't cause server performance issue( creating too many entities sometimes freeze server )
    if ( soul in file.entHasSetUpServerModelHealthFX )
    {
        ServerModelHealthFX_ReCreateActiveEffectsOnEntity( titan )
    }
    if ( soul in file.entHasSetUpServerModelFXData )
    {
        ServerModelFXData_ReCreateActiveSpawnFXOnEntity( titan )
        ServerModelFXData_ReCreateActiveHealthFXOnEntity( titan )
    }
    if ( soul in file.entHasSetUpServerModelBodyGroupFX )
    {
        ServerModelBodyGroupFX_ReCreateActiveEffectsOnEntity( titan )
    }
}
//

entity function CreateModelFXOnEnt( entity ent, asset effectName, string attachment, bool attachToEnt = false, bool loopEffect = false, int visibilityFlags = ENTITY_VISIBLE_TO_EVERYONE, bool immediateDestroy = true )
{
    int attachID = ent.LookupAttachment( attachment )
    // anti-crash
    if ( attachID <= 0 )
        return
    
    entity effect
    if ( attachToEnt )
    {
        if ( loopEffect )
            effect = PlayLoopFXOnEntity( effectName, ent, attachment )
        else
            effect = PlayFXOnEntity( effectName, ent, attachment )
    }
    else
    {
        vector angs = ent.GetAttachmentAngles( attachID )
        vector pos = ent.GetAttachmentOrigin( attachID )
        if ( loopEffect )
            effect = PlayLoopFX( effectName, pos, angs )
        else
            effect = PlayFX( effectName, pos, angs )
    }
    effect.SetOwner( ent )
    effect.kv.VisibilityFlags = visibilityFlags
    if ( immediateDestroy ) // seems client-side effects always do so, though not looking well
        effect.SetStopType( "DestroyImmediately" )
    effect.DisableHibernation()

    return effect
}

entity function CreateRegeneratingModelFXOnEnt_ReturnPlaceHelper( entity ent, asset effectName, string attachment, bool attachToEnt, int visibilityFlags, string sound, float firstDelay, float randomWaitMin, float randomWaitMax )
{
    entity placeHelper = CreateEntity( "info_placement_helper" )
    file.entIsRegeneratingEffectHelper[ placeHelper ] <- true
    file.regeneratingEffectHelperIsHidden[ placeHelper ] <- false
    // track placement helper destroy to stop think
    thread RegeneratingModelFXThink( ent, placeHelper, effectName, attachment, attachToEnt, visibilityFlags, sound, firstDelay, randomWaitMin, randomWaitMax )

    return placeHelper
}

void function RegeneratingModelFXThink( entity ent, entity placeHelper, asset effectName, string attachment, bool attachToEnt, int visibilityFlags, string sound, float firstDelay, float randomWaitMin, float randomWaitMax )
{
    ent.EndSignal( "OnDestroy" )
    placeHelper.EndSignal( "OnDestroy" )
    wait firstDelay

    entity effect

    OnThreadEnd
    (
        function(): ( effect )
        {
            if ( IsValid( effect ) )
                EffectStop( effect )
        }
    )

    while ( true )
    {
        if ( IsValid( effect ) )
        {
            EffectStop( effect )
            effect = null
        }

        int attachID = ent.LookupAttachment( attachment )
        // anti-crash
        if ( attachID <= 0 )
        {
            WaitFrame()
            continue
        }

        // we may want to hide the effect
        if ( file.regeneratingEffectHelperIsHidden[ placeHelper ] )
        {
            wait RandomFloatRange( randomWaitMin, randomWaitMax )
            continue
        }

        if ( attachToEnt )
            effect = PlayFXOnEntity( effectName, ent, attachment )
        else
        {
            vector angs = ent.GetAttachmentAngles( attachID )
            vector pos = ent.GetAttachmentOrigin( attachID )
            effect = PlayFX( effectName, pos, angs )
        }
        effect.SetOwner( ent )
        effect.kv.VisibilityFlags = visibilityFlags
        effect.DisableHibernation()
        if ( sound != "" )
            EmitSoundOnEntity( ent, sound )

        wait RandomFloatRange( randomWaitMin, randomWaitMax )
    }
}

void function HideRegeneratingEffect( entity placeHelper )
{
    if ( placeHelper in file.entIsRegeneratingEffectHelper )
        file.regeneratingEffectHelperIsHidden[ placeHelper ] = true
}

void function ShowRegeneratingEffect( entity placeHelper )
{
    if ( placeHelper in file.entIsRegeneratingEffectHelper )
        file.regeneratingEffectHelperIsHidden[ placeHelper ] = false
}

void function ServerModelHealthFX_Register( asset modelName, float healthFrac, string attachment, asset effectName, bool attachToEnt = false, bool loopEffect = false, int visibilityFlags = ENTITY_VISIBLE_TO_EVERYONE, float doomedHealthFrac = -1 )
{
    if ( !( modelName in file.registeredModelHealthFXTable ) )
        file.registeredModelHealthFXTable[ modelName ] <- []

    ModelHealthFXStruct newEffect
    newEffect.healthFrac = healthFrac
    newEffect.attachment = attachment
    newEffect.healthFrac = healthFrac
    newEffect.effectName = effectName
    newEffect.attachToEnt = attachToEnt
    newEffect.loopEffect = loopEffect
    newEffect.visibilityFlags = visibilityFlags
    newEffect.doomedHealthFrac = doomedHealthFrac
    file.registeredModelHealthFXTable[ modelName ].append( newEffect )

    // setup unique index
    newEffect.index = file.registeredIndex
    file.registeredIndex++
}

void function ServerModelHealthFX_SetUpForEntity( entity ent, bool trackHealthRestore = false )
{
    // HACK for titans: use soul entity for storing everything
    // as PilotBecomesTitan() transfers parents
    if ( ent.IsTitan() )
    {
        ent = ent.GetTitanSoul()
        if ( !IsValid( ent ) )
            return
    }

    if ( ent in file.entHasSetUpServerModelHealthFX ) // don't allow setup multiple times
        return
    file.entHasSetUpServerModelHealthFX[ ent ] <- true
    
    ServerModelHealthFX_ApplyEffectsToEntity( ent )
    // HACK for titans
    if ( IsSoul( ent ) )
    {
        entity titan = ent.GetTitan()
        if ( IsValid( titan ) )
            AddEntityCallback_OnPostDamaged( titan, ServerModelHealthFX_OnEntPostDamage )
    }
    else
        AddEntityCallback_OnPostDamaged( ent, ServerModelHealthFX_OnEntPostDamage )

    thread ModelHealthFX_OwnerTracking( ent, trackHealthRestore )
}

// clean up old effects and apply new ones once owner changed model
// track owner health update and do effects that we might miss upon their scripted health update
// add an option to stop played effect on entity health restore, mainly for titans
void function ModelHealthFX_OwnerTracking( entity ent, bool trackHealthRestore )
{
    ent.Signal( "ModelHealthFX_OwnerTracking" )
    ent.EndSignal( "ModelHealthFX_OwnerTracking" )
    ent.EndSignal( "OnDestroy" )

    asset lastTickModelName
    int lastTickHealth
    bool lastTickAlive
    bool lastTickPhaseShifted
    int lastTickVisibilityFlags
    bool effectsBeingSetToNobodyVisible

    // HACK for titans
    entity soul = IsSoul( ent ) ? ent : null
    entity lastTickTitan
    bool lastTickDoomed

    while ( true )
    {
        // HACK for titans
        lastTickTitan = null
        if ( IsValid( soul ) )
        {
            lastTickTitan = soul.GetTitan()
            if ( IsValid( lastTickTitan ) )
            {
                lastTickModelName = lastTickTitan.GetModelName()
                if ( IsAlive( lastTickTitan ) )
                    lastTickHealth = lastTickTitan.GetHealth()
                lastTickAlive = IsAlive( lastTickTitan )
                lastTickDoomed = GetDoomedState( lastTickTitan )
                lastTickPhaseShifted = lastTickTitan.IsPhaseShifted()
                lastTickVisibilityFlags = int( lastTickTitan.kv.VisibilityFlags )
            }
        }
        else
        {
            lastTickModelName = ent.GetModelName()
            if ( IsAlive( ent ) )
                lastTickHealth = ent.GetHealth()
            lastTickAlive = IsAlive( ent )
            lastTickPhaseShifted = ent.IsPhaseShifted()
            lastTickVisibilityFlags = int( ent.kv.VisibilityFlags )
        }
        
        WaitFrame()

        // HACK for titans
        if ( IsValid( soul ) )
        {
            ent = soul.GetTitan()
            if ( !IsValid( ent ) )
                continue
        }

        // phase shift check
        if ( ent.IsPhaseShifted() != lastTickPhaseShifted )
        {
            // starting phase shift
            if ( ent.IsPhaseShifted() )
            {
                // try to hide effect
                ServerModelHealthFX_UpdateEntEffectVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
            }
            else // exiting phase shift
            {
                // try to show effects again
                if ( !effectsBeingSetToNobodyVisible )
                    ServerModelHealthFX_UpdateEntEffectVisibility( ent, -1, false, true )
            }
        }

        // shifted check: don't do effect updates
        if ( ent.IsPhaseShifted() )
            continue

        // VisibilityFlags being changed
        if ( lastTickVisibilityFlags != int( ent.kv.VisibilityFlags ) )
        {
            // change to the visibility flag that will hide titan's model effects!
            if ( int( ent.kv.VisibilityFlags ) == ENTITY_VISIBLE_TO_NOBODY )
            {
                // try to update effect visibilityFlag
                ServerModelHealthFX_UpdateEntEffectVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
                effectsBeingSetToNobodyVisible = true
            }
            else if ( effectsBeingSetToNobodyVisible )
            {
                // try to show effects again
                ServerModelHealthFX_UpdateEntEffectVisibility( ent, -1, false, true )
                effectsBeingSetToNobodyVisible = false
            }
        }

        // model updated for some reason!
        if ( ent.GetModelName() != lastTickModelName )
        {
            // stop last model effects
            ServerModelHealthFX_RemoveEffectsOnEntity( ent )
            // apply effects for new model
            ServerModelHealthFX_ApplyEffectsToEntity( ent )
        }

        // lifestate checks
        // entity died this tick!
        if ( !IsAlive( ent ) && lastTickAlive )
        {
            // for players, stop any effect if they're dead
            if ( ent.IsPlayer() )
                ServerModelHealthFX_RemoveEffectsOnEntity( ent )
        }
        else if ( ent.IsPlayer() && IsAlive( ent ) && !lastTickAlive ) // player respawned!
        {
            // apply effects
            ServerModelHealthFX_ApplyEffectsToEntity( ent )
        }
        else if ( IsAlive( ent ) ) // never do health checks if ent is dead
        {
            // in case we changed health without taking damage
            bool updateEffects = lastTickHealth != ent.GetHealth()
            // titans check
            // update effects if we changed state
            if ( ent.IsTitan() && GetDoomedState( ent ) != lastTickDoomed )
                updateEffects = true
            if ( updateEffects )
                ServerModelHealthFX_ApplyEffectsToEntity( ent )

            if ( trackHealthRestore )
            {
                updateEffects = ent.GetHealth() > lastTickHealth
                if ( ent.IsTitan() && GetDoomedState( ent ) != lastTickDoomed )
                    updateEffects = true
                if ( updateEffects )
                {
                    // stop model effects those requirements is below our current health
                    ServerModelHealthFX_RemoveEffectsOnEntity( ent, true )
                }
            }
        }
    }
}

// main updating method
void function ServerModelHealthFX_OnEntPostDamage( entity ent, var damageInfo )
{
    if ( !( ent in file.entHasSetUpServerModelHealthFX ) ) // needs to be setup before we can call this think
        return

    ServerModelHealthFX_ApplyEffectsToEntity( ent, damageInfo )
}

// apply any valid effect to current entity
void function ServerModelHealthFX_ApplyEffectsToEntity( entity ent, var damageInfo = null )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelHealthFXTable ) )
        return

    foreach ( effectStruct in file.registeredModelHealthFXTable[ modelName ] )
    {
        float healthFracReq = effectStruct.healthFrac
        // HACK for titans
        bool checkDoomedHealth = ent.IsTitan() && GetDoomedState( ent )
        if ( checkDoomedHealth )
            healthFracReq = effectStruct.doomedHealthFrac
        float entHealthFrac = GetHealthFrac( ent )
        // if we passed an damageInfo inside, calculate entity health left after taking damage
        float entHealthFracAfterDamage
        if ( damageInfo != null )
        {
            entHealthFracAfterDamage = float( ent.GetHealth() - int( DamageInfo_GetDamage( damageInfo ) ) ) / float( ent.GetMaxHealth() )
            if ( entHealthFracAfterDamage > healthFracReq )
                continue
        }
        else
        {
            if ( entHealthFrac > healthFracReq )
                continue
        }

        bool attachToEnt = effectStruct.attachToEnt
        bool loopEffect = effectStruct.loopEffect
        // if effect don't require attach to entity
        // shouldn't play unless we're taking damage
        // only apply when health go down certain percentage
        if ( !attachToEnt && !loopEffect )
        {
            if ( damageInfo == null )
                continue
            bool entTakeDamageDownToFrac = entHealthFrac > healthFracReq && entHealthFracAfterDamage <= healthFracReq
            if ( !entTakeDamageDownToFrac )
                continue
        }

        int index = effectStruct.index
        // add effect here. general checks handled inside this function
        ServerModelHealthFX_CreateEffect( ent, index )
    }
}

// create effect with given index, no validation checks
entity function ServerModelHealthFX_CreateEffect( entity ent, int specifiedIndex )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelHealthFXTable ) )
        return

    // HACK for titans: use soul entity for storing everything
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !( storingEnt in file.entOwnedModelHealthFXs ) )
        file.entOwnedModelHealthFXs[ storingEnt ] <- {}
    
    foreach ( effectStruct in file.registeredModelHealthFXTable[ modelName ] )
    {
        int index = effectStruct.index
        // only use the one we specified
        if ( index != specifiedIndex )
            continue

        // from here we start using "return" if check failed, because we've find our effectStruct
        // don't play effect again if we already had one
        if ( index in file.entOwnedModelHealthFXs[ storingEnt ] )
            return

        // set up variables
        float healthFracReq = effectStruct.healthFrac
        // HACK for titans
        bool checkDoomedHealth = ent.IsTitan() && GetDoomedState( ent )
        if ( checkDoomedHealth )
            healthFracReq = effectStruct.doomedHealthFrac

        string attachment = effectStruct.attachment
        int attachID = ent.LookupAttachment( attachment )
        // anti-crash
        if ( attachID <= 0 )
            return

        bool attachToEnt = effectStruct.attachToEnt
        bool loopEffect = effectStruct.loopEffect
        // if effect don't require attach to entity
        // shouldn't play unless we're taking damage
        // only apply when health go down certain percentage
        if ( !attachToEnt && !loopEffect )
            return

        asset effectName = effectStruct.effectName
        int visibilityFlags = effectStruct.visibilityFlags
        
        // add effect and setup cleanup
        entity effect = CreateModelFXOnEnt( ent, effectName, attachment, attachToEnt, loopEffect, visibilityFlags )
        EntOwnedHealthFX ownedFXStruct
        if ( loopEffect ) // if it's not a looping effect, we don't want to clear it, just wait it over
            ownedFXStruct.effect = effect
        ownedFXStruct.healthFrac = healthFracReq
        ownedFXStruct.checkDoomedHealth = checkDoomedHealth
        ownedFXStruct.defaultVisibilityFlags = visibilityFlags

        file.entOwnedModelHealthFXs[ storingEnt ][ index ] <- ownedFXStruct

        // succeeded generating effect!
        return effect
    }
}

// re-create any active effect on current entity!
void function ServerModelHealthFX_ReCreateActiveEffectsOnEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelHealthFXs ) )
        return
    
    foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXs[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) ) // only try to re-create if last effect is active
        {
            // clean up last effect
            EffectStop( effect )
            delete file.entOwnedModelHealthFXs[ storingEnt ][ index ]

            // create a new effect
            ServerModelHealthFX_CreateEffect( ent, index )
        }
    }
}

void function ServerModelHealthFX_RemoveEffectsOnEntity( entity ent, bool checkHealthFracOnly = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelHealthFXs ) )
        return
        
    foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXs[ storingEnt ] )
    {
        float healthFrac = ownedFXStruct.healthFrac
        bool checkDoomedHealth = ownedFXStruct.checkDoomedHealth
        // health frac check version
        // only stop effect if entity restore their health above required frac
        if ( checkHealthFracOnly )
        {
            // HACK for titans: stop doomed effect once they're no longer doomed
            if ( checkDoomedHealth )
            {
                if ( GetDoomedState( ent ) )
                    continue
            }
            else
            {
                if ( GetHealthFrac( ent ) <= healthFrac )
                    continue
            }
        }

        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) )
            EffectStop( effect )

        delete file.entOwnedModelHealthFXs[ storingEnt ][ index ]
    }
}

void function ServerModelHealthFX_UpdateEntEffectVisibility( entity ent, int visibilityFlags = -1, bool scriptedHide = false, bool resetVisibility = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelHealthFXs ) )
        return
        
    foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXs[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( !IsValid( effect ) )
            continue

        if ( scriptedHide )
            effect.Hide()
        else
            effect.Show()
        
        if ( resetVisibility )
            effect.kv.VisibilityFlags = ownedFXStruct.defaultVisibilityFlags
        else if ( visibilityFlags != -1 )
            effect.kv.VisibilityFlags = visibilityFlags
    }
}


// clean up callbacks, thinks and owned effects
void function ServerModelHealthFX_CleanUpForEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    if ( ent.IsTitan() )
    {
        ent = ent.GetTitanSoul()
        if ( !IsValid( ent ) )
            return
    }

    if ( !( ent in file.entHasSetUpServerModelHealthFX ) ) // needs to be setup before we can call this think
        return
    
    // stop any threads in this file
    ent.Signal( "ModelHealthFX_OwnerTracking" )

    ServerModelHealthFX_RemoveEffectsOnEntity( ent )
    // HACK for titans
    if ( IsSoul( ent ) )
    {
        entity titan = ent.GetTitan()
        if ( IsValid( titan ) )
            RemoveEntityCallback_OnPostDamaged( titan, ServerModelHealthFX_OnEntPostDamage )
    }
    else
        RemoveEntityCallback_OnPostDamaged( ent, ServerModelHealthFX_OnEntPostDamage )

    delete file.entHasSetUpServerModelHealthFX[ ent ]
}


void function ServerModelFXData_Register( asset modelName, string dataName )
{
    if ( !( modelName in file.registeredModelFXData_Spawn ) )
        file.registeredModelFXData_Spawn[ modelName ] <- {}
    if ( !( modelName in file.registeredModelFXData_Health ) )
        file.registeredModelFXData_Health[ modelName ] <- {}

    if ( !( dataName in file.registeredModelFXData_Spawn[ modelName ] ) )
        file.registeredModelFXData_Spawn[ modelName ][ dataName ] <- []
    if ( !( dataName in file.registeredModelFXData_Health[ modelName ] ) )
        file.registeredModelFXData_Health[ modelName ][ dataName ] <- []
}

void function ServerModelFXData_AddSpawnFX( asset modelName, string dataName, string attachment, asset effectName, int visibilityFlags = ENTITY_VISIBLE_TO_EVERYONE )
{
    if ( !( modelName in file.registeredModelFXData_Spawn ) )
        return

    if ( !( dataName in file.registeredModelFXData_Spawn[ modelName ] ) )
        return

    #if SERVER_MODEL_FX_DEBUG
        print( "Adding FX: " + string( effectName ) + " for model: " + string( modelName ) + " , dataName is \"" + dataName + "\"" )
    #endif

    ModelFXDataStruct_Spawn newEffect
    newEffect.attachment = attachment
    newEffect.effectName = effectName
    newEffect.visibilityFlags = visibilityFlags
    file.registeredModelFXData_Spawn[ modelName ][ dataName ].append( newEffect )

    // setup unique index
    newEffect.index = file.registeredIndex
    file.registeredIndex++
}

void function ServerModelFXData_AddHealthFX( asset modelName, string dataName, float healthFrac, string attachment, asset effectName, bool overrideEffectsWithSameAttachment = true, bool removeOnHealthRestore = false, bool attachToEnt = false, bool loopEffect = false, int visibilityFlags = ENTITY_VISIBLE_TO_EVERYONE, float doomedHealthFrac = -1 )
{
    if ( !( modelName in file.registeredModelFXData_Health ) )
        return

    if ( !( dataName in file.registeredModelFXData_Health[ modelName ] ) )
        return

    #if SERVER_MODEL_FX_DEBUG
        print( "Adding FX: " + string( effectName ) + " for model: " + string( modelName ) + " , dataName is \"" + dataName + "\"" )
    #endif

    ModelFXDataStruct_Health newEffect
    newEffect.healthFrac = healthFrac
    newEffect.attachment = attachment
    newEffect.effectName = effectName
    newEffect.overrideEffectsWithSameAttachment = overrideEffectsWithSameAttachment
    newEffect.removeOnHealthRestore = removeOnHealthRestore
    newEffect.attachToEnt = attachToEnt
    newEffect.loopEffect = loopEffect
    newEffect.visibilityFlags = visibilityFlags
    newEffect.doomedHealthFrac = doomedHealthFrac
    file.registeredModelFXData_Health[ modelName ][ dataName ].append( newEffect )

    // setup unique index
    newEffect.index = file.registeredIndex
    file.registeredIndex++
}

void function ServerModelFXData_SetUpForEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    // as PilotBecomesTitan() transfers parents
    if ( ent.IsTitan() )
    {
        ent = ent.GetTitanSoul()
        if ( !IsValid( ent ) )
            return
    }

    if ( ent in file.entHasSetUpServerModelFXData ) // don't allow setup multiple times
        return
    file.entHasSetUpServerModelFXData[ ent ] <- true

    ServerModelFXData_ApplySpawnFXToEntity( ent )
    ServerModelFXData_ApplyHealthFXToEntity( ent )
    // HACK for titans
    if ( IsSoul( ent ) )
    {
        entity titan = ent.GetTitan()
        if ( IsValid( titan ) )
            AddEntityCallback_OnPostDamaged( titan, ServerModelFXData_OnEntPostDamage )
    }
    else
        AddEntityCallback_OnPostDamaged( ent, ServerModelFXData_OnEntPostDamage )

    thread ModelFXData_OwnerTracking( ent )
}

// clean up old effects and apply new ones once owner changed model
// track owner health update and do effects that we might miss upon their scripted health update
void function ModelFXData_OwnerTracking( entity ent )
{
    ent.Signal( "ModelFXData_OwnerTracking" )
    ent.EndSignal( "ModelFXData_OwnerTracking" )
    ent.EndSignal( "OnDestroy" )

    asset lastTickModelName
    int lastTickHealth
    bool lastTickAlive
    bool lastTickPhaseShifted
    int lastTickVisibilityFlags
    bool effectsBeingSetToNobodyVisible

    // HACK for titans
    entity soul = IsSoul( ent ) ? ent : null
    entity lastTickTitan
    bool lastTickDoomed

    while ( true )
    {
        // HACK for titans
        lastTickTitan = null
        if ( IsValid( soul ) )
        {
            lastTickTitan = soul.GetTitan()
            if ( IsValid( lastTickTitan ) )
            {
                lastTickModelName = lastTickTitan.GetModelName()
                if ( IsAlive( lastTickTitan ) )
                    lastTickHealth = lastTickTitan.GetHealth()
                lastTickAlive = IsAlive( lastTickTitan )
                lastTickDoomed = GetDoomedState( lastTickTitan )
                lastTickPhaseShifted = lastTickTitan.IsPhaseShifted()
                lastTickVisibilityFlags = int( lastTickTitan.kv.VisibilityFlags )
            }
        }
        else
        {
            lastTickModelName = ent.GetModelName()
            if ( IsAlive( ent ) )
                lastTickHealth = ent.GetHealth()
            lastTickAlive = IsAlive( ent )
            lastTickPhaseShifted = ent.IsPhaseShifted()
            lastTickVisibilityFlags = int( ent.kv.VisibilityFlags )
        }

        WaitFrame()

        // HACK for titans
        if ( IsValid( soul ) )
        {
            ent = soul.GetTitan()
            if ( !IsValid( ent ) )
                continue
        }

        // phase shift check
        if ( ent.IsPhaseShifted() != lastTickPhaseShifted )
        {
            // starting phase shift
            if ( ent.IsPhaseShifted() )
            {
                // try to hide effect
                ServerModelFXData_UpdateEntSpawnFXVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
                ServerModelFXData_UpdateEntHealthFXVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
            }
            else // exiting phase shift
            {
                // try to show effects again
                if ( !effectsBeingSetToNobodyVisible )
                {
                    ServerModelFXData_UpdateEntSpawnFXVisibility( ent, -1, false, true )
                    ServerModelFXData_UpdateEntHealthFXVisibility( ent, -1, false, true )
                }
            }
        }

        // shifted check: don't do effect updates
        if ( ent.IsPhaseShifted() )
            continue

        // VisibilityFlags being changed
        if ( lastTickVisibilityFlags != int( ent.kv.VisibilityFlags ) )
        {
            //print( "VisibilityFlags updated!" )
            // change to the visibility flag that will hide titan's model effects!
            if ( int( ent.kv.VisibilityFlags ) == ENTITY_VISIBLE_TO_NOBODY )
            {
                // try to update effect visibilityFlag
                ServerModelFXData_UpdateEntSpawnFXVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
                ServerModelFXData_UpdateEntHealthFXVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
                effectsBeingSetToNobodyVisible = true
                //print( "Trying to make effects not visible" )
            }
            else if ( effectsBeingSetToNobodyVisible )
            {
                // try to show effects again
                ServerModelFXData_UpdateEntSpawnFXVisibility( ent, -1, false, true )
                ServerModelFXData_UpdateEntHealthFXVisibility( ent, -1, false, true )
                effectsBeingSetToNobodyVisible = false
                //print( "Trying to restore effects visibility" )
            }
        }

        // model updated for some reason!
        if ( ent.GetModelName() != lastTickModelName )
        {
            // stop last model effects
            ServerModelFXData_RemoveSpawnFXOnEntity( ent )
            ServerModelFXData_RemoveHealthFXOnEntity( ent )
            // apply effects for new model
            ServerModelFXData_ApplySpawnFXToEntity( ent )
            ServerModelFXData_ApplyHealthFXToEntity( ent )
        }

        // lifestate checks
        // entity died this tick!
        if ( !IsAlive( ent ) && lastTickAlive )
        {
            // for players, stop any effect if they're dead
            if ( ent.IsPlayer() )
            {
                ServerModelFXData_RemoveSpawnFXOnEntity( ent )
                ServerModelFXData_RemoveHealthFXOnEntity( ent )
            }
        }
        else if ( ent.IsPlayer() && IsAlive( ent ) && !lastTickAlive ) // player respawned!
        {
            // apply effects
            ServerModelFXData_ApplySpawnFXToEntity( ent )
            ServerModelFXData_ApplyHealthFXToEntity( ent )
        }
        else if ( IsAlive( ent ) ) // never do health checks if ent is dead
        {
            bool updateEffects = lastTickHealth != ent.GetHealth()
            // titans check
            // update effects if we changed state
            if ( ent.IsTitan() && GetDoomedState( ent ) != lastTickDoomed )
                updateEffects = true
            if ( updateEffects ) // in case we changed health without taking damage
            {
                ServerModelFXData_RemoveHealthFXOnEntity( ent, true ) // stop model effects those requirements is below our current health
                ServerModelFXData_ApplyHealthFXToEntity( ent )
            }
        }
    }
}

// main updating method
void function ServerModelFXData_OnEntPostDamage( entity ent, var damageInfo )
{
    if ( !( ent in file.entHasSetUpServerModelFXData ) ) // needs to be setup before we can call this think
        return

    ServerModelFXData_ApplyHealthFXToEntity( ent, damageInfo )
}

// apply any valid effect to current entity
void function ServerModelFXData_ApplySpawnFXToEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelFXData_Spawn ) )
        return

    #if SERVER_MODEL_FX_DEBUG
        print( "Applying spawn FX for entity: " + string( ent ) )
        print( "modelName: " + string( modelName ) )
    #endif

    foreach ( dataName, effectStructs in file.registeredModelFXData_Spawn[ modelName ] )
    {
        #if SERVER_MODEL_FX_DEBUG
            print( "dataName: " + dataName )
        #endif
        foreach ( effectStruct in effectStructs )
        {
            #if SERVER_MODEL_FX_DEBUG
                print( "Found effect: " + string( effectStruct.effectName ) )
                print( "attachment: " + effectStruct.attachment )
                print( "index: " + string( effectStruct.index ) )
            #endif

            int index = effectStruct.index
            // add effect here. general checks handled inside this function
            ServerModelFXData_CreateSpawnFX( ent, index )
        }
    }
}

entity function ServerModelFXData_CreateSpawnFX( entity ent, int specifiedIndex )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelFXData_Spawn ) )
        return

    // HACK for titans: use soul entity for storing everything
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !( storingEnt in file.entOwnedModelSpawnFXsFromData ) )
        file.entOwnedModelSpawnFXsFromData[ storingEnt ] <- {}

    foreach ( dataName, effectStructs in file.registeredModelFXData_Spawn[ modelName ] )
    {
        foreach ( effectStruct in effectStructs )
        {
            int index = effectStruct.index
            // only use the one we specified
            if ( index != specifiedIndex )
                continue

            // from here we start using "return" if check failed, because we've find our effectStruct
            // don't play effect again if we already had one
            if ( index in file.entOwnedModelSpawnFXsFromData[ storingEnt ] )
            {
                #if SERVER_MODEL_FX_DEBUG
                    print( "ent already got this effect!" )
                #endif
                continue
            }

            string attachment = effectStruct.attachment
            int attachID = ent.LookupAttachment( attachment )
            // anti-crash
            if ( attachID <= 0 )
            {
                #if SERVER_MODEL_FX_DEBUG
                    print( "ent don't have attachment for this effect!" )
                #endif
                return
            }

            asset effectName = effectStruct.effectName
            int visibilityFlags = effectStruct.visibilityFlags

            // add effect and setup cleanup
            // spawnFX always attach to ent and loop, won't destroy immediately
            entity effect = CreateModelFXOnEnt( ent, effectName, attachment, true, true, visibilityFlags, false )
            EntOwnedModelFXData_Spawn ownedFXStruct
            ownedFXStruct.effect = effect
            ownedFXStruct.defaultVisibilityFlags = visibilityFlags
            
            file.entOwnedModelSpawnFXsFromData[ storingEnt ][ index ] <- ownedFXStruct
            #if SERVER_MODEL_FX_DEBUG
                print( "Effect functioning on ent!" )
            #endif

            // succeeded generating effect!
            return effect
        }
    }
}

void function ServerModelFXData_ReCreateActiveSpawnFXOnEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelSpawnFXsFromData ) )
        return
    
    foreach ( index, ownedFXStruct in file.entOwnedModelSpawnFXsFromData[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) ) // only try to re-create if last effect is active
        {
            // clean up last effect
            EffectStop( effect )
            delete file.entOwnedModelSpawnFXsFromData[ storingEnt ][ index ]

            // create a new effect
            ServerModelFXData_CreateSpawnFX( ent, index )
        }
    }
}

void function ServerModelFXData_RemoveSpawnFXOnEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelSpawnFXsFromData ) )
        return
    
    foreach ( index, ownedFXStruct in file.entOwnedModelSpawnFXsFromData[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) )
            EffectStop( effect )

        delete file.entOwnedModelSpawnFXsFromData[ storingEnt ][ index ]
    }
}

void function ServerModelFXData_UpdateEntSpawnFXVisibility( entity ent, int visibilityFlags = -1, bool scriptedHide = false, bool resetVisibility = false )
{
     // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelSpawnFXsFromData ) )
        return
    
    foreach ( index, ownedFXStruct in file.entOwnedModelSpawnFXsFromData[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( !IsValid( effect ) )
            continue

        if ( scriptedHide )
            effect.Hide()
        else
            effect.Show()
        
        if ( resetVisibility )
            effect.kv.VisibilityFlags = ownedFXStruct.defaultVisibilityFlags
        else if ( visibilityFlags != -1 )
            effect.kv.VisibilityFlags = visibilityFlags
    }
}

void function ServerModelFXData_ApplyHealthFXToEntity( entity ent, var damageInfo = null )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelFXData_Health ) )
        return

    #if SERVER_MODEL_FX_DEBUG
        //print( "Applying health FX for entity: " + string( ent ) )
        //print( "modelName: " + string( modelName ) )
    #endif

    foreach ( dataName, effectStructs in file.registeredModelFXData_Health[ modelName ] )
    {
        foreach ( effectStruct in effectStructs )
        {
            #if SERVER_MODEL_FX_DEBUG
                //print( "Found effect: " + string( effectStruct.effectName ) )
                //print( "healthFrac: " + effectStruct.healthFrac )
                //print( "doomedHealthFrac: " + effectStruct.doomedHealthFrac )
                //print( "attachment: " + effectStruct.attachment )
                //print( "effectName: " + effectStruct.effectName )
                //print( "index: " + string( effectStruct.index ) )
            #endif

            float healthFracReq = effectStruct.healthFrac
            // HACK for titans
            bool checkDoomedHealth = ent.IsTitan() && GetDoomedState( ent )
            if ( checkDoomedHealth )
                healthFracReq = effectStruct.doomedHealthFrac
            float entHealthFrac = GetHealthFrac( ent )
            #if SERVER_MODEL_FX_DEBUG
                //print( "healthFracReq: " + string( healthFracReq ) )
                //print( "entHealthFrac: " + string( entHealthFrac ) )
            #endif
            // if we passed an damageInfo inside, calculate entity health left after taking damage
            float entHealthFracAfterDamage
            if ( damageInfo != null )
            {
                entHealthFracAfterDamage = float( ent.GetHealth() - int( DamageInfo_GetDamage( damageInfo ) ) ) / float( ent.GetMaxHealth() )
                #if SERVER_MODEL_FX_DEBUG
                    //print( "entHealthFracAfterDamage: " + string( entHealthFracAfterDamage ) )
                #endif
                if ( entHealthFracAfterDamage > healthFracReq )
                {
                    #if SERVER_MODEL_FX_DEBUG
                        //print( "ent don't have required health frac for effect!" )
                    #endif
                    continue
                }
            }
            else
            {
                if ( entHealthFrac > healthFracReq )
                {
                    #if SERVER_MODEL_FX_DEBUG
                        //print( "ent don't have required health frac for effect!" )
                    #endif
                    continue
                }
            }

            bool attachToEnt = effectStruct.attachToEnt
            bool loopEffect = effectStruct.loopEffect
            // if effect don't require attach to entity
            // shouldn't play unless we're taking damage
            // only apply when health go down certain percentage
            if ( !attachToEnt && !loopEffect )
            {
                if ( damageInfo == null )
                    continue
                bool entTakeDamageDownToFrac = entHealthFrac > healthFracReq && entHealthFracAfterDamage <= healthFracReq
                if ( !entTakeDamageDownToFrac )
                    continue
            }

            int index = effectStruct.index
            // add effect here. general checks handled inside this function
            ServerModelFXData_CreateHealthFX( ent, index )
        }
    }
}

entity function ServerModelFXData_CreateHealthFX( entity ent, int specifiedIndex )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelFXData_Health ) )
        return

     // HACK for titans: use soul entity for storing everything
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !( storingEnt in file.entOwnedModelHealthFXsFromData ) )
        file.entOwnedModelHealthFXsFromData[ storingEnt ] <- {}

    foreach ( dataName, effectStructs in file.registeredModelFXData_Health[ modelName ] )
    {
        foreach ( effectStruct in effectStructs )
        {
            int index = effectStruct.index
            // only use the one we specified
            if ( index != specifiedIndex )
                continue

            // from here we start using "return" if check failed, because we've find our effectStruct
            // don't play effect again if we already had one
            if ( index in file.entOwnedModelHealthFXsFromData[ storingEnt ] )
            {
                #if SERVER_MODEL_FX_DEBUG
                    //print( "ent already got this effect!" )
                #endif
                return
            }

            float healthFracReq = effectStruct.healthFrac
            // HACK for titans
            bool checkDoomedHealth = ent.IsTitan() && GetDoomedState( ent )
            if ( checkDoomedHealth )
                healthFracReq = effectStruct.doomedHealthFrac

            string attachment = effectStruct.attachment
            int attachID = ent.LookupAttachment( attachment )
            // anti-crash
            if ( attachID <= 0 )
            {
                #if SERVER_MODEL_FX_DEBUG
                    //print( "ent don't have attachment for this effect!" )
                #endif
                return
            }

            bool attachToEnt = effectStruct.attachToEnt
            bool loopEffect = effectStruct.loopEffect
            // if effect don't require attach to entity
            // shouldn't play unless we're taking damage
            // only apply when health go down certain percentage
            if ( !attachToEnt && !loopEffect )
                return

            // effect override
            bool overrideEffects = effectStruct.overrideEffectsWithSameAttachment
            if ( overrideEffects )
            {
                foreach ( id, fxStruct in file.entOwnedModelHealthFXsFromData[ storingEnt ] )
                {
                    #if SERVER_MODEL_FX_OVERRIDE_DEBUG
                        print( "======Try to override effect======" )
                        print( "our index: " + string( index ) )
                        print( "our dataName: " + dataName )
                        print( "our attachment: " + attachment )
                        print( "effect to override's index: " + string( id ) )
                        print( "effect to override's dataName: " + fxStruct.dataName )
                        print( "effect to override's attachment: " + fxStruct.attachment )
                    #endif

                    if ( id == index ) // don't overwrite same effect
                        continue
                    
                    if ( fxStruct.dataName != dataName ) // only check ones with same data
                        continue
                    
                    if ( fxStruct.attachment == attachment ) // same data, same attachment. try to override
                    {
                        #if SERVER_MODEL_FX_OVERRIDE_DEBUG
                            print( "!!!found one effect with same attachment! cleaning up" )
                        #endif
                        
                        entity effect = fxStruct.effect
                        if ( IsValid( effect ) )
                            EffectStop( effect )

                        // don't delete data here, effect should still be considered as "applied to entity"
                        // so we don't overlap effects on every update
                        //delete file.entOwnedModelHealthFXsFromData[ storingEnt ][ id ]
                    }

                    #if SERVER_MODEL_FX_OVERRIDE_DEBUG
                        print( "==============================" )
                    #endif
                }
            }

            asset effectName = effectStruct.effectName
            int visibilityFlags = effectStruct.visibilityFlags

            // add effect and setup cleanup
            entity effect = CreateModelFXOnEnt( ent, effectName, attachment, attachToEnt, loopEffect, visibilityFlags )
            EntOwnedModelFXData_Health ownedFXStruct
            ownedFXStruct.dataName = dataName
            if ( loopEffect ) // if it's not a looping effect, we don't want to clear it, just wait it over
                ownedFXStruct.effect = effect
            ownedFXStruct.healthFrac = healthFracReq
            ownedFXStruct.attachment = attachment
            ownedFXStruct.checkDoomedHealth = checkDoomedHealth
            ownedFXStruct.defaultVisibilityFlags = visibilityFlags

            file.entOwnedModelHealthFXsFromData[ storingEnt ][ index ] <- ownedFXStruct
            #if SERVER_MODEL_FX_DEBUG
                //print( "Effect functioning on ent!" )
                print( "model health FX functioning on ent!" )
                print( "index: " + string( index ) )
                print( "healthFrac: " + string( ownedFXStruct.healthFrac ) )
                print( "attachment: " + ownedFXStruct.attachment )
                print( "checkDoomedHealth: " + string( ownedFXStruct.checkDoomedHealth ) )
            #endif

            // succeeded generating effect!
            return effect
        }
    }
}

void function ServerModelFXData_ReCreateActiveHealthFXOnEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelHealthFXsFromData ) )
        return
    
    foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXsFromData[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) ) // only try to re-create if last effect is active
        {
            // clean up last effect
            EffectStop( effect )
            delete file.entOwnedModelHealthFXsFromData[ storingEnt ][ index ]

            // create a new effect
            ServerModelFXData_CreateHealthFX( ent, index )
        }
    }
}

void function ServerModelFXData_RemoveHealthFXOnEntity( entity ent, bool checkHealthFracOnly = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelHealthFXsFromData ) )
        return
        
    foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXsFromData[ storingEnt ] )
    {
        float healthFrac = ownedFXStruct.healthFrac
        // HACK for titans
        bool checkDoomedHealth = ownedFXStruct.checkDoomedHealth
        // health frac check version
        // only stop effect if entity restore their health above required frac
        if ( checkHealthFracOnly )
        {
            // HACK for titans: stop doomed effect once they're no longer doomed
            if ( checkDoomedHealth )
            {
                if ( GetDoomedState( ent ) )
                    continue
            }
            else
            {
                if ( GetHealthFrac( ent ) <= healthFrac )
                {
                    #if SERVER_MODEL_FX_DEBUG
                        /*
                        print( "remove model health effect failed!" )
                        print( "index: " + string( index ) )
                        print( "GetHealthFrac( ent ): " + string( GetHealthFrac( ent ) ) )
                        print( "required healthFrac: " + string( healthFrac ) )
                        */
                    #endif
                    continue
                }
            }
        }

        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) )
            EffectStop( effect )

        #if SERVER_MODEL_FX_DEBUG
            //print( "==========removing effect============" )
            print( "removing model health effect" )
            print( "index: " + string( index ) )
            print( "dataName: " + ownedFXStruct.dataName )
            print( "healthFrac: " + string( ownedFXStruct.healthFrac ) )
            print( "attachment: " + ownedFXStruct.attachment )
            //print( "==================================" )
        #endif

        delete file.entOwnedModelHealthFXsFromData[ storingEnt ][ index ]
    }
}

void function ServerModelFXData_UpdateEntHealthFXVisibility( entity ent, int visibilityFlags = -1, bool scriptedHide = false, bool resetVisibility = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelHealthFXsFromData ) )
        return
        
    foreach ( index, ownedFXStruct in file.entOwnedModelHealthFXsFromData[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( !IsValid( effect ) )
            continue

        if ( scriptedHide )
            effect.Hide()
        else
            effect.Show()
        
        if ( resetVisibility )
            effect.kv.VisibilityFlags = ownedFXStruct.defaultVisibilityFlags
        else if ( visibilityFlags != -1 )
            effect.kv.VisibilityFlags = visibilityFlags
    }
}


// clean up callbacks, thinks and owned effects
void function ServerModelFXData_CleanUpForEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    if ( ent.IsTitan() )
    {
        ent = ent.GetTitanSoul()
        if ( !IsValid( ent ) )
            return
    }

    if ( !( ent in file.entHasSetUpServerModelFXData ) ) // needs to be setup before we can call this think
        return
    
    // stop any threads in this file
    ent.Signal( "ModelFXData_OwnerTracking" )

    ServerModelFXData_RemoveSpawnFXOnEntity( ent )
    ServerModelFXData_RemoveHealthFXOnEntity( ent )
    // HACK for titans
    if ( IsSoul( ent ) )
    {
        entity titan = ent.GetTitan()
        if ( IsValid( titan ) )
            RemoveEntityCallback_OnPostDamaged( titan, ServerModelFXData_OnEntPostDamage )
    }
    else
        RemoveEntityCallback_OnPostDamaged( ent, ServerModelFXData_OnEntPostDamage )

    delete file.entHasSetUpServerModelFXData[ ent ]
}


void function ServerModelBodyGroupFX_Register( asset modelName, string bodyGroupName, int stateIndex, string attachment, asset effectName, bool attachToEnt = false, bool loopEffect = false, int visibilityFlags = ENTITY_VISIBLE_TO_EVERYONE, string sound = "", bool regenerateEffect = false, float firstGenerateDelay = -1, float regenerateRandomWaitMin = -1, float regenerateRandomWaitMax = -1 )
{
    if ( !( modelName in file.registeredModelBodyGroupFXTable ) )
        file.registeredModelBodyGroupFXTable[ modelName ] <- []

    ModelBodyGroupFXStruct newEffect
    newEffect.bodyGroupName = bodyGroupName
    newEffect.stateIndex = stateIndex
    newEffect.attachment = attachment
    newEffect.effectName = effectName
    newEffect.attachToEnt = attachToEnt
    newEffect.loopEffect = loopEffect
    newEffect.visibilityFlags = visibilityFlags
    newEffect.sound = sound
    newEffect.regenerateEffect = regenerateEffect
    newEffect.regenerateRandomWaitMin = regenerateRandomWaitMin
    newEffect.regenerateRandomWaitMax = regenerateRandomWaitMax
    file.registeredModelBodyGroupFXTable[ modelName ].append( newEffect )

    // setup unique index
    newEffect.index = file.registeredIndex
    file.registeredIndex++
}

void function ServerModelBodyGroupFX_SetUpForEntity( entity ent, bool trackHealthRestore = false )
{
    // HACK for titans: use soul entity for storing everything
    // as PilotBecomesTitan() transfers parents
    if ( ent.IsTitan() )
    {
        ent = ent.GetTitanSoul()
        if ( !IsValid( ent ) )
            return
    }

    if ( ent in file.entHasSetUpServerModelBodyGroupFX ) // don't allow setup multiple times
        return
    file.entHasSetUpServerModelBodyGroupFX[ ent ] <- true

    thread ModelBodyGroupFX_OwnerTracking( ent )
}

// this tracks both model change and bodygroup update
void function ModelBodyGroupFX_OwnerTracking( entity ent )
{
    ent.Signal( "ModelBodyGroupFX_OwnerTracking" )
    ent.EndSignal( "ModelBodyGroupFX_OwnerTracking" )
    ent.EndSignal( "OnDestroy" )

    int lastTickFullBodyGroup
    asset lastTickModelName
    bool lastTickPhaseShifted
    int lastTickVisibilityFlags
    bool effectsBeingSetToNobodyVisible
    
    // HACK for titans
    entity soul = IsSoul( ent ) ? ent : null
    entity lastTickTitan

    while ( true )
    {
        // HACK for titans
        lastTickTitan = null
        if ( IsValid( soul ) )
        {
            entity lastTickTitan = soul.GetTitan()
            if ( IsValid( lastTickTitan ) )
            {
                lastTickFullBodyGroup = lastTickTitan.GetFullBodygroup()
                lastTickModelName = lastTickTitan.GetModelName()
                lastTickPhaseShifted = lastTickTitan.IsPhaseShifted()
                lastTickVisibilityFlags = int( lastTickTitan.kv.VisibilityFlags )
            }
        }
        else
        {
            lastTickFullBodyGroup = ent.GetFullBodygroup()
            lastTickModelName = ent.GetModelName()
            lastTickPhaseShifted = ent.IsPhaseShifted()
            lastTickVisibilityFlags = int( ent.kv.VisibilityFlags )
        }

        WaitFrame()

        // HACK for titans
        if ( IsValid( soul ) )
        {
            ent = soul.GetTitan()
            if ( !IsValid( ent ) )
                continue
        }

        // phase shift check
        if ( ent.IsPhaseShifted() != lastTickPhaseShifted )
        {
            // starting phase shift
            if ( ent.IsPhaseShifted() )
            {
                // try to hide effect
                ServerModelBodyGroupFX_UpdateEntEffectVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
            }
            else // exiting phase shift
            {
                // try to show effects again
                if ( !effectsBeingSetToNobodyVisible )
                    ServerModelBodyGroupFX_UpdateEntEffectVisibility( ent, -1, false, true )
            }
        }

        // shifted check: don't do effect updates
        if ( ent.IsPhaseShifted() )
            continue

        // VisibilityFlags being changed
        if ( lastTickVisibilityFlags != int( ent.kv.VisibilityFlags ) )
        {
            // change to the visibility flag that will hide titan's model effects!
            if ( int( ent.kv.VisibilityFlags ) == ENTITY_VISIBLE_TO_NOBODY )
            {
                // try to update effect visibilityFlag
                ServerModelBodyGroupFX_UpdateEntEffectVisibility( ent, ENTITY_VISIBLE_TO_NOBODY, true )
                effectsBeingSetToNobodyVisible = true
            }
            else if ( effectsBeingSetToNobodyVisible )
            {
                // try to show effects again
                ServerModelBodyGroupFX_UpdateEntEffectVisibility( ent, -1, false, true )
                effectsBeingSetToNobodyVisible = false
            }
        }

        // for players, stop any effect if they're dead
        if ( ent.IsPlayer() && !IsAlive( ent ) )
        {
            ServerModelBodyGroupFX_RemoveEffectsOnEntity( ent )
            continue
        }

        // pretty bad things happened: model changed!
        if ( ent.GetModelName() != lastTickModelName )
        {
            // stop all model effects
            ServerModelBodyGroupFX_RemoveEffectsOnEntity( ent, true )
            continue
        }
        // bodygroup updated
        if ( ent.GetFullBodygroup() != lastTickFullBodyGroup )
        {
            // clean up effects those aren't match required state
            ServerModelBodyGroupFX_RemoveEffectsOnEntity( ent )
            ServerModelBodyGroupFX_ApplyEffectsToEntity( ent )
        }
    }
}

// apply any valid effect to current entity
void function ServerModelBodyGroupFX_ApplyEffectsToEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelBodyGroupFXTable ) )
        return

    foreach ( effectStruct in file.registeredModelBodyGroupFXTable[ modelName ] )
    {
        int index = effectStruct.index
        // add effect here. general checks handled inside this function
        ServerModelBodyGroupFX_CreateEffect( ent, index )
    }
}

entity function ServerModelBodyGroupFX_CreateEffect( entity ent, int specifiedIndex, bool regenerateEffectRandomDelay = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()

    if ( !IsValid( ent ) )
        return
    
    asset modelName = ent.GetModelName()
    if ( !( modelName in file.registeredModelBodyGroupFXTable ) )
        return
    
    // HACK for titans: use soul entity for storing everything
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !( storingEnt in file.entOwnedModelBodyGroupFXs ) )
        file.entOwnedModelBodyGroupFXs[ storingEnt ] <- {}

    foreach ( effectStruct in file.registeredModelBodyGroupFXTable[ modelName ] )
    {
        int index = effectStruct.index
        // only use the one we specified
        if ( index != specifiedIndex )
            continue

        // from here we start using "return" if check failed, because we've find our effectStruct
        // don't play effect again if we already had one
        if ( index in file.entOwnedModelBodyGroupFXs[ storingEnt ] )
            return

        string bodyGroupName = effectStruct.bodyGroupName
        int bodyGroupIndex = ent.FindBodyGroup( bodyGroupName )
        // anti-crash
        if ( bodyGroupIndex == -1 )
            return
        int stateIndexReq = effectStruct.stateIndex
        int currentState = ent.GetBodyGroupState( bodyGroupIndex )
        if ( currentState != stateIndexReq ) // bodygroup not updated yet!
            return

        string attachment = effectStruct.attachment
        int attachID = ent.LookupAttachment( attachment )
        // anti-crash
        if ( attachID <= 0 )
            return

        asset effectName = effectStruct.effectName
        bool attachToEnt = effectStruct.attachToEnt
        bool loopEffect = effectStruct.loopEffect
        int visibilityFlags = effectStruct.visibilityFlags
        bool regenerateEffect = effectStruct.regenerateEffect
        string sound = effectStruct.sound

        // add effect and setup cleanup
        // don't destroy effects immediately
        entity effect
        if ( regenerateEffect )
        {
            float firstDelay = effectStruct.firstGenerateDelay
            float randomWaitMin = effectStruct.regenerateRandomWaitMin
            float randomWaitMax = effectStruct.regenerateRandomWaitMax
            // allow us use random delay before first generating
            // mostly for re-creating effects and we don't want all effects gets activated together
            if ( regenerateEffectRandomDelay )
                firstDelay = RandomFloatRange( randomWaitMin, randomWaitMax )
            // this actually returns a info_placement_helper to help us manage it
            effect = CreateRegeneratingModelFXOnEnt_ReturnPlaceHelper( ent, effectName, attachment, attachToEnt, visibilityFlags, sound, firstDelay, randomWaitMin, randomWaitMax )
        }
        else
        {
            effect = CreateModelFXOnEnt( ent, effectName, attachment, attachToEnt, loopEffect, visibilityFlags, false )
            // sound event
            if ( sound != "" )
                EmitSoundOnEntity( ent, sound )
        }

        EntOwnedBodyGroupFX ownedFXStruct
        if ( loopEffect || regenerateEffect ) // if it's not a looping or regenerating effect, we don't want to clear it, just wait it over
            ownedFXStruct.effect = effect
        ownedFXStruct.bodyGroupName = bodyGroupName
        ownedFXStruct.stateIndex = currentState
        ownedFXStruct.regenerateEffect = regenerateEffect
        ownedFXStruct.defaultVisibilityFlags = visibilityFlags

        file.entOwnedModelBodyGroupFXs[ storingEnt ][ index ] <- ownedFXStruct

        #if SERVER_MODEL_FX_DEBUG
            //print( "Effect functioning on ent!" )
            print( "model bodygroup FX functioning on ent!" )
            print( "index: " + string( index ) )
            print( "bodyGroupName: " + ownedFXStruct.bodyGroupName )
            print( "stateIndex: " + string( ownedFXStruct.stateIndex ) )
            print( "regenerateEffect: " + string( ownedFXStruct.regenerateEffect ) )
        #endif

        #if SERVER_MODEL_REGENERATING_FX_DEBUG
            if ( ownedFXStruct.regenerateEffect )
            {
                print( "regenerating effect functioning on ent!" )
                print( "index: " + string( index ) )
                print( "bodyGroupName: " + ownedFXStruct.bodyGroupName )
                print( "stateIndex: " + string( ownedFXStruct.stateIndex ) )
            }
        #endif

        // succeeded generating effect!
        return effect
    }
}

void function ServerModelBodyGroupFX_ReCreateActiveEffectsOnEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelBodyGroupFXs ) )
        return
    
    foreach ( index, ownedFXStruct in file.entOwnedModelBodyGroupFXs[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) ) // only try to re-create if last effect is active
        {
            // clean up last effect
            bool regenerateEffect = ownedFXStruct.regenerateEffect
            if ( regenerateEffect ) // regenerating effect uses info_placement_helper to help management
                effect.Destroy()
            else
                EffectStop( effect )
            delete file.entOwnedModelBodyGroupFXs[ storingEnt ][ index ]

            // create a new effect, add random wait on next regenerating effect
            ServerModelBodyGroupFX_CreateEffect( ent, index, true )
        }
    }
}

void function ServerModelBodyGroupFX_RemoveEffectsOnEntity( entity ent, bool destroyAllEffects = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    // model effects still apply to titan
    if ( IsValid( soul ) )
        ent = soul.GetTitan()
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelBodyGroupFXs ) )
        return
        
    foreach ( index, ownedFXStruct in file.entOwnedModelBodyGroupFXs[ storingEnt ] )
    {
        int bodyGroupIndex = ent.FindBodyGroup( ownedFXStruct.bodyGroupName )
        // state check version
        // only stop effect if our state has changed to another
        // always stop effect if we can't find our saved bodygroup
        if ( bodyGroupIndex > -1 )
        {
            if ( !destroyAllEffects )
            {
                int currentState = ent.GetBodyGroupState( bodyGroupIndex ) 
                int stateIndex = ownedFXStruct.stateIndex
                
                if ( currentState == stateIndex ) // state unchanged!
                {
                    #if SERVER_MODEL_FX_DEBUG
                        print( "remove model bodygroup effect failed!" )
                        print( "index: " + string( index ) )
                        print( "currentState: " + string( currentState ) )
                        print( "required stateIndex: " + string( stateIndex ) )
                    #endif

                    #if SERVER_MODEL_REGENERATING_FX_DEBUG
                        if ( ownedFXStruct.regenerateEffect )
                        {
                            print( "remove regenerating model bodygroup effect failed!" )
                            print( "index: " + string( index ) )
                            print( "currentState: " + string( currentState ) )
                            print( "required stateIndex: " + string( stateIndex ) )
                        }
                    #endif
                    continue
                }
            }
        }

        entity effect = ownedFXStruct.effect
        if ( IsValid( effect ) )
        {
            bool regenerateEffect = ownedFXStruct.regenerateEffect
            if ( regenerateEffect ) // regenerating effect uses info_placement_helper to help management
                effect.Destroy()
            else
                EffectStop( effect )
        }

        #if SERVER_MODEL_FX_DEBUG
            //print( "==========removing effect============" )
            print( "removing model bodygroup effect" )
            print( "index: " + string( index ) )
            print( "bodyGroupName: " + ownedFXStruct.bodyGroupName )
            print( "stateIndex: " + string( ownedFXStruct.stateIndex ) )
            print( "regenerateEffect: " + string( ownedFXStruct.regenerateEffect ) )
            //print( "==================================" )
        #endif

        #if SERVER_MODEL_REGENERATING_FX_DEBUG
            if ( ownedFXStruct.regenerateEffect )
            {
                print( "removing regenerating model bodygroup effect" )
                print( "index: " + string( index ) )
                print( "bodyGroupName: " + ownedFXStruct.bodyGroupName )
                print( "stateIndex: " + string( ownedFXStruct.stateIndex ) )
            }
        #endif

        delete file.entOwnedModelBodyGroupFXs[ storingEnt ][ index ]
    }
}

void function ServerModelBodyGroupFX_UpdateEntEffectVisibility( entity ent, int visibilityFlags = -1, bool scriptedHide = false, bool resetVisibility = false )
{
    // HACK for titans: use soul entity for storing everything
    entity soul
    if ( ent.IsTitan() )
        soul = ent.GetTitanSoul()
    if ( IsSoul( ent ) )
        soul = ent
    
    entity storingEnt = IsValid( soul ) ? soul : ent
    if ( !IsValid( ent ) || !IsValid( storingEnt ) )
        return
    if ( !( storingEnt in file.entOwnedModelBodyGroupFXs ) )
        return
        
    foreach ( index, ownedFXStruct in file.entOwnedModelBodyGroupFXs[ storingEnt ] )
    {
        entity effect = ownedFXStruct.effect
        if ( !IsValid( effect ) )
            continue

        if ( scriptedHide )
        {
            // regenerating effect in this script
            if ( ownedFXStruct.regenerateEffect )
                HideRegeneratingEffect( effect )
            else
                effect.Hide()
        }
        else
        {
            if ( ownedFXStruct.regenerateEffect )
                ShowRegeneratingEffect( effect )
            else
                effect.Show()
        }
        
        if ( resetVisibility )
            effect.kv.VisibilityFlags = ownedFXStruct.defaultVisibilityFlags
        else if ( visibilityFlags != -1 )
            effect.kv.VisibilityFlags = visibilityFlags
    }
}


// clean up callbacks, thinks and owned effects
void function ServerModelBodyGroupFX_CleanUpForEntity( entity ent )
{
    // HACK for titans: use soul entity for storing everything
    // as PilotBecomesTitan() transfers parents
    if ( ent.IsTitan() )
    {
        ent = ent.GetTitanSoul()
        if ( !IsValid( ent ) )
            return
    }

    if ( !( ent in file.entHasSetUpServerModelBodyGroupFX ) ) // needs to be setup before we can call this think
        return
    
    // stop any threads in this file
    ent.Signal( "ModelBodyGroupFX_OwnerTracking" )

    ServerModelBodyGroupFX_RemoveEffectsOnEntity( ent, true )

    delete file.entHasSetUpServerModelBodyGroupFX[ ent ]
}