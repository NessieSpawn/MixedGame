untyped
global const array<string> BATTERY_SPAWNERS = 
[
	"1007270968017", // VoyageDB
	"1007320009732", // Powa
] // for every nessie script

global function EverythingNessy_Init
global function Nessy_EnableAllFunny_Init

global function Nessie_ShouldDropPropOnClear // we allow drop props to ground on clearing. they may block bullets but whatever

global function SpawnNessyCostume
global function ClearNessyCostume

global function CreateNessyCostumeForType

//global function Nessie_DecoyOutfitInit // this won't work since decoys don't spawn with DispatchSpawn()
/*
global function AllFunctionsTogether
global function CreateNessyHat
global function CreateNessyBackpack
global function CreateNessyPistol
global function CreateNessyPrimary
global function CreateNessyFX
*/

global function Nessie_AlwaysSpawnRGBStuff
// nessie
global function Nessie_SetNessieSpawnEnabled
global function Nessie_SetAlwaysSpawnNessyDoll
global function Nessie_SetWorldMaxNessieCount
// battery, not enabled by default
global function Nessie_SetBatterySpawnEnabled
// flag
global function Nessie_SetFunnyFlagEnabled
// decoy
global function Nessie_SetDecoyOutfit
// holospray, not enabled by default
global function Nessie_SetHoloSprayEnabled
// holding prop, not enabled by default
global function Nessie_SetHoldingPropsEnabled

struct NessyHat
{
	asset modelasset
	entity hat
	entity owner
}
struct NessyPack
{
	asset modelasset
	entity pack
	entity owner
}
struct NessyPistol
{
	asset modelasset
	entity pistol
	entity owner
}
struct NessyWeapon
{
	asset modelasset
	entity weapon
	entity owner
}
struct NessyFX
{
	entity fx
	entity owner
}
struct NessyMix
{
	array<asset> mixassets
	array<entity> fxhandles
	entity owner
}

const int MAX_NESSIE_COUNT = 64
const int MAX_FUNNY_FLAGS = 32

const float NESSIE_PROP_FADEOUT_DELAY = 5

enum eNessieType
{
	NESSIE_HAT,
	NESSIE_BACKPACK,
	NESSIE_PISTOL,
	NESSIE_PRIMARY,

	NESSIE_ALL_TYPES,
}

// WIP: rework nessie effects
enum eEffectType
{
	EFFECT_SINGLE,
	EFFECT_MIXED,

	EFFECT_ALL_TYPES,
}

struct NessieCostume
{
	entity prop
}

struct NessieEffect
{
	array<asset> mixassets
	array<entity> fxhandles
	entity owner
}

struct
{
	bool allSettingsEnabled = false
	bool shouldDropPropOnClearNessy = true
	bool alwaysRGBSpawn = false // funny

	// nessy
	bool nessieSpawnEnabled = false
	bool alwaysSpawnNessyDoll = true
	int worldMaxNessieCount = MAX_NESSIE_COUNT // default value
	// battery
	bool batterySpawnEnabled = false
	// flag
	bool flagSpawnEnabled = false
	// decoy
	bool decoyNessieOutfit = false
	// holospray
	bool holoSprayEnabled = false
	// holding prop
	bool holdingPropsEnabled = false

	// entities, no need to change default value
	array<entity> nessieDolls
	array<entity> funnyFlags

	table< entity, table<int, entity> > entOwnedNessieCostumes

	// WIP: rework nessie effects
	table< entity, table< int, array<entity> > > entOwnedNessieEffects

	array<NessyFX> nessyfxs
	array<NessyMix> nessymixs

	// cooldowns
	array<entity> holoSprayedPlayer
} file

// valid models array
const array<asset> NESSIE_PLACEMENTS = 
[
	$"models/domestic/nessy_doll.mdl", 
	$"models/robots/drone_frag/drone_frag.mdl",
	$"models/creatures/prowler/r2_prowler.mdl"
	$"models/robots/marvin/marvin.mdl", 
	$"models/weapons/sentry_frag/sentry_frag.mdl",
]
const array<asset> NESSIE_HAT_ASSETS = 
[
	$"models/domestic/nessy_doll.mdl", 
	$"models/robots/drone_frag/drone_frag.mdl", 
	$"models/weapons/sentry_frag/sentry_frag.mdl",
	$"models/robots/marvin/marvin.mdl", 
	$"models/creatures/prowler/r2_prowler.mdl", 
	$"models/weapons/data_knife/v_data_knife.mdl",
]
const array<asset> NESSIE_BACKPACK_ASSETS = 
[
	$"models/weapons/titan_sword/w_titan_sword_prime.mdl", 
	$"models/weapons/titan_sword/w_titan_sword.mdl", 
	$"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl", 
	$"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl", 
	$"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl", 
	$"models/weapons/titan_predator/w_titan_predator.mdl", 
	$"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl", 
	$"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl", 
	$"models/weapons/thr_40mm/w_thr_40mm.mdl", 
	$"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl",
	// added by northstar
	$"models/weapons/titan_arc_rifle/w_titan_arc_rifle.mdl",
	$"models/weapons/titan_triple_threat_og/w_titan_triple_threat_og.mdl",
]
const array<asset> NESSIE_WEAPON_ASSETS = 
[
	$"models/weapons/alternator_smg/w_alternator_smg.mdl", 
	$"models/weapons/p2011_auto/w_p2011_auto.mdl", 
	$"models/weapons/car101/w_car101.mdl", 
	$"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl", 
	$"models/weapons/doubletake/w_doubletake.mdl", 
	$"models/weapons/epg/w_epg.mdl", 
	$"models/weapons/hemlock_br/w_hemlock_br.mdl", 
	$"models/weapons/g2/w_g2a4.mdl", 
	$"models/weapons/m1a1_hemlok/w_hemlok.mdl", 
	$"models/weapons/hemlok_smg/w_hemlok_smg.mdl", 
	$"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl", 
	$"models/weapons/lstar/w_lstar.mdl", 
	$"models/weapons/mastiff_stgn/w_mastiff.mdl", 
	$"models/weapons/pulse_lmg/w_pulse_lmg.mdl", 
	$"models/weapons/rspn101/w_rspn101.mdl", 
	$"models/weapons/r101_sfp/w_r101_sfp.mdl", 
	$"models/weapons/p2011/w_p2011.mdl", 
	$"models/weapons/w1128/w_w1128.mdl", 
	$"models/weapons/pstl_sa3/w_pstl_sa3.mdl", 
	$"models/weapons/p2011sp/w_p2011sp.mdl", 
	$"models/weapons/auto_rocket_launcher_ARL/w_ARL.mdl", 
	$"models/weapons/at_rifle/w_at_rifle.mdl", 
	$"models/weapons/softball_at/w_softball_at.mdl", 
	$"models/weapons/vinson/w_vinson.mdl", 
	$"models/weapons/b3wing/w_b3wing.mdl", 
	$"models/weapons/wingman_elite/w_wingman_elite.mdl",
	// added by northstar
	$"models/weapons/shotgun_doublebarrel/w_shotgun_doublebarrel.mdl",
]

// effects array
const array<asset> NESSIE_EFFECT_ASSETS = 
[
	$"P_wpn_arcball_trail", 
	$"P_wpn_meteor_trail", 
	$"P_titan_sniper1",
]
const array<asset> NESSIE_EFFECT_MIX_BASE = // when mixing effects, these will be basic effect
[
	$"titan_sniper_CH_refract", 
	$"titan_sniper_CH_refract", 
	$"titan_sniper_CH_rope_smoke",
]
const array<asset> NESSIE_EFFECT_MIX_MLT = 
[
	$"P_proj_predator_alt_pwr", 
	$"P_projectile_lstar",
]
const array<asset> NESSIE_EFFECT_MIX_IMC = 
[
	$"titan_sniper_CH_trail_arc", 
	$"wpn_grenade_frag_blue", 
	$"P_doubletake_proj", 
	$"P_wpn_mflash_dbltake_FP_burn",
]

// settings array
const array<asset> HEAVY_PILOT_MODELS =
[
	$"models/humans/pilots/pilot_heavy_drex_m.mdl",
	$"models/humans/pilots/pilot_heavy_drex_f.mdl",
	$"models/humans/pilots/pilot_heavy_roog_f.mdl",
	$"models/humans/pilots/pilot_heavy_roog_m.mdl",
	$"models/humans/grunts/imc_grunt_shield_captain.mdl",
]
const array<asset> LIGHT_PILOT_MODELS =
[
	$"models/Humans/heroes/imc_hero_blisk.mdl",
	$"models/Humans/heroes/imc_hero_ash.mdl",
	$"models/humans/pilots/pilot_light_ged_f.mdl",
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/sp_medium_geist_f.mdl",
	$"models/humans/heroes/mlt_hero_sarah.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
]
const array<asset> MEDIUM_PILOT_MODELS = // mostly unused because after we filtering heavy&light model, the rest are mediums...
[

]
const array<asset> MODELS_HAVE_BIG_BACKPACK =
[
	$"models/humans/pilots/pilot_light_jester_m.mdl",
	$"models/humans/grunts/mlt_grunt_lmg.mdl",
	$"models/robots/spectre/imc_spectre.mdl",
]
const array<asset> MODELS_HAVE_SMALL_BACKPACK =
[
	$"models/humans/heroes/mlt_hero_jack.mdl",
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
]
const array<asset> MODELS_CAN_REMOVE_HEAD =
[
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_light_ged_f.mdl",
	$"models/humans/pilots/pilot_light_jester_m.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
	$"models/robots/spectre/imc_spectre.mdl",
]
const array<asset> MODELS_CANNOT_REMOVE_HELMET =
[
	$"models/humans/heroes/mlt_hero_sarah.mdl",
	$"models/Humans/heroes/imc_hero_blisk.mdl",
	$"models/Humans/heroes/imc_hero_ash.mdl",
]
const array<asset> MODELS_HAVE_EXTERNAL_HELMET =
[
	$"models/Humans/heroes/imc_hero_blisk.mdl",
]
const array<asset> MODELS_HAVE_FLAT_HEAD =
[
	$"models/robots/spectre/imc_spectre.mdl",
]

const array<asset> PILOT_WEAPON_MODELS =
[
	$"models/weapons/alternator_smg/w_alternator_smg.mdl", 
	$"models/weapons/p2011_auto/w_p2011_auto.mdl", 
	$"models/weapons/car101/w_car101.mdl", 
	$"models/weapons/rspn101_dmr/w_rspn101_dmr.mdl", 
	$"models/weapons/doubletake/w_doubletake.mdl", 
	$"models/weapons/epg/w_epg.mdl", 
	$"models/weapons/hemlock_br/w_hemlock_br.mdl", 
	$"models/weapons/g2/w_g2a4.mdl", 
	$"models/weapons/m1a1_hemlok/w_hemlok.mdl", 
	$"models/weapons/hemlok_smg/w_hemlok_smg.mdl", 
	$"models/weapons/lmg_hemlok/w_lmg_hemlok.mdl", 
	$"models/weapons/lstar/w_lstar.mdl", 
	$"models/weapons/mastiff_stgn/w_mastiff.mdl", 
	$"models/weapons/pulse_lmg/w_pulse_lmg.mdl", 
	$"models/weapons/rspn101/w_rspn101.mdl", 
	$"models/weapons/r101_sfp/w_r101_sfp.mdl", 
	$"models/weapons/p2011/w_p2011.mdl", 
	$"models/weapons/w1128/w_w1128.mdl", 
	$"models/weapons/pstl_sa3/w_pstl_sa3.mdl", 
	$"models/weapons/p2011sp/w_p2011sp.mdl", 
	$"models/weapons/auto_rocket_launcher_ARL/w_ARL.mdl", 
	$"models/weapons/at_rifle/w_at_rifle.mdl", 
	$"models/weapons/softball_at/w_softball_at.mdl", 
	$"models/weapons/vinson/w_vinson.mdl", 
	$"models/weapons/b3wing/w_b3wing.mdl", 
	$"models/weapons/wingman_elite/w_wingman_elite.mdl",
	// added by northstar
	$"models/weapons/shotgun_doublebarrel/w_shotgun_doublebarrel.mdl",
]
const array<asset> PILOT_PISTOL_MODELS =
[
	$"models/weapons/b3wing/w_b3wing.mdl", 
	$"models/weapons/wingman_elite/w_wingman_elite.mdl", 
	$"models/weapons/p2011/w_p2011.mdl", 
	$"models/weapons/p2011_auto/w_p2011_auto.mdl", 
	$"models/weapons/pstl_sa3/w_pstl_sa3.mdl",
	// added by northstar
	$"models/weapons/shotgun_doublebarrel/w_shotgun_doublebarrel.mdl",
]
const array<asset> TITAN_WEAPON_MODELS
[
	$"models/weapons/titan_sword/w_titan_sword_prime.mdl", 
	$"models/weapons/titan_sword/w_titan_sword.mdl", 
	$"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl", 
	$"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl",
	$"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl", 
	$"models/weapons/titan_predator/w_titan_predator.mdl", 
	$"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl", 
	$"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl", 
	$"models/weapons/thr_40mm/w_thr_40mm.mdl", 
	$"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl",
	// added by northstar
	$"models/weapons/titan_arc_rifle/w_titan_arc_rifle.mdl",
	$"models/weapons/titan_triple_threat_og/w_titan_triple_threat_og.mdl",
]

// we could've use SetHumanRagdollImpactTable() instead of handling this everywhere...
//int RAGDOLL_IMPACT_TABLE_IDX = -1

void function EverythingNessy_Init()
{
	PrecacheSelectedModels()
	PrecacheSelectedParticles()
	PrecacheParticleSystem( FLAG_FX_FRIENDLY )
	PrecacheParticleSystem( FLAG_FX_ENEMY )

	Nessie_DecoyOutfitInit()

	AddCallback_OnClientConnected( OnClientConnected )

	// following things needs a setting to enable
	if ( !file.allSettingsEnabled )
		return

	if ( Riff_TitanAvailability() == eTitanAvailability.Never )
	{
		// disabled shield battery usage, since we added rodeo battery throw
		//SetPilotBatteryUsageAllowed( true ) // from pilot_shield_battery.gnut
		//SetShieldBatteryNoLimit( true ) // from pilot_shield_battery.gnut
	}

	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )
	AddCallback_OnPlayerKilled( OnPlayerKilled )
	AddCallback_OnPilotBecomesTitan( OnPilotBecomesTitan )
	AddCallback_OnTitanBecomesPilot( OnTitanBecomesPilot )

	if( IsNonFlagGamemode() )
		AddCallback_OnTouchHealthKit( "item_flag", OnFlagCollected )

	// we could've use SetHumanRagdollImpactTable() instead of handling this everywhere...
	//RAGDOLL_IMPACT_TABLE_IDX = PrecacheImpactEffectTable( "ragdoll_human" )

	// using _rodeo_titan.gnut for more fix about batteries
	//AddClientCommandCallback( "spawnbatt", SpawnBattery )
	//AddClientCommandCallback( "givebatt", GiveEmergencyBattery )
	//AddClientCommandCallback( "clearbatt", ClearBattery )
	//AddClientCommandCallback( "rgbnessie", SpawnRGBNessie ) // use a funnier nessie combo keys

	// satchel funny, related with batteries
	AddCallback_OnSatchelPlanted( OnSatchelPlanted )
	// custom suicide commands
	NessieCommands_EnableKillCommands( true )
	// funny commands
	NessieCommands_EnableUtilCommands( true )
	NessieFunny_EnableClientCommands( true )
}

void function Nessy_EnableAllFunny_Init()
{
	file.allSettingsEnabled = true
}

void function Nessie_ShouldDropPropOnClear( bool should )
{
	file.shouldDropPropOnClearNessy = should
}

void function Nessie_AlwaysSpawnRGBStuff( bool always )
{
	file.alwaysRGBSpawn = always
}

bool function IsNonFlagGamemode()
{
	if( GAMETYPE == "ctf" || GAMETYPE == "speedball" || GAMETYPE == "kr" )
		return false

	return true
}

bool function OnFlagCollected( entity player, entity flag )
{
	if ( !IsAlive( player ) || flag.GetParent() != null || player.IsTitan() || player.IsPhaseShifted() ) 
		return false

	//if ( player.GetTeam() != flag.GetTeam() && !expect bool( player.s.hasFlag ) ) 
	// no team check
	if ( !expect bool( player.s.hasFlag ) )
		thread CarryFlag( player, flag ) // pickup enemy flag

	return false // don't wanna delete the flag entity
}

void function CarryFlag( entity player, entity flag )
{
	print( player + " picked up the flag!" )

	flag.SetParent( player, "FLAG" )
	player.s.hasFlag = true
	player.EndSignal( "StartPhaseShift" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	// abandoned for now, keep showing the flag fx!
	//flag.SetOwner( player ) // stop fx for carrier
	//FunnyFlag_StopFX( flag )
	//entity curFlagFX = expect entity( flag.s.fxToHide )
	//if( IsValid( curFlagFX ) )
	//	curFlagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	//entity newFX = FunnyFlag_StartRandomFX( flag )
	//newFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	
	OnThreadEnd(
		function():( player, flag )
		{
			if( IsValid( flag ) )
			{
				flag.ClearParent()
				flag.SetOwner( null )
				flag.SetAngles( < 0, 0, 0 > )
				flag.SetVelocity( < 0, 0, 0 > )
				// abandoned for now, keep showing the flag fx!
				//FunnyFlag_StopFX( flag )
				//FunnyFlag_StartRandomFX( flag )
			}
			if( IsValid( player ) )
			{
				EmitSoundOnEntityOnlyToPlayer( player, player, "UI_CTF_1P_FlagDrop" )
				player.s.hasFlag = false
			}
		}
	)

	// do notifications
	EmitSoundOnEntityOnlyToPlayer( player, player, "UI_CTF_1P_GrabFlag" )
	AddPlayerScore( player, "FlagTaken" )

	WaitForever()
}

void function CallbackFuncSpawnFlag( entity player )
{
	if( !IsNonFlagGamemode() )
		return
	if( !file.flagSpawnEnabled )
		return
	if( !GamePlaying() )
		return
	if( IsValid( player.GetOffhandWeapon( OFFHAND_ANTIRODEO ) ) )
		return
	entity flag = CreateFunnyFlag( player )
	if( flag )
	{
		flag.SetVelocity( player.GetViewVector() * 1000 )
	}
}

void function Nessie_SetFunnyFlagEnabled( bool enabled )
{
	file.flagSpawnEnabled = enabled
}

entity function CreateFunnyFlag( entity player )
{
	// create flag
	entity flag = CreateEntity( "item_flag" )
	flag.SetValueForModelKey( CTF_FLAG_MODEL )
	flag.SetModel( CTF_FLAG_MODEL )
	SetTeam( flag, player.GetTeam() ) // don't set a team if want to make player himself can't see the fx
	flag.MarkAsNonMovingAttachment()
	//flag.Minimap_AlwaysShow( TEAM_IMC, null ) // show flag icon on minimap, for funny flags I say no need
	//flag.Minimap_AlwaysShow( TEAM_MILITIA, null )
	flag.Minimap_Hide( TEAM_IMC, null )
	flag.Minimap_Hide( TEAM_MILITIA, null )
	flag.Minimap_SetAlignUpright( true )
	FunnyFlag_StartRandomFX( flag )
	// abandoned for now, keep showing the flag fx!
	//entity randomFX
	//if( CoinFlip() )
	//	randomFX = PlayFXOnEntity( FLAG_FX_FRIENDLY, flag, "fx_end" )//StartParticleEffectOnEntity_ReturnEntity( flag, GetParticleSystemIndex( FLAG_FX_FRIENDLY ), FX_PATTACH_POINT_FOLLOW, attachID )
	//else
	//	randomFX = PlayFXOnEntity( FLAG_FX_ENEMY, flag, "fx_end" )//StartParticleEffectOnEntity_ReturnEntity( flag, GetParticleSystemIndex( FLAG_FX_ENEMY ), FX_PATTACH_POINT_FOLLOW, attachID )
	//flag.s.fxToHide <- randomFX
	DispatchSpawn( flag )
	flag.SetModel( CTF_FLAG_MODEL )
	flag.SetOrigin( player.EyePosition() ) // ensure flag doesn't spawn clipped into geometry
	int attachID = flag.LookupAttachment( "fx_end" )
	//flag.SetVelocity( < 0, 0, 1 > )
	
	file.funnyFlags.append( flag )
	CheckFunnyFlagsLimit()

	return flag
}

entity function FunnyFlag_StartRandomFX( entity flag )
{
	entity flagFX
	if( CoinFlip() )
	{
		flagFX = PlayLoopFXOnEntity( FLAG_FX_FRIENDLY, flag, "fx_end" )
		//flagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	}
	else
	{
		flagFX = PlayLoopFXOnEntity( FLAG_FX_ENEMY, flag, "fx_end" )
		//flagFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	}
	flag.e.fxArray.append( flagFX )

	return flagFX
}

void function FunnyFlag_StopFX( entity flag )
{
	foreach( entity fx in flag.e.fxArray )
	{
		if( IsValid( fx ) )
			EffectStop( fx )
	}

	flag.e.fxArray.clear()
}

void function CheckFunnyFlagsLimit()
{
	if( file.funnyFlags.len() > MAX_FUNNY_FLAGS )
	{
		for( int i = 0; i < file.funnyFlags.len() - 1; i++ )
		{
			if( !IsValid( file.funnyFlags[i] ) )
			{
				file.funnyFlags.remove( i )
				continue
			}
			if( file.funnyFlags[i].GetParent() ) // assuming this is a flag carried by players
				continue
			file.funnyFlags[i].Destroy()
			break
		}
	}
}

void function CallbackFuncThrowHoloSpray( entity player )
{
	if ( !file.holoSprayEnabled )
		return

	if ( IsValid( player.GetOffhandWeapon( OFFHAND_ANTIRODEO ) ) ) // hardcode for offhand_antirodeo
		return

	if ( file.holoSprayedPlayer.contains( player ) ) // cooldown
		return
	ThrowHoloSprayForPlayer( player )
	AddHoloSprayCooldown( player ) // cooldown
}

void function AddHoloSprayCooldown( entity player )
{
	if ( file.holoSprayedPlayer.contains( player ) )
		return

	file.holoSprayedPlayer.append( player )
	thread CleanUpPlayerHoloSprayCooldown( player )
}

void function CleanUpPlayerHoloSprayCooldown( entity player )
{
	player.EndSignal( "OnDestroy" )
	wait 2 // at least wait for last spray dissolve
	file.holoSprayedPlayer.removebyvalue( player )
}

void function Nessie_SetHoloSprayEnabled( bool enabled )
{
	file.holoSprayEnabled = enabled
}

void function Nessie_SetHoldingPropsEnabled( bool enabled )
{
	file.holdingPropsEnabled = enabled
	HoldingProp_SetUseNotSolidHolding( enabled ) // bind together
}

void function OnClientConnected( entity player )
{
	// nessie
	AddButtonPressedPlayerInputCallback( player, IN_USE, CallbackFuncSpawnNessy )
	AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, CallbackFuncSpawnNessy )
	// battery
	AddButtonPressedPlayerInputCallback( player, IN_MELEE, CallbackFuncSpawnBattery )
	AddPlayerHeldButtonEventCallback( player, IN_MELEE, CallbackFuncThrowBattery, 0.5 ) // should only be use this if disabled primary melee?
	// flag
	player.s.hasFlag <- false
	AddButtonPressedPlayerInputCallback( player, IN_OFFHAND2, CallbackFuncSpawnFlag )
	// ragdoll... not using
	//AddButtonPressedPlayerInputCallback( player, IN_MELEE, CallbackFuncSpawnRagdoll )
	// holospray, was IN_OFFHAND0
	AddButtonPressedPlayerInputCallback( player, IN_OFFHAND2, CallbackFuncThrowHoloSpray )
}

void function OnPlayerRespawned( entity player )
{

}

void function OnPlayerChangeLoadout( entity player, PilotLoadoutDef p )
{
	SpawnNessyCostume( player )
}

void function Nessie_DecoyOutfitInit()
{
	// modified callbacks in mp_ability_holopilot.nut
	AddCallback_OnDecoyCreated( SpawnDecoyOutfit )
	AddCallback_PlayerDecoyDie( DecoyOutfitCleanUp )
	AddCallback_PlayerDecoyDissolve( DecoyOutfitCleanUp )

	// this has been removed, AddCallback_OnDecoyCreated() can handle everything!
	//AddCallback_OnModdedDecoyCreated( SpawnDecoyOutfit ) // separented callback
}

void function SpawnDecoyOutfit( entity player, entity decoy )
{
	if ( file.decoyNessieOutfit || file.allSettingsEnabled )
		SpawnNessyCostume( decoy )
}

void function DecoyOutfitCleanUp( entity decoy, int currentState )
{
	// decoy won't call "OnDeath", have to manually destroy outfit
	ClearNessyCostume( decoy )
}

void function Nessie_SetDecoyOutfit( bool set )
{
	file.decoyNessieOutfit = set
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{

}

void function OnPilotBecomesTitan( entity player, entity titan )
{
	// this clean up has been handled by TrackNessyCostumeOwner()
	//ClearNessyCostume( player )
}

void function OnTitanBecomesPilot( entity titan, entity player )
{
	//AllFunctionsTogether( player )
	SpawnNessyCostume( player )
}

void function PrecacheSelectedModels()
{
	foreach( asset model in NESSIE_PLACEMENTS )
	{
		PrecacheModel( model )
	}
	foreach( asset model in NESSIE_HAT_ASSETS )
	{
		PrecacheModel( model )
	}
	foreach( asset model in NESSIE_BACKPACK_ASSETS )
	{
		PrecacheModel( model )
	}
	foreach( asset model in NESSIE_WEAPON_ASSETS )
	{
		PrecacheModel( model )
	}
}

void function PrecacheSelectedParticles()
{
	foreach( asset particle in NESSIE_EFFECT_ASSETS )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in NESSIE_EFFECT_MIX_BASE )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in NESSIE_EFFECT_MIX_MLT )
	{
		PrecacheParticleSystem( particle )
	}
	foreach( asset particle in NESSIE_EFFECT_MIX_IMC )
	{
		PrecacheParticleSystem( particle )
	}
}

void function SpawnNessyCostume( entity ent )
{
	thread SpawnNessyCostume_Threaded( ent )
}

void function SpawnNessyCostume_Threaded( entity ent )
{
	ClearNessyCostume( ent ) // defensive clear!
	WaitFrame() // better wait for model stuffs set up, we have "altpilot"
	if( !IsAlive( ent ) )
		return
	if( ent.IsTitan() )
		return

	CreateNessyHat( ent )
	CreateNessyBackpack( ent )
	thread TrackNessyCostumeOwner( ent )
}

void function TrackNessyCostumeOwner( entity ent )
{
	ent.EndSignal( "OnDestroy" ) // destroyed ent gets their children destroyed, no worries

	OnThreadEnd
	(
		function(): ( ent )
		{
			if ( IsValid( ent ) )
				ClearNessyCostume( ent )
		}
	)

	while ( true )
	{
		// when owner entity dies, should clear
		// use looping case is to make death callbacks able to go through
		if ( !IsAlive( ent ) )
			return

		// when a player starts embarking, needs to clear their nessy costume
		if( ent.IsPlayer() && ent.p.isEmbarking )
			return
	}
}

void function CreateNessyEffects( entity player )
{
	CreateNessyFX( NESSIE_EFFECT_ASSETS, player )
	CreateNessyPistol( NESSIE_WEAPON_ASSETS, player )
}

bool function SpawnBattery( entity player, array<string> args )
{
	// no battery spawn allowed in titan Gamemodes
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return false
	//if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		//return false
	if( !file.batterySpawnEnabled )
		return false
	if( !GamePlaying() )
		return false

	if( !(args.len() == 0) )
	{
		bool isPickup = false
		bool isThrow = false
		if( args.contains( "pickup" ) )
			isPickup = true
		if( args.contains( "throw" ) )
			isThrow = true
		
		entity battery = Rodeo_CreateBatteryPack( player, isPickup, true )
		if( isThrow )
		{
			if( battery )
			{
				vector batteryVel = player.GetViewVector() * 1000
				battery.SetVelocity( batteryVel )
				//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_NONE
			}
		}
		print( "[NESSIE] " + player.GetPlayerName() + " modified spawning a battery!" )
	}
	else
	{
		Rodeo_CreateBatteryPack( player )
		print( "[NESSIE] " + player.GetPlayerName() + " spawned a battery!" )
	}

	return true
}

bool function GiveEmergencyBattery( entity player, array<string> args )
{
	// no battery spawn allowed in titan Gamemodes
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return false
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	PlayerInventory_PushInventoryItemByBurnRef( player, "burnmeter_emergency_battery" )
	print( "[NESSIE] " + player.GetPlayerName() + " give themselves an emergency battery!" )
	return true
}

bool function ClearBattery( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	if( !GamePlaying() )
		return false

	foreach ( entity battery in GetEntArrayByClass_Expensive( "item_titan_battery" ) )
		battery.Destroy() // there's some fix in _rodeo_titan.gnut
	foreach( entity player in GetPlayerArray() )
	{
		while( GetPlayerBatteryCount( player ) > 0 )
		{
			entity battery = Rodeo_TakeBatteryAwayFromPilot( player )
			if( IsValid( battery ) )
				battery.Destroy()
		}
	}

	PilotBattery_SetMaxCount( 1 )
	print( "[NESSIE] " + player.GetPlayerName() + " cleared all batteries!" )
	
	return true
}

bool function SpawnRGBNessie( entity player, array<string> args )
{
	entity Prop = CreateEntity( "prop_dynamic" )
	Prop.SetValueForModelKey( $"models/domestic/nessy_doll.mdl" )
	Prop.kv.rendercolor = "81 130 151"   
	vector angles = player.EyeAngles()
	vector origin = GetPlayerCrosshairOrigin( player )
	angles.x = 0;
	angles.y += 90
	angles.z = 0;
	origin.z += -30
	Prop.SetOrigin( origin )
	Prop.SetAngles( angles )
	DispatchSpawn( Prop )
	SetTeam( Prop, player.GetTeam() )
	thread RGB_Highlight( Prop, true )
	file.nessieDolls.append( Prop )

	NessieLimitThink()
	return true
}

void function CallbackFuncSpawnNessy( entity player )
{
	// holding prop
	if ( file.holdingPropsEnabled )
	{
		bool playerCrouching = player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )
		if ( IsValid( HoldingProp_GetPlayerPickedProp( player ) ) ) // already holding someting!
		{
			HoldingProp_PlayerDropPickedEntity( player ) // cause it to drop
			return
		}
		else if ( playerCrouching ) // triggering pickup when crouched
		{
			if ( HoldingProp_PlayerTryPickUpEntity( player ) ) // player successfully picked up something!
				return // never do nessie spawn
		}
	}

	if ( !file.nessieSpawnEnabled && !file.allSettingsEnabled ) // bind together with allSettingsEnabled
		return

	// for rgb nessie check
	bool badCombo = ( (player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )) && player.IsInputCommandHeld( IN_SPEED ) && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_ATTACK ) )
	bool goodCombo = ( ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_JUMP ) && player.IsInputCommandHeld( IN_BACK ) && player.IsInputCommandHeld( IN_MELEE ) )
	bool isMoving = ( player.IsSliding() || player.IsWallRunning() || !player.IsOnGround() ) && !player.IsZiplining()
	//print( badCombo )
	//print( goodCombo )

	asset spawnAsset = NESSIE_PLACEMENTS[ RandomInt( NESSIE_PLACEMENTS.len() ) ]
	if ( file.alwaysSpawnNessyDoll ) // nessie only!
		spawnAsset = $"models/domestic/nessy_doll.mdl"

	entity nessie = CreateEntity( "prop_dynamic" )
	nessie.SetValueForModelKey( spawnAsset )
	//nessie.SetValueForModelKey( $"models/domestic/nessy_doll.mdl" )
	//nessie.kv.rendercolor = "81 130 151"   

	// hardcoded here...
	float modelScale = 1.0
	switch ( spawnAsset )
	{
		case $"models/creatures/prowler/r2_prowler.mdl":
			modelScale = 0.2
			break
		case $"models/robots/drone_frag/drone_frag.mdl":
		case $"models/robots/marvin/marvin.mdl":
			modelScale = 0.3
			break
		case $"models/weapons/sentry_frag/sentry_frag.mdl":
			modelScale = 0.35
			break
	}
	nessie.kv.modelscale = modelScale

	// angles offset
	float yawOffset = -180 // default value
	float physicsYawOffset = 180
	switch ( spawnAsset )
	{
		case $"models/domestic/nessy_doll.mdl":
			yawOffset = 90
			physicsYawOffset = 90 // facing the thrower
			break
	}
	// vertical offset( static )
	float verticleOffset = -32
	// origin offset( with physics )
	vector parentedOffset = < 0, 0, -10 >
	switch ( spawnAsset )
	{
		case $"models/creatures/prowler/r2_prowler.mdl":
			parentedOffset = < 5, 0, -8 >
			break
		case $"models/domestic/nessy_doll.mdl":
			parentedOffset = < 0, 0, -3 >
			break
		case $"models/weapons/sentry_frag/sentry_frag.mdl":
			parentedOffset = < 0, 0, -8 >
			break
	}
	
	SetTeam( nessie, player.GetTeam() )
	if( isMoving )
	{
		// attach nessie to physics
		entity physics = AttachPhysicsToNessieProp( nessie )

		// update pos
		nessie.SetAngles( < 0, physicsYawOffset, 0 > ) // rotate
		nessie.SetOrigin( parentedOffset ) // offset

		// throw forward
		physics.SetOrigin( player.EyePosition() + player.GetViewVector() * 100 + < 0,0,40 > ) // don't spawn so close, or it will interrupt zipline
		physics.SetAngles( < 0, player.EyeAngles().y, 0 > )
		physics.SetVelocity( player.GetViewVector() * 1000 )

		// test
		//entity test = CreateEntity( "prop_dynamic" )
		//test.SetValueForModelKey( $"models/weapons/bullets/mgl_grenade.mdl" )
		//test.SetParent( physics, "origin" )
		//DispatchSpawn( test )
		//test.SetModel( $"models/weapons/bullets/mgl_grenade.mdl" )
	}
	else
	{
		vector angles = player.EyeAngles()
		vector origin = GetPlayerCrosshairOrigin( player )
		//nessie.kv.modelscale = 50
		//Highlight_SetFriendlyHighlight( nessie, "health_pickup" )
		angles.x = 0
		// defensive fix!
		angles.y += yawOffset
		angles.y = ClampAngle( angles.y )
		
		//print( angles.y )
		angles.z = 0
		origin.z += verticleOffset
		nessie.SetOrigin( origin )
		nessie.SetAngles( angles )
	}

	DispatchSpawn( nessie )
	if ( spawnAsset == $"models/robots/marvin/marvin.mdl" ) // marvin's faces
		nessie.SetSkin( RandomIntRange( 1, 3 ) ) // happy and sad face, ttf2 only have these two faces

	if( badCombo || file.alwaysRGBSpawn )
		thread RGB_Highlight( nessie, true )
	if( goodCombo )
	{
		EmitSoundOnEntityOnlyToPlayer( player, player, "UI_Spawn_FriendlyPilot" )
		thread RainbowPlayerSkin( player )
		thread RainbowWeaponSkin( player )
	}

	file.nessieDolls.append( nessie )

	//thread DelayedDissolveNessie( nessie )
	NessieLimitThink()
}

entity function AttachPhysicsToNessieProp( entity nessie )
{
	entity physics = CreateEntity( "prop_physics" )
	physics.SetValueForModelKey( $"models/dev/empty_physics.mdl" )
	physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
	physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS // cannot block weapons, not work why?
	//physics.NotSolid() // so they won't block bullets, but also make them can't be pushed
	DispatchSpawn( physics )
	physics.SetModel( $"models/dev/empty_physics.mdl" )

	// attach nessie
	nessie.SetParent( physics, "origin" )
	thread NessiePhysicsLifeTimeCheck( physics, nessie )

	return physics
}

void function NessiePhysicsLifeTimeCheck( entity physics, entity nessie )
{
	nessie.EndSignal( "OnDestroy" )
	physics.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( nessie, physics )
		{
			if( IsValid( nessie ) )
				nessie.Destroy()
			if( IsValid( physics ) )
				physics.Destroy()
		}
	)

	WaitForever()
}

void function Nessie_SetNessieSpawnEnabled( bool enabled )
{
	file.nessieSpawnEnabled = enabled
}

void function Nessie_SetAlwaysSpawnNessyDoll( bool spawnNessyDoll )
{
	file.alwaysSpawnNessyDoll = spawnNessyDoll
}

void function Nessie_SetWorldMaxNessieCount( int count )
{
	file.worldMaxNessieCount = count
}

void function CallbackFuncSpawnBattery( entity player )
{
	if( !file.batterySpawnEnabled )
		return
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return

	entity battery = Rodeo_CreateBatteryPack( player, false, true )
	bool badCombo = ((player.IsInputCommandHeld( IN_DUCKTOGGLE ) || player.IsInputCommandHeld( IN_DUCK )) && player.IsInputCommandHeld( IN_SPEED ) && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) && player.IsInputCommandHeld( IN_ATTACK ))
	if ( !IsValid( battery ) ) // battery won't be returned if it's picked up by player immediately
		battery = GetBatteryOnBack( player )
	if( IsValid( battery ) )
	{
		// never blocks bullet, but also unable to stack batteries. won't work!
		//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS
		//battery.kv.CollisionGroup = TRACE_COLLISION_GROUP_NONE
		if ( !IsValid( battery.GetParent() ) ) // don't reset velocity if it's bind with something(eg. player)
		{
			vector batteryVel = player.GetViewVector() * 1000
			battery.SetVelocity( batteryVel )
		}
		battery.SetBossPlayer( player ) // add a boss player for this battery! we can track satchel planting later
		if( badCombo || file.alwaysRGBSpawn ) // rgb combo!
		{
			thread RGY_BatterySkin( battery )
			thread TrackRGYBatteryOwnerAttach( battery )
		}
		else // random skin!
			battery.SetSkin( RandomInt(3) )
		HoldingProp_SetEntityCanBePickedUpForced( battery, true ) // make battery pickupable
	}
}

void function TrackRGYBatteryOwnerAttach( entity battery )
{
	battery.EndSignal( "OnDestroy" )

	entity lastTickParent
	while ( true )
	{

	}
}

void function CallbackFuncThrowBattery( entity player )
{
	// leave the same check as spawnbattery does
	if( !file.batterySpawnEnabled )
		return
	if ( !(Riff_TitanAvailability() == eTitanAvailability.Never) )
		return

	Rodeo_PilotThrowsBattery( player )
}

void function Nessie_SetBatterySpawnEnabled( bool enabled )
{
	file.batterySpawnEnabled = enabled
}

// satchel funny related with batteries
// function has been modified in mp_weapon_satchel.nut
void function OnSatchelPlanted( entity owner, entity satchel, table collisionParams )
{
	//print( "RUNNING OnSatchelPlanted()" )
	// satchel planted on battery!
	if ( file.batterySpawnEnabled )
	{
		entity hitEnt = expect entity( collisionParams.hitEnt )
		//print( "hitEnt: " + string( hitEnt ) )
		if ( IsValid( hitEnt ) && hitEnt.GetClassName() == "item_titan_battery" )
		{
			entity bossPlayer = hitEnt.GetBossPlayer() // battery spawn from this file will have a boss player
			//print( "bossPlayer: " + string( bossPlayer ) )
			if ( IsValid( satchel ) && IsValid( bossPlayer ) && bossPlayer == owner )
			{
				satchel.ClearParent()
				string attachment = "vent_center"
				vector offset = < 0, 0, 0 >
				vector angles = < 0, 0, -90 >
				if ( bossPlayer.LookupAttachment( "vent_center" ) < 0 ) // anti-crash
				{
					attachment = "CHESTFOCUS"
					offset = < -13, 0, -5 >
					angles = < 0, -180, 0 >
				}
				satchel.SetParent( bossPlayer, attachment )
				satchel.SetOrigin( offset )
				satchel.SetAngles( angles )

				// attach a bigger satchel!
				asset satchelModel = satchel.GetModelName()
				entity biggerSatchel = CreateEntity( "prop_dynamic" )
				biggerSatchel.SetModel( satchelModel )
				DispatchSpawn( biggerSatchel )
				
				attachment = "CHESTFOCUS"
				offset = < -13, 0, -5 >
				angles = < 0, -180, 0 >
				biggerSatchel.SetParent( bossPlayer, attachment )
				biggerSatchel.SetOrigin( offset )
				biggerSatchel.SetAngles( angles )
				biggerSatchel.Highlight_SetInheritHighlight( true )
				biggerSatchel.kv.modelscale = 3
				thread TrackSatchelLifeTime( satchel, biggerSatchel )
			}
		}
	}
}

void function TrackSatchelLifeTime( entity satchel, entity biggerSatchel )
{
	biggerSatchel.EndSignal( "OnDestroy" )
	satchel.WaitSignal( "OnDestroy" )
	//biggerSatchel.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
	biggerSatchel.Destroy()
}

void function CallbackFuncSpawnRagdoll( entity player )
{
	thread SpawnRagdoll_Threaded( player )
}

void function SpawnRagdoll_Threaded( entity player )
{
	entity copyModel = player.CreatePlayerDecoy( 1 )//CreateCopyOfPlayerModel( player )
	vector curVelocity = player.GetVelocity()
	copyModel.EndSignal( "OnDestroy" )
	OnThreadEnd(
		function(): ()
		{
			print( "Copy Model has been destroyed!" )
		}
	)
	copyModel.SetOrigin( player.GetOrigin() )
	copyModel.SetAngles( player.GetAngles() )
	wait 0.2
	copyModel.Anim_Play( "ACT_MP_MELEE_KNIFE_FIRST" )
	//copyModel.BecomeRagdoll( < 0,0,0 >, false )
	HideName( copyModel )
	WaitForever()
	//copyModel.SetActivityModifier( ACT_MODIFIER_STAGGER, true ) // not for a propDynamic
	//wait 2
	SetHumanRagdollImpactTable( copyModel )
	//copyModel.SetContinueAnimatingAfterRagdoll( true )
	//
}

entity function CreateCopyOfPlayerModel( entity player )
{
	entity model = CreatePropDynamic( player.GetModelName() )

	SetTeam( model, player.GetTeam() )

	//model.SetSkin( player.GetSkin() )
	//model.SetCamo( player.GetCamo() )

	//RandomizeHead( model )

	return model
}

void function DelayedDissolveNessie( entity nessy )
{
	wait 10
	if( IsValid( nessy ) )
		nessy.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 100 )
}

void function NessieLimitThink()
{
	if( file.nessieDolls.len() > file.worldMaxNessieCount )
	{
		if( IsValid( file.nessieDolls[0] ) )
			file.nessieDolls[0].Destroy()
		file.nessieDolls.remove(0)
	}
}

void function AllFunctionsTogether( entity player )
{
	CreateNessyHat( player )
	CreateNessyBackpack( player )
	CreateNessyPistol( NESSIE_WEAPON_ASSETS, player )
	CreateNessyPrimary( NESSIE_WEAPON_ASSETS, player )

	// WIP rework
	if( IsFFAGame() )
		CreateNessyFX( NESSIE_EFFECT_ASSETS, player )
	else
		CreateMixedNessyFX( NESSIE_EFFECT_MIX_BASE, NESSIE_EFFECT_MIX_MLT, NESSIE_EFFECT_MIX_IMC, player )
}

void function CreateNessyCostumeForType( entity player, array<asset> randomModels, int specifiedType )
{
	InitNessyCostumeForEnt( player, specifiedType )

	// if player already have a costume at that slot, clear them
	ClearNessyCostume( player, specifiedType )

	entity modelName = NESSIE_HAT_ASSETS[ RandomInt( NESSIE_HAT_ASSETS.len() ) ]
	entity prop = CreatePropDynamic( modelName )

	// currently hardcoded for each type
	switch ( specifiedType )
	{
		case eNessieType.NESSIE_HAT:
			SetNessyHatStats( prop, player )
			break

		//case 
	}
	prop.Highlight_SetInheritHighlight( true )

	file.entOwnedNessieCostumes[ player ][ specifiedType ].append( prop )
}

void function InitNessyCostumeForEnt( entity ent, int cosType = -1 )
{
	if ( !( ent in file.entOwnedNessieCostumes ) )
		file.entOwnedNessieCostumes[ ent ] <- {}

	if ( cosType != -1 )
	{
		if ( !( cosType in file.entOwnedNessieCostumes[ ent ] ) )
			file.entOwnedNessieCostumes[ cosType ]
	}
}

// WIP rework
void function InitNessyEffectForEnt( entity ent )
{
	//if ( !( ent in file.entOwnedNessieCostumes ) )

}

void function CreateNessyHat( entity player )
{
	CreateNessyCostumeForType( player, NESSIE_HAT_ASSETS, eNessieType.NESSIE_HAT )
}

void function SetNessyHatStats( entity prop, entity owner )
{
	prop.SetParent( owner, "HEADSHOT" )

	asset modelName = prop.GetModelName()
	// if we have a external helmet... try to enable it if our given model is empty
	/*
	if ( nessy.modelasset == $"" && HasExternalHelmet( owner ) )
	{
		owner.SetBodygroup( owner.FindBodyGroup( "helmet" ), 1 )
		return
	}
	*/
	// if we have a external helmet... try to enable it 
	if ( HasExternalHelmet( owner ) && CoinFlip() )
		owner.SetBodygroup( owner.FindBodyGroup( "helmet" ), 1 )

	if ( CanRemoveHead( owner ) )
	{
		switch( modelName )
		{
			case $"models/domestic/nessy_doll.mdl":
				owner.SetBodygroup( GetRemovableHeadBodyGroupId( owner ), 1 ) // remove head
				prop.SetOrigin( < 0, 0, -10 > )
				prop.SetAngles( < 0, -90, 0 > )
				break
			
			case $"models/robots/drone_frag/drone_frag.mdl":
				owner.SetBodygroup( GetRemovableHeadBodyGroupId( owner ), 1 ) // remove head
				prop.SetOrigin( < 0, 0, -15 > )
				prop.kv.modelscale = 0.3
				break

			case $"models/weapons/sentry_frag/sentry_frag.mdl":
				owner.SetBodygroup( GetRemovableHeadBodyGroupId( owner ), 1 ) // remove head
				prop.SetOrigin( < 0, 0, -12 > )
				prop.kv.modelscale = 0.35
				break

			case $"models/robots/marvin/marvin.mdl":
				owner.SetBodygroup( GetRemovableHeadBodyGroupId( owner ), 1 ) // remove head
				prop.SetOrigin( < -5, 0, -25 > )
				prop.kv.modelscale = 0.4
				thread TrackMarvinOwnerDamaged( owner, prop )
				break

			case $"models/creatures/prowler/r2_prowler.mdl":
				owner.SetBodygroup( GetRemovableHeadBodyGroupId( owner ), 0 ) // give head back
				if ( HasFlatHead( owner ) ) // spectre
					prop.SetOrigin( < 0, 0, 1 > )
				else
					prop.SetOrigin( < 0, 0, 3 > )
				prop.kv.modelscale = 0.15
				break

			case $"models/weapons/data_knife/v_data_knife.mdl":
				owner.SetBodygroup( GetRemovableHeadBodyGroupId( owner ), 0 ) // give head back
				if ( HasFlatHead( owner ) ) // spectre
					prop.SetOrigin( < 2, 0, 5 > )
				else
					prop.SetOrigin( < 2, 0, 7 > )
				prop.SetAngles( < 0, 0, 0 > )
				return
		}
	}
	else if( CannotRemoveHelmet( owner ) )
	{
		switch( modelName )
		{
			case $"models/domestic/nessy_doll.mdl":
				prop.SetOrigin( < 0, 0, 0 > )
				break

			case $"models/robots/drone_frag/drone_frag.mdl":
				prop.SetOrigin( < 0, 0, -3 > )
				prop.kv.modelscale = 0.3
				break

			case $"models/weapons/sentry_frag/sentry_frag.mdl":
				prop.SetOrigin( < 0, 0, -1 > )
				prop.kv.modelscale = 0.35
				break

			case $"models/robots/marvin/marvin.mdl":
				prop.SetOrigin( < 0, 0, -10 > )
				prop.kv.modelscale = 0.3
				thread TrackMarvinOwnerDamaged( owner, prop )
				break

			case $"models/creatures/prowler/r2_prowler.mdl"
				prop.SetOrigin( < 0, 0, 3 > )
				prop.kv.modelscale = 0.15
				break

			case $"models/weapons/data_knife/v_data_knife.mdl"
				prop.SetOrigin( < 2, 0, 7 > )
				prop.SetAngles( < 0, 0, 0 > )
				break
		}
	}
	else if( HasFlatHead( owner ) )
	{
		switch( modelName )
		{
			case $"models/domestic/nessy_doll.mdl":
				prop.SetOrigin( < 0, 0, 0 > )
				break

			case $"models/robots/drone_frag/drone_frag.mdl":
				prop.SetOrigin( < 0, 0, -5 > )
				prop.kv.modelscale = 0.3
				break

			case $"models/weapons/sentry_frag/sentry_frag.mdl":
				prop.SetOrigin( < 0, 0, -3 > )
				prop.kv.modelscale = 0.35
				break

			case $"models/robots/marvin/marvin.mdl":
				prop.SetOrigin( < 0, 0, -12 > )
				prop.kv.modelscale = 0.3
				thread TrackMarvinOwnerDamaged( owner, prop )
				break

			case $"models/creatures/prowler/r2_prowler.mdl":
				prop.SetOrigin( < 0, 0, 1 > )
				prop.kv.modelscale = 0.15
				break

			case $"models/weapons/data_knife/v_data_knife.mdl":
				prop.SetOrigin( < 2, 0, 5 > )
				prop.SetAngles( < 0, 0, 0 > )
				break
		}
	}
	else
	{
		switch( modelName )
		{
			case $"models/domestic/nessy_doll.mdl":
				owner.SetBodygroup( owner.FindBodyGroup( "head" ), 0 ) // give helmet back
				prop.SetOrigin( < 0, 0, 0 > )
				break
			
			case $"models/robots/drone_frag/drone_frag.mdl":
				owner.SetBodygroup( owner.FindBodyGroup( "head" ), 1 ) // remove helmet
				prop.SetOrigin( < 0, 0, -3 > )
				prop.kv.modelscale = 0.3
				break
			
			case $"models/weapons/sentry_frag/sentry_frag.mdl":
				owner.SetBodygroup( owner.FindBodyGroup( "head" ), 1 ) // remove helmet
				prop.SetOrigin( < 0, 0, -1 > )
				prop.kv.modelscale = 0.35
				break
			
			case $"models/robots/marvin/marvin.mdl":
				owner.SetBodygroup( owner.FindBodyGroup( "head" ), 0 ) // give helmet back
				prop.SetOrigin( < 0, 0, -10 > )
				prop.kv.modelscale = 0.3
				thread TrackMarvinOwnerDamaged( owner, prop )
				break
			
			case $"models/creatures/prowler/r2_prowler.mdl":
				owner.SetBodygroup( owner.FindBodyGroup( "head" ), 0 ) // give helmet back
				prop.SetOrigin( < 0, 0, 3 > )
				prop.kv.modelscale = 0.15
				break
			
			case $"models/weapons/data_knife/v_data_knife.mdl":
				owner.SetBodygroup( owner.FindBodyGroup( "head" ), 1 ) // remove helmet
				prop.SetOrigin( < 2, 0, 7 > )
				prop.SetAngles( < 0, 0, 0 > )
				break
			
		}
	}
}

// switch marvin's face when owner damaged
void function TrackMarvinOwnerDamaged( entity owner, entity marvin )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDestroy" )

	while ( true )
	{
		waitthread MarvinUndamagedFace( owner, marvin )
		waitthread MarvinWounded( owner, marvin )
	}
}

void function MarvinUndamagedFace( entity owner, entity marvin )
{
	//print( "marvin is happy!" )
	owner.EndSignal( "OnDamaged" )
	marvin.SetSkin( 1 ) // happy face
	WaitForever()
}

void function MarvinWounded( entity owner, entity marvin )
{
	//print( "marvin is unhappy!" )
	marvin.SetSkin( 2 ) // sad face
	wait 2.3 // max duration
}

void function CreateNessyBackpack( entity player )
{
	CreateNessyCostumeForType( player, NESSIE_BACKPACK_ASSETS, eNessieType.NESSIE_BACKPACK )
}

void function SetNessyBackpackStats( entity prop, entity owner )
{
	prop.SetParent( owner, "CHESTFOCUS" )
	asset modelName = prop.GetModelName()

	if( HasBigBackpack( owner ) )
	{
		switch( modelName )
		{
			case $"models/weapons/titan_sword/w_titan_sword_prime.mdl":
			case $"models/weapons/titan_sword/w_titan_sword.mdl":
				const styleCount = 2
				switch( RandomInt( styleCount ) )
				{
					case 0:
						prop.SetOrigin( < -14, 10, 10 > )
						prop.SetAngles( < -135, 90, 0 > )
						break
					case 1:
						prop.SetOrigin( < -7, 8, 3 > )
						prop.SetAngles( < 180, 0, 0 > )
						break
				}
				prop.kv.modelscale = 0.3
				break
			
			case $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl":
				const styleCount = 2
				switch( RandomInt( styleCount ) )
				{
					case 0:
						prop.SetOrigin( < -13, 8, 8 > )
						prop.SetAngles( < 135, 90, 0 > )
						break
					case 1:
						prop.SetOrigin( < -8, 8, 6 > )
						prop.SetAngles( < 90, 0, 180 > )
						break
				}
				prop.kv.modelscale = 0.3
				break

			case $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl":
			case $"models/weapons/titan_triple_threat_og/w_titan_triple_threat_og.mdl"
				prop.SetOrigin( < -13, 8, 8 > )
				prop.SetAngles( < 135, 90, 0 > )
				prop.kv.modelscale = 0.3
				break
			
			default
				prop.SetOrigin( < -15, 10, 10 > )
				prop.SetAngles( < 135, 90, 0 > )
				prop.kv.modelscale = 0.3
				break
		}
	}
	else
	{
		switch( modelName )
		{
			case $"models/weapons/titan_sword/w_titan_sword_prime.mdl":
			case $"models/weapons/titan_sword/w_titan_sword.mdl":
				const styleCount = 2
				switch( RandomInt( styleCount ) )
				{
					case 0:
						if( IsHeavyPilot( owner ) || HasSmallBackpack( owner ) )
						{
							prop.SetOrigin( < -10, 10, 10 > )
							prop.SetAngles( < -135, 90, 0 > )
						}
						else
						{
							prop.SetOrigin( < -8, 10, 10 > )
							prop.SetAngles( < -135, 90, 0 > )
						}
						break

					case 1:
						if( IsHeavyPilot( owner ) )
						{
							prop.SetOrigin( < -5, 10, 3 > )
							prop.SetAngles( < 180, 0, 0 > )
						}
						if( IsLightPilot( owner ) )
						{
							prop.SetOrigin( < -4, 8, 3 > )
							prop.SetAngles( < 180, 0, 0 > )
						}
						else
						{
							prop.SetOrigin( < -7, 8, 3 > )
							prop.SetAngles( < 180, 0, 0 > )
						}
						break
				}
				prop.kv.modelscale = 0.3
				break

			case  $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
				const styleCount = 2
				switch( RandomInt( styleCount ) )
				{
					case 0:
						prop.SetOrigin( < -8, 8, 8 > )
						prop.SetAngles( < 135, 90, 0 > )
						break
					
					case 1:
						if( IsHeavyPilot( owner ) )
						{
							prop.SetOrigin( < -8, 10, 6 > )
							prop.SetAngles( < 90, 0, 180 > )
						}
						else
						{
							prop.SetOrigin( < -8, 7, 6 > )
							prop.SetAngles( < 90, 0, 180 > )
						}
						break
				}
				prop.kv.modelscale = 0.3
				break

			case $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl":
				prop.SetOrigin( < -8, 8, 8 > )
				prop.SetAngles( < 135, 90, 0 > )
				prop.kv.modelscale = 0.3
				break

			default:
				prop.SetOrigin( < -10, 10, 10 > )
				prop.SetAngles( < 135, 90, 0 > )
				prop.kv.modelscale = 0.3
				break
		}
	}
}

void function CreateNessyPistol( array<asset> modelassets, entity player )
{
	NessyPistol nessy
	nessy.owner = player
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.pistol = CreateEntity( "prop_dynamic" )
	nessy.pistol.SetModel( nessy.modelasset )
	nessy.pistol.SetParent( nessy.owner, "SIDEARM_HOLSTER" )
	nessy.pistol.Highlight_SetInheritHighlight( true )
	SetNessyPistolStats( nessy )
	file.nessypistols.append(nessy)
}

void function SetNessyPistolStats( NessyPistol nessy )
{
	nessy.pistol.SetOrigin( < 0, 0, 0 > )
	nessy.pistol.SetAngles( < 0, 0, 0 > )
	if( IsPilotPistol( nessy.modelasset ) )
	{
		nessy.pistol.kv.modelscale = 1.2
		return
	}
	else
	{
		nessy.pistol.kv.modelscale = 0.7
		return
	}
}

void function CreateNessyPrimary( array<asset> modelassets, entity player )
{
	NessyWeapon nessy
	nessy.modelasset = modelassets[ RandomInt(modelassets.len()) ]
	nessy.weapon = CreateEntity( "prop_dynamic" )
	nessy.weapon.SetModel( nessy.modelasset )
	nessy.owner = player
	nessy.weapon.SetParent( nessy.owner, "PROPGUN" )
	nessy.weapon.Highlight_SetInheritHighlight( true )
	SetNessyWeaponStats( nessy )
	file.nessyweapons.append(nessy)
}

void function SetNessyWeaponStats( NessyWeapon nessy )
{
	if( nessy.modelasset == $"models/domestic/nessy_doll.mdl" )
	{
		nessy.weapon.SetOrigin( <10, 0, 0> )
		return
	}
	if( nessy.modelasset == $"models/robots/drone_frag/drone_frag.mdl" )
	{
		nessy.weapon.SetOrigin( <10, 0, -5> )
		nessy.weapon.kv.modelscale = 0.3
		return
	}
}

void function CreateNessyFX( array<asset> NESSIE_EFFECT_ASSETS, entity player )
{
	NessyFX nessy
	asset fxasset = NESSIE_EFFECT_ASSETS[ RandomInt(NESSIE_EFFECT_ASSETS.len()) ]
	nessy.owner = player
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )

	nessy.fx = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( fxasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	nessy.fx.SetOwner( nessy.owner )
	nessy.fx.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only

	file.nessyfxs.append(nessy)
}

void function CreateMixedNessyFX( array<asset> mixbase, array<asset> mixmlt, array<asset> miximc, entity player )
{
	NessyMix nessy
	nessy.owner = player
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )

	foreach( asset baseasset in mixbase )
	{
		entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( baseasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		handle.SetOwner( nessy.owner )
		handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
		nessy.fxhandles.append( handle )
	}
	if( player.GetTeam() == TEAM_MILITIA )
	{
		foreach( asset mltasset in mixmlt )
		{
			entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( mltasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
			handle.SetOwner( nessy.owner )
			handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
			nessy.fxhandles.append( handle )
		}
	}
	if( player.GetTeam() == TEAM_IMC )
	{
		foreach( asset imcasset in miximc )
		{
			entity handle = StartParticleEffectOnEntity_ReturnEntity( nessy.owner, GetParticleSystemIndex( imcasset ), FX_PATTACH_POINT_FOLLOW, attachmentIndex )
			handle.SetOwner( nessy.owner )
			handle.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) // not owner only
			nessy.fxhandles.append( handle )
		}
	}
	file.nessymixs.append(nessy)
}

void function ClearNessyCostume( entity ent, int specifiedType = -1 )
{
	if ( !( ent in file.entOwnedNessieCostumes ) )
		return

	bool isDissolving = ent.IsDissolving() || IsPlayerDecoy( ent )
	
	array<entity> allCostumesForType
	// no type specified means we clear all costume
	if ( specifiedType = -1 )
	{
		for ( int i = 0; i < eNessieType.NESSIE_ALL_TYPES; i++ )
		{
			if ( i in file.entOwnedNessieCostumes[ ent ] )
				allCostumesForType = file.entOwnedNessieCostumes[ ent ][ i ]
		}
	}
	else
	{
		if ( specifiedType in file.entOwnedNessieCostumes[ ent ] )
			array<entity> allCostumesForType = file.entOwnedNessieCostumes[ ent ][ specifiedType ]
	}

	ArrayRemoveInvalid( allCostumesForType )
	foreach( prop in allCostumesForType )
	{
		if ( IsValid( prop ) )
			ClearNessyProp( prop, ent, isDissolving )
	}
}

void function ClearNessyProp( entity prop, entity owner = null, bool isDissolving = false )
{
	// drop prop version
	if ( file.shouldDropPropOnClearNessy )
	{
		vector dropDir = prop.GetUpVector()
		float dropSpeed = RandomFloatRange( 50, 100 )
		prop.ClearParent()

		// attach to a physics
		entity physics = AttachPhysicsToNessieProp( nessie )
		physics.NotSolid() // disable collision because they're gonna fadeout soon
		physics.SetVelocity( dropDir * dropSpeed )

		if ( isDissolving )
			thread DissolveNessieProp( prop ) // always dissolve immediately
		else
			thread FadeOutNessieProp( prop, NESSIE_PROP_FADEOUT_DELAY )
	}
	else // normal remove
	{
		if ( isDissolving )
			thread DissolveNessieProp( prop )
		else
			thread FadeOutNessieProp( prop )
	}

	// try to clear from owner owned array
	if ( IsValid( owner ) )
	{
		if ( owner in file.entOwnedNessieCostumes )
		{
			for ( int i = 0; i < eNessieType.NESSIE_ALL_TYPES; i++ )
			{
				if ( i in file.entOwnedNessieCostumes[ owner ] )
				{
					foreach ( int j, prop in file.entOwnedNessieCostumes[ owner ][ i ] )
						file.entOwnedNessieCostumes[ owner ][ i ].remove( j )
				}
			}
		}
	}
}

void function FadeOutNessieProp( entity prop, float delay = 0 )
{
	prop.EndSignal( "OnDestroy" )
	if ( delay > 0 )
		wait delay

	// function defined in prop_utility.gnut, taken from r5s3
	float currentAlpha = int( prop.kv.renderamt )
	waitthread PROTO_FadeModelAlphaOverTime( ent, 1.5, currentAlpha, 0 )
	// consider we've completely hide the prop, destroy it now
	prop.Destroy()
}

void function DissolveNessieProp( entity prop, float delay = 0 )
{
	prop.EndSignal( "OnDestroy" )
	if ( delay > 0 )
		wait delay

	prop.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
	prop.WaitSignal( "OnDestroy" ) // wait for destroy
}

// needs rework
void function ClearNessyEffect( entity ent )
{
	foreach( NessyFX nessy in file.nessyfxs )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.fx ) )
			{
				EffectStop( nessy.fx )
				file.nessyfxs.removebyvalue( nessy )
			}
		}
	}
	foreach( NessyMix nessy in file.nessymixs )
	{
		if(nessy.owner == player)
		{
			if( IsValid( nessy.fxhandles ) )
			{
				foreach( entity handle in nessy.fxhandles )
				{
					if( IsValid(handle) )
						EffectStop( handle )
				}
				file.nessymixs.removebyvalue( nessy )
			}
		}
	}
}

bool function IsHeavyPilot( entity player )
{
	asset playerModel = player.GetModelName()
	if( HEAVY_PILOT_MODELS.contains( playerModel ) )
		return true

	return false
}

bool function IsLightPilot( entity player )
{
	asset playerModel = player.GetModelName()
	if( LIGHT_PILOT_MODELS.contains( playerModel ) )
		return true

	return false
}

bool function HasBigBackpack( entity player )
{
	asset playerModel = player.GetModelName()
	if( MODELS_HAVE_BIG_BACKPACK.contains( playerModel ) )
		return true

	return false
}

bool function HasSmallBackpack( entity player )
{
	asset playerModel = player.GetModelName()
	if( MODELS_HAVE_SMALL_BACKPACK.contains( playerModel ) )
		return true

	return false
}

bool function CanRemoveHead( entity player )
{
	asset playerModel = player.GetModelName()
	if( MODELS_CAN_REMOVE_HEAD.contains( playerModel ) )
		return true

	return false
}

int function GetRemovableHeadBodyGroupId( entity player )
{
	int bodyGroupId = player.FindBodyGroup( "removableHead" )
	if ( bodyGroupId > -1 )
		return bodyGroupId
	bodyGroupId = player.FindBodyGroup( "head" )
	if ( bodyGroupId > -1 )
		return bodyGroupId
	
	return 0
}

bool function CannotRemoveHelmet( entity player )
{
	asset playerModel = player.GetModelName()
	if( MODELS_CANNOT_REMOVE_HELMET.contains( playerModel ) )
		return true

	return false
}

bool function HasExternalHelmet( entity player )
{
	asset playerModel = player.GetModelName()
	if( MODELS_HAVE_EXTERNAL_HELMET.contains( playerModel ) )
		return true

	return false
}

bool function HasFlatHead( entity player )
{
	asset playerModel = player.GetModelName()
	if( MODELS_HAVE_FLAT_HEAD.contains( playerModel ) )
		return true

	return false
}

bool function IsPilotWeapon( asset model )
{
	if( PILOT_WEAPON_MODELS.contains( model ) )
		return true

	return false
}

bool function IsPilotPistol( asset model )
{
	if( PILOT_PISTOL_MODELS.contains( model ) )
		return true

	return false
}

bool function IsTitanWeapon( asset model )
{
	if( TITAN_WEAPON_MODELS.contains( model ) )
		return true

	return false
}