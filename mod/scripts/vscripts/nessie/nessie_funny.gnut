global function Nessie_Funny_Functions_Init

// funny stuffs with clientcommand!
global function NessieFunny_EnableClientCommands

global function RGB_Highlight
global function TitleFlash

global function RainbowPlayerSkin
global function RainbowWeaponSkin

global function RGY_BatterySkin

// holoflash
global function HoloFlash_Loop
global function HoloFlash

// head
global function PlayerPulseBladeModel_HideBodyAndLegs
global function CreatePulseBladeHead
global function CreateWoundedHead
global function BindPulseBladeHeadToPlayer
global function BindeWoundedHeadToPlayer

// loadout
global function BecomeApexLegend

// rainbow dome
global function CreateRainbowDomeShield

// barrel spawn
global function CreatePhysicsBarrel

// player marvin
global function NessyFunny_EnableMarvinScriptedAnim // this may cause sound loss so need a setting
global function PlayerBecomesMarvin

global function NessyFunny_EnablePlayerTickDamageByDefault // THIS IS DEFAULT SETTING. remember that PlayerBecomesTick() parameters can bypass this
global function PlayerBecomesTick

// debug
const NESSIE_FUNNY_DEBUG = false

enum eMarvinMovement
{
	IDLE,

	// walking and spriting doesn't working fine
	// EDIT: walking has been fixed and sprinting is removed
	WALKING,
	SPRINTING,
	
	IN_AIR,

	WAVING,
	WELDING,
	WASHING_WINDOW,

	SCRIPTED_ANIMATION,

	_count_
}

struct MarvinIntroAnim
{
	string animName
	float initialTime = -1 // -1 means not modified
	float actualLength = -1 // -1 means not modified
	vector offset = < 0, 0, 0 >
	table<string, float> introSounds // have to manually control intro sounds... otherwise all players on map can hear it
	float introSoundRadius = 1500 // default value
}

// modifiable consts
const float MARVIN_INTRO_ANIM_COOLDOWN = 15.0 // gets applied after animation end

enum eTickMovement
{
	IDLE,
	WALKING,

	LANDING,
	JUMPING,

	OVERLOADING,

	_count_
}

struct TickOverloadBehavior
{
	float suicideChaseTime
	float suicideChaseSpeedScale
	float overloadDelayAdjustment
}

struct
{
	bool clientCommandsEnabled
	bool fakeMarvinScriptedAnimEnabled // this may cause sound loss so need a setting
	bool playerTickCanDoDamageByDefault // remember that PlayerBecomesTick() parameters can bypass this

	table<entity, bool> playerHasRGBHighlight
	table<entity, bool> playerHasRainbowSkin
	table<entity, bool> playerHasRGYBattery

	table<entity, entity> playerFlipperMover
	table<entity, entity> playerFakeNPC
	table<entity, bool> playerFakeNPCTookDamage

	table<entity, int> fakeMarvinMovementState
	table<entity, float> playerNextFakeMarvinScriptedAnimAllowedTime
	array<MarvinIntroAnim> marvinIntroAnims

	table<entity, int> fakeTickMovementState
	table<entity, TickOverloadBehavior> tickOverloadBehavior
	table<entity, bool> playerTickDoingSuicideChase
} file

void function Nessie_Funny_Functions_Init()
{
	// precaching
	PrecacheModel( ROCKET_TURRET_MODEL )

	// signals
	// rgb highlight
    RegisterSignal( "StartRGBHighlight" )
	RegisterSignal( "EndRGBHighlight" )
	AddClientCommandCallback( "rgbself", CC_SelfRGBHighlight )

	// sb title
    RegisterSignal( "StartSBTitle" )
	RegisterSignal( "EndSBTitle" )
	//AddClientCommandCallback( "sbself", CC_SelfIMSBTitle )

	// rainbow skin
	RegisterSignal( "StartRainbowPlayer" )
	RegisterSignal( "EndRainbowPlayer" )
	RegisterSignal( "StartRainbowWeapon" )
	RegisterSignal( "EndRainbowWeapon" )

	// rgy battery
	RegisterSignal( "StartRGYBattery" )
	RegisterSignal( "EndRGYBattery" )

	// holo flash
	RegisterSignal( "StartHoloFlash" )
	RegisterSignal( "EndHoloFlash" )

	// self flip
	RegisterSignal( "EndFlipper" )
	AddClientCommandCallback( "flipself", CC_FlipPlayerSelf )

	// barrel
	//PrecacheModel( $"models/containers/barrel.mdl" ) // always precache barrel model
	//AddClientCommandCallback( "spawnbarrel", CC_ThrowABarrel )

	// others
	//AddClientCommandCallback( "rainbowdome", CC_SpawnRainbowDome )
	AddClientCommandCallback( "nessycostume", CC_SpawnNessyCostume )

	// marvin
	InitMarvinIntroAnim()
	RegisterSignal( "MarvinPlayerMoveAnimThink" )
	AddClientCommandCallback( "becomemarvin", CC_PlayerBecomeFakeMarvin )

	// tick
	PrecacheParticleSystem( $"P_frag_drone_jump_jet" )
	RegisterSignal( "ClearTickPlayerTraverse" )
	RegisterSignal( "TickPlayerStartsOverload" )
	RegisterSignal( "OverloadingTickTookDamage" )
	RegisterSignal( "TickPlayerTimerRunsOut" )
	RegisterSignal( "TickPlayerJump" )
	RegisterSignal( "TickPlayerDoubleJump" )
	RegisterSignal( "TickPlayerTouchGround" )
	AddClientCommandCallback( "becometick", CC_PlayerBecomeFakeTick )

	// callbacks
	AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnDecoyCreated( OnDecoyCreated )
	// this has been removed, AddCallback_OnDecoyCreated() can handle everything!
	//AddCallback_OnModdedDecoyCreated( OnDecoyCreated )
	AddCallback_IsValidMeleeExecutionTarget( IsValidMeleeExecutionTarget )
	AddDamageCallback( "player", OnPlayerDamaged )

	// debug
	#if NESSIE_FUNNY_DEBUG
		AddCallback_OnPlayerRespawned( OnPlayerRespawned )
		SetPlayerDeathsHidden( true )
		SetDeathCamLengthForced( 0.1 )
		SetReplayStartDelayOverride( 1.0 )
		NessyFunny_EnablePlayerTickDamageByDefault( true )
	#endif
}

// callbacks
void function OnClientConnected( entity player )
{
	file.playerHasRGBHighlight[ player ] <- false
	file.playerHasRainbowSkin[ player ] <- false
	file.playerHasRGYBattery[ player ] <- false

	file.playerFlipperMover[ player ] <- null
	file.playerFakeNPC[ player ] <- null
	file.playerFakeNPCTookDamage[ player ] <- false

	file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] <- 0.0
	file.playerTickDoingSuicideChase[ player ] <- false
}

void function OnDecoyCreated( entity player, entity decoy )
{
	if ( IsValid( player ) )
	{
		// inherit rgb highlight to decoy
		if ( file.playerHasRGBHighlight[ player ] )
			thread RGB_Highlight( decoy, true )
		// inherit rainbow skin to decoy
		if ( file.playerHasRainbowSkin[ player ] )
			thread RainbowPlayerSkin( decoy )
		// inherit rgy battery to decoy
		if ( file.playerHasRGYBattery[ player ] )
		{
			var childEnt = decoy.FirstMoveChild()
			while ( childEnt != null )
			{
				expect entity( childEnt )

				//print( "childEnt: " + string( childEnt ) )
				//print( "childEnt.GetModelName(): " + string( childEnt.GetModelName() ) )
				bool isBattery = childEnt.GetModelName() == RODEO_BATTERY_MODEL
				if ( isBattery )
					thread RGY_BatterySkin( childEnt )
				
				childEnt = childEnt.NextMovePeer()
			}
		}
	}
}

bool function IsValidMeleeExecutionTarget( entity attacker, entity target )
{
	// prevent fake marvin player from executing each other
	if ( attacker.IsPlayer() && IsValid( file.playerFakeNPC[ attacker ] ) )
		return false

	if ( target.IsPlayer() && IsValid( file.playerFakeNPC[ target ] ) )
		return false
	
	return true
}

void function OnPlayerDamaged( entity player, var damageInfo )
{
	// if we have fake npc active, and damage isn't passed by them, we remove damage
	if ( IsValid( file.playerFakeNPC[ player ] ) && !file.playerFakeNPCTookDamage[ player ] )
	{
		// player still take trigger_hurt damage
		entity attacker = DamageInfo_GetAttacker( damageInfo )
		if ( IsValid( attacker ) )
		{
			string attackerClassname = attacker.GetClassName()
			if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
				return
		}

		DamageInfo_SetDamage( damageInfo, 0 )
	}
}

#if NESSIE_FUNNY_DEBUG
void function OnPlayerRespawned( entity player )
{
	// debug
	array<string> tickTypes = 
	[
		"npc_frag_drone",
		"npc_frag_drone_throwable",
	]
	int rngValue = RandomInt( tickTypes.len() )
	array<float> tickOverloadDelayAdjustments =
	[
		-1.28333,		// ~1.05s overload for normal frag drone
		-0.6,			// ~0.9s overload for sentry frag drone
	]
	array<int> tickHealthValue = 
	[
		140,
		85,
	]

	entity tick = PlayerBecomesTick( player, tickTypes[rngValue], 1.25, 5.0, 2.5, tickOverloadDelayAdjustments[rngValue] )
	tick.SetMaxHealth( tickHealthValue[rngValue] )
	tick.SetHealth( tickHealthValue[rngValue] )
	player.SetMaxHealth( tickHealthValue[rngValue] )
	player.SetHealth( tickHealthValue[rngValue] )
}
#endif

// client commands
void function NessieFunny_EnableClientCommands( bool enable )
{
	file.clientCommandsEnabled = enable
}

bool function CC_SpawnRainbowDome( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	float duration = -1 // infinite hold time
	if ( args.len() > 0 )
		duration = float( args[0] )
	CreateRainbowDomeShield( player.GetOrigin(), < 0,0,0 >, duration )

	return true
}

void function DelayedDestroyRainbowDome( entity domeShield, float delay )
{
	wait delay

	domeShield.Destroy()
}

bool function CC_SpawnNessyCostume( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	SpawnNessyCostume( player )
	return true
}

bool function CC_SelfRGBHighlight( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false
	//if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
	//	return false

	thread RGB_Highlight( player, true )
	return true
}

bool function CC_SelfIMSBTitle( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	thread TitleFlash( player )
	return true
}

bool function CC_FlipPlayerSelf( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	thread FlipperMoverThink( player )

	return true
}

bool function CC_ThrowABarrel( entity player, array<string> args )
{
	//if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
	//	return false

	entity barrel = CreatePhysicsBarrel( player.EyePosition(), < 0, player.EyeAngles().y, 0 > )
    barrel.SetVelocity( player.GetViewVector() * 1000 )
	return true
}

bool function CC_PlayerBecomeFakeMarvin( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	PlayerBecomesMarvin( player )
	return true
}

bool function CC_PlayerBecomeFakeTick( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	PlayerBecomesTick( player )
	return true
}
//

void function RGB_Highlight( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	ent.Signal( "StartRGBHighlight" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartRGBHighlight" )
	ent.EndSignal( "EndRGBHighlight" )

	// player specific
	if ( ent.IsPlayer() )
	{
		file.playerHasRGBHighlight[ ent ] = true
	}

	OnThreadEnd(
		function(): ( ent )
		{
			if( IsValid( ent ) )
			{
				// player specific
				if ( ent.IsPlayer() )
					file.playerHasRGBHighlight[ ent ] = false

				Highlight_ClearFriendlyHighlight( ent )
				Highlight_ClearEnemyHighlight( ent )
				Highlight_ClearNeutralHighlight( ent )
				Highlight_ClearOwnedHighlight( ent )
			}
		}
	)

	while ( true )
	{
		waitthread RGBHighlightThink( ent, showToAll, alwaysShow )
		ent.WaitSignal( "StopPhaseShift" ) // wait for exiting phase shift, we do highlight again!
	}
}

void function RGBHighlightThink( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	ent.EndSignal( "StartPhaseShift" ) // phase shift cleans up highlight

	string highlightToUse = "sp_enemy_pilot" // normal one, visible through viewmodel, kinda funny
	if ( alwaysShow )
		highlightToUse = "sp_friendly_hero" // this one will show across walls

	array<vector> colorArray = [ < 255,0,0 >, < 0,255,0 >, < 0,0,255 > ]
	int index = 0
	while( true )
	{
		index = index == colorArray.len() - 1 ? 0 : index + 1

		// needs to update highlight for every loop... in case we can update it for later-joiners
		Highlight_SetFriendlyHighlight( ent, highlightToUse )
		Highlight_SetOwnedHighlight( ent, highlightToUse )
		ent.Highlight_SetParam( 1, 0, colorArray[index] ) // friendly
		ent.Highlight_SetParam( 3, 0, colorArray[index] ) // owned

		if( showToAll )
		{
			Highlight_SetEnemyHighlight( ent, highlightToUse )
			Highlight_SetNeutralHighlight( ent, highlightToUse )
			ent.Highlight_SetParam( 2, 0, colorArray[index] ) // enemy
			ent.Highlight_SetParam( 0, 0, colorArray[index] ) // neutral
		}

		// never wait before we actually update entity's highlight
		// if we do, an entity spawn with no highlight will crash the server
		WaitFrame()
	}
}

void function TitleFlash( entity ent, array<string> titleArray = [ "我是傻逼", "傻逼是我" ] )
{
	if ( titleArray.len() <= 0 ) // no title given
		return
	ent.Signal( "StartSBTitle" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartSBTitle" )
	ent.EndSignal( "EndSBTitle" )

	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == titleArray.len() - 1 ? 0 : index + 1

		ent.SetTitle( titleArray[index] )
	}
}

void function RainbowPlayerSkin( entity player )
{
	if( !PilotModelSupportsCamo( player ) )
		return
	player.Signal( "StartRainbowPlayer" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartRainbowPlayer" )
	player.EndSignal( "EndRainbowPlayer" )

	// player specific
	if ( player.IsPlayer() )
		file.playerHasRainbowSkin[ player ] = true

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				// player specific
				if ( player.IsPlayer() )
					file.playerHasRainbowSkin[ player ] = false
			}
		}
	)

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		player.SetSkin( 1 )
		player.SetCamo( camoIndexArray[index] )
	}
}


array<asset> PILOT_MODELS_SUPPORTS_CAMO =
[
	$"models/humans/pilots/pilot_medium_stalker_m.mdl",
	$"models/humans/pilots/pilot_medium_stalker_f.mdl",
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_light_ged_f.mdl",
	$"models/humans/pilots/pilot_light_jester_m.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
	$"models/humans/pilots/pilot_medium_reaper_m.mdl"
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/pilot_medium_geist_m.mdl",
	$"models/humans/pilots/pilot_medium_geist_f.mdl",
	$"models/humans/pilots/pilot_heavy_roog_m.mdl",
	$"models/humans/pilots/pilot_heavy_roog_f.mdl",
	$"models/humans/pilots/pilot_heavy_drex_m.mdl",
	$"models/humans/pilots/pilot_heavy_drex_f.mdl"
]

bool function PilotModelSupportsCamo( entity player )
{
	asset modelName = player.GetModelName()
	if ( PILOT_MODELS_SUPPORTS_CAMO.contains( modelName ) )
	 	return true

	return false
}

void function RainbowWeaponSkin( entity weaponOwner )
{
	weaponOwner.Signal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "OnDestroy" )
	weaponOwner.EndSignal( "OnDeath" )
	weaponOwner.EndSignal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "EndRainbowWeapon" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		foreach( entity weapon in weaponOwner.GetMainWeapons() )
		{
			weapon.SetSkin( 1 )
			weapon.SetCamo( camoIndexArray[index] )
		}
	}
}

void function RGY_BatterySkin( entity battery )
{
	bool isRealBattery = battery.GetClassName() == "item_titan_battery"
	bool isPropBattery = !isRealBattery && battery.GetModelName() == RODEO_BATTERY_MODEL
	if( !isRealBattery && !isPropBattery )
		return

	battery.Signal( "StartRGYBattery" )
	battery.EndSignal( "OnDestroy" )
	battery.EndSignal( "StartRGYBattery" )
	battery.EndSignal( "EndRGYBattery" )

	entity lastTickParent
	OnThreadEnd(
		function(): ( battery, lastTickParent )
		{
			if ( IsValid( lastTickParent ) && lastTickParent.IsPlayer() )
				file.playerHasRGYBattery[ lastTickParent ] = false
		}
	)

	int index = 0
	while( true )
	{
		// for real batteries, we check their parent
		if ( isRealBattery )
			lastTickParent = battery.GetParent()

		//print( "setting battery skin: " + string( index ) )
		WaitFrame()

		battery.SetSkin( index )
		Battery_StopFX( battery )
		if( index == 2 )
			index = 0
		else
			index++

		// for real batteries, we check their current parent
		// and if player changed parented battery or something, we update playerHasRGYBattery
		entity currentParent = battery.GetParent()
		// parent updated!
		if ( lastTickParent != currentParent )
		{
			if ( IsValid( lastTickParent ) && lastTickParent.IsPlayer() )
				file.playerHasRGYBattery[ lastTickParent ] = false
		}
		// a player currently holding the RGY battery
		if ( IsValid( currentParent ) && currentParent.IsPlayer() )
			file.playerHasRGYBattery[ lastTickParent ] = true
	}
}

void function HoloFlash_Loop( entity player, float interval = 1.0 )
{
	player.Signal( "StartHoloFlash" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartHoloFlash" )
	player.EndSignal( "EndHoloFlash" )

	while( true )
	{
		wait interval

		HoloFlash( player )
	}
}

void function HoloFlash( entity player )
{
	int attachIndex = player.LookupAttachment( "CHESTFOCUS" )
	//StartParticleEffectOnEntity( player, GetParticleSystemIndex( GHOST_TRAIL_EFFECT ), FX_PATTACH_POINT_FOLLOW, attachIndex )
	entity flashFX = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( GHOST_FLASH_EFFECT ), FX_PATTACH_POINT, attachIndex )
	flashFX.SetOwner( player )
	SetTeam( flashFX, player.GetTeam() )
	flashFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // not owner only
}

void function PlayerPulseBladeModel_HideBodyAndLegs( entity player )
{
	player.SetModel( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = player.FindBodyGroup( "body" )
	player.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = player.FindBodyGroup( "legs" )
	player.SetBodygroup( bodyGroupIndex, 0 )
}

// create a pulseblade pilot's head
entity function CreatePulseBladeHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

// create a headshot head! this is not a model that can freely scale
entity function CreateWoundedHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "head" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

void function BindPulseBladeHeadToPlayer( entity player )
{
	entity head = CreatePulseBladeHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
	
	//head.SetSkin( 2 )
	//head.SetCamo( 14 )
}

void function BindeWoundedHeadToPlayer( entity player )
{
	entity head = CreateWoundedHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
}

void function TrackPlayerDeathForHeadProp( entity player, entity head )
{
	player.EndSignal( "OnDestroy" )

	WaitFrame() // since altpilot resets player's visibility everytime they respawn or changeloadout
	player.kv.VisibilityFlags = 0 // hide player

	OnThreadEnd(
		function():( head )
		{
			if ( IsValid( head ) )
				head.Destroy()
		}
	)

	player.WaitSignal( "OnDeath" )
	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // restore player visibility!
}

void function BecomeApexLegend( entity player, asset model ) // ash, blisk, jack, sarah
{
	TakeAllWeapons( player )

	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_phase"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_ORDNANCE, ["octane_stim"] )
	player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_ANTIRODEO, ["deployable_dome_shield"] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, ["dash_melee", "pushback_melee"] )
	player.GiveWeapon( "mp_weapon_gunship_missile", ["pilot_emptyhanded"] )
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), ["disable_doublejump","only_wallclimb", "pas_wallhang"] )

	player.SetModel( model )
	GivePassive( player, ePassives.PAS_STEALTH_MOVEMENT ) // hide jetpack flame
	Rodeo_SetStealthMovementDisabledForPlayer( player, true ) // disable stealth rodeo, so player will have jetpack modified only

	thread DisableBoostBar( player )
}

void function DisableBoostBar( entity player )
{
	WaitFrame()
	if( IsValid( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

entity function CreateRainbowDomeShield( vector origin, vector angles, float duration = -1, bool notSolid = false )
{
	entity bubbleShield = CreateEntity( "prop_dynamic" )
	bubbleShield.SetValueForModelKey( $"models/fx/xo_shield.mdl" )
	if ( !notSolid )
		bubbleShield.kv.solid = SOLID_VPHYSICS
    bubbleShield.kv.rendercolor = "81 130 151"
    bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
	bubbleShield.SetOrigin( origin )
	bubbleShield.SetAngles( angles )
	bubbleShield.Hide()

    // Blocks bullets, projectiles but not players and not AI
	// THIS IS BAD BEHAVIOR
    // TRACE_COLLISION_GROUP_BLOCK_WEAPONS makes scorch thermite pass through shield
	//bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
    bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS
	bubbleShield.SetBlocksRadiusDamage( true )
	DispatchSpawn( bubbleShield )
    array<entity> bubbleShieldFXs
	vector coloredFXOrigin = bubbleShield.GetOrigin()
	table bubbleShieldDotS = expect table( bubbleShield.s )

	//Create friendly and enemy colored particle systems
	entity rainbowColoredFX = StartParticleEffectInWorld_ReturnEntity( BUBBLE_SHIELD_FX_PARTICLE_SYSTEM_INDEX, coloredFXOrigin, angles )
	thread RainbowColorThink( rainbowColoredFX )
	bubbleShieldFXs.append( rainbowColoredFX )

	// should set all bubble shield particle to disable hibernation
	foreach ( entity particle in bubbleShieldFXs )
	{
		if ( IsValid( particle ) )
			particle.DisableHibernation() 
	}

    EmitSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
    thread CleanupBubbleShield( bubbleShield, bubbleShieldFXs, duration )

	return bubbleShield
}

void function RainbowColorThink( entity fx )
{
	fx.EndSignal( "OnDestroy" )

	vector rgb = < 255, 0, 0 > // start with red
	float segment = 25.5
	while ( true )
	{
		WaitFrame()

		// to < 255, 255, 0 >
		if ( rgb.x == 255 && rgb.y < 255 && rgb.z == 0 )
			rgb.y = min( 255, rgb.y + segment )
		// to < 0, 255, 0 >
		else if ( rgb.x > 0 && rgb.y == 255 && rgb.z == 0 )
			rgb.x = max( 0, rgb.x - segment )
		// to < 0, 255, 255 >
		else if ( rgb.x == 0 && rgb.y == 255 && rgb.z < 255 )
			rgb.z = min( 255, rgb.z + segment )
		// to < 0, 0, 255 >
		else if ( rgb.x == 0 && rgb.y > 0 && rgb.z == 255 )
			rgb.y = max( 0, rgb.y - segment )
		// to < 255, 0, 255 >
		else if ( rgb.x < 255 && rgb.y == 0 && rgb.z == 255 )
			rgb.x = min( 255, rgb.x + segment )
		// to < 255, 0, 0 >, a whole loop done
		else if ( rgb.x == 255 && rgb.y == 0 && rgb.z > 0 )
			rgb.z = max( 0, rgb.z - segment )

		//print( rgb )
		EffectSetControlPointVector( fx, 1, rgb )
	}
}

void function CleanupBubbleShield( entity bubbleShield, array<entity> bubbleShieldFXs, float fadeTime )
{
	bubbleShield.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( bubbleShield, bubbleShieldFXs )
		{
			if ( IsValid_ThisFrame( bubbleShield ) )
			{
				StopSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
				EmitSoundOnEntity( bubbleShield, "BubbleShield_End" )
				DestroyBubbleShield( bubbleShield )
			}

			foreach ( fx in bubbleShieldFXs )
			{
				if ( IsValid_ThisFrame( fx ) )
				{
					EffectStop( fx )
				}
			}
		}
	)

	if ( fadeTime == -1 ) // default
		WaitForever()
	else if ( fadeTime > 0 )
		wait fadeTime
}

// flipper
void function FlipperMoverThink( entity player )
{
	if ( !IsAlive( player ) ) // defensive fix
		return

	entity playerParent = player.GetParent()
	//print( "playerParent: " + string( playerParent ) )
	if ( IsValid( playerParent ) )
	{
		if ( playerParent == file.playerFlipperMover[ player ] )
			player.Signal( "EndFlipper" ) // try to end last flipper

		return // always return, whether player is parented with flipper or other entities
	}

	player.Signal( "EndFlipper" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "EndFlipper" )

	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-soli
	DispatchSpawn( viewControl )
	viewControl.EndSignal( "OnDestroy" )

	float offset = player.IsTitan() ? 500.0 : 200.0
	float playerViewYaw = player.EyeAngles().y
	float playerBackViewYaw = ClampAngle( playerViewYaw - 180 )
	viewControl.SetOrigin( player.GetOrigin() + AnglesToForward( < 0, playerBackViewYaw, 0 > ) * offset )
	viewControl.SetAngles( < 0, playerViewYaw, 0 > )
	player.SetViewEntity( viewControl, true )

	entity mover = CreateExpensiveScriptMover()
	mover.EndSignal( "OnDestroy" )

	mover.SetOrigin( player.GetOrigin() )
	mover.SetAngles( < 0, playerBackViewYaw, 0 > )
	player.SetParent( mover )
	file.playerFlipperMover[ player ] = mover

	OnThreadEnd
	(
		function(): ( player, mover, viewControl )
		{
			if ( IsValid( player ) )
			{
				player.ClearParent()
				FindNearestSafeSpotAndPutEntity( player, 1 )
				player.ClearViewEntity()
				file.playerFlipperMover[ player ] = null
			}

			if ( IsValid( viewControl ) )
				viewControl.Destroy()
			if ( IsValid( mover ) )
				mover.Destroy()
		}
	)

	int loopCount = 0
	while ( true )
	{
		float x = loopCount % 2 == 0 ? -180.0 : 0.0
		mover.NonPhysicsRotateTo( < x, playerBackViewYaw, 0 >, 0.3, 0, 0 )
		loopCount += 1
		wait 0.2
	}
}

// barrel
entity function CreatePhysicsBarrel( vector origin, vector angles )
{
	entity barrel = CreateEntity( "prop_physics" )
	barrel.SetValueForModelKey( $"models/containers/barrel.mdl" )
	barrel.SetModel( $"models/containers/barrel.mdl" )

	// spawn settings, copied from map_spawn.ent
	barrel.kv.spawnflags = "1"
	//barrel.kv.solid = SOLID_VPHYSICS
	barrel.kv.skin = "0"
	barrel.kv.shadowcastdist = "0"
	barrel.kv.rendermode = "0"
	barrel.kv.renderfx = "0"
	barrel.kv.rendercolor = "255 255 255"
	barrel.kv.renderamt = "255"
	barrel.kv.pressuredelay = "0"
	barrel.kv.physdamagescale = "0.1"
	barrel.kv.PerformanceMode = "0"
	barrel.kv.nodamageforces = "0"
	barrel.kv.minhealthdmg = "0"
	barrel.kv.mingpulevel = "0"
	barrel.kv.mincpulevel = "0"
	barrel.kv.maxgpulevel = "0"
	barrel.kv.maxcpulevel = "0"
	barrel.kv.massScale = "0"
	barrel.kv.inertiaScale = "1.0"
	barrel.kv.fadedist = "-1"
	barrel.kv.ExplodeRadius = "0"
	barrel.kv.ExplodeDamage = "0"
	barrel.kv.drawinfastreflection = "0"
	barrel.kv.disableX360 = "0"
	barrel.kv.disableshadows = "0"
	barrel.kv.disablereceiveshadows = "0"
	barrel.kv.Damagetype = "0"
	barrel.kv.damagetoenablemotion = "0"
	barrel.kv.allowfunnel = "1"
	barrel.kv.scale = "1"
	//barrel.kv.angles = "0 -26.065 0"
	//barrel.kv.origin = "3180 -4114 55.9981"
	//barrel.kv.targetname = "func_static_1"
	barrel.kv.physicsmode = "1"
	barrel.kv.forcetoenablemotion = "0"
	barrel.kv.classname = "prop_physics"

	barrel.SetOrigin( origin )
	barrel.SetAngles( angles )

	DispatchSpawn( barrel )
	barrel.SetModel( $"models/containers/barrel.mdl" )
	barrel.SetForceVisibleInPhaseShift( true )

	return barrel
}


// init marvin scripted anim
void function InitMarvinIntroAnim()
{
	// now we leave only freestyle, others needs testing
	/*
	MarvinIntroAnim greeter
	greeter.animName = "commander_MP_flyin_marvin_greeter"
	greeter.initialTime = -1 // needs testing
	greeter.actualLength = -1
	file.marvinIntroAnims.append( greeter )

	MarvinIntroAnim highfive
	highfive.animName = "commander_MP_flyin_marvin_highfive"
	highfive.initialTime = -1 // needs testing
	highfive.actualLength = -1
	file.marvinIntroAnims.append( highfive )

	MarvinIntroAnim salute
	salute.animName = "commander_MP_flyin_marvin_salute"
	salute.initialTime = -1 // needs testing
	salute.actualLength = -1
	file.marvinIntroAnims.append( salute )

	MarvinIntroAnim glitch
	glitch.animName = "commander_MP_flyin_marvin_glitch"
	glitch.initialTime = -1 // needs testing
	glitch.actualLength = -1
	file.marvinIntroAnims.append( glitch )
	*/

	MarvinIntroAnim freestyle
	freestyle.animName = "commander_MP_flyin_marvin_freestyle"
	freestyle.initialTime = -1 // needs testing
	freestyle.actualLength = 14
	freestyle.offset = < 0, 0, 0 >
	freestyle.introSounds = { 
		["commander_marvin_freestyle_music"] = 0.0,
		["commander_marvin_freestyle"] = 1.1,
		["diag_mcor_marvin_dropship_cmdr_freestyle"] = 1.1,
	}
	freestyle.introSoundRadius = 800 // freestyle is loud, needs reduced sound radius
	file.marvinIntroAnims.append( freestyle )
}

// this may cause sound loss so need a setting
void function NessyFunny_EnableMarvinScriptedAnim( bool enable )
{
	file.fakeMarvinScriptedAnimEnabled = enable
}

// player controlled marvin
entity function PlayerBecomesMarvin( entity player )
{
	if ( IsValid( file.playerFakeNPC[ player ] ) )
		return

	if ( !IsAlive( player ) )
		return
	
	if ( player.IsTitan() || player.Anim_IsActive() || IsValid( player.GetParent() ) )
		return

	// remove ragdoll impact effect
	SetHumanRagdollImpactTable( player )
	
	int team = player.GetTeam()
	vector origin = player.GetOrigin()
	vector angles = < 0, player.GetAngles().y, 0 >
	entity marvin = CreateMarvin( team, origin, angles )
	marvin.kv.spawnflags = 516
	marvin.kv.contents = (int(marvin.kv.contents) | CONTENTS_NOGRAPPLE)
	marvin.ai.killShotSound = false
	DispatchSpawn( marvin )

	// setup player
	// we still allow player to change player settings from loadout selection... as a easter egg
	// nope, never allow loadout change influence playerSetFile. now hanlded by PlayerMarvinThink()
	//player.SetPlayerSettingsWithMods( "pilot_coliseum_female", ["disable_doublejump", "disable_wallrun"] )
	player.SetNoTarget( true )
	PainDeathSounds_SetDisabledForEntity( player, true ) // temp
	DeathPackage_SetDisabledForEntity( player, true )
	file.playerFakeNPC[ player ] = marvin
	// how do I hide highlight for this player?
	// now doing loop in PlayerMarvinThink()
	//SetUpFakeMarvinHighlight( player )

	// they can take doubled damage from passing-through and explosions, double the health
	// EDIT: we've fixed that case by using damage callbacks, but health change is good enough, keeping here
	//player.SetShieldHealthMax( 1000 )
	//player.SetShieldHealth( 1000 )
	SetShieldHealthMaxWithFix( player, 1000 )
    SetShieldHealthWithFix( player, 1000 )
	player.SetMaxHealth( 1000 )
	player.SetHealth( 1000 )

	// setup marvin
	// dont let AI titan get enemies. Don't do trigger checks
	// EDIT: maybe do trigger checks so we get proper fall damage and stuffs...?
	marvin.SetEfficientMode( true )
	//marvin.SetTouchTriggers( false )
	marvin.SetNoTarget( true )
	marvin.SetAimAssistAllowed( false )
	// doesn't work because parent is nonsolid, still won't touch any trigger stuffs
	//marvin.e.destroyTriggerHurt = true // so they gets removed when taking fall damage, and player dies

	// temp health
	// reworked here, we make player take damage instead of marvin re-direct damage
	// EDIT: reworked again here: still change to use marvin for re-directing damage, but player took radius damage will be blocked
	/*
	marvin.SetMaxHealth( 400 )
	marvin.SetHealth( 400 )
	*/
	// update basic shield value for marvin so we have proper impact effects
	//marvin.SetShieldHealthMax( 300 )
	//marvin.SetShieldHealth( 300 )
	SetShieldHealthMaxWithFix( marvin, 1000 )
    SetShieldHealthWithFix( marvin, 1000 )

	marvin.SetBossPlayer( player )

	// how do I hide highlight for their marvin?
	// now doing loop in PlayerMarvinThink()
	//SetUpFakeMarvinHighlight( marvin )
	marvin.Highlight_SetInheritHighlight( true )

	marvin.SetParent( player, "ORIGIN" )
	SetForceDrawWhileParented( marvin, true )
	//marvin.SetTitle( player.GetPlayerName() ) // boss player can show title for npcs
	AddEntityCallback_OnFinalDamaged( marvin, OnFakeNPCFinalDamaged ) // this callback can pass shield damage to player
	if ( BATTERY_SPAWNERS.contains( player.GetUID() ) )
		HideName( marvin )
	marvin.Signal( "StopDoingJobs" ) // stop automatic job think

	thread PlayerMarvinThink( player, marvin )
	thread TrackMarvinOwnerDamaged( player, marvin )
	thread DisableBoostBar( player )

	return marvin
}

void function SetUpFakeMarvinHighlight( entity ent )
{
	// now doing loop in PlayerMarvinThink(), no need to remove default enemy highlight
	//ent.e.hasDefaultEnemyHighlight = false
	Highlight_ClearEnemyHighlight( ent )

	// temp remove highlight overrides
	/*
	// friendly highlight
	Highlight_SetFriendlyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 1, 0, HIGHLIGHT_COLOR_NEUTRAL )
	// enemy highlight
	Highlight_SetEnemyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 2, 0, HIGHLIGHT_COLOR_NEUTRAL )
	// owned highlight
	Highlight_SetOwnedHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_NEUTRAL )
	*/
}

// for better adjusting damage dealing to player
// this is shared between fake npc thinks
void function OnFakeNPCFinalDamaged( entity ent, var damageInfo )
{
	//print( "fake marvin damaged!" )
	//print( "fake npc " + string( ent ) + " took damage!" )

	entity owner = ent.GetBossPlayer()
	if ( IsValid( owner ) )
	{
		file.playerFakeNPCTookDamage[ owner ] = true // mark this as true so we can receive damage properly
		
		owner.TakeDamage( 
			DamageInfo_GetDamage( damageInfo ), 
			DamageInfo_GetAttacker( damageInfo ), 
			DamageInfo_GetInflictor( damageInfo ), 
			{ // damage table
				forceKill = DamageInfo_GetForceKill( damageInfo ),
				weapon = DamageInfo_GetWeapon( damageInfo ),
				origin = DamageInfo_GetDamagePosition( damageInfo ), 
				force = DamageInfo_GetDamageForce( damageInfo ), 
				scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
				damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
			}
		)
		file.playerFakeNPCTookDamage[ owner ] = false // owner stops taking damage anymore

		// update npc shield value so we get proper impact effects
		SetShieldHealthMaxWithFix( ent, GetShieldHealthMaxWithFix( owner ) )
		SetShieldHealthWithFix( ent, GetShieldHealthWithFix( owner ) )
	}

	DamageInfo_SetDamage( damageInfo, 0 ) // never damage npc
}

// switch marvin's face when owner damaged
void function TrackMarvinOwnerDamaged( entity owner, entity marvin )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDestroy" )

	while ( true )
	{
		waitthread MarvinUndamagedFace( owner, marvin )
		waitthread MarvinWounded( owner, marvin )
	}
}

void function MarvinUndamagedFace( entity owner, entity marvin )
{
	//print( "marvin is happy!" )
	owner.EndSignal( "OnDamaged" )
	marvin.SetSkin( 1 ) // happy face
	WaitForever()
}

void function MarvinWounded( entity owner, entity marvin )
{
	//print( "marvin is unhappy!" )
	marvin.SetSkin( 2 ) // sad face
	wait 2.3 // max duration
}

void function PlayerMarvinThink( entity player, entity marvin )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "player_embarks_titan" ) // maybe no need to add this... embarking as marvin kills you!
	marvin.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDeath" )

	array<int> statusEffectsToCleanUp
	statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.35 ) )
	statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.2 ) )

	// start third person tracking
	MarvinPlayerTrackView( player )

	OnThreadEnd
	(
		function(): ( player, marvin, statusEffectsToCleanUp )
		{
			if ( IsValid( marvin ) )
			{
				RemoveEntityCallback_OnFinalDamaged( marvin, OnFakeNPCFinalDamaged )
				marvin.Anim_Stop()
				HideName( marvin )
				marvin.ClearParent()
				if ( IsAlive( marvin ) )
					marvin.Die( marvin, marvin, { damageSourceId = damagedef_suicide } )
			}
			if ( IsValid( player ) )
			{
				// clean up
				foreach ( effect in statusEffectsToCleanUp )
					StatusEffect_Stop( player, effect )

				player.Anim_Stop()
				player.SetNoTarget( false )
				player.SetTrackEntity( null )
				player.ClearTrackEntitySettings()

				PainDeathSounds_SetDisabledForEntity( player, false )
				DeathPackage_SetDisabledForEntity( player, false )

				ShowName( player )
				//player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // this gets cleared on player respawn, now we need to hide so their corpse won't show
				// reworked here, we make player take damage instead of marvin re-direct damage
				// no need to clean up
				// EDIT: reworked again here: still change to use marvin for re-directing damage, but player took radius damage will be blocked
				//player.ClearInvulnerable()
				player.Solid()
				//player.kv.modelscale = 1.0
				player.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
				player.UnforceStand()

				//player.SetShieldHealth( 0 )
				//player.SetShieldHealthMax( 0 )
    			SetShieldHealthWithFix( player, 0 )
				SetShieldHealthMaxWithFix( player, 0 )

				if ( IsAlive( player ) )
				{
					//player.Despawn() // no corpse, but isn't force kill
					player.Die( player, player, { damageSourceId = damagedef_suicide } )
				}
				//else
				//{
				//	player.Gib( < 0, 0, 100000 > ) // no corpse
					// modified function in sh_death_package.gnut
				//	HumanSizedGibSound( player )
				//}

				file.playerFakeNPC[ player ] = null
				file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] = 0.0
			}
		}
	)

	// marvin movement anim init
	marvin.Anim_ScriptedPlay( "mv_idle_unarmed" )
	file.fakeMarvinMovementState[ marvin ] <- eMarvinMovement.IDLE

	float lastStartTraverseTime = -1

	while ( true )
	{
		TakeAllWeapons( player )

		// health
		int playerMaxHealth = player.GetMaxHealth()
		int playerMaxShield = GetShieldHealthMaxWithFix( player )
		int playerHealth = player.GetHealth()
		int playerShield = GetShieldHealthWithFix( player )

		// class mods
		string setFile = player.GetPlayerSettings()
		array<string> classMods = player.GetPlayerSettingsMods()
		bool isColiseumFemale = setFile == "pilot_coliseum_female"
		bool hasMovementLimiter = classMods.contains( "disable_doublejump" ) && classMods.contains( "disable_wallrun" )
		if ( !isColiseumFemale || !hasMovementLimiter )
		{
			player.SetPlayerSettingsWithMods( "pilot_coliseum_female", ["disable_doublejump", "disable_wallrun"] )
		
			// update health
			player.SetMaxHealth( playerMaxHealth )
			player.SetHealth( playerHealth )
		}

		// visual effect
		// looping to update highlight could be good
		if ( !file.playerHasRGBHighlight[ player ] )
			SetUpFakeMarvinHighlight( player )
		HideName( player )
		player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
		// reworked here, we make player take damage instead of marvin re-direct damage
		// welp, guess making both entities take damage could be better
		//player.SetInvulnerable()
		player.NotSolid() // non-solid makes player unable to take trigger_hurt damage and won't trigger OOB... DOESN"T MATTER! player can use kill command to get back, enabling this could be fun!
		// this is bad... will make attachments messed up
		//player.kv.modelscale = 0.01 // instead, we make player almost unable to getting hit, they'll still caught in explosions though
		player.kv.CollisionGroup = 0 // TRACE_COLLISION_GROUP_BLOCK_WEAPONS
		
		// movement limiter
		//player.ClearTraverse() // marvin don't have suitable anim for mantling, but we still allow player to traverse
		if ( player.IsTraversing() )
		{
			if ( lastStartTraverseTime == -1 )
				lastStartTraverseTime = Time()
			else if ( Time() - lastStartTraverseTime > 1 ) // maxnium of 1s mantling. enough for most traverse
				player.ClearTraverse()
		}
		else
			lastStartTraverseTime = -1
		
		player.ForceStand() // avoid camera glitch when using chasing cam
		
		// health
		// reworked here, we make player take damage instead of marvin re-direct damage
		// EDIT: reworked again here: still change to use marvin for re-directing damage, but player took radius damage will be blocked
		/*
		//player.SetShieldHealthMax( marvin.GetShieldHealthMax() )
		//player.SetShieldHealth( marvin.GetShieldHealth() )
		SetShieldHealthMaxWithFix( player, GetShieldHealthMaxWithFix( marvin ) )
		SetShieldHealthWithFix( player, GetShieldHealthWithFix( marvin ) )
		player.SetMaxHealth( marvin.GetMaxHealth() )
		player.SetHealth( marvin.GetHealth() )
		*/

		// marvin effects
		// looping to update highlight could be good
		if ( !file.playerHasRGBHighlight[ player ] )
			SetUpFakeMarvinHighlight( marvin )
		//marvin.SetInvulnerable()
		// maybe no need to change collision
		//marvin.kv.CollisionGroup = 0

		//marvin.NotSolid() // non-solid entity won't show name, which is bad
		//SetShieldHealthMaxWithFix( marvin, playerMaxShield )
		//SetShieldHealthWithFix( marvin, playerShield )
		
		// keep marvin at extremely high health, don't want them to die from normal damages
		//marvin.SetMaxHealth( playerMaxHealth )
		//marvin.SetHealth( playerHealth )
		// keep marvin at extremely high health, don't want them to die
		// acutally damage can be handled by "OnFakeMarvinFinalDamaged" but whatever
		marvin.SetMaxHealth( 99999 )
		marvin.SetHealth( 99999 )

		// marvin animations
		if ( !player.IsOnGround() 
			 || player.IsWallRunning() 
			 || player.IsWallHanging() 
			 || player.IsTraversing() 
			 )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.IN_AIR )
			{
				marvin.Anim_ScriptedPlay( "mv_skyfall" ) // "mv_skyfall_lean"
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.IN_AIR
			}
			//printt( "player marvin in air!" )
		}
		// walking and spriting doesn't working fine
		// parented move anim seems weird...
		// fixed by marvin.Anim_DisableUpdatePosition()
		// sprinting still not look so good
		// whatever, we've added moveslow for player so I think there's no need to add sprinting
		/*
		else if ( player.IsSprinting() )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.SPRINTING )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.SPRINTING
				marvin.Anim_ScriptedPlay( "sp_sprint_tmp" ) //
				marvin.Anim_DisableUpdatePosition() // can this fix marvin change position through walking?
			}
			//printt( "player marvin sprinting!" )
		}
		*/
		// key combo: scripted animation
		else if ( file.fakeMarvinScriptedAnimEnabled
				  && !IsValid( player.GetParent() ) // can't use scripted anim while parented
				  && file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] <= Time()
				  && player.IsOnGround() 
				  && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) )
				  && ( player.IsInputCommandHeld( IN_ATTACK ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) 
				  && player.IsInputCommandHeld( IN_MELEE ) 
				  )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.SCRIPTED_ANIMATION )
			{
				// stop looping and wait for animation end
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.SCRIPTED_ANIMATION
				waitthread MarvinScriptedIntroAnim( player, marvin )
				file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] = Time() + MARVIN_INTRO_ANIM_COOLDOWN // update cooldown
			}
		}
		else if ( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WAVING )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WAVING
				marvin.Anim_ScriptedPlay( "mv_wave_unarmed" )
			}
			//printt( "player marvin waving!" )
		}
		// walking has lower priority than waving
		else if ( Length( player.GetVelocity() ) > 10 )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WALKING )
			{
				//file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WALKING // state setup handled in MarvinPlayerMoveAnimThink()
				// parented move anim seems weird...
				// fixed by marvin.Anim_DisableUpdatePosition()
				//thread MarvinPlayerMoveAnimThink( player, marvin, "Walk_All", eMarvinMovement.WALKING ) // Walk_all_v2
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WALKING
				marvin.Anim_ScriptedPlay( "Walk_All" ) //
				marvin.Anim_DisableUpdatePosition() // can this fix marvin change position through walking?
			}
			//printt( "player marvin walking!" )
		}
		else if ( player.IsInputCommandHeld( IN_ZOOM ) 
				  || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) 
				  )
		{
			if ( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
			{
				if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WASHING_WINDOW )
				{
					file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WASHING_WINDOW
					marvin.Anim_ScriptedPlay( "mv_idle_wash_window" )
				}
			}
			else
			{
				if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WELDING )
				{
					file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WELDING
					marvin.Anim_ScriptedPlay( "mv_idle_weld" )
				}
			}
		}
		else // idle
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.IDLE )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.IDLE
				marvin.Anim_ScriptedPlay( "mv_idle_unarmed" )
			}
			//printt( "player marvin idle!" )
		}

		WaitFrame()
	}
}

void function MarvinPlayerTrackView( entity player )
{
	player.SetTrackEntity( player ) // Sets an entity to be viewed by this player in third person
	//player.SetTrackEntity( GetNPCArray()[0] )
	player.SetTrackEntityPitchLookMode( "orbit" )
	player.SetTrackEntityYawLookMode( "orbit" )
	player.SetTrackEntityDistanceMode( "scriptOffset" )
	player.SetTrackEntityMinYaw( -180 )
	player.SetTrackEntityMaxYaw( 180 )
	player.SetTrackEntityMinPitch( -30 ) // was -89, which means max pitch view
	player.SetTrackEntityMaxPitch( 44 ) // // was 89, which means max pitch view
	player.SetTrackEntityOffset( < -150.0, 0, 30.0 > )
	//player.SetTrackEntityOffsetDistance( -50.0 )
	//player.SetTrackEntityOffsetHeight( 30.0 )
}

// parented move anim seems weird...
// fixed by marvin.Anim_DisableUpdatePosition()
/*
void function MarvinPlayerMoveAnimThink( entity player, entity marvin, string anim, int stateKeep )
{
	//marvin = CreatePropDynamic( $"models/robots/marvin/marvin.mdl", marvin.GetOrigin(), marvin.GetAngles(), 6 )
	marvin.EndSignal( "OnDeath" )
	marvin.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	marvin.Signal( "MarvinPlayerMoveAnimThink" )
	marvin.EndSignal( "MarvinPlayerMoveAnimThink" )

	print( "marvin doing anim!" )

	entity mover = CreateScriptMover()
	mover.SetOrigin( player.GetOrigin() )
	mover.SetAngles( < 0, player.GetAngles().y, 0 > )
	marvin.ClearParent()
	marvin.SetParent( mover )
	marvin.Anim_ScriptedPlay( anim )

	OnThreadEnd
	(
		function(): ( player, marvin, mover )
		{
			if ( IsValid( player ) && IsValid( marvin ) )
			{
				marvin.ClearParent()
				marvin.SetParent( player, "ORIGIN" ) // set back
			}
			if ( IsValid( mover ) )
				mover.Destroy()
		}
	)

	file.fakeMarvinMovementState[ marvin ] = stateKeep
	while ( file.fakeMarvinMovementState[ marvin ] == stateKeep )
	{
		mover.NonPhysicsMoveTo( player.GetOrigin(), 0.1, 0.0, 0.0 )
		mover.NonPhysicsRotateTo( < 0, player.GetAngles().y, 0 >, 0.1, 0.0, 0.0 )
		WaitFrame()
	}

	print( "state lost!" )
}
*/

// for playing dropship intro anims
// might be kinda annoying...
// bunch of stupid stuffs inside
void function MarvinScriptedIntroAnim( entity player, entity marvin )
{
	if ( IsValid( player.GetParent() ) ) // can't use scripted anim while parented
		return

	// EndSignals handled by PlayerMarvinThink()
	player.FreezeControlsOnServer()

	OnThreadEnd
	(
		function(): ( player, marvin )
		{
			if ( IsValid( player ) )
			{
				player.UnfreezeControlsOnServer()
				player.ClearInvulnerable()
				player.SetPhysics( MOVETYPE_WALK )
			}
			if ( IsValid( marvin ) )
			{
				marvin.Anim_Stop()
				if ( IsAlive( player ) )
				{
					marvin.SetParent( player, "ORIGIN" )
					marvin.SetOrigin( < 0, 0, 0 > )
				}
				marvin.ClearInvulnerable()
			}
		}
	)

	array<MarvinIntroAnim> validAnimations = clone file.marvinIntroAnims
	MarvinIntroAnim randomAnim = validAnimations.getrandom()

	// temp clear parent
	marvin.ClearParent()
	// since parent has been cleared, if player has RGB highlight we need to apply it for marvin
	if ( file.playerHasRGBHighlight[ player ] )
		thread RGB_Highlight( file.playerFakeNPC[ player ], true )

	// don't want marvin or player die here
	marvin.SetInvulnerable()
	player.SetInvulnerable()
	// stop movements from here
	player.SetVelocity( < 0, 0, 0 > )
	marvin.SetVelocity( < 0, 0, 0 > )
	player.SetPhysics( MOVETYPE_NOCLIP )
	// needs to set offset for marvin
	vector posWithOffset = player.GetOrigin() + randomAnim.offset
	marvin.SetOrigin( posWithOffset )

	marvin.Anim_ScriptedPlay( randomAnim.animName )
	if ( randomAnim.initialTime > 0 )
		marvin.Anim_SetInitialTime( randomAnim.initialTime )

	// HACK and may cause sound loss on players
	thread MarvinIntroSoundThink( marvin, randomAnim )

	WaitEndFrame() // may works different with higher script_server_fps
	// stop sound may loss if server or client unstable...
	StopSoundOnEntity( marvin, "crow_mp_intro" )

	if ( randomAnim.actualLength > 0 )
		wait randomAnim.actualLength
	else
		wait marvin.GetSequenceDuration( randomAnim.animName )
}

void function MarvinIntroSoundThink( entity marvin, MarvinIntroAnim animStruct )
{
	marvin.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDeath" )

	table<string, float> soundsTable = animStruct.introSounds
	float soundRadius = animStruct.introSoundRadius

	float startTime = Time()
	if ( animStruct.initialTime > 0 )
		startTime += animStruct.initialTime

	array<string> soundsPlayed
	while ( marvin.Anim_IsActive() )
	{
		foreach ( string soundName, float playDelay in soundsTable )
		{
			if ( soundsPlayed.contains( soundName ) )
				continue
			float soundPlayTime = startTime + playDelay
			float soundMaxPlayTime = soundPlayTime + 0.2 // if we looped more than 0.2s before playing a sound, do nothing
			if ( Time() >= soundPlayTime && Time() < soundMaxPlayTime )
			{
				PlayMarvinSoundToNearbyPlayers( marvin, soundName, soundRadius )
				soundsPlayed.append( soundName )
			}
			else // if sound not played yet, try stop sound played by animation
			{
				// looping to stop sound may cause sound loss
				// remove if it can be handled by PlayMarvinSoundToNearbyPlayers()
				//StopSoundOnEntity( marvin, soundName )
			}
		}

		WaitFrame()
	}
}

void function PlayMarvinSoundToNearbyPlayers( entity marvin, string soundName, float radius )
{
	// try stop sound played by animation
	// stop sound may loss if server or client unstable...
	StopSoundOnEntity( marvin, soundName )
	foreach ( entity player in GetAllPlayersInMarvinSoundRadius( marvin.GetOrigin(), radius ) )
	{
		EmitSoundOnEntityOnlyToPlayer( marvin, player, soundName )
	}

	// no need to track sound end, cause Anim_Stop() will clean them up on dead entities( pretty good )
}

array<entity> function GetAllPlayersInMarvinSoundRadius( vector pos, float radius )
{
	array<entity> targetPlayers
	// only for living players, dead players can respawn and change position
	foreach ( entity player in GetPlayerArray_Alive() )
	{
		if ( Distance( pos, player.GetOrigin() ) > radius )
			continue

		targetPlayers.append( player )
	}

	return targetPlayers
}

void function NessyFunny_EnablePlayerTickDamageByDefault( bool enable )
{
	file.playerTickCanDoDamageByDefault = enable
}

entity function PlayerBecomesTick( entity player, string tickAiSettings = "npc_frag_drone_throwable", float moveSpeedScale = -1, float suicideChaseTime = -1, float suicideChaseSpeedScale = -1, float overloadDelayAdjustment = -1, bool ornull tickCanDoDamageOverride = null )
{
	if ( IsValid( file.playerFakeNPC[ player ] ) )
		return

	if ( !IsAlive( player ) )
		return
	
	if ( player.IsTitan() || player.Anim_IsActive() || IsValid( player.GetParent() ) )
		return

	// remove ragdoll impact effect
	SetHumanRagdollImpactTable( player )
	
	bool tickCanDoDamage = file.playerTickCanDoDamageByDefault
	// override from default value
	if ( tickCanDoDamageOverride != null )
		tickCanDoDamage = expect bool( tickCanDoDamageOverride )

	int team = player.GetTeam()
	vector origin = player.GetOrigin()
	vector angles = player.GetAngles()
	
	entity tick = CreateFragDroneCan( team, origin, < 0, angles.y, 0 > )
	SetSpawnOption_AISettings( tick, tickAiSettings )

	tick.kv.contents = (int(tick.kv.contents) | CONTENTS_NOGRAPPLE)
	tick.ai.killShotSound = false
	
	// if tick cannot do damage, we assign fake explosion for them
	if ( !tickCanDoDamage )
		SuicideSpectre_SetNotExploding( tick )

	DispatchSpawn( tick )

	// remove tick's original think and stuffs
	// these utility functions are defined in modified _ai_suicide_spectres.gnut
	RemoveSuicideSpectre( tick ) // maybe not good enough!! this will remove their anim event, we can't use it to identify what they're doing
	
	// lock player until tick is armed
	// really need a movement utility func to handle control freezing...
	tick.SetBossPlayer( player )
	player.FreezeControlsOnServer()
	AddAnimEvent( tick, "frag_drone_armed", FragDroneArmed ) // guess we manually add an anim event??? also handles control freezing
	
	// start deploy without delay
	thread FragDroneDeplyAnimation( tick, 0.0, 0.1 )

	// update player health
	player.SetMaxHealth( tick.GetMaxHealth() )
	player.SetHealth( tick.GetHealth() )

	// setup everything
	player.SetNoTarget( true )
	PainDeathSounds_SetDisabledForEntity( player, true ) // temp
	DeathPackage_SetDisabledForEntity( player, true )
	file.playerFakeNPC[ player ] <- tick

	// our tick maybe safe to other entities
	if ( !tickCanDoDamage )
	{
		tick.SetEfficientMode( true )
		//tick.SetTouchTriggers( false )
		tick.SetNoTarget( true )
		tick.SetAimAssistAllowed( false )
	}

	// setup tick
	tick.Highlight_SetInheritHighlight( true )

	tick.SetShieldHealthMax( player.GetShieldHealthMax() )
	tick.SetShieldHealth( player.GetShieldHealth() )

	tick.SetParent( player, "ORIGIN" )
	SetForceDrawWhileParented( tick, true )

	if ( BATTERY_SPAWNERS.contains( player.GetUID() ) )
		HideName( tick )

	// pass damage to player
	AddEntityCallback_OnFinalDamaged( tick, OnFakeNPCFinalDamaged )
	AddEntityCallback_OnPostDamaged( player, OnTickPlayerDamaged )
	// disables health regen. utility defined in modified _health_regen.gnut
	HealthRegen_SetDisabled( false, player )

	thread PlayerTickThink( player, tick, moveSpeedScale, suicideChaseTime, suicideChaseSpeedScale, overloadDelayAdjustment )
	thread PlayerTickAnimationThink( player, tick ) // tick animation is pretty simple compare to marvin's, use thread here
	thread DisableBoostBar( player )

	return tick
}

void function FragDroneArmed( entity npc )
{
	//print( "frag drone armed!" )
	npc.ai.fragDroneArmed = true
	entity bossPlayer = npc.GetBossPlayer()

	if ( IsValid( bossPlayer ) )
		bossPlayer.UnfreezeControlsOnServer() // unfreeze their owner
}

void function OnTickPlayerDamaged( entity player, var damageInfo )
{
	// upon damage, start suicide chase
	if ( DamageInfo_GetDamage( damageInfo ) > 0 ) // shield taking damage won't do anything...?
	{
		entity tick = file.playerFakeNPC[ player ]
		if ( IsAlive( tick ) && tick.ai.fragDroneArmed ) // validate tick
		{
			if ( !file.playerTickDoingSuicideChase[ player ] )
			{
				thread PlayerTickStartsSuicideChase( player )
				file.playerTickDoingSuicideChase[ player ] = true
			}
			else if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING ) // tick overloading
				player.Signal( "OverloadingTickTookDamage" ) // detonate immediately
		}
	}
}

void function PlayerTickStartsSuicideChase( entity player )
{
	entity tick = file.playerFakeNPC[ player ]
	if ( !IsAlive( tick ) )
		return

	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )

	// get tick's settings!
	float suicideChaseTime = file.tickOverloadBehavior[ tick ].suicideChaseTime
	float suicideChaseSpeedScale = file.tickOverloadBehavior[ tick ].suicideChaseSpeedScale

	// debug
	//suicideChaseTime = 10
	//suicideChaseSpeedScale = 3

	if ( suicideChaseTime > 0 )
	{
		if ( suicideChaseSpeedScale > 1.0 )
		{
			StatusEffect_AddTimed( player, eStatusEffect.speed_boost, GetSpeedBoostEffectSeverity( suicideChaseSpeedScale ), suicideChaseTime, 0.0 )
			tick.SetNPCMoveSpeedScale( suicideChaseSpeedScale ) // does this scales up animation cycle?
		}
		float endTime = Time() + suicideChaseTime
		while ( Time() < endTime )
		{
			float timeLeftToExplode = floor( (endTime - Time() ) * 100 ) / 100
			#if !NESSIE_FUNNY_DEBUG
				SendHudMessage( player, "距離過載剩餘：" + timeLeftToExplode, -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
				//SendHudMessage( player, "Overloading in: " + timeLeftToExplode, -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
			#endif
			WaitFrame()
		}
	}

	waitthread PlayerTickOverloads( player, tick )
}

// player's speed_boost effect is actually value^2, needs a utility for calculating
float function GetSpeedBoostEffectSeverity( float expectedSpeedScale )
{
	// temptemp
	//print( "expectedSpeedScale: " + string( expectedSpeedScale ) )
	if ( expectedSpeedScale < 1 ) // given value is not good!
		return 0.0
	
	float boostSeverity = sqrt( expectedSpeedScale ) - 1
	//print( "boostSeverity: " + string( boostSeverity ) )
	return boostSeverity
}

void function PlayerTickThink( entity player, entity tick, float moveSpeedScale, float suicideChaseTime, float suicideChaseSpeedScale, float overloadDelayAdjustment )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "player_embarks_titan" ) // maybe no need to add this... embarking as tick kills you!
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )

	// get all settings value
	// if there're no settings override, use default value

	if ( moveSpeedScale == -1 )
	{
		float minSpeedScale = expect float( tick.Dev_GetAISettingByKeyField( "minSpeedScale" ) )
		float maxSpeedScale = expect float( tick.Dev_GetAISettingByKeyField( "maxSpeedScale" ) )
		moveSpeedScale = ( minSpeedScale + maxSpeedScale ) / 2
		//print( "moveSpeedScale: " + string( moveSpeedScale ) )
	}

	if ( suicideChaseTime == -1 )
	{
		if ( tick.Dev_GetAISettingByKeyField( "SuicideChaseTime" ) != null )
			suicideChaseTime = expect float( tick.Dev_GetAISettingByKeyField( "SuicideChaseTime" ) )
		else
			suicideChaseTime = 0.0
	}
	
	if ( suicideChaseSpeedScale == -1 )
		suicideChaseSpeedScale = expect float( tick.Dev_GetAISettingByKeyField( "maxSpeedScale" ) )
	
	if ( overloadDelayAdjustment == -1 )
	{
		overloadDelayAdjustment = 0.0
		// same checks as _ai_suicide_spectres.gnut does
		bool isFragDrone = tick.mySpawnOptions_aiSettings == "npc_frag_drone_throwable"
		if ( !isFragDrone )
			overloadDelayAdjustment = 0.25
	}

	TickOverloadBehavior overloadBehaviorStruct
	overloadBehaviorStruct.suicideChaseTime = suicideChaseTime
	overloadBehaviorStruct.suicideChaseSpeedScale = suicideChaseSpeedScale
	overloadBehaviorStruct.overloadDelayAdjustment = overloadDelayAdjustment
	file.tickOverloadBehavior[ tick ] <- overloadBehaviorStruct

	array<int> statusEffectsToCleanUp
	// add move speed penalty to prevent sprinting
	statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.1 ) )
	// add basic speed boost
	if ( moveSpeedScale > 1.0 )
	{
		statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.speed_boost, GetSpeedBoostEffectSeverity( moveSpeedScale ) ) )
		tick.SetNPCMoveSpeedScale( moveSpeedScale ) // does this scales up animation cycle?
	}
	//else // lower than 1, idk how to add slow effect...

	// start third person tracking
	TickPlayerTrackView( player )

	OnThreadEnd
	(
		function(): ( player, tick, statusEffectsToCleanUp )
		{
			if ( IsValid( tick ) )
			{
				RemoveEntityCallback_OnFinalDamaged( tick, OnFakeNPCFinalDamaged )
				tick.Anim_Stop()
				HideName( tick )
				tick.ClearParent()
				if ( IsAlive( tick ) )
					tick.Die( tick, tick, { damageSourceId = damagedef_suicide } )
			}
			if ( IsValid( player ) )
			{
				RemoveEntityCallback_OnPostDamaged( player, OnTickPlayerDamaged )
				HealthRegen_ClearDisabledSettingsOverride( player )
				player.Signal( "ClearTickPlayerTraverse" )

				// clean up
				foreach ( effect in statusEffectsToCleanUp )
					StatusEffect_Stop( player, effect )
				
				player.Anim_Stop()
				player.SetNoTarget( false )
				player.SetTrackEntity( null )
				player.ClearTrackEntitySettings()

				PainDeathSounds_SetDisabledForEntity( player, false )
				DeathPackage_SetDisabledForEntity( player, false )

				RestorePlayerPermanentAirSpeed( player )
				RestorePlayerPermanentAirAcceleration( player )

				ShowName( player )
				player.Solid()
				player.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
				player.UnforceStand()

				if ( IsAlive( player ) )
					player.Die( player, player, { damageSourceId = damagedef_suicide } )

				file.playerFakeNPC[ player ] = null
				file.playerTickDoingSuicideChase[ player ] = false // so next tick will be able to do suicide chase
			}
		}
	)

	//thread ClearTickPlayerTraverse( player )
	float lastStartTraverseTime = -1
	
	while ( true )
	{
		TakeAllWeapons( player )

		// health
		int playerMaxHealth = player.GetMaxHealth()
		int playerHealth = player.GetHealth()

		// class mods
		string setFile = player.GetPlayerSettings()
		array<string> classMods = player.GetPlayerSettingsMods()
		// maybe funnier to use pilot_boost?
		// nah, works bad. they don't have double jumping and can't disable wallrun 
		bool isColiseumMale = setFile == "pilot_coliseum_male"
		//bool isPilotBoostMale = setFile == "pilot_boost_male"
		bool hasMovementLimiter = classMods.contains( "disable_wallrun" )

		//if ( !isPilotBoostMale || !hasMovementLimiter )
		if ( !isColiseumMale || !hasMovementLimiter )
		{
			player.SetPlayerSettingsWithMods( "pilot_coliseum_male", ["disable_wallrun"] )
			//player.SetPlayerSettingsWithMods( "pilot_boost_male", [] )
		
			// update health
			player.SetMaxHealth( playerMaxHealth )
			player.SetHealth( playerHealth )

			// update mid-air control
			/*
			player.kv.airSpeed = int( player.kv.airSpeed ) * 0.5
			player.kv.airAcceleration = int( player.kv.airAcceleration ) * 1.5
			*/
			player.kv.airSpeed = 50 // normal pilot value
			player.kv.airAcceleration = 720 // pilot_coliseum value
		}

		// hide the player
		HideName( player )
		player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
		player.NotSolid() // non-solid makes player unable to take trigger_hurt damage and won't trigger OOB
		player.kv.CollisionGroup = 0 // TRACE_COLLISION_GROUP_BLOCK_WEAPONS

		// movement limiter
		// still feels bad! don't know how to handle, maybe higher air speed
		// nah, just need a higher tickrate. handled by ClearTickPlayerTraverse()
		// still feels bad because it blocks player from reaching higher place
		// maybe we only clear it when player mantling for too long
		//player.ClearTraverse() // ticks can double jump, so we'd remove their ability to traverse

		if ( player.IsTraversing() )
		{
			if ( lastStartTraverseTime == -1 )
				lastStartTraverseTime = Time()
			else if ( Time() - lastStartTraverseTime > 0.5 ) // maxnium of 0.5s(was 1s) mantling. needs keep holding direction button to traverse
				player.ClearTraverse()
		}
		else
			lastStartTraverseTime = -1

		player.ForceStand() // avoid camera glitch when using chasing cam

		// idk why ticks will ignore projectile damage
		// it's because _ai_suicide_spectres.gnut. has been fixed!
		//tick.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS // was 0, which may make them invulnerable to projectiles...?

		// wait till tick finish arming
		if ( tick.ai.fragDroneArmed )
		{
			// ready to detonate???
			bool attackHeld = player.IsInputCommandHeld( IN_ATTACK )
			bool zoomHeld = player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE )
			if ( attackHeld && zoomHeld )
			{
				waitthread PlayerTickOverloads( player, tick )
				return
			}
			else if ( attackHeld || zoomHeld ) // only one button held, do something
			{
				#if !NESSIE_FUNNY_DEBUG
					SendHudMessage( player, "同時按住 開火+開鏡 以進行過載", -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
					//SendHudMessage( player, "Hold both ATTACK + ZOOM to overload", -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
				#endif
			}
		}

		WaitFrame()
	}
}

void function ClearTickPlayerTraverse( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	player.Signal( "ClearTickPlayerTraverse" )
	player.EndSignal( "ClearTickPlayerTraverse" )

	while ( true )
	{
		player.ClearTraverse()

		WaitFrame( true ) // higher tickrate!
	}
}

void function PlayerTickOverloads( entity player, entity tick )
{
	if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING ) // already overloading?
		return

	// endSignals inherit from PlayerTickThink()
	
	// to end PlayerTickAnimationThink()
	player.Signal( "TickPlayerStartsOverload" )
	//UpdatePlayerTickMovementState( player, eTickMovement.OVERLOADING )
	file.fakeTickMovementState[ tick ] = eTickMovement.OVERLOADING // mark as tick overloading

	bool isFragDrone = tick.mySpawnOptions_aiSettings == "npc_frag_drone_throwable"
	// can't handle airpop's animation initial pos... temp removed
	//bool airPop = !player.IsOnGround()
	bool airPop = false

	// if we're doing suicide chase, airpop shouldn't emit sound
	string overloadSF
	if ( !airPop || !file.playerTickDoingSuicideChase[ player ] )
	{
		if ( isFragDrone )
			overloadSF = "weapon_sentryfragdrone_preexplo"
		else
			overloadSF = "corporate_spectre_overload_beep"
		// Overload Sound
		EmitSoundOnEntity( tick, overloadSF )
	}

	AI_CreateDangerousArea_DamageDef( damagedef_frag_drone_explode, tick, TEAM_INVALID, true, false )

	string overloadAnim = "sp_suicide_spectre_explode_stand"
	if ( airPop ) // airpop
	{
		overloadAnim = "sd_jump_explode"
		// airpop shouldn't have overload delay, but player can choose to do so... maybe no need to add?
		//overloadDelayAdjustment = 0.0
	}

	// freeze movements
	// welp, not good enough, we need freeze player so they can't jump
	//int moveLockEffect = StatusEffect_AddEndless( player, eStatusEffect.move_slow, 1.0 )
	// really need a movement utility func to handle control freezing...
	player.FreezeControlsOnServer()
	player.ClearTraverse() // remove any traversal in progress

	// Cleanup on thread end
	OnThreadEnd(
		// change to use control freeze
		//function() : ( player, tick, overloadSF, moveLockEffect )
		function() : ( player, tick, overloadSF )
		{
			if ( IsValid( player ) )
			{
				// change to use control freeze
				//StatusEffect_Stop( player, moveLockEffect )
				player.UnfreezeControlsOnServer()
			}
			if ( IsValid( tick ) )
			{
				if ( overloadSF != "" )
					StopSoundOnEntity( tick, overloadSF )
			}
		}
	)

	float sequenceDuration = tick.GetSequenceDuration( overloadAnim )
	float overloadDelayAdjustment = file.tickOverloadBehavior[ tick ].overloadDelayAdjustment

	float expectedTimer = sequenceDuration + overloadDelayAdjustment
	//print( "overloadDelayAdjustment: " + string( overloadDelayAdjustment ) )
	//print( "expectedTimer: " + string( expectedTimer ) )
	thread TrackTickTimerRunsOut( tick, expectedTimer )

	// can't play with ref point while parented
	//thread PlayAnim( tick, overloadAnim )
	tick.Anim_ScriptedPlay( overloadAnim )
	tick.Anim_DisableUpdatePosition()
	// explode when taking damage or timer runs out
	WaitSignal( tick, "OnAnimationInterrupted", "OnAnimationDone", "TickPlayerTimerRunsOut", "OverloadingTickTookDamage" )

	// explode. player dies without ragdoll
	// tick will explode without issue
	player.Die( player, player, { damageType = DMG_REMOVENORAGDOLL, damageSourceId = eDamageSourceId.suicideSpectreAoE } )
}

void function TrackTickTimerRunsOut( entity tick, float expectedTimer )
{
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )
	
	wait expectedTimer
	tick.Signal( "TickPlayerTimerRunsOut" )
}

void function PlayerTickAnimationThink( entity player, entity tick )
{
	// end signals for overloading
	player.EndSignal( "TickPlayerStartsOverload" )

	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )

	// nah these can't handle well... traverse animation can't be used to fake jumping
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, OnTickPlayerJump )
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, OnTickPlayerDoubleJump )
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, OnTickPlayerTouchGround )

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, OnTickPlayerJump )
				RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, OnTickPlayerDoubleJump )
				RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, OnTickPlayerTouchGround )
			}
		}
	)

	// wait till fully arm!
	while ( !tick.ai.fragDroneArmed )
		WaitFrame()

	// idle init
	tick.Anim_ScriptedPlay( "sd_spectre_idle" )
	file.fakeTickMovementState[ tick ] <- eTickMovement.IDLE

	while ( true )
	{
		// defensive fix
		if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING )
			return

		if ( file.fakeTickMovementState[ tick ] != eTickMovement.JUMPING )
		{
			// can't handle in-air animation, guess sound and jet effect is enough
			/*
			if ( !player.IsOnGround() ) // consider freefalling
			{
				
			}
			else if ( Length( player.GetVelocity() ) > 10 )
			*/
			// welp, maybe skip updating when player isn't on ground could be better
			if ( player.IsOnGround() )
			{
				UpdatePlayerTickAnimation( player, tick )
			}
		}

		WaitFrame()
	}
}

// WIP: animation
void function OnTickPlayerJump( entity player )
{
	//print( "RUNNING OnTickPlayerJump()" )
	// animation don't work well. sound is enough
	/*
	UpdatePlayerTickMovementState( player, eTickMovement.JUMPING )
	player.Signal( "TickPlayerJump" )
	thread TickPlayerJump( player )
	*/
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		UpdatePlayerTickAnimation( player, tick )
		PlayFragDroneSound( tick, "jump_default_3p" )
	}
}

void function OnTickPlayerDoubleJump( entity player )
{
	//print( "RUNNING OnTickPlayerDoubleJump()" )
	// animation don't work well. sound and effect is enough
	/*
	UpdatePlayerTickMovementState( player, eTickMovement.JUMPING )
	//player.Signal( "TickPlayerDoubleJump" )
	player.Signal( "TickPlayerJump" ) // same signal should be enough
	thread TickPlayerJump( player, true )
	*/
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		UpdatePlayerTickAnimation( player, tick )
		// already got jump jet sound
		//EmitSoundOnEntity( tick, "sentryfragdrone_jump_default_3p" )

		// for sp tick only: jet effect
		bool isSPFragDrone = tick.GetModelName() == $"models/robots/drone_frag/drone_frag.mdl"
		if ( isSPFragDrone )
			PlayFXOnEntity( $"P_frag_drone_jump_jet", tick, "HEADFOCUS" )
	}
}

void function OnTickPlayerTouchGround( entity player )
{
	//print( "RUNNING OnTickPlayerTouchGround()" )
	/*
	UpdatePlayerTickMovementState( player, eTickMovement.LANDING )
	player.Signal( "TickPlayerTouchGround" )
	*/

	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		UpdatePlayerTickAnimation( player, tick )
		// should we remove sound for traversing?
		// somehow makes player themselves feels janky... because they can't hear their own traverse sound in third person
		// but landing sound for SP frag drone is a bit too loud ahhhh
		//if ( !player.IsTraversing() )
			PlayFragDroneSound( tick, "land_default_3p" )
	}
}

void function PlayFragDroneSound( entity tick, string soundSuffix )
{
	bool isSPFragDrone = tick.GetModelName() == $"models/robots/drone_frag/drone_frag.mdl"
	string soundPrefix = isSPFragDrone ? "tick" : "sentryfragdrone"

	EmitSoundOnEntity( tick, soundPrefix + "_" + soundSuffix )
}

// these funcs are not good enough
/*
void function UpdatePlayerTickMovementState( entity player, int expectedState )
{
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) && ( tick in file.fakeTickMovementState ) )
		file.fakeTickMovementState[ tick ] = expectedState
}

void function TickPlayerJump( entity player, bool isAirJump = false )
{
	player.EndSignal( "TickPlayerTouchGround" )
	player.EndSignal( "TickPlayerJump" )

	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		tick.Anim_ScriptedPlay( "sd_traverse_over" )
		tick.Anim_DisableUpdatePosition()
	}
}
*/

void function UpdatePlayerTickAnimation( entity player, entity tick )
{
	// not armed yet!
	if ( !( tick in file.fakeTickMovementState ) )
		return
	
	if ( Length( < player.GetVelocity().x, player.GetVelocity().y, 0 > ) > 10 ) // walking. only calculate horizontal velocity
	{
		if ( file.fakeTickMovementState[ tick ] != eTickMovement.WALKING )
		{
			file.fakeTickMovementState[ tick ] = eTickMovement.WALKING
			tick.Anim_ScriptedPlay( "sd_aggressive_runaim" )
			tick.Anim_DisableUpdatePosition()
		}
	}
	else // idling
	{
		if ( file.fakeTickMovementState[ tick ] != eTickMovement.IDLE )
		{
			file.fakeTickMovementState[ tick ] = eTickMovement.IDLE
			tick.Anim_ScriptedPlay( "sd_spectre_idle" )
		}
	}
}

void function TickPlayerTrackView( entity player )
{
	player.SetTrackEntity( player ) // Sets an entity to be viewed by this player in third person

	player.SetTrackEntityPitchLookMode( "orbit" )
	player.SetTrackEntityYawLookMode( "orbit" )
	player.SetTrackEntityDistanceMode( "scriptOffset" )
	player.SetTrackEntityMinYaw( -180 )
	player.SetTrackEntityMaxYaw( 180 )
	player.SetTrackEntityMinPitch( -30 )
	player.SetTrackEntityMaxPitch( 30 )

	bool isSPFragDrone = false
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
		isSPFragDrone = tick.GetModelName() == $"models/robots/drone_frag/drone_frag.mdl"
	
	if ( isSPFragDrone )
		player.SetTrackEntityOffset( < -130.0, 0, 30.0 > ) // sp tick is a bit larger
	else
		player.SetTrackEntityOffset( < -120.0, 0, 25.0 > )
}