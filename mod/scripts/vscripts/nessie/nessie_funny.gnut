global function Nessie_Funny_Functions_Init

// funny stuffs with clientcommand!
global function NessieFunny_EnableClientCommands

global function RGB_Highlight
global function TitleFlash

global function RainbowPlayerSkin
global function RainbowWeaponSkin

global function RGY_BatterySkin

// holoflash
global function HoloFlash_Loop
global function HoloFlash

// head
global function PlayerPulseBladeModel_HideBodyAndLegs
global function CreatePulseBladeHead
global function CreateWoundedHead
global function BindPulseBladeHeadToPlayer
global function BindeWoundedHeadToPlayer

// loadout
global function BecomeApexLegend

// rainbow dome
global function CreateRainbowDomeShield

// barrel spawn
global function CreatePhysicsBarrel

// player marvin
global function NessyFunny_EnableMarvinScriptedAnim // this may cause sound loss so need a setting
global function PlayerBecomeMarvin

enum eMarvinMovement
{
	IDLE,

	// walking and spriting doesn't working fine
	WALKING,
	SPRINTING,
	
	IN_AIR,

	WAVING,
	WELDING,
	WASHING_WINDOW,

	SCRIPTED_ANIMATION,

	_count_
}

struct MarvinIntroAnim
{
	string animName
	float initialTime = -1 // -1 means not modified
	float actualLength = -1 // -1 means not modified
	vector offset = < 0, 0, 0 >
	table<string, float> introSounds // have to manually control intro sounds... otherwise all players on map can hear it
	float introSoundRadius = 1500 // default value
}

// modifiable consts
const float MARVIN_INTRO_ANIM_COOLDOWN = 15.0 // gets applied after animation end

struct
{
	bool clientCommandsEnabled
	bool fakeMarvinScriptedAnimEnabled // this may cause sound loss so need a setting

	table<entity, bool> playerHasRGBHighlight
	table<entity, bool> playerHasRainbowSkin
	table<entity, entity> playerFlipperMover
	table<entity, entity> playerFakeMarvin

	table<entity, int> fakeMarvinMovementState
	table<entity, float> playerNextFakeMarvinScriptedAnimAllowedTime
	array<MarvinIntroAnim> marvinIntroAnims
} file

void function Nessie_Funny_Functions_Init()
{
	// precaching
	PrecacheModel( ROCKET_TURRET_MODEL )

	// signals
	// rgb highlight
    RegisterSignal( "StartRGBHighlight" )
	RegisterSignal( "EndRGBHighlight" )
	AddClientCommandCallback( "rgbself", CC_SelfRGBHighlight )

	// sb title
    RegisterSignal( "StartSBTitle" )
	RegisterSignal( "EndSBTitle" )
	//AddClientCommandCallback( "sbself", CC_SelfIMSBTitle )

	// rainbow skin
	RegisterSignal( "StartRainbowPlayer" )
	RegisterSignal( "EndRainbowPlayer" )
	RegisterSignal( "StartRainbowWeapon" )
	RegisterSignal( "EndRainbowWeapon" )

	// rgy battery
	RegisterSignal( "StartRGYBattery" )
	RegisterSignal( "EndRGYBattery" )

	// holo flash
	RegisterSignal( "StartHoloFlash" )
	RegisterSignal( "EndHoloFlash" )

	// self flip
	RegisterSignal( "EndFlipper" )
	AddClientCommandCallback( "flipself", CC_FlipPlayerSelf )

	// barrel
	//PrecacheModel( $"models/containers/barrel.mdl" ) // always precache barrel model
	//AddClientCommandCallback( "spawnbarrel", CC_ThrowABarrel )

	// others
	//AddClientCommandCallback( "rainbowdome", CC_SpawnRainbowDome )
	AddClientCommandCallback( "nessyoutfit", CC_SpawnNessyOutfit )

	// marvin
	InitMarvinIntroAnim()
	RegisterSignal( "MarvinMoveAnimThink" )
	AddClientCommandCallback( "becomemarvin", CC_PlayerBecomeFakeMarvin )

	// callbacks
	AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnDecoyCreated( OnDecoyCreated )
	AddCallback_OnModdedDecoyCreated( OnDecoyCreated )
	AddCallback_IsValidMeleeExecutionTarget( IsValidMeleeExecutionTarget )
}

// callbacks
void function OnClientConnected( entity player )
{
	file.playerHasRGBHighlight[ player ] <- false
	file.playerHasRainbowSkin[ player ] <- false
	file.playerFlipperMover[ player ] <- null
	file.playerFakeMarvin[ player ] <- null
	file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] <- 0.0
}

void function OnDecoyCreated( entity decoy )
{
	entity bossPlayer = decoy.GetBossPlayer()
	if ( IsValid( bossPlayer ) )
	{
		// inherit rgb highlight to decoy
		if ( file.playerHasRGBHighlight[ bossPlayer ] )
			thread RGB_Highlight( decoy, true )
		// inherit rainbow skin to decoy
		if ( file.playerHasRainbowSkin[ bossPlayer ] )
			thread RainbowPlayerSkin( decoy )
	}
}

bool function IsValidMeleeExecutionTarget( entity attacker, entity target )
{
	if ( attacker.IsPlayer() && IsValid( file.playerFakeMarvin[ attacker ] ) )
		return false

	if ( target.IsPlayer() && IsValid( file.playerFakeMarvin[ target ] ) )
		return false
	
	return true
}

// client commands
void function NessieFunny_EnableClientCommands( bool enable )
{
	file.clientCommandsEnabled = enable
}

bool function CC_SpawnRainbowDome( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	float duration = -1 // infinite hold time
	if ( args.len() > 0 )
		duration = float( args[0] )
	CreateRainbowDomeShield( player.GetOrigin(), < 0,0,0 >, duration )

	return true
}

void function DelayedDestroyRainbowDome( entity domeShield, float delay )
{
	wait delay

	domeShield.Destroy()
}

bool function CC_SpawnNessyOutfit( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	SpawnNessyOutfit( player )
	return true
}

bool function CC_SelfRGBHighlight( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false
	//if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
	//	return false

	thread RGB_Highlight( player, true )
	return true
}

bool function CC_SelfIMSBTitle( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	thread TitleFlash( player )
	return true
}

bool function CC_FlipPlayerSelf( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	thread FlipperMoverThink( player )

	return true
}

bool function CC_ThrowABarrel( entity player, array<string> args )
{
	//if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
	//	return false

	entity barrel = CreatePhysicsBarrel( player.EyePosition(), < 0, player.EyeAngles().y, 0 > )
    barrel.SetVelocity( player.GetViewVector() * 1000 )
	return true
}

bool function CC_PlayerBecomeFakeMarvin( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	PlayerBecomeMarvin( player )
	return true
}
//

void function RGB_Highlight( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	ent.Signal( "StartRGBHighlight" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartRGBHighlight" )
	ent.EndSignal( "EndRGBHighlight" )

	// player specific
	if ( ent.IsPlayer() )
	{
		file.playerHasRGBHighlight[ ent ] = true
	}

	OnThreadEnd(
		function(): ( ent )
		{
			if( IsValid( ent ) )
			{
				// player specific
				if ( ent.IsPlayer() )
					file.playerHasRGBHighlight[ ent ] = false

				Highlight_ClearFriendlyHighlight( ent )
				Highlight_ClearEnemyHighlight( ent )
				Highlight_ClearNeutralHighlight( ent )
				Highlight_ClearOwnedHighlight( ent )
			}
		}
	)

	while ( true )
	{
		waitthread RGBHighlightThink( ent, showToAll, alwaysShow )
		ent.WaitSignal( "StopPhaseShift" ) // wait for exiting phase shift, we do highlight again!
	}
}

void function RGBHighlightThink( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	ent.EndSignal( "StartPhaseShift" ) // phase shift cleans up highlight

	string highlightToUse = "sp_enemy_pilot" // normal one, visible through viewmodel, kinda funny
	if ( alwaysShow )
		highlightToUse = "sp_friendly_hero" // this one will show across walls

	array<vector> colorArray = [ < 255,0,0 >, < 0,255,0 >, < 0,0,255 > ]
	int index = 0
	while( true )
	{
		index = index == colorArray.len() - 1 ? 0 : index + 1

		// needs to update highlight for every loop... in case we can update it for later-joiners
		Highlight_SetFriendlyHighlight( ent, highlightToUse )
		Highlight_SetOwnedHighlight( ent, highlightToUse )
		ent.Highlight_SetParam( 1, 0, colorArray[index] ) // friendly
		ent.Highlight_SetParam( 3, 0, colorArray[index] ) // owned

		if( showToAll )
		{
			Highlight_SetEnemyHighlight( ent, highlightToUse )
			Highlight_SetNeutralHighlight( ent, highlightToUse )
			ent.Highlight_SetParam( 2, 0, colorArray[index] ) // enemy
			ent.Highlight_SetParam( 0, 0, colorArray[index] ) // neutral
		}

		// never wait before we actually update entity's highlight
		// if we do, an entity spawn with no highlight will crash the server
		WaitFrame()
	}
}

void function TitleFlash( entity ent, array<string> titleArray = [ "我是傻逼", "傻逼是我" ] )
{
	if ( titleArray.len() <= 0 ) // no title given
		return
	ent.Signal( "StartSBTitle" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartSBTitle" )
	ent.EndSignal( "EndSBTitle" )

	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == titleArray.len() - 1 ? 0 : index + 1

		ent.SetTitle( titleArray[index] )
	}
}

void function RainbowPlayerSkin( entity player )
{
	if( !PilotModelSupportsCamo( player ) )
		return
	player.Signal( "StartRainbowPlayer" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartRainbowPlayer" )
	player.EndSignal( "EndRainbowPlayer" )

	// player specific
	if ( player.IsPlayer() )
		file.playerHasRainbowSkin[ player ] = true

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				// player specific
				if ( player.IsPlayer() )
					file.playerHasRainbowSkin[ player ] = false
			}
		}
	)

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		player.SetSkin( 1 )
		player.SetCamo( camoIndexArray[index] )
	}
}


array<asset> PILOT_MODELS_SUPPORTS_CAMO =
[
	$"models/humans/pilots/pilot_medium_stalker_m.mdl",
	$"models/humans/pilots/pilot_medium_stalker_f.mdl",
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_light_ged_f.mdl",
	$"models/humans/pilots/pilot_light_jester_m.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
	$"models/humans/pilots/pilot_medium_reaper_m.mdl"
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/pilot_medium_geist_m.mdl",
	$"models/humans/pilots/pilot_medium_geist_f.mdl",
	$"models/humans/pilots/pilot_heavy_roog_m.mdl",
	$"models/humans/pilots/pilot_heavy_roog_f.mdl",
	$"models/humans/pilots/pilot_heavy_drex_m.mdl",
	$"models/humans/pilots/pilot_heavy_drex_f.mdl"
]

bool function PilotModelSupportsCamo( entity player )
{
	asset modelName = player.GetModelName()
	if ( PILOT_MODELS_SUPPORTS_CAMO.contains( modelName ) )
	 	return true

	return false
}

void function RainbowWeaponSkin( entity weaponOwner )
{
	weaponOwner.Signal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "OnDestroy" )
	weaponOwner.EndSignal( "OnDeath" )
	weaponOwner.EndSignal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "EndRainbowWeapon" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		foreach( entity weapon in weaponOwner.GetMainWeapons() )
		{
			weapon.SetSkin( 1 )
			weapon.SetCamo( camoIndexArray[index] )
		}
	}
}

void function RGY_BatterySkin( entity battery )
{
	if( battery.GetClassName() != "item_titan_battery" )
		return

	battery.Signal( "StartRGYBattery" )
	battery.EndSignal( "OnDestroy" )
	battery.EndSignal( "StartRGYBattery" )
	battery.EndSignal( "EndRGYBattery" )

	int index = 0
	while( true )
	{
		//print( "setting battery skin: " + string( index ) )
		WaitFrame()
		battery.SetSkin( index )
		Battery_StopFX( battery )
		if( index == 2 )
			index = 0
		else
			index++
	}
}

void function HoloFlash_Loop( entity player, float interval = 1.0 )
{
	player.Signal( "StartHoloFlash" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartHoloFlash" )
	player.EndSignal( "EndHoloFlash" )

	while( true )
	{
		wait interval

		HoloFlash( player )
	}
}

void function HoloFlash( entity player )
{
	int attachIndex = player.LookupAttachment( "CHESTFOCUS" )
	//StartParticleEffectOnEntity( player, GetParticleSystemIndex( GHOST_TRAIL_EFFECT ), FX_PATTACH_POINT_FOLLOW, attachIndex )
	entity flashFX = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( GHOST_FLASH_EFFECT ), FX_PATTACH_POINT, attachIndex )
	flashFX.SetOwner( player )
	SetTeam( flashFX, player.GetTeam() )
	flashFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // not owner only
}

void function PlayerPulseBladeModel_HideBodyAndLegs( entity player )
{
	player.SetModel( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = player.FindBodyGroup( "body" )
	player.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = player.FindBodyGroup( "legs" )
	player.SetBodygroup( bodyGroupIndex, 0 )
}

// create a pulseblade pilot's head
entity function CreatePulseBladeHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

// create a headshot head! this is not a model that can freely scale
entity function CreateWoundedHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "head" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

void function BindPulseBladeHeadToPlayer( entity player )
{
	entity head = CreatePulseBladeHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
	
	//head.SetSkin( 2 )
	//head.SetCamo( 14 )
}

void function BindeWoundedHeadToPlayer( entity player )
{
	entity head = CreateWoundedHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
}

void function TrackPlayerDeathForHeadProp( entity player, entity head )
{
	player.EndSignal( "OnDestroy" )

	WaitFrame() // since altpilot resets player's visibility everytime they respawn or changeloadout
	player.kv.VisibilityFlags = 0 // hide player

	OnThreadEnd(
		function():( head )
		{
			if ( IsValid( head ) )
				head.Destroy()
		}
	)

	player.WaitSignal( "OnDeath" )
	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // restore player visibility!
}

void function BecomeApexLegend( entity player, asset model ) // ash, blisk, jack, sarah
{
	TakeAllWeapons( player )

	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_phase"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_ORDNANCE, ["octane_stim"] )
	player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_ANTIRODEO, ["deployable_dome_shield"] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, ["dash_melee", "pushback_melee"] )
	player.GiveWeapon( "mp_weapon_gunship_missile", ["pilot_emptyhanded"] )
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), ["disable_doublejump","only_wallclimb", "pas_wallhang"] )

	player.SetModel( model )
	GivePassive( player, ePassives.PAS_STEALTH_MOVEMENT ) // hide jetpack flame
	Rodeo_SetStealthMovementDisabledForPlayer( player, true ) // disable stealth rodeo, so player will have jetpack modified only

	thread DisableBoostBar( player )
}

void function DisableBoostBar( entity player )
{
	WaitFrame()
	if( IsValid( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

entity function CreateRainbowDomeShield( vector origin, vector angles, float duration = -1, bool notSolid = false )
{
	entity bubbleShield = CreateEntity( "prop_dynamic" )
	bubbleShield.SetValueForModelKey( $"models/fx/xo_shield.mdl" )
	if ( !notSolid )
		bubbleShield.kv.solid = SOLID_VPHYSICS
    bubbleShield.kv.rendercolor = "81 130 151"
    bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
	bubbleShield.SetOrigin( origin )
	bubbleShield.SetAngles( angles )
	bubbleShield.Hide()

    // Blocks bullets, projectiles but not players and not AI
	// THIS IS BAD BEHAVIOR
    // TRACE_COLLISION_GROUP_BLOCK_WEAPONS makes scorch thermite pass through shield
	//bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
    bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS
	bubbleShield.SetBlocksRadiusDamage( true )
	DispatchSpawn( bubbleShield )
    array<entity> bubbleShieldFXs
	vector coloredFXOrigin = bubbleShield.GetOrigin()
	table bubbleShieldDotS = expect table( bubbleShield.s )

	//Create friendly and enemy colored particle systems
	entity rainbowColoredFX = StartParticleEffectInWorld_ReturnEntity( BUBBLE_SHIELD_FX_PARTICLE_SYSTEM_INDEX, coloredFXOrigin, angles )
	thread RainbowColorThink( rainbowColoredFX )
	bubbleShieldFXs.append( rainbowColoredFX )

	// should set all bubble shield particle to disable hibernation
	foreach ( entity particle in bubbleShieldFXs )
	{
		if ( IsValid( particle ) )
			particle.DisableHibernation() 
	}

    EmitSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
    thread CleanupBubbleShield( bubbleShield, bubbleShieldFXs, duration )

	return bubbleShield
}

void function RainbowColorThink( entity fx )
{
	fx.EndSignal( "OnDestroy" )

	vector rgb = < 255, 0, 0 > // start with red
	float segment = 25.5
	while ( true )
	{
		WaitFrame()

		// to < 255, 255, 0 >
		if ( rgb.x == 255 && rgb.y < 255 && rgb.z == 0 )
			rgb.y = min( 255, rgb.y + segment )
		// to < 0, 255, 0 >
		else if ( rgb.x > 0 && rgb.y == 255 && rgb.z == 0 )
			rgb.x = max( 0, rgb.x - segment )
		// to < 0, 255, 255 >
		else if ( rgb.x == 0 && rgb.y == 255 && rgb.z < 255 )
			rgb.z = min( 255, rgb.z + segment )
		// to < 0, 0, 255 >
		else if ( rgb.x == 0 && rgb.y > 0 && rgb.z == 255 )
			rgb.y = max( 0, rgb.y - segment )
		// to < 255, 0, 255 >
		else if ( rgb.x < 255 && rgb.y == 0 && rgb.z == 255 )
			rgb.x = min( 255, rgb.x + segment )
		// to < 255, 0, 0 >, a whole loop done
		else if ( rgb.x == 255 && rgb.y == 0 && rgb.z > 0 )
			rgb.z = max( 0, rgb.z - segment )

		//print( rgb )
		EffectSetControlPointVector( fx, 1, rgb )
	}
}

void function CleanupBubbleShield( entity bubbleShield, array<entity> bubbleShieldFXs, float fadeTime )
{
	bubbleShield.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( bubbleShield, bubbleShieldFXs )
		{
			if ( IsValid_ThisFrame( bubbleShield ) )
			{
				StopSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
				EmitSoundOnEntity( bubbleShield, "BubbleShield_End" )
				DestroyBubbleShield( bubbleShield )
			}

			foreach ( fx in bubbleShieldFXs )
			{
				if ( IsValid_ThisFrame( fx ) )
				{
					EffectStop( fx )
				}
			}
		}
	)

	if ( fadeTime == -1 ) // default
		WaitForever()
	else if ( fadeTime > 0 )
		wait fadeTime
}

// flipper
void function FlipperMoverThink( entity player )
{
	if ( !IsAlive( player ) ) // defensive fix
		return

	entity playerParent = player.GetParent()
	//print( "playerParent: " + string( playerParent ) )
	if ( IsValid( playerParent ) )
	{
		if ( playerParent == file.playerFlipperMover[ player ] )
			player.Signal( "EndFlipper" ) // try to end last flipper

		return // always return, whether player is parented with flipper or other entities
	}

	player.Signal( "EndFlipper" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "EndFlipper" )

	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-soli
	DispatchSpawn( viewControl )
	viewControl.EndSignal( "OnDestroy" )

	float offset = player.IsTitan() ? 500.0 : 200.0
	float playerViewYaw = player.EyeAngles().y
	float playerBackViewYaw = ClampAngle( playerViewYaw - 180 )
	viewControl.SetOrigin( player.GetOrigin() + AnglesToForward( < 0, playerBackViewYaw, 0 > ) * offset )
	viewControl.SetAngles( < 0, playerViewYaw, 0 > )
	player.SetViewEntity( viewControl, true )

	entity mover = CreateExpensiveScriptMover()
	mover.EndSignal( "OnDestroy" )

	mover.SetOrigin( player.GetOrigin() )
	mover.SetAngles( < 0, playerBackViewYaw, 0 > )
	player.SetParent( mover )
	file.playerFlipperMover[ player ] = mover

	OnThreadEnd
	(
		function(): ( player, mover, viewControl )
		{
			if ( IsValid( player ) )
			{
				player.ClearParent()
				FindNearestSafeSpotAndPutEntity( player, 1 )
				player.ClearViewEntity()
				file.playerFlipperMover[ player ] = null
			}

			if ( IsValid( viewControl ) )
				viewControl.Destroy()
			if ( IsValid( mover ) )
				mover.Destroy()
		}
	)

	int loopCount = 0
	while ( true )
	{
		float x = loopCount % 2 == 0 ? -180.0 : 0.0
		mover.NonPhysicsRotateTo( < x, playerBackViewYaw, 0 >, 0.3, 0, 0 )
		loopCount += 1
		wait 0.2
	}
}

// barrel
entity function CreatePhysicsBarrel( vector origin, vector angles )
{
	entity barrel = CreateEntity( "prop_physics" )
	barrel.SetValueForModelKey( $"models/containers/barrel.mdl" )
	barrel.SetModel( $"models/containers/barrel.mdl" )

	// spawn settings, copied from map_spawn.ent
	barrel.kv.spawnflags = "1"
	//barrel.kv.solid = SOLID_VPHYSICS
	barrel.kv.skin = "0"
	barrel.kv.shadowcastdist = "0"
	barrel.kv.rendermode = "0"
	barrel.kv.renderfx = "0"
	barrel.kv.rendercolor = "255 255 255"
	barrel.kv.renderamt = "255"
	barrel.kv.pressuredelay = "0"
	barrel.kv.physdamagescale = "0.1"
	barrel.kv.PerformanceMode = "0"
	barrel.kv.nodamageforces = "0"
	barrel.kv.minhealthdmg = "0"
	barrel.kv.mingpulevel = "0"
	barrel.kv.mincpulevel = "0"
	barrel.kv.maxgpulevel = "0"
	barrel.kv.maxcpulevel = "0"
	barrel.kv.massScale = "0"
	barrel.kv.inertiaScale = "1.0"
	barrel.kv.fadedist = "-1"
	barrel.kv.ExplodeRadius = "0"
	barrel.kv.ExplodeDamage = "0"
	barrel.kv.drawinfastreflection = "0"
	barrel.kv.disableX360 = "0"
	barrel.kv.disableshadows = "0"
	barrel.kv.disablereceiveshadows = "0"
	barrel.kv.Damagetype = "0"
	barrel.kv.damagetoenablemotion = "0"
	barrel.kv.allowfunnel = "1"
	barrel.kv.scale = "1"
	//barrel.kv.angles = "0 -26.065 0"
	//barrel.kv.origin = "3180 -4114 55.9981"
	//barrel.kv.targetname = "func_static_1"
	barrel.kv.physicsmode = "1"
	barrel.kv.forcetoenablemotion = "0"
	barrel.kv.classname = "prop_physics"

	barrel.SetOrigin( origin )
	barrel.SetAngles( angles )

	DispatchSpawn( barrel )
	barrel.SetModel( $"models/containers/barrel.mdl" )
	barrel.SetForceVisibleInPhaseShift( true )

	return barrel
}


// init marvin scripted anim
void function InitMarvinIntroAnim()
{
	// now we leave only freestyle, others needs testing
	/*
	MarvinIntroAnim greeter
	greeter.animName = "commander_MP_flyin_marvin_greeter"
	greeter.initialTime = -1 // needs testing
	greeter.actualLength = -1
	file.marvinIntroAnims.append( greeter )

	MarvinIntroAnim highfive
	highfive.animName = "commander_MP_flyin_marvin_highfive"
	highfive.initialTime = -1 // needs testing
	highfive.actualLength = -1
	file.marvinIntroAnims.append( highfive )

	MarvinIntroAnim salute
	salute.animName = "commander_MP_flyin_marvin_salute"
	salute.initialTime = -1 // needs testing
	salute.actualLength = -1
	file.marvinIntroAnims.append( salute )

	MarvinIntroAnim glitch
	glitch.animName = "commander_MP_flyin_marvin_glitch"
	glitch.initialTime = -1 // needs testing
	glitch.actualLength = -1
	file.marvinIntroAnims.append( glitch )
	*/

	MarvinIntroAnim freestyle
	freestyle.animName = "commander_MP_flyin_marvin_freestyle"
	freestyle.initialTime = -1 // needs testing
	freestyle.actualLength = 14
	freestyle.offset = < 0, 0, 0 >
	freestyle.introSounds = { 
		["commander_marvin_freestyle_music"] = 0.0,
		["commander_marvin_freestyle"] = 1.1,
		["diag_mcor_marvin_dropship_cmdr_freestyle"] = 1.1,
	}
	freestyle.introSoundRadius = 800 // freestyle is loud, needs reduced sound radius
	file.marvinIntroAnims.append( freestyle )
}

// this may cause sound loss so need a setting
void function NessyFunny_EnableMarvinScriptedAnim( bool enable )
{
	file.fakeMarvinScriptedAnimEnabled = enable
}

// player controlled marvin
entity function PlayerBecomeMarvin( entity player )
{
	if ( IsValid( file.playerFakeMarvin[ player ] ) )
		return

	if ( !IsAlive( player ) )
		return
	
	if ( player.IsTitan() || player.Anim_IsActive() || IsValid( player.GetParent() ) )
		return
	
	int team = player.GetTeam()
	vector origin = player.GetOrigin()
	vector angles = < 0, player.GetAngles().y, 0 >
	entity marvin = CreateMarvin( team, origin, angles )
	marvin.kv.spawnflags = 516
	marvin.kv.contents = (int(marvin.kv.contents) | CONTENTS_NOGRAPPLE)
	marvin.ai.killShotSound = false
	DispatchSpawn( marvin )

	// setup player
	// we still allow player to change player settings from loadout selection... as a easter egg
	// nope, never allow loadout change influence playerSetFile. now hanlded by PlayerMarvinThink()
	//player.SetPlayerSettingsWithMods( "pilot_coliseum_female", ["disable_doublejump", "disable_wallrun"] )
	player.SetNoTarget( true )
	PainDeathSounds_SetDisabledForEntity( player, true ) // temp
	DeathPackage_SetDisabledForEntity( player, true )
	file.playerFakeMarvin[ player ] = marvin
	// how do I hide highlight for this player?
	// now doing loop in PlayerMarvinThink()
	//SetUpFakeMarvinHighlight( player )

	// they can take doubled damage from passing-through and explosions, double the health
	//player.SetShieldHealthMax( 1000 )
	//player.SetShieldHealth( 1000 )
	SetShieldHealthMaxWithFix( player, 1000 )
    SetShieldHealthWithFix( player, 1000 )
	player.SetMaxHealth( 1000 )
	player.SetHealth( 1000 )

	// setup marvin
	// dont let AI titan get enemies. Don't do trigger checks
	marvin.SetEfficientMode( true )
	marvin.SetTouchTriggers( false )
	marvin.SetNoTarget( true )
	marvin.SetAimAssistAllowed( false )

	// temp health
	// reworked here, we make player take damage instead of marvin re-direct damage
	/*
	//marvin.SetShieldHealthMax( 300 )
	//marvin.SetShieldHealth( 300 )
	SetShieldHealthMaxWithFix( marvin, 300 )
    SetShieldHealthWithFix( marvin, 300 )
	marvin.SetMaxHealth( 400 )
	marvin.SetHealth( 400 )
	*/

	marvin.SetBossPlayer( player )

	// how do I hide highlight for their marvin?
	// now doing loop in PlayerMarvinThink()
	//SetUpFakeMarvinHighlight( marvin )
	marvin.Highlight_SetInheritHighlight( true )

	marvin.SetParent( player, "ORIGIN" )
	SetForceDrawWhileParented( marvin, true )
	//marvin.SetTitle( player.GetPlayerName() ) // boss player can show title for npcs
	AddEntityCallback_OnFinalDamaged( marvin, OnFakeMarvinFinalDamaged )
	if ( BATTERY_SPAWNERS.contains( player.GetUID() ) )
		HideName( marvin )
	marvin.Signal( "StopDoingJobs" ) // stop automatic job think

	thread PlayerMarvinThink( player, marvin )

	return marvin
}

void function SetUpFakeMarvinHighlight( entity ent )
{
	// now doing loop in PlayerMarvinThink(), no need to remove default enemy highlight
	//ent.e.hasDefaultEnemyHighlight = false
	Highlight_ClearEnemyHighlight( ent )
	// friendly highlight
	Highlight_SetFriendlyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 1, 0, HIGHLIGHT_COLOR_NEUTRAL )
	// enemy highlight
	Highlight_SetEnemyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 2, 0, HIGHLIGHT_COLOR_NEUTRAL )
	// owned highlight
	Highlight_SetOwnedHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_NEUTRAL )
}

// for better adjusting damage dealing to player
void function OnFakeMarvinFinalDamaged( entity marvin, var damageInfo )
{
	//print( "fake marvin damaged!" )
	entity owner = marvin.GetBossPlayer()
	if ( IsValid( owner ) )
	{
		owner.TakeDamage( 
			DamageInfo_GetDamage( damageInfo ), 
			DamageInfo_GetAttacker( damageInfo ), 
			DamageInfo_GetInflictor( damageInfo ), 
			{ // damage table
				forceKill = DamageInfo_GetForceKill( damageInfo ),
				weapon = DamageInfo_GetWeapon( damageInfo ),
				origin = DamageInfo_GetDamagePosition( damageInfo ), 
				force = DamageInfo_GetDamageForce( damageInfo ), 
				scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
				damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
			}
		)
	}

	DamageInfo_SetDamage( damageInfo, 0 ) // never damage marvin
}

void function PlayerMarvinThink( entity player, entity marvin )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "player_embarks_titan" ) // maybe no need to add this... embarking as marvin kills you!
	marvin.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDeath" )

	OnThreadEnd
	(
		function(): ( player, marvin )
		{
			if ( IsValid( marvin ) )
			{
				marvin.Anim_Stop()
				HideName( marvin )
				marvin.ClearParent()
				if ( IsAlive( marvin ) )
					marvin.Die( marvin, marvin, { damageSourceId = damagedef_suicide } )
			}
			if ( IsValid( player ) )
			{
				// clean up
				player.Anim_Stop()
				player.SetNoTarget( false )
				player.SetTrackEntity( null )
				player.ClearTrackEntitySettings()

				PainDeathSounds_SetDisabledForEntity( player, false )
				DeathPackage_SetDisabledForEntity( player, false )

				ShowName( player )
				//player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // this gets cleared on player respawn, now we need to hide so their corpse won't show
				// reworked here, we make player take damage instead of marvin re-direct damage
				// no need to clean up
				/*
				player.ClearInvulnerable()
				player.Solid()
				*/
				//player.kv.modelscale = 1.0
				player.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
				player.UnforceStand()

				//player.SetShieldHealth( 0 )
				//player.SetShieldHealthMax( 0 )
    			SetShieldHealthWithFix( player, 0 )
				SetShieldHealthMaxWithFix( player, 0 )

				if ( IsAlive( player ) )
				{
					//player.Despawn() // no corpse, but isn't force kill
					player.Die( player, player, { damageSourceId = damagedef_suicide } )
				}
				//else
				//{
				//	player.Gib( < 0, 0, 100000 > ) // no corpse
					// modified function in sh_death_package.gnut
				//	HumanSizedGibSound( player )
				//}

				file.playerFakeMarvin[ player ] = null
				file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] = 0.0
			}
		}
	)

	MarvinPlayerTrackView( player )
	StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.35 )
	StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.2 )

	// marvin movement anim init
	marvin.Anim_ScriptedPlay( "mv_idle_unarmed" )
	file.fakeMarvinMovementState[ marvin ] <- eMarvinMovement.IDLE

	while ( true )
	{
		TakeAllWeapons( player )

		// health
		int playerMaxHealth = player.GetMaxHealth()
		int playerMaxShield = GetShieldHealthMaxWithFix( player )
		int playerHealth = player.GetHealth()
		int playerShield = GetShieldHealthWithFix( player )

		// class mods
		string setFile = player.GetPlayerSettings()
		array<string> classMods = player.GetPlayerSettingsMods()
		bool isColiseumFemale = setFile == "pilot_coliseum_female"
		bool hasMovementLimiter = classMods.contains( "disable_doublejump" ) && classMods.contains( "disable_wallrun" )
		if ( !isColiseumFemale || !hasMovementLimiter )
		{
			player.SetPlayerSettingsWithMods( "pilot_coliseum_female", ["disable_doublejump", "disable_wallrun"] )
		
			// update health
			player.SetMaxHealth( playerMaxHealth )
			player.SetHealth( playerHealth )
		}

		// visual effect
		// looping to update highlight could be good
		if ( !file.playerHasRGBHighlight[ player ] )
			SetUpFakeMarvinHighlight( player )
		HideName( player )
		player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
		// reworked here, we make player take damage instead of marvin re-direct damage
		// welp, guess making both entities take damage could be better
		//player.SetInvulnerable()
		//player.NotSolid() // non-solid makes player unable to take trigger_hurt damage
		// this is bad... will make attachments messed up
		//player.kv.modelscale = 0.01 // instead, we make player almost unable to getting hit, they'll still caught in explosions though
		player.kv.CollisionGroup = 0 // TRACE_COLLISION_GROUP_BLOCK_WEAPONS
		// movement limiter
		//player.ClearTraverse() // marvin don't have suitable anim for mantling, but we still allow player to traverse
		player.ForceStand() // avoid camera glitch when using chasing cam
		
		// health
		// reworked here, we make player take damage instead of marvin re-direct damage
		/*
		//player.SetShieldHealthMax( marvin.GetShieldHealthMax() )
		//player.SetShieldHealth( marvin.GetShieldHealth() )
		SetShieldHealthMaxWithFix( player, GetShieldHealthMaxWithFix( marvin ) )
		SetShieldHealthWithFix( player, GetShieldHealthWithFix( marvin ) )
		player.SetMaxHealth( marvin.GetMaxHealth() )
		player.SetHealth( marvin.GetHealth() )
		*/

		// marvin effects
		// looping to update highlight could be good
		if ( !file.playerHasRGBHighlight[ player ] )
			SetUpFakeMarvinHighlight( marvin )
		//marvin.SetInvulnerable()
		marvin.kv.CollisionGroup = 0 // TRACE_COLLISION_GROUP_BLOCK_WEAPONS
		//marvin.NotSolid() // non-solid entity won't show name, which is bad
		//SetShieldHealthMaxWithFix( marvin, playerMaxShield )
		//SetShieldHealthWithFix( marvin, playerShield )
		// keep marvin at extremely high health, don't want them to die from normal damages
		//marvin.SetMaxHealth( playerMaxHealth )
		//marvin.SetHealth( playerHealth )
		// keep marvin at extremely high health, don't want them to die
		// acutally damage can be handled by "OnFakeMarvinFinalDamaged" but whatever
		marvin.SetMaxHealth( 99999 )
		marvin.SetHealth( 99999 )

		// marvin animations
		if ( !player.IsOnGround() 
			 || player.IsWallRunning() 
			 || player.IsWallHanging() 
			 || player.IsTraversing() 
			 )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.IN_AIR )
			{
				marvin.Anim_ScriptedPlay( "mv_skyfall" ) // "mv_skyfall_lean"
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.IN_AIR
			}
			//printt( "player marvin in air!" )
		}
		// walking and spriting doesn't working fine
		// parented move anim seems weird...
		// fixed by marvin.Anim_DisableUpdatePosition()
		// sprinting still not look so good
		// whatever, we've added moveslow for player so I think there's no need to add sprinting
		/*
		else if ( player.IsSprinting() )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.SPRINTING )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.SPRINTING
				marvin.Anim_ScriptedPlay( "sp_sprint_tmp" ) //
				marvin.Anim_DisableUpdatePosition() // can this fix marvin change position through walking?
			}
			//printt( "player marvin sprinting!" )
		}
		*/
		// key combo: scripted animation
		else if ( file.fakeMarvinScriptedAnimEnabled
				  && !IsValid( player.GetParent() ) // can't use scripted anim while parented
				  && file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] <= Time()
				  && player.IsOnGround() 
				  && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) )
				  && ( player.IsInputCommandHeld( IN_ATTACK ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) 
				  && player.IsInputCommandHeld( IN_MELEE ) 
				  )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.SCRIPTED_ANIMATION )
			{
				// stop looping and wait for animation end
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.SCRIPTED_ANIMATION
				waitthread MarvinScriptedIntroAnim( player, marvin )
				file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] = Time() + MARVIN_INTRO_ANIM_COOLDOWN // update cooldown
			}
		}
		else if ( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WAVING )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WAVING
				marvin.Anim_ScriptedPlay( "mv_wave_unarmed" )
			}
			//printt( "player marvin waving!" )
		}
		// walking has lower priority than waving
		else if ( Length( player.GetVelocity() ) > 10 )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WALKING )
			{
				//file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WALKING // state setup handled in MarvinMoveAnimThink()
				// parented move anim seems weird...
				// fixed by marvin.Anim_DisableUpdatePosition()
				//thread MarvinMoveAnimThink( player, marvin, "Walk_All", eMarvinMovement.WALKING ) // Walk_all_v2
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WALKING
				marvin.Anim_ScriptedPlay( "Walk_All" ) //
				marvin.Anim_DisableUpdatePosition() // can this fix marvin change position through walking?
			}
			//printt( "player marvin walking!" )
		}
		else if ( player.IsInputCommandHeld( IN_ZOOM ) 
				  || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) 
				  )
		{
			if ( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
			{
				if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WASHING_WINDOW )
				{
					file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WASHING_WINDOW
					marvin.Anim_ScriptedPlay( "mv_idle_wash_window" )
				}
			}
			else
			{
				if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WELDING )
				{
					file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WELDING
					marvin.Anim_ScriptedPlay( "mv_idle_weld" )
				}
			}
		}
		else // idle
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.IDLE )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.IDLE
				marvin.Anim_ScriptedPlay( "mv_idle_unarmed" )
			}
			//printt( "player marvin idle!" )
		}

		// marvin face
		if ( Time() - player.p.lastDamageTime < 3.0 )
		{
			if ( marvin.GetSkin() != 2 )
				marvin.SetSkin( 2 ) // sad face
		}
		else
		{
			if ( marvin.GetSkin() != 1 )
				marvin.SetSkin( 1 ) // happy face
		}

		WaitFrame()
	}
}

void function MarvinPlayerTrackView( entity player )
{
	player.SetTrackEntity( player ) // Sets an entity to be viewed by this player in third person
	//player.SetTrackEntity( GetNPCArray()[0] )
	player.SetTrackEntityPitchLookMode( "orbit" )
	player.SetTrackEntityYawLookMode( "orbit" )
	player.SetTrackEntityDistanceMode( "scriptOffset" )
	player.SetTrackEntityMinYaw( -180 )
	player.SetTrackEntityMaxYaw( 180 )
	player.SetTrackEntityMinPitch( -30 ) // was -89, which means max pitch view
	player.SetTrackEntityMaxPitch( 44 ) // // was 89, which means max pitch view
	player.SetTrackEntityOffset( < -150.0, 0, 30.0 > )
	//player.SetTrackEntityOffsetDistance( -50.0 )
	//player.SetTrackEntityOffsetHeight( 30.0 )
}

// parented move anim seems weird...
// fixed by marvin.Anim_DisableUpdatePosition()
/*
void function MarvinMoveAnimThink( entity player, entity marvin, string anim, int stateKeep )
{
	//marvin = CreatePropDynamic( $"models/robots/marvin/marvin.mdl", marvin.GetOrigin(), marvin.GetAngles(), 6 )
	marvin.EndSignal( "OnDeath" )
	marvin.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	marvin.Signal( "MarvinMoveAnimThink" )
	marvin.EndSignal( "MarvinMoveAnimThink" )

	print( "marvin doing anim!" )

	entity mover = CreateScriptMover()
	mover.SetOrigin( player.GetOrigin() )
	mover.SetAngles( < 0, player.GetAngles().y, 0 > )
	marvin.ClearParent()
	marvin.SetParent( mover )
	marvin.Anim_ScriptedPlay( anim )

	OnThreadEnd
	(
		function(): ( player, marvin, mover )
		{
			if ( IsValid( player ) && IsValid( marvin ) )
			{
				marvin.ClearParent()
				marvin.SetParent( player, "ORIGIN" ) // set back
			}
			if ( IsValid( mover ) )
				mover.Destroy()
		}
	)

	file.fakeMarvinMovementState[ marvin ] = stateKeep
	while ( file.fakeMarvinMovementState[ marvin ] == stateKeep )
	{
		mover.NonPhysicsMoveTo( player.GetOrigin(), 0.1, 0.0, 0.0 )
		mover.NonPhysicsRotateTo( < 0, player.GetAngles().y, 0 >, 0.1, 0.0, 0.0 )
		WaitFrame()
	}

	print( "state lost!" )
}
*/

// for playing dropship intro anims
// might be kinda annoying...
// bunch of stupid stuffs inside
void function MarvinScriptedIntroAnim( entity player, entity marvin )
{
	if ( IsValid( player.GetParent() ) ) // can't use scripted anim while parented
		return

	// EndSignals handled by PlayerMarvinThink()
	player.FreezeControlsOnServer()

	OnThreadEnd
	(
		function(): ( player, marvin )
		{
			if ( IsValid( player ) )
			{
				player.UnfreezeControlsOnServer()
				player.ClearInvulnerable()
				player.SetPhysics( MOVETYPE_WALK )
			}
			if ( IsValid( marvin ) )
			{
				marvin.Anim_Stop()
				if ( IsAlive( player ) )
				{
					marvin.SetParent( player, "ORIGIN" )
					marvin.SetOrigin( < 0, 0, 0 > )
				}
				marvin.ClearInvulnerable()
			}
		}
	)

	array<MarvinIntroAnim> validAnimations = clone file.marvinIntroAnims
	MarvinIntroAnim randomAnim = validAnimations.getrandom()

	// temp clear parent
	marvin.ClearParent()
	// since parent has been cleared, if player has RGB highlight we need to apply it for marvin
	if ( file.playerHasRGBHighlight[ player ] )
		thread RGB_Highlight( file.playerFakeMarvin[ player ], true )

	// don't want marvin or player die here
	marvin.SetInvulnerable()
	player.SetInvulnerable()
	// stop movements from here
	player.SetVelocity( < 0, 0, 0 > )
	marvin.SetVelocity( < 0, 0, 0 > )
	player.SetPhysics( MOVETYPE_NOCLIP )
	// needs to set offset for marvin
	vector posWithOffset = player.GetOrigin() + randomAnim.offset
	marvin.SetOrigin( posWithOffset )

	marvin.Anim_ScriptedPlay( randomAnim.animName )
	if ( randomAnim.initialTime > 0 )
		marvin.Anim_SetInitialTime( randomAnim.initialTime )

	// HACK and may cause sound loss on players
	thread MarvinIntroSoundThink( marvin, randomAnim )

	WaitEndFrame() // may works different with higher script_server_fps
	// stop sound may loss if server or client unstable...
	StopSoundOnEntity( marvin, "crow_mp_intro" )

	if ( randomAnim.actualLength > 0 )
		wait randomAnim.actualLength
	else
		wait marvin.GetSequenceDuration( randomAnim.animName )
}

void function MarvinIntroSoundThink( entity marvin, MarvinIntroAnim animStruct )
{
	marvin.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDeath" )

	table<string, float> soundsTable = animStruct.introSounds
	float soundRadius = animStruct.introSoundRadius

	float startTime = Time()
	if ( animStruct.initialTime > 0 )
		startTime += animStruct.initialTime

	array<string> soundsPlayed
	while ( marvin.Anim_IsActive() )
	{
		foreach ( string soundName, float playDelay in soundsTable )
		{
			if ( soundsPlayed.contains( soundName ) )
				continue
			float soundPlayTime = startTime + playDelay
			float soundMaxPlayTime = soundPlayTime + 0.2 // if we looped more than 0.2s before playing a sound, do nothing
			if ( Time() >= soundPlayTime && Time() < soundMaxPlayTime )
			{
				PlayMarvinSoundToNearbyPlayers( marvin, soundName, soundRadius )
				soundsPlayed.append( soundName )
			}
			else // if sound not played yet, try stop sound played by animation
			{
				// looping to stop sound may cause sound loss
				// remove if it can be handled by PlayMarvinSoundToNearbyPlayers()
				//StopSoundOnEntity( marvin, soundName )
			}
		}

		WaitFrame()
	}
}

void function PlayMarvinSoundToNearbyPlayers( entity marvin, string soundName, float radius )
{
	// try stop sound played by animation
	// stop sound may loss if server or client unstable...
	StopSoundOnEntity( marvin, soundName )
	foreach ( entity player in GetAllPlayersInMarvinSoundRadius( marvin.GetOrigin(), radius ) )
	{
		EmitSoundOnEntityOnlyToPlayer( marvin, player, soundName )
	}

	// no need to track sound end, cause Anim_Stop() will clean them up on dead entities( pretty good )
}

array<entity> function GetAllPlayersInMarvinSoundRadius( vector pos, float radius )
{
	array<entity> targetPlayers
	// only for living players, dead players can respawn and change position
	foreach ( entity player in GetPlayerArray_Alive() )
	{
		if ( Distance( pos, player.GetOrigin() ) > radius )
			continue

		targetPlayers.append( player )
	}

	return targetPlayers
}