untyped // for handling stuffs inside table
global function Nessie_Funny_Functions_Init

// funny stuffs with clientcommand!
global function NessieFunny_EnableClientCommands

global function RGB_Highlight
global function TitleFlash

global function RainbowPlayerSkin
global function RainbowWeaponSkin

global function RGY_BatterySkin

// holoflash
global function HoloFlash_Loop
global function HoloFlash

// head
global function PlayerPulseBladeModel_HideBodyAndLegs
global function CreatePulseBladeHead
global function CreateWoundedHead
global function BindPulseBladeHeadToPlayer
global function BindeWoundedHeadToPlayer

// loadout
global function BecomeApexLegend

// rainbow dome
global function CreateRainbowDomeShield

// barrel spawn
global function CreatePhysicsBarrel

// player marvin
global function NessyFunny_EnableMarvinScriptedAnim // this may cause sound loss so need a setting
global function PlayerBecomesMarvin

global function NessyFunny_EnablePlayerTickDamageByDefault // THIS IS DEFAULT SETTING. remember that PlayerBecomesTick() parameters can bypass this
global function PlayerBecomesTick

// barker -- reimplement after getting funcion
// still not working fine, but spectres and stalkers looks good
/*
global function BecomeFakeBarker
global function BecomeFakeSpectre
*/
// to be shared for debugging
global function CreateModelProxyForEntity

// brains
global function BrainDead

enum eMarvinMovement
{
	IDLE,

	// walking and spriting doesn't working fine
	// EDIT: walking has been fixed and sprinting is removed
	WALKING,
	SPRINTING,
	
	IN_AIR,

	WAVING,
	WELDING,
	WASHING_WINDOW,

	SCRIPTED_ANIMATION,

	_count_
}

struct MarvinIntroAnim
{
	string animName
	float initialTime = -1 // -1 means not modified
	float actualLength = -1 // -1 means not modified
	vector offset = < 0, 0, 0 >
	table<string, float> introSounds // have to manually control intro sounds... otherwise all players on map can hear it
	float introSoundRadius = 1500 // default value
}

// modifiable consts
const float MARVIN_INTRO_ANIM_COOLDOWN = 15.0 // gets applied after animation end

enum eTickMovement
{
	IDLE,
	WALKING,

	LANDING,
	JUMPING,

	OVERLOADING,

	_count_
}

struct TickOverloadBehavior
{
	float suicideChaseTime
	float suicideChaseSpeedScale
	float overloadDelayAdjustment
}

struct
{
	bool clientCommandsEnabled
	bool fakeMarvinScriptedAnimEnabled // this may cause sound loss so need a setting
	bool playerTickCanDoDamageByDefault // remember that PlayerBecomesTick() parameters can bypass this

	table<entity, bool> playerHasRGBHighlight
	table<entity, bool> playerHasRainbowSkin
	table<entity, bool> playerHasRGYBattery

	table<entity, entity> playerFlipperMover

	table<entity, bool> playerUsingFakeNPCThisLife // if player is using third person chasing cam, we shouldn't do kill replay for them
	table<entity, entity> playerFakeNPC
	table<entity, bool> playerFakeNPCTookDamage

	table<entity, int> fakeMarvinMovementState
	table<entity, float> playerNextFakeMarvinScriptedAnimAllowedTime
	array<MarvinIntroAnim> marvinIntroAnims

	table<entity, int> fakeTickMovementState
	table<entity, TickOverloadBehavior> tickOverloadBehavior
	table<entity, bool> playerTickDoingSuicideChase

	table<entity, entity> entFakeModelProxy
} file

void function Nessie_Funny_Functions_Init()
{
	// precaching
	PrecacheModel( ROCKET_TURRET_MODEL )

	// signals
	// rgb highlight
    RegisterSignal( "StartRGBHighlight" )
	RegisterSignal( "EndRGBHighlight" )
	AddClientCommandCallback( "rgbself", CC_SelfRGBHighlight )

	// sb title
    RegisterSignal( "StartSBTitle" )
	RegisterSignal( "EndSBTitle" )
	//AddClientCommandCallback( "sbself", CC_SelfIMSBTitle )

	// rainbow skin
	RegisterSignal( "StartRainbowPlayer" )
	RegisterSignal( "EndRainbowPlayer" )
	RegisterSignal( "StartRainbowWeapon" )
	RegisterSignal( "EndRainbowWeapon" )

	// rgy battery
	RegisterSignal( "StartRGYBattery" )
	RegisterSignal( "EndRGYBattery" )

	// holo flash
	RegisterSignal( "StartHoloFlash" )
	RegisterSignal( "EndHoloFlash" )

	// self flip
	RegisterSignal( "EndFlipper" )
	AddClientCommandCallback( "flipself", CC_FlipPlayerSelf )

	// barrel
	//PrecacheModel( $"models/containers/barrel.mdl" ) // always precache barrel model
	//AddClientCommandCallback( "spawnbarrel", CC_ThrowABarrel )

	// others
	//AddClientCommandCallback( "rainbowdome", CC_SpawnRainbowDome )
	AddClientCommandCallback( "nessycostume", CC_SpawnNessyCostume )

	// marvin
	InitMarvinIntroAnim()
	RegisterSignal( "MarvinPlayerMoveAnimThink" )
	AddClientCommandCallback( "becomemarvin", CC_PlayerBecomeFakeMarvin )

	// tick
	PrecacheParticleSystem( $"P_frag_drone_jump_jet" )
	RegisterSignal( "ClearTickPlayerTraverse" )
	RegisterSignal( "TickPlayerStartsOverload" )
	RegisterSignal( "OverloadingTickTookDamage" )
	RegisterSignal( "TickPlayerTimerRunsOut" )
	RegisterSignal( "TickPlayerJump" )
	RegisterSignal( "TickPlayerDoubleJump" )
	RegisterSignal( "TickPlayerTouchGround" )
	AddClientCommandCallback( "becometick", CC_PlayerBecomeFakeTick )

	// fake model proxy
	PrecacheParticleSystem( $"P_stalker_eye_foe" )
	PrecacheParticleSystem( $"P_stalker_eye_friend" )
	PrecacheParticleSystem( $"P_spectre_eye_foe" )
	PrecacheParticleSystem( $"P_spectre_eye_friend" )
	RegisterSignal( "FakeModelProxyOwnerDeath" )
	// BAD bone merge, funny though
	AddClientCommandCallback( "fakebarker", CC_BecomeFakeBarker )
	AddClientCommandCallback( "fakemarder", CC_BecomeFakeMarder )
	// works really fine, just need a better model for handling hitboxes
	AddClientCommandCallback( "fakespectre", CC_BecomeFakeSpectre )
	AddClientCommandCallback( "fakestalker", CC_BecomeFakeStalker )

	// funny enough
	RegisterSignal( "BrainDead" )
	AddClientCommandCallback( "braindead", CC_BrainDead )

	// callbacks
	AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	// northstar new adding callback
	AddCallback_IsValidMeleeExecutionTarget( IsValidMeleeExecutionTarget )
	AddDamageCallback( "player", OnPlayerDamaged )

	// modified callback defined in mp_ability_holopilot.nut, gets called whenever a player projects hologram
	AddCallback_OnDecoyCreated( OnDecoyCreated )
	// this has been removed, AddCallback_OnDecoyCreated() can handle everything!
	//AddCallback_OnModdedDecoyCreated( OnDecoyCreated )
	AddCallback_PlayerDecoyDie( OnDecoyDie )
	AddCallback_PlayerDecoyDissolve( OnDecoyDissolve )

	// modified callback defined in _utility_shared.nut, for us disabling replay
	AddCallback_ShouldDoReplay( ShouldDoFunnyReplayStuffs )

	AddCallback_PlayerClassChanged( OnPlayerChangedClass )
	// HANDLE everything related with our model proxy
	// function Levels_GetAllVulnerableEntityClasses() shared from levels_util.gnut
	foreach ( string className in Levels_GetAllVulnerableEntityClasses() )
	{
		//AddDamageFinalCallback( className, OnEntityFinalDamaged ) // I JUST CAN"T DEAL WITH RAGDOLLS WHY
		AddDeathCallback( className, OnEntityDeath ) // not working well because we can't remove player's ragdoll
	}
}

// callbacks
void function OnClientConnected( entity player )
{
	file.playerHasRGBHighlight[ player ] <- false
	file.playerHasRainbowSkin[ player ] <- false
	file.playerHasRGYBattery[ player ] <- false

	file.playerFlipperMover[ player ] <- null

	file.playerUsingFakeNPCThisLife[ player ] <- false
	file.playerFakeNPC[ player ] <- null
	file.playerFakeNPCTookDamage[ player ] <- false

	file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] <- 0.0
	file.playerTickDoingSuicideChase[ player ] <- false

	file.entFakeModelProxy[ player ] <- null
}

void function OnPlayerRespawned( entity player )
{
	// clean up variables we setup with usage of fake npcs
	if ( !IsAlive( file.playerFakeNPC[ player ] ) ) // to prevent other files calling fake npc func before this callback
		file.playerUsingFakeNPCThisLife[ player ] = false

	// clean up fake model proxy on respawn, so that they can cover death animation stuffs( may also transfer to ragdolls? idk )
	// currently I'll set ent to proxy's model on death to play death animation, this clean up won't really work
	// EDIT: force resetting model may work really bad, could track model's position or something?
	if ( IsValid( file.entFakeModelProxy[ player ] ) )
		file.entFakeModelProxy[ player ].Destroy()
}

void function OnDecoyCreated( entity player, entity decoy )
{
	if ( IsValid( player ) )
	{
		// inherit rgb highlight to decoy
		if ( file.playerHasRGBHighlight[ player ] )
			thread RGB_Highlight( decoy, true )
		// inherit rainbow skin to decoy
		if ( file.playerHasRainbowSkin[ player ] )
			thread RainbowPlayerSkin( decoy )
		// inherit rgy battery to decoy
		if ( file.playerHasRGYBattery[ player ] )
		{
			var childEnt = decoy.FirstMoveChild()
			while ( childEnt != null )
			{
				expect entity( childEnt )

				//print( "childEnt: " + string( childEnt ) )
				//print( "childEnt.GetModelName(): " + string( childEnt.GetModelName() ) )
				bool isBattery = childEnt.GetModelName() == RODEO_BATTERY_MODEL
				if ( isBattery )
					thread RGY_BatterySkin( childEnt )
				
				childEnt = childEnt.NextMovePeer()
			}
		}

		if ( IsValid( file.entFakeModelProxy[ player ] ) )
		{
			asset modelName = file.entFakeModelProxy[ player ].GetModelName()
			// init for decoy
			file.entFakeModelProxy[ decoy ] <- CreateModelProxyForEntity( decoy, modelName )
		}
	}
}

void function OnDecoyDie( entity decoy, int currentState )
{
	CleanUpDecoyModelProxy( decoy )
}

void function OnDecoyDissolve( entity decoy, int currentState )
{
	CleanUpDecoyModelProxy( decoy )
}

void function CleanUpDecoyModelProxy( entity decoy )
{
	if ( decoy in file.entFakeModelProxy && IsValid( file.entFakeModelProxy[ decoy ] ) )
	{
		entity proxy = file.entFakeModelProxy[ decoy ]
		// hide decoy, we dissolve proxy instead
		// resetting decoy's rendermode also works, and proxy will be dissolved as well because decoy seems to dissolve all parented entity in native code
		/*
		decoy.kv.rendermode = 4
		decoy.kv.renderamt = 0
		*/
		// we're now changing visibilityFlags, maybe no need to handle like this
		// EDIT: fuck all of these. footsteps gets lost once players are hidden. change back to use rendermode changes, at least it works fine for npcs.
		decoy.Hide()

		// manually do effect for dissolving
		// no need because hiding a decoy won't hide it's effect
		/*
		int attachIndex = proxy.LookupAttachment( "CHESTFOCUS" )
		if ( attachIndex > 0 )
			StartParticleEffectOnEntity( proxy, GetParticleSystemIndex( GHOST_FLASH_EFFECT ), FX_PATTACH_POINT_FOLLOW, attachIndex )
		*/
		proxy.Dissolve( ENTITY_DISSOLVE_CHAR, < 0, 0, 0 >, 0 ) // props can't get Decoy_Dissolve() particle effects}
	}
}

bool function IsValidMeleeExecutionTarget( entity attacker, entity target )
{
	// prevent fake marvin player from executing each other
	if ( attacker.IsPlayer() && IsValid( file.playerFakeNPC[ attacker ] ) )
		return false

	if ( target.IsPlayer() && IsValid( file.playerFakeNPC[ target ] ) )
		return false
	
	return true
}

void function OnPlayerDamaged( entity player, var damageInfo )
{
	// if we have fake npc active, and damage isn't passed by them, we remove damage
	if ( IsValid( file.playerFakeNPC[ player ] ) && !file.playerFakeNPCTookDamage[ player ] )
	{
		// player still take trigger_hurt damage
		entity attacker = DamageInfo_GetAttacker( damageInfo )
		if ( IsValid( attacker ) )
		{
			string attackerClassname = attacker.GetClassName()
			if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
				return
		}

		DamageInfo_SetDamage( damageInfo, 0 )
	}
}

bool function ShouldDoFunnyReplayStuffs( entity player, entity attacker, float replayTime, int methodOfDeath )
{
	// if our player is using third person tracking camera, disable their kill replay
	if ( file.playerUsingFakeNPCThisLife[ player ] )
		return false

	// default returning true to let other callbacks go through
	return true
}

void function OnEntityFinalDamaged( entity ent, var damageInfo )
{
	// pass damageInfo to our handling table, so that we can create a npc to die for player
	if ( ( ent in file.entFakeModelProxy ) && IsValid( file.entFakeModelProxy[ ent ] ) )
	{
		if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) )	
			return // these could be nice
		bool surviveDamage = ent.GetHealth() + ent.GetShieldHealth() - DamageInfo_GetDamage( damageInfo ) > 0
		if ( ent.IsTitan() )
			surviveDamage = TitanCanSurviveDamage( ent, damageInfo )
		// KILLSHOT
		if ( !surviveDamage )
		{
			// hopefully this will work
			table results = {}
			results.attacker <- DamageInfo_GetAttacker( damageInfo )
			results.inflictor <- DamageInfo_GetInflictor( damageInfo )
			results.weapon <- DamageInfo_GetWeapon( damageInfo )
			results.damageSourceId <- DamageInfo_GetDamageSourceIdentifier( damageInfo )
			results.origin <- DamageInfo_GetDamagePosition( damageInfo )
			results.force <- DamageInfo_GetDamageForce( damageInfo )
			results.scriptType <- DamageInfo_GetCustomDamageType( damageInfo )
			results.damageType <- DamageInfo_GetDamageType( damageInfo )

			// new adding damageflag DF_NO_PAIN: no pain/death sound on damage
			// we remove all other damagetypes, leaving only this
			// all because I don't know how to add DMG_REMOVENORAGDOLL to existing damage...
			DamageInfo_SetCustomDamageType( damageInfo, DF_NO_PAIN )
			
			ent.Die( 
				results.attacker, 
				results.inflictor,  
				{ 	// damage table, remove all death package related stuffs
					forceKill = true, // force killing them
					weapon = results.weapon, // just for _stats.gnut to record info
					damageType = DMG_REMOVENORAGDOLL, // REMOVING RAGDOLL
					damageSourceId = results.damageSourceId
				} 
			)

			Signal( ent, "FakeModelProxyOwnerDeath", results )
		}
	}
}

void function OnPlayerChangedClass( entity player )
{
	// if we DO have a fake model active, update visibility because it's gonna be reset after player changing class
	if ( ( player in file.entFakeModelProxy ) && IsValid( file.entFakeModelProxy[ player ] ) )
	{
		// EDIT: still broken after changing class. can't handle that case
		/*
		player.kv.rendermode = 4
		player.kv.renderamt = 0
		*/
	}
}

void function OnEntityDeath( entity ent, var damageInfo )
{
	// pass damageInfo to our handling table, so that we can create a npc to die for player
	if ( ( ent in file.entFakeModelProxy ) && IsValid( file.entFakeModelProxy[ ent ] ) )
	{
		// new adding damageflag DF_NO_PAIN: no pain/death sound on damage
		// we remove all other damagetypes, leaving only this
		// all because I don't know how to add DMG_REMOVENORAGDOLL to existing damage...
		// we could remove death package stuffs, this isn't very needed
		// also, we may always want to gib fake model players. if we do, comment this line out
		DamageInfo_SetCustomDamageType( damageInfo, DF_NO_PAIN )

		// hopefully this will work
		table results = {}
		results.attacker <- DamageInfo_GetAttacker( damageInfo )
		results.inflictor <- DamageInfo_GetInflictor( damageInfo )
		results.weapon <- DamageInfo_GetWeapon( damageInfo )
		results.damageSourceId <- DamageInfo_GetDamageSourceIdentifier( damageInfo )
		results.origin <- DamageInfo_GetDamagePosition( damageInfo )
		results.force <- DamageInfo_GetDamageForce( damageInfo )
		results.scriptType <- DamageInfo_GetCustomDamageType( damageInfo )
		results.damageType <- DamageInfo_GetDamageType( damageInfo )
		Signal( ent, "FakeModelProxyOwnerDeath", results )
	}
}

// client commands
void function NessieFunny_EnableClientCommands( bool enable )
{
	file.clientCommandsEnabled = enable
}

bool function CC_SpawnRainbowDome( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	float duration = -1 // infinite hold time
	if ( args.len() > 0 )
		duration = float( args[0] )
	CreateRainbowDomeShield( player.GetOrigin(), < 0,0,0 >, duration )

	return true
}

void function DelayedDestroyRainbowDome( entity domeShield, float delay )
{
	wait delay

	domeShield.Destroy()
}

bool function CC_SpawnNessyCostume( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	SpawnNessyCostume( player )
	return true
}

bool function CC_SelfRGBHighlight( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false
	//if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
	//	return false

	thread RGB_Highlight( player, true )
	return true
}

bool function CC_SelfIMSBTitle( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	if ( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	thread TitleFlash( player )
	return true
}

bool function CC_FlipPlayerSelf( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	thread FlipperMoverThink( player )

	return true
}

bool function CC_ThrowABarrel( entity player, array<string> args )
{
	//if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
	//	return false

	entity barrel = CreatePhysicsBarrel( player.EyePosition(), < 0, player.EyeAngles().y, 0 > )
    barrel.SetVelocity( player.GetViewVector() * 1000 )
	return true
}

bool function CC_PlayerBecomeFakeMarvin( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	PlayerBecomesMarvin( player )
	return true
}

bool function CC_PlayerBecomeFakeTick( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	PlayerBecomesTick( player )
	return true
}
//

void function RGB_Highlight( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	ent.Signal( "StartRGBHighlight" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartRGBHighlight" )
	ent.EndSignal( "EndRGBHighlight" )

	// player specific
	if ( ent.IsPlayer() )
	{
		file.playerHasRGBHighlight[ ent ] = true
	}

	OnThreadEnd(
		function(): ( ent )
		{
			if( IsValid( ent ) )
			{
				// player specific
				if ( ent.IsPlayer() )
					file.playerHasRGBHighlight[ ent ] = false

				Highlight_ClearFriendlyHighlight( ent )
				Highlight_ClearEnemyHighlight( ent )
				Highlight_ClearNeutralHighlight( ent )
				Highlight_ClearOwnedHighlight( ent )
			}
		}
	)

	while ( true )
	{
		waitthread RGBHighlightThink( ent, showToAll, alwaysShow )
		ent.WaitSignal( "StopPhaseShift" ) // wait for exiting phase shift, we do highlight again!
	}
}

void function RGBHighlightThink( entity ent, bool showToAll = false, bool alwaysShow = false )
{
	ent.EndSignal( "StartPhaseShift" ) // phase shift cleans up highlight

	string highlightToUse = "sp_enemy_pilot" // normal one, visible through viewmodel, kinda funny
	if ( alwaysShow )
		highlightToUse = "sp_friendly_hero" // this one will show across walls

	array<vector> colorArray = [ < 255,0,0 >, < 0,255,0 >, < 0,0,255 > ]
	int index = 0
	while( true )
	{
		index = index == colorArray.len() - 1 ? 0 : index + 1

		// needs to update highlight for every loop... in case we can update it for later-joiners
		Highlight_SetFriendlyHighlight( ent, highlightToUse )
		Highlight_SetOwnedHighlight( ent, highlightToUse )
		ent.Highlight_SetParam( 1, 0, colorArray[index] ) // friendly
		ent.Highlight_SetParam( 3, 0, colorArray[index] ) // owned

		if( showToAll )
		{
			Highlight_SetEnemyHighlight( ent, highlightToUse )
			Highlight_SetNeutralHighlight( ent, highlightToUse )
			ent.Highlight_SetParam( 2, 0, colorArray[index] ) // enemy
			ent.Highlight_SetParam( 0, 0, colorArray[index] ) // neutral
		}

		// never wait before we actually update entity's highlight
		// if we do, an entity spawn with no highlight will crash the server
		WaitFrame()
	}
}

void function TitleFlash( entity ent, array<string> titleArray = [ "我是傻逼", "傻逼是我" ] )
{
	if ( titleArray.len() <= 0 ) // no title given
		return
	ent.Signal( "StartSBTitle" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StartSBTitle" )
	ent.EndSignal( "EndSBTitle" )

	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == titleArray.len() - 1 ? 0 : index + 1

		ent.SetTitle( titleArray[index] )
	}
}

void function RainbowPlayerSkin( entity player )
{
	if( !PilotModelSupportsCamo( player ) )
		return
	player.Signal( "StartRainbowPlayer" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartRainbowPlayer" )
	player.EndSignal( "EndRainbowPlayer" )

	// player specific
	if ( player.IsPlayer() )
		file.playerHasRainbowSkin[ player ] = true

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				// player specific
				if ( player.IsPlayer() )
					file.playerHasRainbowSkin[ player ] = false
			}
		}
	)

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		player.SetSkin( 1 )
		player.SetCamo( camoIndexArray[index] )
	}
}


array<asset> PILOT_MODELS_SUPPORTS_CAMO =
[
	$"models/humans/pilots/pilot_medium_stalker_m.mdl",
	$"models/humans/pilots/pilot_medium_stalker_f.mdl",
	$"models/humans/pilots/pilot_light_ged_m.mdl",
	$"models/humans/pilots/pilot_light_ged_f.mdl",
	$"models/humans/pilots/pilot_light_jester_m.mdl",
	$"models/humans/pilots/pilot_light_jester_f.mdl",
	$"models/humans/pilots/pilot_medium_reaper_m.mdl"
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/pilot_medium_geist_m.mdl",
	$"models/humans/pilots/pilot_medium_geist_f.mdl",
	$"models/humans/pilots/pilot_heavy_roog_m.mdl",
	$"models/humans/pilots/pilot_heavy_roog_f.mdl",
	$"models/humans/pilots/pilot_heavy_drex_m.mdl",
	$"models/humans/pilots/pilot_heavy_drex_f.mdl"
]

bool function PilotModelSupportsCamo( entity player )
{
	asset modelName = player.GetModelName()
	if ( PILOT_MODELS_SUPPORTS_CAMO.contains( modelName ) )
	 	return true

	return false
}

void function RainbowWeaponSkin( entity weaponOwner )
{
	weaponOwner.Signal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "OnDestroy" )
	weaponOwner.EndSignal( "OnDeath" )
	weaponOwner.EndSignal( "StartRainbowWeapon" )
	weaponOwner.EndSignal( "EndRainbowWeapon" )

	array<int> camoIndexArray = [ 14, 81, 30, 31, 17, 83, 16 ] // skin 1
	// green, pink, black, white, orange, purple, gold
	int index = 0
	while( true )
	{
		WaitFrame()
		index = index == camoIndexArray.len() - 1 ? 0 : index + 1

		foreach( entity weapon in weaponOwner.GetMainWeapons() )
		{
			weapon.SetSkin( 1 )
			weapon.SetCamo( camoIndexArray[index] )
		}
	}
}

void function RGY_BatterySkin( entity battery )
{
	bool isRealBattery = battery.GetClassName() == "item_titan_battery"
	bool isPropBattery = !isRealBattery && battery.GetModelName() == RODEO_BATTERY_MODEL
	if( !isRealBattery && !isPropBattery )
		return

	battery.Signal( "StartRGYBattery" )
	battery.EndSignal( "OnDestroy" )
	battery.EndSignal( "StartRGYBattery" )
	battery.EndSignal( "EndRGYBattery" )

	entity lastTickParent
	OnThreadEnd(
		function(): ( battery, lastTickParent )
		{
			if ( IsValid( lastTickParent ) && lastTickParent.IsPlayer() )
				file.playerHasRGYBattery[ lastTickParent ] = false
		}
	)

	int index = 0
	while( true )
	{
		// for real batteries, we check their parent
		if ( isRealBattery )
			lastTickParent = battery.GetParent()

		//print( "setting battery skin: " + string( index ) )
		WaitFrame()

		battery.SetSkin( index )
		Battery_StopFX( battery )
		if( index == 2 )
			index = 0
		else
			index++

		// for real batteries, we check their current parent
		// and if player changed parented battery or something, we update playerHasRGYBattery
		entity currentParent = battery.GetParent()
		// parent updated!
		if ( lastTickParent != currentParent )
		{
			if ( IsValid( lastTickParent ) && lastTickParent.IsPlayer() )
				file.playerHasRGYBattery[ lastTickParent ] = false
		}
		// a player currently holding the RGY battery
		if ( IsValid( currentParent ) && currentParent.IsPlayer() )
			file.playerHasRGYBattery[ lastTickParent ] = true
	}
}

void function HoloFlash_Loop( entity player, float interval = 1.0 )
{
	player.Signal( "StartHoloFlash" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "StartHoloFlash" )
	player.EndSignal( "EndHoloFlash" )

	while( true )
	{
		wait interval

		HoloFlash( player )
	}
}

void function HoloFlash( entity player )
{
	int attachIndex = player.LookupAttachment( "CHESTFOCUS" )
	//StartParticleEffectOnEntity( player, GetParticleSystemIndex( GHOST_TRAIL_EFFECT ), FX_PATTACH_POINT_FOLLOW, attachIndex )
	entity flashFX = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( GHOST_FLASH_EFFECT ), FX_PATTACH_POINT, attachIndex )
	flashFX.SetOwner( player )
	SetTeam( flashFX, player.GetTeam() )
	flashFX.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // not owner only
}

void function PlayerPulseBladeModel_HideBodyAndLegs( entity player )
{
	player.SetModel( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = player.FindBodyGroup( "body" )
	player.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = player.FindBodyGroup( "legs" )
	player.SetBodygroup( bodyGroupIndex, 0 )
}

// create a pulseblade pilot's head
entity function CreatePulseBladeHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

// create a headshot head! this is not a model that can freely scale
entity function CreateWoundedHead( vector origin = < 0,0,0 >, vector angles = < 0,0,0 > )
{
	entity prop = CreatePropDynamic( $"models/humans/pilots/pilot_medium_reaper_m.mdl" )
	int bodyGroupIndex = prop.FindBodyGroup( "body" )
	prop.SetBodygroup( bodyGroupIndex, 1 )
	bodyGroupIndex = prop.FindBodyGroup( "legs" )
	prop.SetBodygroup( bodyGroupIndex, 0 )
	bodyGroupIndex = prop.FindBodyGroup( "head" )
	prop.SetBodygroup( bodyGroupIndex, 1 )

	prop.SetOrigin( origin )
	prop.SetAngles( angles )

	return prop
}

void function BindPulseBladeHeadToPlayer( entity player )
{
	entity head = CreatePulseBladeHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
	
	//head.SetSkin( 2 )
	//head.SetCamo( 14 )
}

void function BindeWoundedHeadToPlayer( entity player )
{
	entity head = CreateWoundedHead()

	// bind it to entity
	head.SetParent( player, "ORIGIN" )
	head.kv.modelscale = 5
	head.SetOrigin( < 0,0,-300 > ) // the head can be really high
	head.SetOwner( player )
	SetTeam( head, player.GetTeam() )
	head.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // hide head for player
	thread TrackPlayerDeathForHeadProp( player, head )
	SetForceDrawWhileParented( head, true )
}

void function TrackPlayerDeathForHeadProp( entity player, entity head )
{
	player.EndSignal( "OnDestroy" )

	WaitFrame() // since altpilot resets player's visibility everytime they respawn or changeloadout
	player.kv.VisibilityFlags = 0 // hide player

	OnThreadEnd(
		function():( head )
		{
			if ( IsValid( head ) )
				head.Destroy()
		}
	)

	player.WaitSignal( "OnDeath" )
	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // restore player visibility!
}

void function BecomeApexLegend( entity player, asset model ) // ash, blisk, jack, sarah
{
	TakeAllWeapons( player )

	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_phase"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_ORDNANCE, ["octane_stim"] )
	player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_ANTIRODEO, ["deployable_dome_shield"] )
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, ["dash_melee", "pushback_melee"] )
	player.GiveWeapon( "mp_weapon_gunship_missile", ["pilot_emptyhanded"] )
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), ["disable_doublejump","only_wallclimb", "pas_wallhang"] )

	player.SetModel( model )
	GivePassive( player, ePassives.PAS_STEALTH_MOVEMENT ) // hide jetpack flame
	Rodeo_SetStealthMovementDisabledForPlayer( player, true ) // disable stealth rodeo, so player will have jetpack modified only

	thread DisableBoostBar( player )
}

void function DisableBoostBar( entity player )
{
	WaitFrame()
	if( IsValid( player ) )
		PlayerEarnMeter_SetMode( player, eEarnMeterMode.DISABLED )
}

entity function CreateRainbowDomeShield( vector origin, vector angles, float duration = -1, bool notSolid = false )
{
	entity bubbleShield = CreateEntity( "prop_dynamic" )
	bubbleShield.SetValueForModelKey( $"models/fx/xo_shield.mdl" )
	if ( !notSolid )
		bubbleShield.kv.solid = SOLID_VPHYSICS
    bubbleShield.kv.rendercolor = "81 130 151"
    bubbleShield.kv.contents = (int(bubbleShield.kv.contents) | CONTENTS_NOGRAPPLE)
	bubbleShield.SetOrigin( origin )
	bubbleShield.SetAngles( angles )
	bubbleShield.Hide()

    // Blocks bullets, projectiles but not players and not AI
	// THIS IS BAD BEHAVIOR
    // TRACE_COLLISION_GROUP_BLOCK_WEAPONS makes scorch thermite pass through shield
	//bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS
    bubbleShield.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS
	bubbleShield.SetBlocksRadiusDamage( true )
	DispatchSpawn( bubbleShield )
    array<entity> bubbleShieldFXs
	vector coloredFXOrigin = bubbleShield.GetOrigin()
	table bubbleShieldDotS = expect table( bubbleShield.s )

	//Create friendly and enemy colored particle systems
	entity rainbowColoredFX = StartParticleEffectInWorld_ReturnEntity( BUBBLE_SHIELD_FX_PARTICLE_SYSTEM_INDEX, coloredFXOrigin, angles )
	thread RainbowColorThink( rainbowColoredFX )
	bubbleShieldFXs.append( rainbowColoredFX )

	// should set all bubble shield particle to disable hibernation
	foreach ( entity particle in bubbleShieldFXs )
	{
		if ( IsValid( particle ) )
			particle.DisableHibernation() 
	}

    EmitSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
    thread CleanupBubbleShield( bubbleShield, bubbleShieldFXs, duration )

	return bubbleShield
}

void function RainbowColorThink( entity fx )
{
	fx.EndSignal( "OnDestroy" )

	vector rgb = < 255, 0, 0 > // start with red
	float segment = 25.5
	while ( true )
	{
		WaitFrame()

		// to < 255, 255, 0 >
		if ( rgb.x == 255 && rgb.y < 255 && rgb.z == 0 )
			rgb.y = min( 255, rgb.y + segment )
		// to < 0, 255, 0 >
		else if ( rgb.x > 0 && rgb.y == 255 && rgb.z == 0 )
			rgb.x = max( 0, rgb.x - segment )
		// to < 0, 255, 255 >
		else if ( rgb.x == 0 && rgb.y == 255 && rgb.z < 255 )
			rgb.z = min( 255, rgb.z + segment )
		// to < 0, 0, 255 >
		else if ( rgb.x == 0 && rgb.y > 0 && rgb.z == 255 )
			rgb.y = max( 0, rgb.y - segment )
		// to < 255, 0, 255 >
		else if ( rgb.x < 255 && rgb.y == 0 && rgb.z == 255 )
			rgb.x = min( 255, rgb.x + segment )
		// to < 255, 0, 0 >, a whole loop done
		else if ( rgb.x == 255 && rgb.y == 0 && rgb.z > 0 )
			rgb.z = max( 0, rgb.z - segment )

		//print( rgb )
		EffectSetControlPointVector( fx, 1, rgb )
	}
}

void function CleanupBubbleShield( entity bubbleShield, array<entity> bubbleShieldFXs, float fadeTime )
{
	bubbleShield.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function () : ( bubbleShield, bubbleShieldFXs )
		{
			if ( IsValid_ThisFrame( bubbleShield ) )
			{
				StopSoundOnEntity( bubbleShield, "BubbleShield_Sustain_Loop" )
				EmitSoundOnEntity( bubbleShield, "BubbleShield_End" )
				DestroyBubbleShield( bubbleShield )
			}

			foreach ( fx in bubbleShieldFXs )
			{
				if ( IsValid_ThisFrame( fx ) )
				{
					EffectStop( fx )
				}
			}
		}
	)

	if ( fadeTime == -1 ) // default
		WaitForever()
	else if ( fadeTime > 0 )
		wait fadeTime
}

// flipper
void function FlipperMoverThink( entity player )
{
	if ( !IsAlive( player ) ) // defensive fix
		return

	entity playerParent = player.GetParent()
	//print( "playerParent: " + string( playerParent ) )
	if ( IsValid( playerParent ) )
	{
		if ( playerParent == file.playerFlipperMover[ player ] )
			player.Signal( "EndFlipper" ) // try to end last flipper

		return // always return, whether player is parented with flipper or other entities
	}

	player.Signal( "EndFlipper" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "EndFlipper" )

	entity viewControl = CreateEntity( "point_viewcontrol" )
	viewControl.kv.spawnflags = 56 // infinite hold time, snap to goal angles, make player non-soli
	DispatchSpawn( viewControl )
	viewControl.EndSignal( "OnDestroy" )

	float offset = player.IsTitan() ? 500.0 : 200.0
	float playerViewYaw = player.EyeAngles().y
	float playerBackViewYaw = ClampAngle( playerViewYaw - 180 )
	viewControl.SetOrigin( player.GetOrigin() + AnglesToForward( < 0, playerBackViewYaw, 0 > ) * offset )
	viewControl.SetAngles( < 0, playerViewYaw, 0 > )
	player.SetViewEntity( viewControl, true )

	entity mover = CreateExpensiveScriptMover()
	mover.EndSignal( "OnDestroy" )

	mover.SetOrigin( player.GetOrigin() )
	mover.SetAngles( < 0, playerBackViewYaw, 0 > )
	player.SetParent( mover )
	file.playerFlipperMover[ player ] = mover

	OnThreadEnd
	(
		function(): ( player, mover, viewControl )
		{
			if ( IsValid( player ) )
			{
				player.ClearParent()
				FindNearestSafeSpotAndPutEntity( player, 1 )
				player.ClearViewEntity()
				file.playerFlipperMover[ player ] = null
			}

			if ( IsValid( viewControl ) )
				viewControl.Destroy()
			if ( IsValid( mover ) )
				mover.Destroy()
		}
	)

	int loopCount = 0
	while ( true )
	{
		float x = loopCount % 2 == 0 ? -180.0 : 0.0
		mover.NonPhysicsRotateTo( < x, playerBackViewYaw, 0 >, 0.3, 0, 0 )
		loopCount += 1
		wait 0.2
	}
}

// barrel
entity function CreatePhysicsBarrel( vector origin, vector angles )
{
	entity barrel = CreateEntity( "prop_physics" )
	barrel.SetValueForModelKey( $"models/containers/barrel.mdl" )
	barrel.SetModel( $"models/containers/barrel.mdl" )

	// spawn settings, copied from map_spawn.ent
	barrel.kv.spawnflags = "1"
	//barrel.kv.solid = SOLID_VPHYSICS
	barrel.kv.skin = "0"
	barrel.kv.shadowcastdist = "0"
	barrel.kv.rendermode = "0"
	barrel.kv.renderfx = "0"
	barrel.kv.rendercolor = "255 255 255"
	barrel.kv.renderamt = "255"
	barrel.kv.pressuredelay = "0"
	barrel.kv.physdamagescale = "0.1"
	barrel.kv.PerformanceMode = "0"
	barrel.kv.nodamageforces = "0"
	barrel.kv.minhealthdmg = "0"
	barrel.kv.mingpulevel = "0"
	barrel.kv.mincpulevel = "0"
	barrel.kv.maxgpulevel = "0"
	barrel.kv.maxcpulevel = "0"
	barrel.kv.massScale = "0"
	barrel.kv.inertiaScale = "1.0"
	barrel.kv.fadedist = "-1"
	barrel.kv.ExplodeRadius = "0"
	barrel.kv.ExplodeDamage = "0"
	barrel.kv.drawinfastreflection = "0"
	barrel.kv.disableX360 = "0"
	barrel.kv.disableshadows = "0"
	barrel.kv.disablereceiveshadows = "0"
	barrel.kv.Damagetype = "0"
	barrel.kv.damagetoenablemotion = "0"
	barrel.kv.allowfunnel = "1"
	barrel.kv.scale = "1"
	//barrel.kv.angles = "0 -26.065 0"
	//barrel.kv.origin = "3180 -4114 55.9981"
	//barrel.kv.targetname = "func_static_1"
	barrel.kv.physicsmode = "1"
	barrel.kv.forcetoenablemotion = "0"
	barrel.kv.classname = "prop_physics"

	barrel.SetOrigin( origin )
	barrel.SetAngles( angles )

	DispatchSpawn( barrel )
	barrel.SetModel( $"models/containers/barrel.mdl" )
	barrel.SetForceVisibleInPhaseShift( true )

	return barrel
}


// init marvin scripted anim
void function InitMarvinIntroAnim()
{
	// now we leave only freestyle, others needs testing
	/*
	MarvinIntroAnim greeter
	greeter.animName = "commander_MP_flyin_marvin_greeter"
	greeter.initialTime = -1 // needs testing
	greeter.actualLength = -1
	file.marvinIntroAnims.append( greeter )

	MarvinIntroAnim highfive
	highfive.animName = "commander_MP_flyin_marvin_highfive"
	highfive.initialTime = -1 // needs testing
	highfive.actualLength = -1
	file.marvinIntroAnims.append( highfive )

	MarvinIntroAnim salute
	salute.animName = "commander_MP_flyin_marvin_salute"
	salute.initialTime = -1 // needs testing
	salute.actualLength = -1
	file.marvinIntroAnims.append( salute )

	MarvinIntroAnim glitch
	glitch.animName = "commander_MP_flyin_marvin_glitch"
	glitch.initialTime = -1 // needs testing
	glitch.actualLength = -1
	file.marvinIntroAnims.append( glitch )
	*/

	MarvinIntroAnim freestyle
	freestyle.animName = "commander_MP_flyin_marvin_freestyle"
	freestyle.initialTime = -1 // needs testing
	freestyle.actualLength = 14
	freestyle.offset = < 0, 0, 0 >
	freestyle.introSounds = { 
		["commander_marvin_freestyle_music"] = 0.0,
		["commander_marvin_freestyle"] = 1.1,
		["diag_mcor_marvin_dropship_cmdr_freestyle"] = 1.1,
	}
	freestyle.introSoundRadius = 800 // freestyle is loud, needs reduced sound radius
	file.marvinIntroAnims.append( freestyle )
}

// this may cause sound loss so need a setting
void function NessyFunny_EnableMarvinScriptedAnim( bool enable )
{
	file.fakeMarvinScriptedAnimEnabled = enable
}

// player controlled marvin
entity function PlayerBecomesMarvin( entity player )
{
	if ( IsValid( file.playerFakeNPC[ player ] ) )
		return

	if ( !IsAlive( player ) )
		return
	
	if ( player.IsTitan() || player.Anim_IsActive() || IsValid( player.GetParent() ) )
		return

	// remove ragdoll impact effect
	SetHumanRagdollImpactTable( player )
	
	int team = player.GetTeam()
	vector origin = player.GetOrigin()
	vector angles = < 0, player.GetAngles().y, 0 >
	entity marvin = CreateMarvin( team, origin, angles )
	marvin.kv.spawnflags = 516
	marvin.kv.contents = (int(marvin.kv.contents) | CONTENTS_NOGRAPPLE)
	marvin.ai.killShotSound = false
	DispatchSpawn( marvin )

	// setup player
	// we still allow player to change player settings from loadout selection... as a easter egg
	// nope, never allow loadout change influence playerSetFile. now hanlded by PlayerMarvinThink()
	//player.SetPlayerSettingsWithMods( "pilot_coliseum_female", ["disable_doublejump", "disable_wallrun"] )
	player.SetNoTarget( true )
	PainDeathSounds_SetDisabledForEntity( player, true ) // temp
	DeathPackage_SetDisabledForEntity( player, true )
	file.playerFakeNPC[ player ] = marvin
	// how do I hide highlight for this player?
	// now doing loop in PlayerMarvinThink()
	//SetUpFakeMarvinHighlight( player )

	// they can take doubled damage from passing-through and explosions, double the health
	// EDIT: we've fixed that case by using damage callbacks, but health change is good enough, keeping here
	//player.SetShieldHealthMax( 1000 )
	//player.SetShieldHealth( 1000 )
	SetShieldHealthMaxWithFix( player, 1000 )
    SetShieldHealthWithFix( player, 1000 )
	player.SetMaxHealth( 1000 )
	player.SetHealth( 1000 )

	// setup marvin
	// dont let AI titan get enemies. Don't do trigger checks
	// EDIT: maybe do trigger checks so we get proper fall damage and stuffs...?
	marvin.SetEfficientMode( true )
	//marvin.SetTouchTriggers( false )
	marvin.SetNoTarget( true )
	marvin.SetAimAssistAllowed( false )
	// doesn't work because parent is nonsolid, still won't touch any trigger stuffs
	//marvin.e.destroyTriggerHurt = true // so they gets removed when taking fall damage, and player dies

	// temp health
	// reworked here, we make player take damage instead of marvin re-direct damage
	// EDIT: reworked again here: still change to use marvin for re-directing damage, but player took radius damage will be blocked
	/*
	marvin.SetMaxHealth( 400 )
	marvin.SetHealth( 400 )
	*/
	// update basic shield value for marvin so we have proper impact effects
	//marvin.SetShieldHealthMax( 300 )
	//marvin.SetShieldHealth( 300 )
	SetShieldHealthMaxWithFix( marvin, 1000 )
    SetShieldHealthWithFix( marvin, 1000 )

	marvin.SetBossPlayer( player )

	// how do I hide highlight for their marvin?
	// now doing loop in PlayerMarvinThink()
	//SetUpFakeMarvinHighlight( marvin )
	marvin.Highlight_SetInheritHighlight( true )

	marvin.SetParent( player, "ORIGIN" )
	SetForceDrawWhileParented( marvin, true )
	//marvin.SetTitle( player.GetPlayerName() ) // boss player can show title for npcs
	AddEntityCallback_OnFinalDamaged( marvin, OnFakeNPCFinalDamaged ) // this callback can pass shield damage to player
	if ( BATTERY_SPAWNERS.contains( player.GetUID() ) )
		HideName( marvin )
	marvin.Signal( "StopDoingJobs" ) // stop automatic job think

	thread PlayerMarvinThink( player, marvin )
	thread TrackMarvinOwnerDamaged( player, marvin )
	thread DisableBoostBar( player )

	return marvin
}

void function SetUpFakeMarvinHighlight( entity ent )
{
	// now doing loop in PlayerMarvinThink(), no need to remove default enemy highlight
	//ent.e.hasDefaultEnemyHighlight = false
	Highlight_ClearEnemyHighlight( ent )

	// temp remove highlight overrides
	/*
	// friendly highlight
	Highlight_SetFriendlyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 1, 0, HIGHLIGHT_COLOR_NEUTRAL )
	// enemy highlight
	Highlight_SetEnemyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 2, 0, HIGHLIGHT_COLOR_NEUTRAL )
	// owned highlight
	Highlight_SetOwnedHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_NEUTRAL )
	*/
}

// for better adjusting damage dealing to player
// this is shared between fake npc thinks
void function OnFakeNPCFinalDamaged( entity ent, var damageInfo )
{
	//print( "fake marvin damaged!" )
	//print( "fake npc " + string( ent ) + " took damage!" )

	entity owner = ent.GetBossPlayer()
	if ( IsValid( owner ) )
	{
		file.playerFakeNPCTookDamage[ owner ] = true // mark this as true so we can receive damage properly
		
		owner.TakeDamage( 
			DamageInfo_GetDamage( damageInfo ), 
			DamageInfo_GetAttacker( damageInfo ), 
			DamageInfo_GetInflictor( damageInfo ), 
			{ // damage table
				forceKill = DamageInfo_GetForceKill( damageInfo ),
				weapon = DamageInfo_GetWeapon( damageInfo ),
				origin = DamageInfo_GetDamagePosition( damageInfo ), 
				force = DamageInfo_GetDamageForce( damageInfo ), 
				scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
				damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
			}
		)
		file.playerFakeNPCTookDamage[ owner ] = false // owner stops taking damage anymore

		// update npc shield value so we get proper impact effects
		SetShieldHealthMaxWithFix( ent, GetShieldHealthMaxWithFix( owner ) )
		SetShieldHealthWithFix( ent, GetShieldHealthWithFix( owner ) )
	}

	DamageInfo_SetDamage( damageInfo, 0 ) // never damage npc
}

// switch marvin's face when owner damaged
void function TrackMarvinOwnerDamaged( entity owner, entity marvin )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDestroy" )

	while ( true )
	{
		waitthread MarvinUndamagedFace( owner, marvin )
		waitthread MarvinWounded( owner, marvin )
	}
}

void function MarvinUndamagedFace( entity owner, entity marvin )
{
	//print( "marvin is happy!" )
	owner.EndSignal( "OnDamaged" )
	marvin.SetSkin( 1 ) // happy face
	WaitForever()
}

void function MarvinWounded( entity owner, entity marvin )
{
	//print( "marvin is unhappy!" )
	marvin.SetSkin( 2 ) // sad face
	wait 2.3 // max duration
}

void function PlayerMarvinThink( entity player, entity marvin )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "player_embarks_titan" ) // maybe no need to add this... embarking as marvin kills you!
	marvin.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDeath" )

	array<int> statusEffectsToCleanUp
	statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.35 ) )
	statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.2 ) )

	// start third person tracking
	MarvinPlayerTrackView( player )

	OnThreadEnd
	(
		function(): ( player, marvin, statusEffectsToCleanUp )
		{
			if ( IsValid( marvin ) )
			{
				RemoveEntityCallback_OnFinalDamaged( marvin, OnFakeNPCFinalDamaged )
				marvin.Anim_Stop()
				HideName( marvin )
				marvin.ClearParent()
				if ( IsAlive( marvin ) )
					marvin.Die( marvin, marvin, { damageSourceId = damagedef_suicide } )
			}
			if ( IsValid( player ) )
			{
				// clean up
				foreach ( effect in statusEffectsToCleanUp )
					StatusEffect_Stop( player, effect )

				player.Anim_Stop()
				player.SetNoTarget( false )
				player.SetTrackEntity( null )
				player.ClearTrackEntitySettings()

				PainDeathSounds_SetDisabledForEntity( player, false )
				DeathPackage_SetDisabledForEntity( player, false )

				ShowName( player )
				//player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // this gets cleared on player respawn, now we need to hide so their corpse won't show
				// reworked here, we make player take damage instead of marvin re-direct damage
				// no need to clean up
				// EDIT: reworked again here: still change to use marvin for re-directing damage, but player took radius damage will be blocked
				//player.ClearInvulnerable()
				player.Solid()
				//player.kv.modelscale = 1.0
				player.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
				player.UnforceStand()

				//player.SetShieldHealth( 0 )
				//player.SetShieldHealthMax( 0 )
    			SetShieldHealthWithFix( player, 0 )
				SetShieldHealthMaxWithFix( player, 0 )

				if ( IsAlive( player ) )
				{
					//player.Despawn() // no corpse, but isn't force kill
					player.Die( player, player, { damageSourceId = damagedef_suicide } )
				}
				//else
				//{
				//	player.Gib( < 0, 0, 100000 > ) // no corpse
					// modified function in sh_death_package.gnut
				//	HumanSizedGibSound( player )
				//}

				file.playerFakeNPC[ player ] = null
				file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] = 0.0
			}
		}
	)

	// marvin movement anim init
	marvin.Anim_ScriptedPlay( "mv_idle_unarmed" )
	file.fakeMarvinMovementState[ marvin ] <- eMarvinMovement.IDLE

	float lastStartTraverseTime = -1

	while ( true )
	{
		TakeAllWeapons( player )

		// health
		int playerMaxHealth = player.GetMaxHealth()
		int playerMaxShield = GetShieldHealthMaxWithFix( player )
		int playerHealth = player.GetHealth()
		int playerShield = GetShieldHealthWithFix( player )

		// class mods
		string setFile = player.GetPlayerSettings()
		array<string> classMods = player.GetPlayerSettingsMods()
		bool isColiseumFemale = setFile == "pilot_coliseum_female"
		bool hasMovementLimiter = classMods.contains( "disable_doublejump" ) && classMods.contains( "disable_wallrun" )
		if ( !isColiseumFemale || !hasMovementLimiter )
		{
			player.SetPlayerSettingsWithMods( "pilot_coliseum_female", ["disable_doublejump", "disable_wallrun"] )
		
			// update health
			player.SetMaxHealth( playerMaxHealth )
			player.SetHealth( playerHealth )
		}

		// visual effect
		// looping to update highlight could be good
		if ( !file.playerHasRGBHighlight[ player ] )
			SetUpFakeMarvinHighlight( player )
		HideName( player )
		player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
		// reworked here, we make player take damage instead of marvin re-direct damage
		// welp, guess making both entities take damage could be better
		//player.SetInvulnerable()
		player.NotSolid() // non-solid makes player unable to take trigger_hurt damage and won't trigger OOB... DOESN"T MATTER! player can use kill command to get back, enabling this could be fun!
		// this is bad... will make attachments messed up
		//player.kv.modelscale = 0.01 // instead, we make player almost unable to getting hit, they'll still caught in explosions though
		player.kv.CollisionGroup = 0 // TRACE_COLLISION_GROUP_BLOCK_WEAPONS
		
		// movement limiter
		//player.ClearTraverse() // marvin don't have suitable anim for mantling, but we still allow player to traverse
		if ( player.IsTraversing() )
		{
			if ( lastStartTraverseTime == -1 )
				lastStartTraverseTime = Time()
			else if ( Time() - lastStartTraverseTime > 1 ) // maxnium of 1s mantling. enough for most traverse
				player.ClearTraverse()
		}
		else
			lastStartTraverseTime = -1
		
		player.ForceStand() // avoid camera glitch when using chasing cam
		
		// health
		// reworked here, we make player take damage instead of marvin re-direct damage
		// EDIT: reworked again here: still change to use marvin for re-directing damage, but player took radius damage will be blocked
		/*
		//player.SetShieldHealthMax( marvin.GetShieldHealthMax() )
		//player.SetShieldHealth( marvin.GetShieldHealth() )
		SetShieldHealthMaxWithFix( player, GetShieldHealthMaxWithFix( marvin ) )
		SetShieldHealthWithFix( player, GetShieldHealthWithFix( marvin ) )
		player.SetMaxHealth( marvin.GetMaxHealth() )
		player.SetHealth( marvin.GetHealth() )
		*/

		// marvin effects
		// looping to update highlight could be good
		if ( !file.playerHasRGBHighlight[ player ] )
			SetUpFakeMarvinHighlight( marvin )
		//marvin.SetInvulnerable()
		// maybe no need to change collision
		//marvin.kv.CollisionGroup = 0

		//marvin.NotSolid() // non-solid entity won't show name, which is bad
		//SetShieldHealthMaxWithFix( marvin, playerMaxShield )
		//SetShieldHealthWithFix( marvin, playerShield )
		
		// keep marvin at extremely high health, don't want them to die from normal damages
		//marvin.SetMaxHealth( playerMaxHealth )
		//marvin.SetHealth( playerHealth )
		// keep marvin at extremely high health, don't want them to die
		// acutally damage can be handled by "OnFakeMarvinFinalDamaged" but whatever
		marvin.SetMaxHealth( 99999 )
		marvin.SetHealth( 99999 )

		// marvin animations
		if ( !player.IsOnGround() 
			 || player.IsWallRunning() 
			 || player.IsWallHanging() 
			 || player.IsTraversing() 
			 )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.IN_AIR )
			{
				marvin.Anim_ScriptedPlay( "mv_skyfall" ) // "mv_skyfall_lean"
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.IN_AIR
			}
			//printt( "player marvin in air!" )
		}
		// walking and spriting doesn't working fine
		// parented move anim seems weird...
		// fixed by marvin.Anim_DisableUpdatePosition()
		// sprinting still not look so good
		// whatever, we've added moveslow for player so I think there's no need to add sprinting
		/*
		else if ( player.IsSprinting() )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.SPRINTING )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.SPRINTING
				marvin.Anim_ScriptedPlay( "sp_sprint_tmp" ) //
				marvin.Anim_DisableUpdatePosition() // can this fix marvin change position through walking?
			}
			//printt( "player marvin sprinting!" )
		}
		*/
		// key combo: scripted animation
		else if ( file.fakeMarvinScriptedAnimEnabled
				  && !IsValid( player.GetParent() ) // can't use scripted anim while parented
				  && file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] <= Time()
				  && player.IsOnGround() 
				  && ( player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) )
				  && ( player.IsInputCommandHeld( IN_ATTACK ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) ) 
				  && player.IsInputCommandHeld( IN_MELEE ) 
				  )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.SCRIPTED_ANIMATION )
			{
				// stop looping and wait for animation end
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.SCRIPTED_ANIMATION
				waitthread MarvinScriptedIntroAnim( player, marvin )
				file.playerNextFakeMarvinScriptedAnimAllowedTime[ player ] = Time() + MARVIN_INTRO_ANIM_COOLDOWN // update cooldown
			}
		}
		else if ( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WAVING )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WAVING
				marvin.Anim_ScriptedPlay( "mv_wave_unarmed" )
			}
			//printt( "player marvin waving!" )
		}
		// walking has lower priority than waving
		else if ( Length( player.GetVelocity() ) > 10 )
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WALKING )
			{
				//file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WALKING // state setup handled in MarvinPlayerMoveAnimThink()
				// parented move anim seems weird...
				// fixed by marvin.Anim_DisableUpdatePosition()
				//thread MarvinPlayerMoveAnimThink( player, marvin, "Walk_All", eMarvinMovement.WALKING ) // Walk_all_v2
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WALKING
				marvin.Anim_ScriptedPlay( "Walk_All" ) //
				marvin.Anim_DisableUpdatePosition() // can this fix marvin change position through walking?
			}
			//printt( "player marvin walking!" )
		}
		else if ( player.IsInputCommandHeld( IN_ZOOM ) 
				  || player.IsInputCommandHeld( IN_ZOOM_TOGGLE ) 
				  )
		{
			if ( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
			{
				if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WASHING_WINDOW )
				{
					file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WASHING_WINDOW
					marvin.Anim_ScriptedPlay( "mv_idle_wash_window" )
				}
			}
			else
			{
				if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.WELDING )
				{
					file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.WELDING
					marvin.Anim_ScriptedPlay( "mv_idle_weld" )
				}
			}
		}
		else // idle
		{
			if ( file.fakeMarvinMovementState[ marvin ] != eMarvinMovement.IDLE )
			{
				file.fakeMarvinMovementState[ marvin ] = eMarvinMovement.IDLE
				marvin.Anim_ScriptedPlay( "mv_idle_unarmed" )
			}
			//printt( "player marvin idle!" )
		}

		WaitFrame()
	}
}

void function MarvinPlayerTrackView( entity player )
{
	// player will use third person camera, which will mess up kill replay
	// adding this mark so we won't do replay for them
	// this mark only gets cleared on next respawn, so make sure your fake npc kills the player along with them!
	file.playerUsingFakeNPCThisLife[ player ] = true

	player.SetTrackEntity( player ) // Sets an entity to be viewed by this player in third person
	//player.SetTrackEntity( GetNPCArray()[0] )
	player.SetTrackEntityPitchLookMode( "orbit" )
	player.SetTrackEntityYawLookMode( "orbit" )
	player.SetTrackEntityDistanceMode( "scriptOffset" )
	player.SetTrackEntityMinYaw( -180 )
	player.SetTrackEntityMaxYaw( 180 )
	player.SetTrackEntityMinPitch( -30 ) // was -89, which means max pitch view
	player.SetTrackEntityMaxPitch( 44 ) // // was 89, which means max pitch view
	player.SetTrackEntityOffset( < -150.0, 0, 30.0 > )
	//player.SetTrackEntityOffsetDistance( -50.0 )
	//player.SetTrackEntityOffsetHeight( 30.0 )
}

// parented move anim seems weird...
// fixed by marvin.Anim_DisableUpdatePosition()
/*
void function MarvinPlayerMoveAnimThink( entity player, entity marvin, string anim, int stateKeep )
{
	//marvin = CreatePropDynamic( $"models/robots/marvin/marvin.mdl", marvin.GetOrigin(), marvin.GetAngles(), 6 )
	marvin.EndSignal( "OnDeath" )
	marvin.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	marvin.Signal( "MarvinPlayerMoveAnimThink" )
	marvin.EndSignal( "MarvinPlayerMoveAnimThink" )

	print( "marvin doing anim!" )

	entity mover = CreateScriptMover()
	mover.SetOrigin( player.GetOrigin() )
	mover.SetAngles( < 0, player.GetAngles().y, 0 > )
	marvin.ClearParent()
	marvin.SetParent( mover )
	marvin.Anim_ScriptedPlay( anim )

	OnThreadEnd
	(
		function(): ( player, marvin, mover )
		{
			if ( IsValid( player ) && IsValid( marvin ) )
			{
				marvin.ClearParent()
				marvin.SetParent( player, "ORIGIN" ) // set back
			}
			if ( IsValid( mover ) )
				mover.Destroy()
		}
	)

	file.fakeMarvinMovementState[ marvin ] = stateKeep
	while ( file.fakeMarvinMovementState[ marvin ] == stateKeep )
	{
		mover.NonPhysicsMoveTo( player.GetOrigin(), 0.1, 0.0, 0.0 )
		mover.NonPhysicsRotateTo( < 0, player.GetAngles().y, 0 >, 0.1, 0.0, 0.0 )
		WaitFrame()
	}

	print( "state lost!" )
}
*/

// for playing dropship intro anims
// might be kinda annoying...
// bunch of stupid stuffs inside
void function MarvinScriptedIntroAnim( entity player, entity marvin )
{
	if ( IsValid( player.GetParent() ) ) // can't use scripted anim while parented
		return

	// EndSignals handled by PlayerMarvinThink()
	player.FreezeControlsOnServer()

	OnThreadEnd
	(
		function(): ( player, marvin )
		{
			if ( IsValid( player ) )
			{
				player.UnfreezeControlsOnServer()
				player.ClearInvulnerable()
				player.SetPhysics( MOVETYPE_WALK )
			}
			if ( IsValid( marvin ) )
			{
				marvin.Anim_Stop()
				if ( IsAlive( player ) )
				{
					marvin.SetParent( player, "ORIGIN" )
					marvin.SetOrigin( < 0, 0, 0 > )
				}
				marvin.ClearInvulnerable()
			}
		}
	)

	array<MarvinIntroAnim> validAnimations = clone file.marvinIntroAnims
	MarvinIntroAnim randomAnim = validAnimations.getrandom()

	// temp clear parent
	marvin.ClearParent()
	// since parent has been cleared, if player has RGB highlight we need to apply it for marvin
	if ( file.playerHasRGBHighlight[ player ] )
		thread RGB_Highlight( file.playerFakeNPC[ player ], true )

	// don't want marvin or player die here
	marvin.SetInvulnerable()
	player.SetInvulnerable()
	// stop movements from here
	player.SetVelocity( < 0, 0, 0 > )
	marvin.SetVelocity( < 0, 0, 0 > )
	player.SetPhysics( MOVETYPE_NOCLIP )
	// needs to set offset for marvin
	vector posWithOffset = player.GetOrigin() + randomAnim.offset
	marvin.SetOrigin( posWithOffset )

	marvin.Anim_ScriptedPlay( randomAnim.animName )
	if ( randomAnim.initialTime > 0 )
		marvin.Anim_SetInitialTime( randomAnim.initialTime )

	// HACK and may cause sound loss on players
	thread MarvinIntroSoundThink( marvin, randomAnim )

	WaitEndFrame() // may works different with higher script_server_fps
	// stop sound may loss if server or client unstable...
	StopSoundOnEntity( marvin, "crow_mp_intro" )

	if ( randomAnim.actualLength > 0 )
		wait randomAnim.actualLength
	else
		wait marvin.GetSequenceDuration( randomAnim.animName )
}

void function MarvinIntroSoundThink( entity marvin, MarvinIntroAnim animStruct )
{
	marvin.EndSignal( "OnDestroy" )
	marvin.EndSignal( "OnDeath" )

	table<string, float> soundsTable = animStruct.introSounds
	float soundRadius = animStruct.introSoundRadius

	float startTime = Time()
	if ( animStruct.initialTime > 0 )
		startTime += animStruct.initialTime

	array<string> soundsPlayed
	while ( marvin.Anim_IsActive() )
	{
		foreach ( string soundName, float playDelay in soundsTable )
		{
			if ( soundsPlayed.contains( soundName ) )
				continue
			float soundPlayTime = startTime + playDelay
			float soundMaxPlayTime = soundPlayTime + 0.2 // if we looped more than 0.2s before playing a sound, do nothing
			if ( Time() >= soundPlayTime && Time() < soundMaxPlayTime )
			{
				PlayMarvinSoundToNearbyPlayers( marvin, soundName, soundRadius )
				soundsPlayed.append( soundName )
			}
			else // if sound not played yet, try stop sound played by animation
			{
				// looping to stop sound may cause sound loss
				// remove if it can be handled by PlayMarvinSoundToNearbyPlayers()
				//StopSoundOnEntity( marvin, soundName )
			}
		}

		WaitFrame()
	}
}

void function PlayMarvinSoundToNearbyPlayers( entity marvin, string soundName, float radius )
{
	// try stop sound played by animation
	// stop sound may loss if server or client unstable...
	StopSoundOnEntity( marvin, soundName )
	foreach ( entity player in GetAllPlayersInMarvinSoundRadius( marvin.GetOrigin(), radius ) )
	{
		EmitSoundOnEntityOnlyToPlayer( marvin, player, soundName )
	}

	// no need to track sound end, cause Anim_Stop() will clean them up on dead entities( pretty good )
}

array<entity> function GetAllPlayersInMarvinSoundRadius( vector pos, float radius )
{
	array<entity> targetPlayers
	// only for living players, dead players can respawn and change position
	foreach ( entity player in GetPlayerArray_Alive() )
	{
		if ( Distance( pos, player.GetOrigin() ) > radius )
			continue

		targetPlayers.append( player )
	}

	return targetPlayers
}

void function NessyFunny_EnablePlayerTickDamageByDefault( bool enable )
{
	file.playerTickCanDoDamageByDefault = enable
}

entity function PlayerBecomesTick( entity player, string tickAiSettings = "npc_frag_drone_throwable", float moveSpeedScale = -1, float suicideChaseTime = -1, float suicideChaseSpeedScale = -1, float overloadDelayAdjustment = -1, bool ornull tickCanDoDamageOverride = null )
{
	if ( IsValid( file.playerFakeNPC[ player ] ) )
		return

	if ( !IsAlive( player ) )
		return
	
	if ( player.IsTitan() || player.Anim_IsActive() || IsValid( player.GetParent() ) )
		return

	// remove ragdoll impact effect
	SetHumanRagdollImpactTable( player )
	
	bool tickCanDoDamage = file.playerTickCanDoDamageByDefault
	// override from default value
	if ( tickCanDoDamageOverride != null )
		tickCanDoDamage = expect bool( tickCanDoDamageOverride )

	int team = player.GetTeam()
	vector origin = player.GetOrigin()
	vector angles = player.GetAngles()
	
	entity tick = CreateFragDroneCan( team, origin, < 0, angles.y, 0 > )
	SetSpawnOption_AISettings( tick, tickAiSettings )

	tick.kv.contents = (int(tick.kv.contents) | CONTENTS_NOGRAPPLE)
	tick.ai.killShotSound = false
	
	// if tick cannot do damage, we assign fake explosion for them
	if ( !tickCanDoDamage )
		SuicideSpectre_SetNotExploding( tick )

	DispatchSpawn( tick )

	// remove tick's original think and stuffs
	// these utility functions are defined in modified _ai_suicide_spectres.gnut
	RemoveSuicideSpectre( tick ) // maybe not good enough!! this will remove their anim event, we can't use it to identify what they're doing
	
	// lock player until tick is armed
	// really need a movement utility func to handle control freezing...
	tick.SetBossPlayer( player )
	player.FreezeControlsOnServer()
	AddAnimEvent( tick, "frag_drone_armed", FragDroneArmed ) // guess we manually add an anim event??? also handles control freezing
	
	// start deploy without delay
	thread FragDroneDeplyAnimation( tick, 0.0, 0.1 )

	// update player health
	player.SetMaxHealth( tick.GetMaxHealth() )
	player.SetHealth( tick.GetHealth() )

	// setup everything
	player.SetNoTarget( true )
	PainDeathSounds_SetDisabledForEntity( player, true ) // temp
	DeathPackage_SetDisabledForEntity( player, true )
	file.playerFakeNPC[ player ] <- tick

	// our tick maybe safe to other entities
	if ( !tickCanDoDamage )
	{
		tick.SetEfficientMode( true )
		//tick.SetTouchTriggers( false )
		tick.SetNoTarget( true )
		tick.SetAimAssistAllowed( false )
	}

	// setup tick
	tick.Highlight_SetInheritHighlight( true )

	tick.SetShieldHealthMax( player.GetShieldHealthMax() )
	tick.SetShieldHealth( player.GetShieldHealth() )

	tick.SetParent( player, "ORIGIN" )
	SetForceDrawWhileParented( tick, true )

	if ( BATTERY_SPAWNERS.contains( player.GetUID() ) )
		HideName( tick )

	// pass damage to player
	AddEntityCallback_OnFinalDamaged( tick, OnFakeNPCFinalDamaged )
	AddEntityCallback_OnPostDamaged( player, OnTickPlayerDamaged )
	// disables health regen. utility defined in modified _health_regen.gnut
	HealthRegen_SetDisabled( true, player )

	thread PlayerTickThink( player, tick, moveSpeedScale, suicideChaseTime, suicideChaseSpeedScale, overloadDelayAdjustment )
	thread PlayerTickAnimationThink( player, tick ) // tick animation is pretty simple compare to marvin's, use thread here
	thread DisableBoostBar( player )

	return tick
}

void function FragDroneArmed( entity npc )
{
	//print( "frag drone armed!" )
	npc.ai.fragDroneArmed = true
	entity bossPlayer = npc.GetBossPlayer()

	if ( IsValid( bossPlayer ) )
		bossPlayer.UnfreezeControlsOnServer() // unfreeze their owner
}

void function OnTickPlayerDamaged( entity player, var damageInfo )
{
	// upon damage, start suicide chase
	if ( DamageInfo_GetDamage( damageInfo ) > 0 ) // shield taking damage won't do anything...?
	{
		entity tick = file.playerFakeNPC[ player ]
		// tick isn't inited yet, temp blank damage taken
		if ( !IsValid( tick ) || !( tick in file.fakeTickMovementState ) )
		{
			DamageInfo_SetDamage( damageInfo, 0 )
			return
		}

		if ( IsAlive( tick ) && tick.ai.fragDroneArmed ) // validation tick
		{
			if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING ) // tick overloading
				tick.Signal( "OverloadingTickTookDamage" ) // detonate immediately
			else if ( !file.playerTickDoingSuicideChase[ player ] )
			{
				thread PlayerTickStartsSuicideChase( player )
				file.playerTickDoingSuicideChase[ player ] = true
			}
		}
	}
}

void function PlayerTickStartsSuicideChase( entity player )
{
	entity tick = file.playerFakeNPC[ player ]
	if ( !IsAlive( tick ) )
		return

	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	player.EndSignal( "TickPlayerStartsOverload" ) // overloading stops any message

	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )

	// get tick's settings!
	float suicideChaseTime = file.tickOverloadBehavior[ tick ].suicideChaseTime
	float suicideChaseSpeedScale = file.tickOverloadBehavior[ tick ].suicideChaseSpeedScale

	// debug
	//suicideChaseTime = 10
	//suicideChaseSpeedScale = 3

	if ( suicideChaseTime > 0 )
	{
		if ( suicideChaseSpeedScale > 1.0 )
		{
			StatusEffect_AddTimed( player, eStatusEffect.speed_boost, GetSpeedBoostEffectSeverity( suicideChaseSpeedScale ), suicideChaseTime, 0.0 )
			tick.SetNPCMoveSpeedScale( suicideChaseSpeedScale ) // does this scales up animation cycle?
		}
		float endTime = Time() + suicideChaseTime
		while ( Time() < endTime )
		{
			// defensive fix
			if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING )
				return

			float timeLeftToExplode = floor( (endTime - Time() ) * 100 ) / 100
			SendHudMessage( player, "遭受攻擊！距離過載剩餘 " + timeLeftToExplode, -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
			//SendHudMessage( player, "Took Damage! Overloading in " + timeLeftToExplode, -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
			WaitFrame()
		}
	}

	thread PlayerTickOverloads( player, tick )
}

// player's speed_boost effect is actually value^2, needs a utility for calculating
float function GetSpeedBoostEffectSeverity( float expectedSpeedScale )
{
	// temptemp
	//print( "expectedSpeedScale: " + string( expectedSpeedScale ) )
	if ( expectedSpeedScale < 1 ) // given value is not good!
		return 0.0
	
	float boostSeverity = sqrt( expectedSpeedScale ) - 1
	//print( "boostSeverity: " + string( boostSeverity ) )
	return boostSeverity
}

void function PlayerTickThink( entity player, entity tick, float moveSpeedScale, float suicideChaseTime, float suicideChaseSpeedScale, float overloadDelayAdjustment )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "player_embarks_titan" ) // maybe no need to add this... embarking as tick kills you!
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )

	// get all settings value
	// if there're no settings override, use default value

	if ( moveSpeedScale == -1 )
	{
		float minSpeedScale = expect float( tick.Dev_GetAISettingByKeyField( "minSpeedScale" ) )
		float maxSpeedScale = expect float( tick.Dev_GetAISettingByKeyField( "maxSpeedScale" ) )
		moveSpeedScale = ( minSpeedScale + maxSpeedScale ) / 2
		//print( "moveSpeedScale: " + string( moveSpeedScale ) )
	}

	if ( suicideChaseTime == -1 )
	{
		if ( tick.Dev_GetAISettingByKeyField( "SuicideChaseTime" ) != null )
			suicideChaseTime = expect float( tick.Dev_GetAISettingByKeyField( "SuicideChaseTime" ) )
		else
			suicideChaseTime = 0.0
	}
	
	if ( suicideChaseSpeedScale == -1 )
		suicideChaseSpeedScale = expect float( tick.Dev_GetAISettingByKeyField( "maxSpeedScale" ) )
	
	if ( overloadDelayAdjustment == -1 )
	{
		overloadDelayAdjustment = 0.0
		// same checks as _ai_suicide_spectres.gnut does
		bool isFragDrone = tick.mySpawnOptions_aiSettings == "npc_frag_drone_throwable"
		if ( !isFragDrone )
			overloadDelayAdjustment = 0.25
	}

	TickOverloadBehavior overloadBehaviorStruct
	overloadBehaviorStruct.suicideChaseTime = suicideChaseTime
	overloadBehaviorStruct.suicideChaseSpeedScale = suicideChaseSpeedScale
	overloadBehaviorStruct.overloadDelayAdjustment = overloadDelayAdjustment
	file.tickOverloadBehavior[ tick ] <- overloadBehaviorStruct

	array<int> statusEffectsToCleanUp
	// add move speed penalty to prevent sprinting
	statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.1 ) )
	// add basic speed boost
	if ( moveSpeedScale > 1.0 )
	{
		statusEffectsToCleanUp.append( StatusEffect_AddEndless( player, eStatusEffect.speed_boost, GetSpeedBoostEffectSeverity( moveSpeedScale ) ) )
		tick.SetNPCMoveSpeedScale( moveSpeedScale ) // does this scales up animation cycle?
	}
	//else // lower than 1, idk how to add slow effect...

	// start third person tracking
	TickPlayerTrackView( player )
	// end any loadout update immediately
	player.Signal( "OnPrimaryAttack" )

	OnThreadEnd
	(
		function(): ( player, tick, statusEffectsToCleanUp )
		{
			if ( IsValid( tick ) )
			{
				RemoveEntityCallback_OnFinalDamaged( tick, OnFakeNPCFinalDamaged )
				tick.Anim_Stop()
				HideName( tick )
				tick.ClearParent()
				if ( IsAlive( tick ) )
					tick.Die( tick, tick, { damageSourceId = damagedef_suicide } )
			}
			if ( IsValid( player ) )
			{
				RemoveEntityCallback_OnPostDamaged( player, OnTickPlayerDamaged )
				HealthRegen_ClearDisabledSettingsOverride( player )
				player.Signal( "ClearTickPlayerTraverse" )

				// clean up
				foreach ( effect in statusEffectsToCleanUp )
					StatusEffect_Stop( player, effect )
				
				player.Anim_Stop()
				player.SetNoTarget( false )
				player.SetTrackEntity( null )
				player.ClearTrackEntitySettings()

				PainDeathSounds_SetDisabledForEntity( player, false )
				DeathPackage_SetDisabledForEntity( player, false )

				RestorePlayerPermanentAirSpeed( player )
				RestorePlayerPermanentAirAcceleration( player )

				ShowName( player )
				player.Solid()
				player.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
				player.UnforceStand()

				if ( IsAlive( player ) )
					player.Die( player, player, { damageSourceId = damagedef_suicide } )

				file.playerFakeNPC[ player ] = null
				file.playerTickDoingSuicideChase[ player ] = false // so next tick will be able to do suicide chase
			}
		}
	)

	//thread ClearTickPlayerTraverse( player )
	float lastStartTraverseTime = -1
	
	while ( true )
	{
		TakeAllWeapons( player )

		// health
		int playerMaxHealth = player.GetMaxHealth()
		int playerHealth = player.GetHealth()

		// class mods
		string setFile = player.GetPlayerSettings()
		array<string> classMods = player.GetPlayerSettingsMods()
		// maybe funnier to use pilot_boost?
		// nah, works bad. they don't have double jumping and can't disable wallrun 
		bool isColiseumMale = setFile == "pilot_coliseum_male"
		//bool isPilotBoostMale = setFile == "pilot_boost_male"
		bool hasMovementLimiter = classMods.contains( "disable_wallrun" )

		//if ( !isPilotBoostMale || !hasMovementLimiter )
		if ( !isColiseumMale || !hasMovementLimiter )
		{
			player.SetPlayerSettingsWithMods( "pilot_coliseum_male", ["disable_wallrun"] )
			//player.SetPlayerSettingsWithMods( "pilot_boost_male", [] )
		
			// update health
			player.SetMaxHealth( playerMaxHealth )
			player.SetHealth( playerHealth )

			// update mid-air control
			/*
			player.kv.airSpeed = int( player.kv.airSpeed ) * 0.5
			player.kv.airAcceleration = int( player.kv.airAcceleration ) * 1.5
			*/
			player.kv.airSpeed = 50 // normal pilot value
			player.kv.airAcceleration = 720 // pilot_coliseum value
		}

		// hide the player
		HideName( player )
		player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
		player.NotSolid() // non-solid makes player unable to take trigger_hurt damage and won't trigger OOB
		player.kv.CollisionGroup = 0 // TRACE_COLLISION_GROUP_BLOCK_WEAPONS

		// movement limiter
		// still feels bad! don't know how to handle, maybe higher air speed
		// nah, just need a higher tickrate. handled by ClearTickPlayerTraverse()
		// still feels bad because it blocks player from reaching higher place
		// maybe we only clear it when player mantling for too long
		//player.ClearTraverse() // ticks can double jump, so we'd remove their ability to traverse

		if ( player.IsTraversing() )
		{
			if ( lastStartTraverseTime == -1 )
				lastStartTraverseTime = Time()
			else if ( Time() - lastStartTraverseTime > 0.5 ) // maxnium of 0.5s(was 1s) mantling. needs keep holding direction button to traverse
				player.ClearTraverse()
		}
		else
			lastStartTraverseTime = -1

		player.ForceStand() // avoid camera glitch when using chasing cam

		// idk why ticks will ignore projectile damage
		// it's because _ai_suicide_spectres.gnut. has been fixed!
		//tick.kv.CollisionGroup = TRACE_COLLISION_GROUP_BLOCK_WEAPONS_AND_PHYSICS // was 0, which may make them invulnerable to projectiles...?

		// wait till tick finish arming
		if ( tick.ai.fragDroneArmed )
		{
			// ready to detonate???
			bool attackHeld = player.IsInputCommandHeld( IN_ATTACK )
			bool zoomHeld = player.IsInputCommandHeld( IN_ZOOM ) || player.IsInputCommandHeld( IN_ZOOM_TOGGLE )
			if ( attackHeld && zoomHeld )
			{
				waitthread PlayerTickOverloads( player, tick )
				return
			}
			else if ( attackHeld || zoomHeld ) // only one button held, do something
			{
				SendHudMessage( player, "同時按住 開火+開鏡 以進行過載", -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
				//SendHudMessage( player, "Hold both ATTACK + ZOOM to overload", -1, -0.3, 255, 255, 0, 255, 0, 0.2, 0 )
			}
		}

		WaitFrame()
	}
}

void function ClearTickPlayerTraverse( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	player.Signal( "ClearTickPlayerTraverse" )
	player.EndSignal( "ClearTickPlayerTraverse" )

	while ( true )
	{
		player.ClearTraverse()

		WaitFrame( true ) // higher tickrate!
	}
}

void function PlayerTickOverloads( entity player, entity tick )
{
	// haven't setup yet
	if ( !( tick in file.fakeTickMovementState ) )
		return
	
	if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING ) // already overloading?
		return

	// endSignals inherit from PlayerTickThink()

	tick.EndSignal( "OverloadingTickTookDamage" ) // taking damage during overloading causes insta explode
	
	// to end PlayerTickAnimationThink()
	player.Signal( "TickPlayerStartsOverload" )
	//UpdatePlayerTickMovementState( player, eTickMovement.OVERLOADING )
	file.fakeTickMovementState[ tick ] = eTickMovement.OVERLOADING // mark as tick overloading

	bool isFragDrone = tick.mySpawnOptions_aiSettings == "npc_frag_drone_throwable"
	// can't handle airpop's animation initial pos... temp removed
	//bool airPop = !player.IsOnGround()
	bool airPop = false

	// if we're doing suicide chase, airpop shouldn't emit sound
	string overloadSF
	if ( !airPop || !file.playerTickDoingSuicideChase[ player ] )
	{
		if ( isFragDrone )
			overloadSF = "weapon_sentryfragdrone_preexplo"
		else
			overloadSF = "corporate_spectre_overload_beep"
		// Overload Sound
		EmitSoundOnEntity( tick, overloadSF )
	}

	AI_CreateDangerousArea_DamageDef( damagedef_frag_drone_explode, tick, TEAM_INVALID, true, false )

	string overloadAnim = "sp_suicide_spectre_explode_stand"
	if ( airPop ) // airpop
	{
		overloadAnim = "sd_jump_explode"
		// airpop shouldn't have overload delay, but player can choose to do so... maybe no need to add?
		//overloadDelayAdjustment = 0.0
	}

	// freeze movements
	// welp, not good enough, we need freeze player so they can't jump
	//int moveLockEffect = StatusEffect_AddEndless( player, eStatusEffect.move_slow, 1.0 )
	// really need a movement utility func to handle control freezing...
	player.FreezeControlsOnServer()
	player.ClearTraverse() // remove any traversal in progress

	// Cleanup on thread end
	OnThreadEnd(
		// change to use control freeze
		//function() : ( player, tick, overloadSF, moveLockEffect )
		function() : ( player, tick, overloadSF )
		{
			if ( IsValid( player ) )
			{
				if ( IsAlive( player ) )
				{
					// explode. player dies without ragdoll
					// tick will explode without issue
					player.Die( player, player, { damageType = DMG_REMOVENORAGDOLL, damageSourceId = eDamageSourceId.suicideSpectreAoE } )
				}

				// change to use control freeze
				//StatusEffect_Stop( player, moveLockEffect )
				player.UnfreezeControlsOnServer()
			}
			if ( IsValid( tick ) )
			{
				if ( overloadSF != "" )
					StopSoundOnEntity( tick, overloadSF )
			}
		}
	)

	float sequenceDuration = tick.GetSequenceDuration( overloadAnim )
	float overloadDelayAdjustment = file.tickOverloadBehavior[ tick ].overloadDelayAdjustment

	float expectedTimer = sequenceDuration + overloadDelayAdjustment
	//print( "overloadDelayAdjustment: " + string( overloadDelayAdjustment ) )
	//print( "expectedTimer: " + string( expectedTimer ) )

	tick.Anim_ScriptedPlay( overloadAnim )
	tick.Anim_DisableUpdatePosition()
	// can't play with ref point while parented
	//thread PlayAnim( tick, overloadAnim )
	
	// if we got longer timer, do delay after animation done
	if ( expectedTimer > sequenceDuration && expectedTimer > 0 ) // these think only available when timer is above 0. otherwise it must be a script issue
	{
		//print( "doing delay AFTER animation!" )
		WaitSignal( tick, "OnAnimationInterrupted", "OnAnimationDone" )
		// if animation already done, we'd make tick idle so they don't running around
		tick.Anim_ScriptedPlay( "sd_spectre_idle" )
		wait overloadDelayAdjustment
	}
	else if ( expectedTimer < sequenceDuration && expectedTimer > 0 ) // if we got shorter timer, add timeout for animation
	{
		//print( "doing animation ALONG with timer!" )
		thread TrackTickTimerRunsOut( tick, expectedTimer )
		WaitSignal( tick, "OnAnimationInterrupted", "OnAnimationDone", "TickPlayerTimerRunsOut" )
	}
	else // no timer adjustments or we got minus timer value
	{
		//print( "no any behavior change for tick!" )
		WaitSignal( tick, "OnAnimationInterrupted", "OnAnimationDone" )
	}
}

void function TrackTickTimerRunsOut( entity tick, float expectedTimer )
{
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )
	
	wait expectedTimer
	tick.Signal( "TickPlayerTimerRunsOut" )
}

void function PlayerTickAnimationThink( entity player, entity tick )
{
	// end signals for overloading
	player.EndSignal( "TickPlayerStartsOverload" )

	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	tick.EndSignal( "OnDeath" )
	tick.EndSignal( "OnDestroy" )

	// nah these can't handle well... traverse animation can't be used to fake jumping
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, OnTickPlayerJump )
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, OnTickPlayerDoubleJump )
	AddPlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, OnTickPlayerTouchGround )

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.JUMP, OnTickPlayerJump )
				RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.DOUBLE_JUMP, OnTickPlayerDoubleJump )
				RemovePlayerMovementEventCallback( player, ePlayerMovementEvents.TOUCH_GROUND, OnTickPlayerTouchGround )
			}
		}
	)

	// idle init
	file.fakeTickMovementState[ tick ] <- eTickMovement.IDLE

	// wait till fully arm!
	while ( !tick.ai.fragDroneArmed )
		WaitFrame()
	tick.Anim_ScriptedPlay( "sd_spectre_idle" )

	while ( true )
	{
		// defensive fix
		if ( file.fakeTickMovementState[ tick ] == eTickMovement.OVERLOADING )
			return

		if ( file.fakeTickMovementState[ tick ] != eTickMovement.JUMPING )
		{
			// can't handle in-air animation, guess sound and jet effect is enough
			/*
			if ( !player.IsOnGround() ) // consider freefalling
			{
				
			}
			else if ( Length( player.GetVelocity() ) > 10 )
			*/
			// welp, maybe skip updating when player isn't on ground could be better
			if ( player.IsOnGround() )
			{
				UpdatePlayerTickAnimation( player, tick )
			}
		}

		WaitFrame()
	}
}

// WIP: animation
void function OnTickPlayerJump( entity player )
{
	//print( "RUNNING OnTickPlayerJump()" )
	// animation don't work well. sound is enough
	/*
	UpdatePlayerTickMovementState( player, eTickMovement.JUMPING )
	player.Signal( "TickPlayerJump" )
	thread TickPlayerJump( player )
	*/
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		UpdatePlayerTickAnimation( player, tick )
		PlayFragDroneSound( tick, "jump_default_3p" )
	}
}

void function OnTickPlayerDoubleJump( entity player )
{
	//print( "RUNNING OnTickPlayerDoubleJump()" )
	// animation don't work well. sound and effect is enough
	/*
	UpdatePlayerTickMovementState( player, eTickMovement.JUMPING )
	//player.Signal( "TickPlayerDoubleJump" )
	player.Signal( "TickPlayerJump" ) // same signal should be enough
	thread TickPlayerJump( player, true )
	*/
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		UpdatePlayerTickAnimation( player, tick )
		// already got jump jet sound
		//EmitSoundOnEntity( tick, "sentryfragdrone_jump_default_3p" )

		// for sp tick only: jet effect
		bool isSPFragDrone = tick.GetModelName() == $"models/robots/drone_frag/drone_frag.mdl"
		if ( isSPFragDrone )
			PlayFXOnEntity( $"P_frag_drone_jump_jet", tick, "HEADFOCUS" )
	}
}

void function OnTickPlayerTouchGround( entity player )
{
	//print( "RUNNING OnTickPlayerTouchGround()" )
	/*
	UpdatePlayerTickMovementState( player, eTickMovement.LANDING )
	player.Signal( "TickPlayerTouchGround" )
	*/

	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		UpdatePlayerTickAnimation( player, tick )
		// should we remove sound for traversing?
		// somehow makes player themselves feels janky... because they can't hear their own traverse sound in third person
		// but landing sound for SP frag drone is a bit too loud ahhhh
		//if ( !player.IsTraversing() )
			PlayFragDroneSound( tick, "land_default_3p" )
	}
}

void function PlayFragDroneSound( entity tick, string soundSuffix )
{
	bool isSPFragDrone = tick.GetModelName() == $"models/robots/drone_frag/drone_frag.mdl"
	string soundPrefix = isSPFragDrone ? "tick" : "sentryfragdrone"

	EmitSoundOnEntity( tick, soundPrefix + "_" + soundSuffix )
}

// these funcs are not good enough
/*
void function UpdatePlayerTickMovementState( entity player, int expectedState )
{
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) && ( tick in file.fakeTickMovementState ) )
		file.fakeTickMovementState[ tick ] = expectedState
}

void function TickPlayerJump( entity player, bool isAirJump = false )
{
	player.EndSignal( "TickPlayerTouchGround" )
	player.EndSignal( "TickPlayerJump" )

	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
	{
		tick.Anim_ScriptedPlay( "sd_traverse_over" )
		tick.Anim_DisableUpdatePosition()
	}
}
*/

void function UpdatePlayerTickAnimation( entity player, entity tick )
{
	// not armed yet!
	if ( !( tick in file.fakeTickMovementState ) )
		return
	
	if ( Length( < player.GetVelocity().x, player.GetVelocity().y, 0 > ) > 10 ) // walking. only calculate horizontal velocity
	{
		if ( file.fakeTickMovementState[ tick ] != eTickMovement.WALKING )
		{
			file.fakeTickMovementState[ tick ] = eTickMovement.WALKING
			tick.Anim_ScriptedPlay( "sd_aggressive_runaim" )
			tick.Anim_DisableUpdatePosition()
		}
	}
	else // idling
	{
		if ( file.fakeTickMovementState[ tick ] != eTickMovement.IDLE )
		{
			file.fakeTickMovementState[ tick ] = eTickMovement.IDLE
			tick.Anim_ScriptedPlay( "sd_spectre_idle" )
		}
	}
}

void function TickPlayerTrackView( entity player )
{
	// player will use third person camera, which will mess up kill replay
	// adding this mark so we won't do replay for them
	// this mark only gets cleared on next respawn, so make sure your fake npc kills the player along with them!
	file.playerUsingFakeNPCThisLife[ player ] = true

	player.SetTrackEntity( player ) // Sets an entity to be viewed by this player in third person
	player.SetTrackEntityPitchLookMode( "orbit" )
	player.SetTrackEntityYawLookMode( "orbit" )
	player.SetTrackEntityDistanceMode( "scriptOffset" )
	player.SetTrackEntityMinYaw( -180 )
	player.SetTrackEntityMaxYaw( 180 )
	player.SetTrackEntityMinPitch( -30 )
	player.SetTrackEntityMaxPitch( 30 )

	bool isSPFragDrone = false
	entity tick = file.playerFakeNPC[ player ]
	if ( IsAlive( tick ) )
		isSPFragDrone = tick.GetModelName() == $"models/robots/drone_frag/drone_frag.mdl"
	
	if ( isSPFragDrone )
		player.SetTrackEntityOffset( < -130.0, 0, 30.0 > ) // sp tick is a bit larger
	else
		player.SetTrackEntityOffset( < -120.0, 0, 25.0 > )
}

// ENOUGH, could've use gib death
// EDIT: 04/11/2025 change back to use gib death again. I've suffered enough, these proxy cannot be used on players
entity function CreateModelProxyForEntity( entity ent, asset modelName, string deathNPCClass = "npc_soldier", bool alwaysGibDeath = true )
{
	// better hide -- only adds invisibility, won't impact effects
	// THIS STOPS WORKING ONCE PLAYER RESPAWNED. FUCK IT
	// EDIT: MUST RESET RENDERMODE BEFORE RESPAWNING! otherwise it just stops working in following games
	// I've now added an extra fix in _base_gametype_mp.gnut
	// ALSO, MUST RESET RENDERMODE BEFORE CLASS CHANGE!
	// it's highly related with SetPlayerSettingsWithMods() method... guess we'll have to wrap it. way too complecated have leave it till we also wrap other model proxy stuffs...
	// EDIT2: cannot handle settings change AT ALL! guess we'll have to use player.Hide(), removing their jumpjet effects... this will also make health bar tracking become weird
	// EDIT3: fuck all of these. footsteps gets lost once players are hidden. change back to use rendermode changes, at least it works fine for npcs.
	ent.kv.rendermode = 4
	ent.kv.renderamt = 0
	// DAMMIT! HIDING ENTITY WILL REMOVE ALL OF THEIR SOUND!
	// that gives one way to make a REAL LOW PROFILE for us, but not good for usual use...
	//ent.Hide()
	//ent.kv.VisibilityFlags = 0

	// cannot use camo or skin for non-titan model... be awared
	entity proxy = CreatePropDynamic( modelName, ent.GetOrigin(), ent.GetAngles() )
	SetTeam( proxy, ent.GetTeam() ) // hopefully we'll have proper team lights
	proxy.SetParent( ent, "REF" )
	proxy.SetBoneMerge( ent )
	proxy.MarkAsNonMovingAttachment()
	proxy.RemoveFromSpatialPartition()
	proxy.Highlight_SetInheritHighlight( true )
	/*
	SetForceDrawWhileParented( proxy, true ) // have to do this after ent.kv.VisibilityFlags = 0
	proxy.SetOwner( ent )
	ent.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY // not owner only
	*/
	// NPC variant
	/*
	entity proxy = CreateEntity( "npc_pilot_elite" ) // pilot elite never speak
	proxy.SetValueForModelKey( modelName )
	// this should totally avoid any collision?
	SetSpawnflags( proxy, ( SF_NPC_NO_PLAYER_PUSHAWAY | SF_NPC_ALLOW_SPAWN_SOLID | SF_NPC_ALTCOLLISION | SF_NPC_START_EFFICIENT ) )
	DispatchSpawn( proxy )
	proxy.SetModel( modelName )
	TakeAllWeapons( proxy )
	proxy.SetParent( ent, "REF" )
	proxy.SetBoneMerge( ent )
	proxy.MarkAsNonMovingAttachment()
	proxy.RemoveFromSpatialPartition()
	proxy.Highlight_SetInheritHighlight( true )
	proxy.Freeze() // can't freeze otherwise model light won't move...
	*/
	
	// why players won't get hide if we don't run this function???
	// isn't very stable on players idk why
	if ( !alwaysGibDeath )
		thread ModelProxyLifetime( ent, proxy, deathNPCClass )
	else // much easier way
		thread GibOwnerOnDeath( ent, proxy )
	//thread TransferChildrenToProxy( ent, proxy )

	return proxy
}

void function ModelProxyLifetime( entity ent, entity proxy, string deathNPCClass )
{
	ent.EndSignal( "OnDestroy" )
	proxy.EndSignal( "OnDestroy" )

	// better hide -- only adds invisibility, won't impact effects
	// isn't very stable on players idk why
	// THIS STOPS WORKING ONCE PLAYER RESPAWNED. FUCK IT
	// EDIT: MUST RESET RENDERMODE BEFORE RESPAWNING! otherwise it just stops working in following games
	// I've now added an extra fix in _base_gametype_mp.gnut
	// EDIT: still broken after changing class. can't handle that case
	// EDIT2: fuck all of these. footsteps gets lost once players are hidden. change back to use rendermode changes, at least it works fine for npcs.
	//ent.kv.rendermode = 4
	//ent.kv.renderamt = 0

	// disable death package for player/npc, all handled below
	// I'm not counting using this thing on players now. let's handle npcs good enough
	//if ( ent.IsPlayer() || ent.IsNPC() )
	if ( ent.IsPlayer() )
		DeathPackage_SetDisabledForEntity( ent, true )

	OnThreadEnd
	(
		function() : ( ent, proxy )
		{
			if ( IsValid( ent ) )
			{
				// restore stuffs
				// I'm not counting using this thing on players now. let's handle npcs good enough
				//if ( ent.IsPlayer() || ent.IsNPC() )
				if ( ent.IsPlayer() )
					DeathPackage_SetDisabledForEntity( ent, false )
				// will this make player's next life able to use the think again?
				// YES IT DOES!
				// I've now added an extra fix in _base_gametype_mp.gnut
				// EDIT: still broken after changing class. can't handle that case
				// EDIT2: fuck all of these. footsteps gets lost once players are hidden. change back to use rendermode changes, at least it works fine for npcs.
				ent.kv.rendermode = 0
				ent.kv.renderamt = 255
				//ent.Show()
				//ent.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
			}
			if ( IsValid( proxy ) )
				proxy.Destroy()
		}
	)

	// why is decoy sending "OnDeath" signal on getting shot???
	// should only handle for player/npc
	// nah player and npc also not working fine with these... they'll slide when model changed after death
	// also stalkers don't have proper animation for player death
	// I'm not counting using this thing on players now. let's handle npcs good enough
	//if ( ent.IsPlayer() || ent.IsNPC() )
	if ( ent.IsPlayer() )
	{
		table results = WaitSignal( ent, "FakeModelProxyOwnerDeath" )

		// handling being executed over here
		if ( ent.Anim_IsActive() )
		{
			// at this point we need to restore death package for ent
			// still can't handle anim event stuffs because death package think is called earlier than player death
			// it's fine I've suffered enough. could've make stalker players unable to be executed because you know, npcs also do so
			//DeathPackage_SetDisabledForEntity( ent, false )
			WaittillAnimDone( ent )
			// just ragdoll our proxy, should be good enough
			// maybe player will also drop a ragdoll... whatever
			// yes they do, and we may have 2 ragdolls dropping together. stupid
			proxy.BecomeRagdoll( <0,0,0>, false )
			// if we don't take hold, will leave only a player's ragdoll. actually feels better..?
			//WaitFrame() // ragdoll take hold
		}
		else
		{
			// maybe we could just destroy proxy here and let ent themselves play death animation? idk maybe they don't have one
			// welp maybe better solution: add a npc to play death animation for them
			/*
			ent.SetModel( proxy.GetModelName() )
			ent.SetValueForModelKey( proxy.GetModelName() )
			ent.kv.rendermode = 0
			ent.kv.renderamt = 255
			*/
			entity deathNPC = CreateEntity( deathNPCClass )
			deathNPC.SetValueForModelKey( proxy.GetModelName() )
			// this should totally avoid any collision?
			// they still gets snatched to their place for whatever
			SetSpawnflags( deathNPC, ( SF_NPC_NO_PLAYER_PUSHAWAY | SF_NPC_ALLOW_SPAWN_SOLID | SF_NPC_ALTCOLLISION | SF_NPC_START_EFFICIENT ) )
			DispatchSpawn( deathNPC )
			TakeAllWeapons( deathNPC )

			deathNPC.SetModel( proxy.GetModelName() )
			deathNPC.SetFullBodygroup( proxy.GetFullBodygroup() )

			PainDeathSounds_SetBodyTypeOverride( deathNPC, PainDeathSounds_GetBodyTypeOverride( ent ) )

			deathNPC.kv.CollisionGroup = 0 // stop collision
			deathNPC.NotSolid() // don't let them blocking bullets
			deathNPC.SetHealth( 1 ) // so spectres will die from frag grenades

			deathNPC.Die( 
				null, 
				null,  
				{ 	// damage table
					forceKill = true, // force killing them
					weapon = results.weapon, 
					origin = results.origin, 
					force = results.force, 
					scriptType = results.scriptType, 
					damageType = results.damageType, 
					damageSourceId = results.damageSourceId
				} 
			)
			deathNPC.SetOrigin( ent.GetOrigin() ) // sometimes it moves to weird position, maybe because navmeshes?
			deathNPC.SetAngles( < 0, ent.GetAngles().y, 0 > ) // no rotation for npcs

			//print( "player on ground: " + string( player.IsOnGround() ) )
			if ( !ent.IsOnGround() ) // if player died on ground we don't update velocity
			{
				vector forceVec = expect vector( results.force ) + ent.GetVelocity()
				float forceMag = Length( forceVec )
				forceVec = Normalize( forceVec )
				const float MAX_FORCE = 30000
				if ( forceMag > MAX_FORCE )
					forceMag = MAX_FORCE

				deathNPC.SetVelocity( forceVec * forceMag ) // so the body can fly as players does
			}

			// drop weapon manually
			entity activeWeapon = ent.GetActiveWeapon()
			// activeWeapon will become invalid if player is dropping weapon from death animation
			if ( IsValid( activeWeapon ) )
			{
				//print( "Death cam length modified but player can't make it to drop weapon!" )
				//print( "Dropping " + string( activeWeapon ) + " manually" )
				ent.DropWeapon( activeWeapon )
				activeWeapon.SetVelocity( ent.GetVelocity() )
			}

			// CAN'T RAGDOLL WITH EMPTY MODEL
			//thread DelayedFixRagdollWillThis( ent )
			// still can't show player here... otherwise they'll do ACT_DEATH on changing to spectator
			/*
			ent.kv.rendermode = 0
			ent.kv.renderamt = 255
			ent.Hide() // should be cleared on respawn with fixed scripts, I think
			// only one method: leave a head on ground
			PlayerPulseBladeModel_HideBodyAndLegs( ent )
			// change to wounded head
			ent.SetBodygroup( ent.FindBodyGroup( "head" ), 1 )
			//ent.BecomeRagdoll( <0,0,0>, false ) // ragdoll leave for animation
			ent.StopPhysics()
			*/
			
			// or maybe something really stupid: use buddy titan model because it's all parts can be hidden
			thread RagdollAsHiddenBuddyTitan( ent )
		}
	}
	else if ( ent.IsNPC() )
	{
		ent.WaitSignal( "OnDeath" )
		// changing model for dead npcs should work fine
		// or maybe we could just gib them
		// EDIT: this will take ~1 frame hold of T-Posing. idk how to tell it's weird but okay...?
		ent.SetModel( proxy.GetModelName() )
		ent.SetValueForModelKey( proxy.GetModelName() )
		ent.kv.rendermode = 0
		ent.kv.renderamt = 255
	}
	else
		WaitForever()
}


// HOW TO HIDE RAGDOLL AHHHHHHH
void function DelayedFixRagdollWillThis( entity ent )
{
	ent.EndSignal( "OnDestroy" )
	// wait for death animation to be played for at least 1 frame
	WaitFrame()
	if ( IsAlive( ent ) ) // player can respawn
		return
	// CAN'T RAGDOLL WITH EMPTY MODEL
	ent.SetModel( $"models/dev/empty_model.mdl" ) // this is stupid
	ent.BecomeRagdoll( <0,0,0>, false )
	ent.StopPhysics()
}

void function RagdollAsHiddenBuddyTitan( entity ent )
{
	ent.EndSignal( "OnDestroy" )
	ent.StopPhysics()

	// remove ragdoll impact
	ent.SetRagdollImpactFX( HUMAN_RAGDOLL_IMPACT_TABLE_IDX )
	ent.SetModel( $"models/titans/buddy/titan_buddy.mdl" )
	ent.SetBodygroup( ent.FindBodyGroup( "left_arm" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "right_arm" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "left_leg" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "right_leg" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "front" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "back" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "hatch" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "hip" ), 2 )
	ent.SetBodygroup( ent.FindBodyGroup( "battery_cap_center" ), 1 )
	ent.SetBodygroup( ent.FindBodyGroup( "battery_cap_outer" ), 1 )

	// wait for model to be actually changed
	wait 0.2
	if ( IsAlive( ent ) ) // player can respawn
		return
	
	ent.BecomeRagdoll( <0,0,0>, false )
	ent.StopPhysics() // player's view still gets slide away idk why
	StopSoundOnEntity( ent, "buddy_Movement_combat_idle" ) // idle sound played by buddy titan model

	WaitFrame() // wait till ragdoll process
	if ( IsAlive( ent ) ) // player can respawn
		return
	
	// try to stop camera for whatever!
	// it doesn't work
	ent.SetModel( $"models/dev/empty_model.mdl" ) // this is stupid
	ent.StopPhysics()
}


void function GibOwnerOnDeath( entity ent, entity proxy )
{
	ent.EndSignal( "OnDestroy" )
	proxy.EndSignal( "OnDestroy" )

	// disable death package for player/npc, so we don't gib them twice
	// this also removes headshot effects but whatever
	if ( ent.IsPlayer() || ent.IsNPC() )
		DeathPackage_SetDisabledForEntity( ent, true )

	OnThreadEnd
	(
		function() : ( ent, proxy )
		{
			if ( IsValid( ent ) )
			{
				// restore stuffs
				if ( ent.IsPlayer() || ent.IsNPC() )
					DeathPackage_SetDisabledForEntity( ent, false )
				ent.kv.rendermode = 0
				ent.kv.renderamt = 255
			}
			if ( IsValid( proxy ) )
				proxy.Destroy()
		}
	)

	// why is decoy sending "OnDeath" signal on getting shot???
	// should only handle for player/npc
	// nah player and npc also not working fine with these... they'll slide when model changed after death
	// also stalkers don't have proper animation for player death
	if ( ent.IsPlayer() || ent.IsNPC() )
	{
		// welp... we could also handle headshots manually
		//ent.WaitSignal( "OnDeath" )
		table results = WaitSignal( ent, "FakeModelProxyOwnerDeath" )
		// copied from sh_death_package.gnut
		int dpFlags = expect int( results.scriptType )
		if ( ( dpFlags & DF_HEADSHOT ) && IsHumanSized( ent ) && !ent.IsHologram() )
			TryHeadshotDeathFX( ent )
		HumanSizedGibDeath( ent )
	}
	else
		WaitForever()
}

void function GivesPlayerFakeModelProxy( entity player, asset modelName, string deathNPCClass = "npc_soldier" )
{
	if ( IsValid( file.entFakeModelProxy[ player ] ) )
		file.entFakeModelProxy[ player ].Destroy()
	file.entFakeModelProxy[ player ] = CreateModelProxyForEntity( player, modelName, deathNPCClass )
}

// just for fun
bool function CC_BecomeFakeBarker( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	BecomeFakeBarker( player )
	return true
}

void function BecomeFakeBarker( entity player )
{
	GivesPlayerFakeModelProxy( player, $"models/humans/heroes/mlt_hero_barker.mdl" )
}

bool function CC_BecomeFakeMarder( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	BecomeFakeMarder( player )
	return true
}

void function BecomeFakeMarder( entity player )
{
	GivesPlayerFakeModelProxy( player, $"models/humans/heroes/imc_hero_marder.mdl" )
}

bool function CC_BecomeFakeSpectre( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	BecomeFakeSpectre( player )
	return true
}

void function BecomeFakeSpectre( entity player )
{
	GivesPlayerFakeModelProxy( player, $"models/robots/spectre/imc_spectre.mdl", "npc_spectre" )
	// have to add effect
	// effects won't follow, which is fucked
	/*
	entity spectreProxy = file.entFakeModelProxy[ player ]
	entity eyeFXFriendly = StartParticleEffectOnEntity_ReturnEntity( spectreProxy, GetParticleSystemIndex( $"P_spectre_eye_friend" ), FX_PATTACH_POINT, spectreProxy.LookupAttachment( "EYEGLOW" ) )
	eyeFXFriendly.SetOwner( player )
	SetTeam( eyeFXFriendly, player.GetTeam() )
	eyeFXFriendly.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	entity eyeFXEnemy = StartParticleEffectOnEntity_ReturnEntity( spectreProxy, GetParticleSystemIndex( $"P_spectre_eye_foe" ), FX_PATTACH_POINT, spectreProxy.LookupAttachment( "EYEGLOW" ) )
	eyeFXEnemy.SetOwner( player )
	SetTeam( eyeFXEnemy, player.GetTeam() )
	eyeFXEnemy.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	*/
}

bool function CC_BecomeFakeStalker( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	BecomeFakeStalker( player )
	return true
}

void function BecomeFakeStalker( entity player )
{
	asset model = $"models/robots/stalker/robot_stalker.mdl" // default to use imc-style stalker: white one
	if ( player.GetTeam() == TEAM_MILITIA )
		model = $"models/robots/stalker/robot_stalker_red.mdl"
	GivesPlayerFakeModelProxy( player, model, "npc_stalker" )
	// have to add effect
	// effects won't follow, which is fucked
	/*
	entity stalkerProxy = file.entFakeModelProxy[ player ]
	entity eyeFXFriendly = StartParticleEffectOnEntity_ReturnEntity( stalkerProxy, GetParticleSystemIndex( $"P_stalker_eye_friend" ), FX_PATTACH_POINT, stalkerProxy.LookupAttachment( "FX_C_EYE" ) )
	eyeFXFriendly.SetOwner( player )
	SetTeam( eyeFXFriendly, player.GetTeam() )
	eyeFXFriendly.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
	entity eyeFXEnemy = StartParticleEffectOnEntity_ReturnEntity( stalkerProxy, GetParticleSystemIndex( $"P_stalker_eye_foe" ), FX_PATTACH_POINT, stalkerProxy.LookupAttachment( "FX_C_EYE" ) )
	eyeFXEnemy.SetOwner( player )
	SetTeam( eyeFXEnemy, player.GetTeam() )
	eyeFXEnemy.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	*/
}

bool function CC_BrainDead( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) && !file.clientCommandsEnabled )
		return false

	BrainDead( player )
	return true
}

// still no enough attachments to cover body
const array<string> BRAIN_DEAD_ATTACHMENTS = 
[
	//"OFFSET",
	//"REF",
	"HEADFOCUS",
	"HEADSHOT",
	//"CHESTFOCUS",
	//"PROPGUN",
	//"VDU",
	"L_HAND",
	"R_HAND",
	//"KNIFE",
	//"ORIGIN",
	//"SHIELD",
	"foot_L_sole",
	"foot_R_sole",
	//"FLAG",
	//"vent_right_back",
	//"vent_left_back",
	//"RIFLE_HOLSTER",
	//"ANTI_TITAN_HOLSTER",
	//"SIDEARM_HOLSTER",
	"vent_right",
	"vent_left",
	//"vent_right_out",
	//"vent_left_out",
	"vent_center",
	//"vent_center_out",
	//"BATTERY_ATTACH",
]

void function BrainDead( entity player )
{
	// drop existing brains
	player.Signal( "BrainDead" )

	// leave only a head first
	PlayerPulseBladeModel_HideBodyAndLegs( player )
	// change to wounded head
	player.SetBodygroup( player.FindBodyGroup( "head" ), 1 )

	// start attaching brains
	array<entity> brains
	foreach ( string attachment in BRAIN_DEAD_ATTACHMENTS )
	{
		entity brain = CreateHumanBrain( player.GetOrigin(), player.GetAngles() )
		brain.SetParent( player, attachment )
		brain.Highlight_SetInheritHighlight( true )
		brain.NotSolid() // to avoid blocking bullets
		brains.append( brain )
	}
	// one giant brain using "CHESTFOCUS"
	entity bodyBrain = CreateHumanBrain( player.GetOrigin(), player.GetAngles(), 4 )
	bodyBrain.SetParent( player, "CHESTFOCUS" )
	bodyBrain.Highlight_SetInheritHighlight( true )
	bodyBrain.SetOrigin( < 0, 0, -5 > ) // closer to body

	thread ManageBrainsLifeTime( player, brains )
	thread ManageBodyBrainLifeTime( player, bodyBrain )
}

void function ManageBrainsLifeTime( entity player, array<entity> brains )
{
	OnThreadEnd
	(
		function() : ( player, brains )
		{
			// make brains drop to ground
			vector velocity = Vector( 0, 0, 0 )
			if ( IsValid( player ) )
				velocity = player.GetVelocity()
			ArrayRemoveInvalid( brains )
			foreach ( entity brain in brains )
			{
				brain.ClearParent()
				brain.SetVelocity( velocity )
				thread DelayedPinkmistBrain( brain )
				brain.Solid() // start colliding with bullets
			}
			// ragdoll player immediately on death
			if ( IsValid( player ) && !IsAlive( player ) )
			{
				player.BecomeRagdoll( velocity, false )
				player.Gib( velocity )
			}
		}
	)

	WaitSignal( player, "OnDeath", "OnDestroy", "BrainDead" )
}

void function ManageBodyBrainLifeTime( entity player, entity brain )
{
	brain.EndSignal( "OnDestroy" )

	WaitSignal( player, "OnDeath", "OnDestroy", "BrainDead" )
	brain.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}

// similar function exists in nessie_debug.gnut, this one allowing us always spawn a brain
entity function CreateHumanBrain( vector origin, vector angles, float scale = 2.0 )
{
	entity prop_physics = CreateEntity( "prop_physics" )
	prop_physics.SetValueForModelKey( $"models/gibs/human_gibs.mdl" )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" ) // required to make finding bodygroup work
	prop_physics.kv.spawnflags = 4 // 4 = SF_PHYSPROP_DEBRIS
	prop_physics.kv.fadedist = 2000
	prop_physics.kv.renderamt = 255
	prop_physics.kv.rendercolor = "255 255 255"
	prop_physics.kv.CollisionGroup = TRACE_COLLISION_GROUP_DEBRIS

	// funny things
	int bodyGroupIndex = prop_physics.FindBodyGroup( "gibs" )
	/* 
		index
		studio "gib_lump_LOD0.smd"
		studio "gib_small_02_LOD0.smd"
		studio "gib_brain_LOD0.smd"
		studio "gib_muscle_LOD0.smd"
		studio "gib_small_01_LOD0.smd"
	*/
	prop_physics.SetBodygroup( bodyGroupIndex, 2 )

	prop_physics.kv.modelscale = scale // should be good enough?

	prop_physics.SetOrigin( origin )
	prop_physics.SetAngles( angles )
	DispatchSpawn( prop_physics )
	prop_physics.SetModel( $"models/gibs/human_gibs.mdl" )

	return prop_physics
}

void function DelayedPinkmistBrain( entity gib, float dissolveDelay = 8.0 ) // 8s is default force respawn delay
{
	gib.EndSignal( "OnDestroy" )

	wait dissolveDelay
	gib.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}