untyped // for handling IsCriticalHit_WithScriptedShieldCheck() untyped variables

// this is to fix respawn's weird client-side crash
// use in-file shield value for non-titan heavy armor target
// needs to replace all .GetShieldHealth(), .SetShieldHealth(), .GetShieldHealthMax() and .SetShieldHealthMax() method with fixed functions in this file

// IMPORTANT CONST! should adjust value based on different branch
const bool CLIENT_HAS_FIXED_SHIELD_CRASH = false // for NS, we need to use server-side shield effect to fix everything

global function Nessie_Shield_Crash_Fix_Init

global function SetShieldHealthWithFix
global function GetShieldHealthWithFix
global function SetShieldHealthMaxWithFix
global function GetShieldHealthMaxWithFix

// replacement func to handle native think
// prevents crits from happening on scripted shield entities
global function IsCriticalHit_WithScriptedShieldCheck
global function EntCanHaveShield

// effects from cl_player_common.gnut
const asset SHIELD_BODY_FX = $"P_xo_armor_body_CP"
const asset SHIELD_HIT_FX = $"P_xo_armor_impact"
// DEPRECATED
//const asset SHIELD_HIT_FX_VICTIM = $"impact_metal" // not working fine
//const asset SHIELD_HIT_FX_EXTRA = $"P_impact_xo_shield_cp"
const asset SHIELD_HIT_FX_EXP = $"P_xo_armor_impact_EXP" // played with explosive stuffs( those are safe and with 1+ explosionradius & explosion_damage )
const asset SHIELD_BREAK_FX = $"P_xo_armor_break_CP"

// main functioning array
const array<string> USE_SCRIPTED_SHIELD_CLASSES =
[
    "npc_super_spectre",
    "npc_stalker",
]

// below handles effects( hardcoded!!! )
// we get things from weapon/projectile's impact_effect_table settings. which means modifying it mid-way won't inflence this script!
const array<string> IMPACTS_EFFECT_DISABLED =
[
    "exp_arc_ball",
    "exp_arc_cannon",
    "exp_defender",
    "exp_laser_lite",
    "exp_monarch_beam_v1",
    "exp_monarch_beam_LG_v1",
    "exp_monarch_beam_v2",
    "exp_monarch_beam_LG_v2",
    "exp_small",
    "laser_core",
    "melee_prowler",
    "melee_spectre",
    "none",
    "titan_meteor",
]

const array<string> IMPACTS_SOUND_DISABLED =
[
    // actually this won't disable sound
    // it's just because in vanilla when mastiff hits a point blank there'll be too many sounds gets played together and causes sound drop
    //"bullet_mastiff"
]

// impact sound
const table<string, string> IMPACTS_SOUND_OVERRIDE =
{
    ["predator_bullet"]                 = "titanshield_heavy_bulletimpact",
    ["titan_bullet"]                    = "titanshield_heavy_bulletimpact",
    ["titan_shotgun_bullet"]            = "titanshield_heavy_bulletimpact",
    ["exp_super_spectre"]               = "titanshield_explo_plasmasmall_impact",
    ["titan_bullet_elec"]               = "titanshield_ampedxo16_bulletimpact",
    ["exp_plasma_lg"]                   = "titanshield_explo_plasmasmall_impact",
    ["melee_titan"]                     = "titanshield_meleeimpact",
    ["titan_sword"]                     = "titanshield_meleeimpact"
}

// some impact effect have different sound for attacker vs victim...
const table<string, string> IMPACTS_SOUND_OVERRIDE_1P =
{
    ["titan_particle_accelerator"]      = "titanshield_lstar_bulletimpact",
    ["lstar"]                           = "titanshield_lstar_bulletimpact",
}

const table<string, string> IMPACTS_SOUND_OVERRIDE_3P =
{
    ["titan_particle_accelerator"]      = "titanshield_ampedxo16_bulletimpact",
    ["lstar"]                           = "titanshield_ampedxo16_bulletimpact",
}

// there's only one PAINFUL thing: we can't get whether a damage is radius damage or not... maybe just ignore most grenade impacts...???
// direct hit check is their damage position <= 2hu of grenade position. but I think it's gonna broken when projectile having large bolt_hit_size... should've check that??? 
const array<string> GRENADE_SAFE_IMPACTS =
[
    "pulse_blade",
    "exp_softball_grenade",
    "exp_mgl",
    //"exp_frag_grenade", // maybe we do need to check their parent status??? but whatever who'll be so stupid to stand on a exploding frag grenade
    "exp_satchel",
]

// NO WAY TO GO HAVE TO HARDCODE
// still can't resolve anything -- 0 damage impact won't trigger callbacks, explosion damage > impact damage means we can't check things correctly
// best way is to hardcode inside their weapon files... which is something even worse
const array<string> WEAPONS_I_DONT_KNOW_HOW_TO_DEAL_WITH =
[
    "mp_weapon_mgl",
    "mp_weapon_softball",
    "mp_weapon_satchel", // cannot handle AT ALL, I guess
]

struct
{
    table<entity, int> entMaxShieldValue
    table<entity, int> entShieldValue

    // in-file tables
    table<entity, bool> entCritHiddenByThisScript
	table<entity, float> entNextShieldDamageSoundAllowedTime
    // unused
    /*
    table<entity, entity> entTargetShieldEffect
    table<entity, entity> entNeutralShieldEffect
    */
    table<entity, float> projectilesTriggeredShieldEffectTime // don't let same projectile trigger effect multiple times in same frame
} file

void function Nessie_Shield_Crash_Fix_Init()
{
    PrecacheParticleSystem( SHIELD_BODY_FX )
    PrecacheParticleSystem( SHIELD_HIT_FX )
    // DEPRECATED
    //PrecacheParticleSystem( SHIELD_HIT_FX_VICTIM )
    //PrecacheParticleSystem( SHIELD_HIT_FX_EXTRA )
    PrecacheParticleSystem( SHIELD_HIT_FX_EXP )
    PrecacheParticleSystem( SHIELD_BREAK_FX )

    // just for debugging in the same file
    /*
    PrecacheParticleSystem( $"impact_flesh_victim" ) 
    PrecacheParticleSystem( $"P_impact_flesh_attacker" )
    PrecacheParticleSystem( $"impact_flesh" )
    */

    // change effect to be handled by server
    // play in final damage callback because it's where shield health isn't modified yet
    foreach ( string className in USE_SCRIPTED_SHIELD_CLASSES )
    {
        AddDamageFinalCallback( className, OnScriptedShieldEntDamage )
        // modified callback in _codecallbacks_common.gnut, handles damage that failed to pass through
        // this is for us playing a fake shield impact effect and sound
        AddDamageFailedCallback( className, OnScriptedShieldEntDamageFailed )
    }
    // removes client-side effect and crit indicator
    // modified callback in _base_gametype.gnut
    AddCallback_PlayerDamageFeedback( ScriptedShieldPlayerFeedbackFix )
}

// replacement func to handle native think
// prevents crits from happening on scripted shield entities
// needs to be fully untyped so we can handle vanilla usages...
bool function IsCriticalHit_WithScriptedShieldCheck( attacker, victim, hitbox, damageAmount, damageTypes )
{
    expect entity( victim )
    bool victimHasShield = GetShieldHealthWithFix( victim ) > 0 && GetShieldHealthMaxWithFix( victim ) > 0
    return IsCriticalHit( attacker, victim, hitbox, damageAmount, damageTypes ) && !victimHasShield
}

void function OnScriptedShieldEntDamage( entity ent, var damageInfo )
{
    if ( IsPassThroughProjectileFriendlyFire( ent, damageInfo ) )
        return
    if ( DamageInfoProjectileLastFrameDidEffect( damageInfo ) )
        return

    // fix shield hit effect on scripted shield entity
    // can't fix impact effect and sound, those are native stuff
    // normally this effect is only played when player hits this entity
    // but we don't have impact effect, doing this for all players is good enough
    if ( !EntCanHaveShield( ent ) && GetShieldHealthWithFix( ent ) > 0 )
    {
        PlayShieldHitEffect_Server( ent, damageInfo )
        // shield hit sound is disabled on attacker, to avoid sound delay
        // actually works pretty fine! we can't handle everything as we want, doing a sound works really fine
        PlayShieldHitSound_Server( ent, damageInfo )
        // debugging
        //EmitSoundOnEntity( ent, "titanshield_light_bulletimpact_1p_vs_3p" )

        UpdateDamageInfoProjectileLastEffectTime( damageInfo )
    }
}

void function OnScriptedShieldEntDamageFailed( entity ent, var damageInfo )
{
    if ( IsPassThroughProjectileFriendlyFire( ent, damageInfo ) )
        return
    if ( DamageInfoProjectileLastFrameDidEffect( damageInfo ) )
        return

    if ( !EntCanHaveShield( ent ) && GetShieldHealthWithFix( ent ) > 0 )
    {
        PlayShieldHitEffect_Server( ent, damageInfo, true ) // we won't do shield health effect, only neutral one
        PlayShieldHitSound_Server( ent, damageInfo )

        UpdateDamageInfoProjectileLastEffectTime( damageInfo )
    }
}

// for projectile with pass_through_depth, we won't do effect on light armor friendly entities
bool function IsPassThroughProjectileFriendlyFire( entity ent, var damageInfo )
{
    if ( ent.GetArmorType() == ARMOR_TYPE_HEAVY )
        return false

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    if ( IsValid( attacker ) && attacker.GetTeam() == ent.GetTeam() )
    {
        entity inflictor = DamageInfo_GetInflictor( damageInfo )
        if ( IsValid( inflictor ) && inflictor.IsProjectile() )
        {
            if ( inflictor.GetProjectileWeaponSettingInt( eWeaponVar.pass_through_depth ) > 0 )
                return true
        }
    }

    return false
}

// don't let same projectile trigger effect multiple times in same frame
void function UpdateDamageInfoProjectileLastEffectTime( var damageInfo )
{
    entity inflictor = DamageInfo_GetInflictor( damageInfo )
    if ( IsValid( inflictor ) && inflictor.IsProjectile() )
    {
        if ( !( inflictor in file.projectilesTriggeredShieldEffectTime ) )
            file.projectilesTriggeredShieldEffectTime[ inflictor ] <- Time()
        else
            file.projectilesTriggeredShieldEffectTime[ inflictor ] = Time()
    }
}

bool function DamageInfoProjectileLastFrameDidEffect( var damageInfo )
{
    entity inflictor = DamageInfo_GetInflictor( damageInfo )
    if ( IsValid( inflictor ) && inflictor.IsProjectile() )
    {
        if ( ( inflictor in file.projectilesTriggeredShieldEffectTime ) && file.projectilesTriggeredShieldEffectTime[ inflictor ] == Time() )
            return true
    }
    return false
}

void function ScriptedShieldPlayerFeedbackFix( entity victim, var damageInfo, PlayerDamageFeedbackStruct feedbackStruct )
{
    if ( !EntCanHaveShield( victim ) )
    {
        bool victimHasShield = GetShieldHealthWithFix( victim ) > 0 && GetShieldHealthMaxWithFix( victim ) > 0
        // removes client-side effect and crit indicator
        if ( victimHasShield )
        {
            if ( feedbackStruct.customDamageType & DF_CRITICAL )
                feedbackStruct.customDamageType = feedbackStruct.customDamageType & ~DF_CRITICAL
            if ( feedbackStruct.customDamageType & DF_SHIELD_DAMAGE )
                feedbackStruct.customDamageType = feedbackStruct.customDamageType & ~DF_SHIELD_DAMAGE
        }
    }
}

void function InitFakeShieldValue( entity ent )
{
    if ( !EntCanHaveShield( ent ) )
    {
        if ( !( ent in file.entShieldValue ) )
        {
            file.entMaxShieldValue[ ent ] <- 0
            file.entShieldValue[ ent ] <- 0
        }
    }
}

// for non-titan heavy armor unit, use scripted shield health
bool function EntCanHaveShield( entity ent )
{
    // if our client has been fixed, no need to use scripted shield value
    #if CLIENT_HAS_FIXED_SHIELD_CRASH
        return true
    #endif

    string className = ent.GetClassName()
    if ( USE_SCRIPTED_SHIELD_CLASSES.contains( className ) )
        return false

    return true
}

bool function EntCritHidden( entity ent )
{
    // script handle
    if ( "critHiddenByScript" in ent.s )
        return true

    int bodyGroupIndex = ent.FindBodyGroup( "hitpoints" )

	if ( bodyGroupIndex == -1 )
		return false

	return ent.GetBodyGroupState( bodyGroupIndex ) == 1
}

void function SetShieldHealthWithFix( entity ent, var targetShield )
{
    InitFakeShieldValue( ent )

    // shield value before updating
    int oldShieldValue = GetShieldHealthWithFix( ent )
    // type casting
    int intShieldValue = typeof( targetShield ) == "int" ? expect int( targetShield ) : int( targetShield )

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
    {
        file.entShieldValue[ ent ] = intShieldValue
        // due we can't make client-side get shield they left
        // try to hide on server-side
        if ( intShieldValue > 0 && GetShieldHealthMaxWithFix( ent ) > 0 )
        {
            //print( "trying to hide crit for entity..." )
            if ( !EntCritHidden( ent ) )
            {
                //print( "crit hidden!" )
                HideCrit( ent )
                file.entCritHiddenByThisScript[ ent ] <- true
            }
        }
        else
        {
            //print( "trying to show crit for entity..." )
            if ( ent in file.entCritHiddenByThisScript ) // only recover crit for those getting hidden by this file
            {
                //print( "crit shown!" )
                ShowCrit( ent )
                delete file.entCritHiddenByThisScript[ ent ]
            }
        }

        // fake effect: shield up / shield down
        int maxShieldValue = GetShieldHealthMaxWithFix( ent )
        if ( GetShieldHealthMaxWithFix( ent ) > 0 )
        {
            // behavior from cl_code_callbacks_mp.gnut
            if ( maxShieldValue > 0 )
            {
                if ( oldShieldValue > 0 && intShieldValue <= 0 )
                    PlayShieldBreakEffect_Server( ent )
                else if ( oldShieldValue != maxShieldValue && intShieldValue == maxShieldValue )
                    PlayShieldActivateEffect_Server( ent )
            }
        }
    }
    else // otherwise we use vanilla behavior
        ent.SetShieldHealth( intShieldValue )
}

int function GetShieldHealthWithFix( entity ent )
{
    InitFakeShieldValue( ent )

    // if entity has no max shield, don't do anything
    if ( GetShieldHealthMaxWithFix( ent ) <= 0 )
        return 0

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
        return file.entShieldValue[ ent ]
  
    // safe to use vanilla behavior
    return ent.GetShieldHealth()
}

void function SetShieldHealthMaxWithFix( entity ent, var targetMaxShield )
{
    InitFakeShieldValue( ent )

    // type casting
    int intShieldValue = typeof( targetMaxShield ) == "int" ? expect int( targetMaxShield ) : int( targetMaxShield )

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
    {
        file.entMaxShieldValue[ ent ] = intShieldValue
        // due we can't make client-side get shield they left
        // try to hide on server-side
        if ( intShieldValue > 0 && GetShieldHealthWithFix( ent ) > 0 )
        {
            //print( "trying to hide crit for entity..." )
            if ( !EntCritHidden( ent ) )
            {
                //print( "crit hidden!" )
                HideCrit( ent )
                file.entCritHiddenByThisScript[ ent ] <- true
            }
        }
        else
        {
            //print( "trying to show crit for entity..." )
            if ( ent in file.entCritHiddenByThisScript ) // only recover crit for those getting hidden by this file
            {
                //print( "crit shown!" )
                ShowCrit( ent )
                delete file.entCritHiddenByThisScript[ ent ]
            }
        }
    }
    else // otherwise we use vanilla behavior
        ent.SetShieldHealthMax( intShieldValue )
}

int function GetShieldHealthMaxWithFix( entity ent )
{
    InitFakeShieldValue( ent )

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
        return file.entMaxShieldValue[ ent ]
  
    // safe to use vanilla behavior
    return ent.GetShieldHealthMax()
}

// shared utility for following functions to use
// hope it's gonna working fine...
bool function ProjectileIsDirectHit( entity projectile, entity victim, var damageInfo )
{
    // distance check version -- with bolt hitsize thinks
    /*
    vector hitPos = DamageInfo_GetDamagePosition( damageInfo )
    float directHitDist = 2 // hits closer than 2hu is considered as direct hit

    // bolt specific hitsize
    if ( projectile.GetClassName() == "crossbow_bolt" )
    {
        float creationTime = projectile.GetProjectileCreationTime()
        float boltHitSize = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize )
        float firstSizeGrowTime = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize_grow1_time )
        if ( firstSizeGrowTime > 0 )
        {
            float growTime = min( Time() - creationTime, firstSizeGrowTime )
            float sizeAfterGrow = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize_grow1_size )
            float maxGrowSize = sizeAfterGrow - boltHitSize
            boltHitSize += maxGrowSize * ( growTime / firstSizeGrowTime )
        }
        float secondSizeGrowTime = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize_grow2_time )
        if ( secondSizeGrowTime > 0 )
        {
            float growTime = min( Time() - creationTime, secondSizeGrowTime )
            float sizeAfterGrow = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize_grow2_size )
            float maxGrowSize = sizeAfterGrow - boltHitSize
            boltHitSize += maxGrowSize * ( growTime / secondSizeGrowTime )
        }
        float finalSizeGrowTime = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize_growfinal_lerptime )
        if ( finalSizeGrowTime > 0 )
        {
            float growTime = min( Time() - creationTime, finalSizeGrowTime )
            float sizeAfterGrow = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.bolt_hitsize_growfinal_size )
            float maxGrowSize = sizeAfterGrow - boltHitSize
            boltHitSize += maxGrowSize * ( growTime / finalSizeGrowTime )
        }
        // guess we should add hitsize to check bolt hits... or maybe checking damage value???
        directHitDist += boltHitSize
    }

    if ( Distance( projectile.GetOrigin(), hitPos ) <= directHitDist )
        return true
    */

    // damage value check version
    int explosionDamage = projectile.GetProjectileWeaponSettingInt( eWeaponVar.explosion_damage )
    float explosionRaidius = projectile.GetProjectileWeaponSettingFloat( eWeaponVar.explosionradius )
    // if our projectile don't have any explosion damage... any damage they dealt should be direct hit
    if ( explosionDamage <= 0 || explosionRaidius <= 0 )
        return true
    
    // update explosion damage after initial checks
    if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
        explosionDamage = projectile.GetProjectileWeaponSettingInt( eWeaponVar.explosion_damage_heavy_armor )
    
    // most explosive weapons won't have damage falloff, should be safe to think like this
    // this won't work... projectile's damage position IS their origin, thus distance will always be 0
    /*
    int directHitDamage = projectile.GetProjectileWeaponSettingInt( eWeaponVar.damage_near_value )
    if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
        directHitDamage = projectile.GetProjectileWeaponSettingInt( eWeaponVar.damage_near_value_titanarmor )
    // very low / no damage on direct hit!! should be ordnance, softball & mgl stuffs...
    if ( directHitDamage < explosionDamage )
    {
        // consider checking distance
        // idk whether grenade's hitsize is greater than 2hu... needs debugging
        float projectileDist = Distance( DamageInfo_GetDamagePosition( damageInfo ), projectile.GetOrigin() )
        //print( "projectile distance between actual damage position: " + string( projectileDist ) )
        if ( projectileDist <= 2 )
            return true
    }
    else // most grenadier weapon case
    {
        // checking damage report
        if ( DamageInfo_GetDamage( damageInfo ) >= directHitDamage )
            return true
    }
    */

    // checking damage report. can't handle the case where direct hit damage is lower than explosions( softball and mgl stuffs... fuck it )
    int directHitDamage = projectile.GetProjectileWeaponSettingInt( eWeaponVar.damage_near_value )
    if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
        directHitDamage = projectile.GetProjectileWeaponSettingInt( eWeaponVar.damage_near_value_titanarmor )
    if ( directHitDamage > explosionDamage )
    {
        if ( DamageInfo_GetDamage( damageInfo ) >= directHitDamage )
            return true
    }
    // or there's some hardcoded case where impact damage is lower than explosion damage
    string weaponName = projectile.ProjectileGetWeaponClassName()
    if ( WEAPONS_I_DONT_KNOW_HOW_TO_DEAL_WITH.contains( weaponName ) )
    {
        // may trigger effect incorrectly if damage is equal to direct hit one but... what the hell
        if ( DamageInfo_GetDamage( damageInfo ) == directHitDamage )
            return true
    }

    return false
}

// with all the things we mess up with projectile, this one should be much easier
bool function WeaponIsDirectHit( entity weapon, entity victim, var damageInfo )
{
    // damage value check version
    int explosionDamage = weapon.GetWeaponSettingInt( eWeaponVar.explosion_damage )
    float explosionRaidius = weapon.GetWeaponSettingFloat( eWeaponVar.explosionradius )
    // if our weapon don't have any explosion damage... any damage they dealt should be direct hit
    if ( explosionDamage <= 0 || explosionRaidius <= 0 )
        return true

    // update explosion damage after initial checks
    if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
        explosionDamage = weapon.GetWeaponSettingInt( eWeaponVar.explosion_damage_heavy_armor )

    // checking damage report. can't handle the case where direct hit damage is lower than explosions
    int directHitDamage = weapon.GetWeaponSettingInt( eWeaponVar.damage_near_value )
    if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
        directHitDamage = weapon.GetWeaponSettingInt( eWeaponVar.damage_near_value_titanarmor )
    if ( directHitDamage > explosionDamage )
    {
        if ( DamageInfo_GetDamage( damageInfo ) >= directHitDamage )
            return true
    }

    return false
}

// effects taken from cl_player.gnut
void function PlayShieldHitEffect_Server( entity ent, var damageInfo, bool neutralEffect = false )
{
    // MANY VALIDATION CHECKS goes here
    entity weapon = DamageInfo_GetWeapon( damageInfo )
    entity inflictor = DamageInfo_GetInflictor( damageInfo )
    //print( "weapon: " + string( weapon ) )
    //print( "inflictor: " + string( inflictor ) )

    // too bad we don't have anything valid
    if ( !IsValid( weapon ) && !IsValid( inflictor ) )
        return

    int damageTypes = DamageInfo_GetCustomDamageType( damageInfo )
    bool isMeleeHit = bool( damageTypes & DF_MELEE )
    // we don't do projectile checks as long as weapon is valid
    // also needs to handle melee -- that case no need to check all these
    if ( !isMeleeHit )
    {
        if ( !IsValid( weapon ) )
        {
            if ( IsValid( inflictor ) )
            {
                // inflictor will be weapon entity for shotgun blast case
                // EDIT: shotgun blast can still get weapon themselves, inflictor case is for hitscan weapon splash damage
                if ( !inflictor.IsProjectile() && !(inflictor instanceof CWeaponX) )
                    return
            }
        }
    }

    int shieldbodyFX = GetParticleSystemIndex( SHIELD_BODY_FX )
	int attachID
	if ( ent.IsTitan() )
		attachID = ent.LookupAttachment( "exp_torso_main" )
	else
		attachID = ent.LookupAttachment( "ref" ) // TEMP

    // white shield: play to others to fake shield hit effects( WIP ). also gets played if damage failed to pass through
    // don't need anymore
    /*
    entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( ent, shieldbodyFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, < 1, 1, 1 > )
    */
    entity shieldFXHandle

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    if ( IsValid( attacker ) )
    {
        // maybe also try shield hit effect
        // only do when inflictor is weapon
        // turns out that projectile can also do effects. check needs to handle that
        /*
        entity inflictor = DamageInfo_GetInflictor( damageInfo )
        entity weapon = DamageInfo_GetWeapon( damageInfo )
        if ( IsValid( weapon ) )
            inflictor = weapon
        if ( IsValid( inflictor ) && (inflictor instanceof CWeaponX) )
        {
        */

            // shield hit effect only gets played when hitting direct hits
            bool isDirectHit
            bool effectDisabled = false
            if ( !isMeleeHit )
            {
                // we don't do projectile checks as long as weapon is valid
                if ( IsValid( weapon ) )
                    isDirectHit = WeaponIsDirectHit( weapon, ent, damageInfo )
                else
                {
                    if ( IsValid( inflictor ) && inflictor.IsProjectile() )
                        isDirectHit = ProjectileIsDirectHit( inflictor, ent, damageInfo )
                }
            }

            // SOFTBALL HARDCODE: no impact effect on enemy entities???
            // WHY I MEAN JUST, WHY??? why sometimes vanilla softball has enemy impact effect and sometimes it doesn't
            // I'M DONE WITH THIS
            /*
            if ( IsValid( inflictor ) && inflictor.IsProjectile() && inflictor.ProjectileGetWeaponClassName() == "mp_weapon_softball" )
            {
                if ( attacker.GetTeam() != ent.GetTeam() && !FriendlyFire_IsEnabled() )
                    effectDisabled = true
            }
            */
            //

            if ( ( isMeleeHit || isDirectHit ) && !effectDisabled )
            {
                // we may wants to hide effect
                string impactEffectName
                if ( !isMeleeHit )
                {
                    if ( IsValid( weapon ) )
                        impactEffectName = GetImpactTableNameFromWeaponOrProjectile( weapon ) // shared utility from _unpredicted_impact_fix.gnut
                    else if ( IsValid( inflictor ) && inflictor.IsProjectile() )
                        impactEffectName = GetImpactTableNameFromWeaponOrProjectile( inflictor )
                }

                bool hideShieldHitFX = IMPACTS_EFFECT_DISABLED.contains( impactEffectName )
                // melee hit checks
                if ( isMeleeHit )
                {
                    entity meleeWeapon = attacker.GetOffhandWeapon( OFFHAND_MELEE )
                    if ( !IsValid( meleeWeapon ) )
                        hideShieldHitFX = true
                    else
                    {
                        impactEffectName = GetImpactTableNameFromWeaponOrProjectile( meleeWeapon )
                        hideShieldHitFX = IMPACTS_EFFECT_DISABLED.contains( impactEffectName )
                    }
                }
                else
                {
                    // grenade specific checks
                    if ( IsValid( inflictor ) && inflictor.IsProjectile() && inflictor.GetClassName() == "grenade" )
                        hideShieldHitFX = !GRENADE_SAFE_IMPACTS.contains( impactEffectName )
                }

                if ( !hideShieldHitFX )
                {
                    int shieldHitFX = GetParticleSystemIndex( SHIELD_HIT_FX )
                    if ( damageTypes & DF_EXPLOSION ) // explosion damage specific
                        shieldHitFX = GetParticleSystemIndex( SHIELD_HIT_FX_EXP )
                    
                    vector pos = DamageInfo_GetDamagePosition( damageInfo )
                    // maybe we could trace attacker
                    /*
                    vector entPos = ent.GetOrigin()
                    vector entEyePos = ent.EyePosition()
                    float entCenterDot = ( entEyePos.z + entPos.z ) / 2
                    vector entCenterPos = < entPos.x, entPos.y, entCenterDot >
                    vector victimFacePos = VectorToAngles( Normalize( entCenterPos - pos ) )
                    */

                    // eyepos -> hitpos seems to be better... idk... needs debugging
                    //vector victimFacePos = VectorToAngles( Normalize( pos - attacker.EyePosition() ) )
                    vector victimFacePos = VectorToAngles( Normalize( attacker.EyePosition() - pos ) )

                    // control point won't work
                    /*
                    entity shieldHitFXHandle = StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos )
                    //EffectSetControlPointVector( shieldHitFXHandle, 0, < 115, 247, 255 > ) // this hides the effect idk
                    EffectSetControlPointVector( shieldHitFXHandle, 1, < 115, 247, 255 > ) // blue
                    */
                    
                    // wth this works
                    StartParticleEffectInWorldWithControlPoint( shieldHitFX, pos, victimFacePos, < 115, 247, 255 > )

                    // bad effect
                    /*
                    int shieldHitFXVictim = GetParticleSystemIndex( SHIELD_HIT_FX_VICTIM )
                    StartParticleEffectOnEntity_ReturnEntity( ent, shieldHitFXVictim, FX_PATTACH_POINT_FOLLOW, attachID )
                    */
                    //SHIELD_HIT_FX_EXTRA

                    // debugging for fun
                    // still can't get correct blood spray effect
                    /*
                    shieldHitFX = GetParticleSystemIndex( $"P_impact_flesh_attacker" )
                    EffectSetControlPointVector( StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos ), 1, < 255, 255, 255 > )
                    shieldHitFX = GetParticleSystemIndex( $"impact_flesh" )
                    StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos )
                    StartParticleEffectInWorldWithControlPoint( GetParticleSystemIndex( $"impact_flesh" ), pos, victimFacePos, < 255, 255, 255 > )
                    StartParticleEffectInWorldWithControlPoint( GetParticleSystemIndex( $"P_impact_flesh_attacker" ), pos, victimFacePos, < 255, 255, 255 > )
                    */

                    // extra effect
                    // does not work
                    /*
                    shieldHitFX = GetParticleSystemIndex( SHIELD_HIT_FX_EXTRA )
                    entity shieldHitFXHandle = StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos )
                    EffectSetControlPointVector( shieldHitFXHandle, 0, < 115, 247, 255 > ) // blue
                    */

                    // still can't control CP
                    /*
                    entity shieldHitFXHandle = StartParticleEffectOnEntity_ReturnEntity( ent, shieldHitFX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "CHESTFOCUS" ) )
                    EffectSetControlPointVector( shieldHitFXHandle, 1, < 115, 247, 255 > ) // blue
                    */
                }
            }

        /*
        }
        */

        // colored shield: only play to player attacker
        if ( !neutralEffect && attacker.IsPlayer() )
        {
            float shieldHealthFrac = GetShieldHealthFrac( ent )

            shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( ent, shieldbodyFX, FX_PATTACH_POINT_FOLLOW, attachID )
            EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
            // TO OWNER ONLY
            shieldFXHandle.SetOwner( attacker )
            shieldFXHandle.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
        }
    }
}

const table SHIELD_COLOR_CHARGE_FULL = { r = 115, g = 247, b = 255 }    // blue
const table SHIELD_COLOR_CHARGE_MED  = { r = 200, g = 128, b = 80 } // orange
const table SHIELD_COLOR_CHARGE_EMPTY = { r = 200, g = 80, b = 80 } // red

const SHIELD_COLOR_CROSSOVERFRAC_FULL2MED    = 0.75  // from zero to this fraction, fade between full and medium charge colors
const SHIELD_COLOR_CROSSOVERFRAC_MED2EMPTY    = 0.95  // from "full2med" to this fraction, fade between medium and empty charge colors

function GetShieldEffectCurrentColor( shieldHealthFrac )
{
	local color1 = SHIELD_COLOR_CHARGE_FULL
	local color2 = SHIELD_COLOR_CHARGE_MED
	local color3 = SHIELD_COLOR_CHARGE_EMPTY

	local crossover1 = SHIELD_COLOR_CROSSOVERFRAC_FULL2MED  // from zero to this fraction, fade between color1 and color2
	local crossover2 = SHIELD_COLOR_CROSSOVERFRAC_MED2EMPTY  // from crossover1 to this fraction, fade between color2 and color3

	local colorVec = < 0, 0, 0 >
	// 0 = full charge, 1 = no charge remaining
	if ( shieldHealthFrac < crossover1 )
	{
		colorVec.x = Graph( shieldHealthFrac, 0, crossover1, color1.r, color2.r )
		colorVec.y = Graph( shieldHealthFrac, 0, crossover1, color1.g, color2.g )
		colorVec.z = Graph( shieldHealthFrac, 0, crossover1, color1.b, color2.b )
	}
	else if ( shieldHealthFrac < crossover2 )
	{
		colorVec.x = Graph( shieldHealthFrac, crossover1, crossover2, color2.r, color3.r )
		colorVec.y = Graph( shieldHealthFrac, crossover1, crossover2, color2.g, color3.g )
		colorVec.z = Graph( shieldHealthFrac, crossover1, crossover2, color2.b, color3.b )
	}
	else
	{
		// for the last bit of overload timer, keep it max danger color
		colorVec.x = color3.r
		colorVec.y = color3.g
		colorVec.z = color3.b
	}

	return colorVec
}

// keep similar as _health_regen.gnut does
// not all damage works fine with sound
// all the sound has "_1p_vs_3p", "_3p_vs_1p" and "_3p_vs_3p" suffix for us to use
const string SHIELD_DAMAGE_SOUND_PREFIX = "titanshield_light_bulletimpact" // sound when getting hit by bullets( sadly "titanshield_heavy_bulletimpact_3p_vs_1p" sounds identical to light impact one )
//const string SHIELD_DAMAGE_SOUND_PREFIX_HEAVY = "titanshield_heavy_bulletimpact"

// only bullet damage plays the sound every time, other damage types have a sound interval because we can't ignore radius damage like native does
// btw it seems that projectile impacts mostly won't do shield effect... guess we could handle only hitscan weapons?
const string SHIELD_DAMAGE_SOUND_PREFIX_EXPLOSION = "titanshield_explosive_bulletimpact" // sound when getting hit by explosive damage
const string SHIELD_DAMAGE_SOUND_PREFIX_ELECTRICAL = "titanshield_energy_bulletimpact" // sound when getting hit by electrical damage
// no special sound for human melee actually. titans handled by overrides
//const string SHIELD_DAMAGE_SOUND_PREFIX_MELEE = "titanshield_meleeimpact" // sound when getting hit by melee

// SPECIAL: titan bullet impact sound
// welp maybe it should be handled by IMPACTS_SOUND_OVERRIDE stuffs...
//const string SHIELD_DAMAGE_SOUND_PREFIX_TITAN = "titanshield_heavy_bulletimpact"

// no need to add interval after we manually handle many things
/*
const float SHIELD_DAMAGE_SOUND_INTERVAL_MIN = 0.4 // prevent sound spaming
const float SHIELD_DAMAGE_SOUND_INTERVAL_MAX = 0.5
*/

// FULLY REWORKED
/*
void function PlayShieldHitSound_Server( entity ent, var damageInfo )
{
    InitShieldSoundVars( ent )

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    // shield on-hit sound
	int damageTypes = DamageInfo_GetCustomDamageType( damageInfo )
	string shieldHitSound = GetShieldDamagedSound( damageTypes )
    // only bullet damage plays the sound every time, other damage types have a sound interval because we can't ignore radius damage like native does
    // only do when inflictor is weapon
    entity inflictor = DamageInfo_GetInflictor( damageInfo )
    entity weapon = DamageInfo_GetWeapon( damageInfo )
    if ( IsValid( weapon ) )
        inflictor = weapon
    if ( IsValid( inflictor ) && (inflictor instanceof CWeaponX) )
    {
        if ( shieldHitSound == SHIELD_DAMAGE_SOUND_PREFIX || shieldHitSound == SHIELD_DAMAGE_SOUND_PREFIX_HEAVY )
            ShieldHitSoundByType( ent, attacker, shieldHitSound )
        else 
        {
            if ( Time() > file.entNextShieldDamageSoundAllowedTime[ ent ] )
            {
                ShieldHitSoundByType( ent, attacker, shieldHitSound )
                // add sound cooldown
                float nextSoundInterval = RandomFloatRange( SHIELD_DAMAGE_SOUND_INTERVAL_MIN, SHIELD_DAMAGE_SOUND_INTERVAL_MAX )
                file.entNextShieldDamageSoundAllowedTime[ ent ] = Time() + nextSoundInterval
            }
            //else
            //	print( "player still in shield damage sound cooldown!" )
        }
    }
}
*/

void function PlayShieldHitSound_Server( entity ent, var damageInfo )
{
    // MANY VALIDATION CHECKS goes here
    entity weapon = DamageInfo_GetWeapon( damageInfo )
    entity inflictor = DamageInfo_GetInflictor( damageInfo )

    // too bad we don't have anything valid
    if ( !IsValid( weapon ) && !IsValid( inflictor ) )
        return

    int damageTypes = DamageInfo_GetCustomDamageType( damageInfo )
    bool isMeleeHit = bool( damageTypes & DF_MELEE )
    // we don't do projectile checks as long as weapon is valid
    // actually the case is... hit scan weapon splash damage won't pass their weapon inside
    // but they'll always be inflictor so no worries?
    // also needs to handle melee -- that case no need to check all these
    if ( !isMeleeHit )
    {
        if ( IsValid( weapon ) )
        {
            if ( !WeaponIsDirectHit( weapon, ent, damageInfo ) )
                return
        }
        else
        {
            if ( IsValid( inflictor ) )
            {
                // inflictor will be weapon entity for shotgun blast case
                // no need. inflictor will always be weapon, and shotgun blast also pass themselves as "weapon" not other things
                //if ( !inflictor.IsProjectile() && !(inflictor instanceof CWeaponX) )
                if ( !inflictor.IsProjectile() )
                    return
                
                // projectile checks
                if ( inflictor.IsProjectile() )
                {
                    if ( !ProjectileIsDirectHit( inflictor, ent, damageInfo ) )
                        return
                }
            }
        }
    }

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    // SOFTBALL HARDCODE: no impact effect on enemy entities???
    // WHY I MEAN JUST, WHY??? why sometimes vanilla softball has enemy impact effect and sometimes it doesn't
    // I'M DONE WITH THIS
    /*
    if ( IsValid( inflictor ) && inflictor.IsProjectile() && inflictor.ProjectileGetWeaponClassName() == "mp_weapon_softball" )
    {
        if ( !IsValid( attacker ) )
            return
        if ( attacker.GetTeam() != ent.GetTeam() && !FriendlyFire_IsEnabled() )
            return
    }
    */
    //

    // get impact effect name for us checking more stuffs
    string impactEffectName
    if ( isMeleeHit )
    {
        if ( !IsValid( attacker ) )
            return
        // melee weapon checks. if we can't find any melee weapon could just return
        entity meleeWeapon = attacker.GetOffhandWeapon( OFFHAND_MELEE )
        if ( !IsValid( meleeWeapon ) )
            return

        impactEffectName = GetImpactTableNameFromWeaponOrProjectile( meleeWeapon )
    }
    else
    {
        if ( IsValid( weapon ) )
            impactEffectName = GetImpactTableNameFromWeaponOrProjectile( weapon ) // shared utility from _unpredicted_impact_fix.gnut
        else if ( IsValid( inflictor ) && inflictor.IsProjectile() )
            impactEffectName = GetImpactTableNameFromWeaponOrProjectile( inflictor )
        
        // grenade specific checks
        if ( IsValid( inflictor ) && inflictor.IsProjectile() && inflictor.GetClassName() == "grenade" )
        {
            if ( !GRENADE_SAFE_IMPACTS.contains( impactEffectName ) )
                return
        }
    }

    // some impacts don't have sound
    if ( IMPACTS_SOUND_DISABLED.contains( impactEffectName ) )
        return

    // default shield on-hit sound
	string shieldHitSound = GetShieldDamagedSound( damageTypes )
    // overrides
    if ( impactEffectName in IMPACTS_SOUND_OVERRIDE )
        shieldHitSound = IMPACTS_SOUND_OVERRIDE[ impactEffectName ]
    // 1p/3p different sound
    string fpSoundOverride
    string tpSoundOverride
    if ( impactEffectName in IMPACTS_SOUND_OVERRIDE_1P )
        fpSoundOverride = IMPACTS_SOUND_OVERRIDE_1P[ impactEffectName ]
    if ( impactEffectName in IMPACTS_SOUND_OVERRIDE_3P )
        tpSoundOverride = IMPACTS_SOUND_OVERRIDE_3P[ impactEffectName ]

    // all checks passed... I think?
    ShieldHitSoundByType( ent, DamageInfo_GetAttacker( damageInfo ), shieldHitSound, fpSoundOverride, tpSoundOverride )
}

// we do have a example on how to handle impact sound from serverside for player victim, in mp_projectile_titanweapon_triplethreat.gnut
// in this file we just don't need to, because only npcs can have bad shield behaviors
void function ShieldHitSoundByType( entity ent, entity attacker, string soundPrefix, string fpSoundOverride = "", string tpSoundOverride = "" )
{
    string fpSound = soundPrefix + "_1p_vs_3p"
    string tpSound = soundPrefix + "_3p_vs_3p"
    if ( fpSoundOverride != "" )
        fpSound = fpSoundOverride + "_1p_vs_3p"
    if ( tpSoundOverride != "" )
        tpSound = tpSoundOverride + "_3p_vs_3p"
    // attacker sound
    if ( IsValid( attacker ) && attacker.IsPlayer() )
    {
        EmitSoundOnEntityOnlyToPlayer( ent, attacker, fpSound )
        EmitSoundOnEntityExceptToPlayer( ent, attacker, tpSound )
    }
    else // netual sound
        EmitSoundOnEntity( ent, tpSound )
}

string function GetShieldDamagedSound( int damageTypes )
{
	string shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX // default sound

    // this may not very necessary though... should've handled by overrides
    /*
    if ( damageTypes & DF_KNOCK_BACK )
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_HEAVY
    */
    
	if ( damageTypes & DF_EXPLOSION ) // explosion damage specific sound, overrides bullets
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_EXPLOSION
	if ( damageTypes & DF_ELECTRICAL ) // electrical damage specific sound, overrides explosion and bullets
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_ELECTRICAL

    // no special sound for human melee actually. titans handled by overrides
    /*
	if ( damageTypes & DF_MELEE ) // melee damage specific sound, has highest priority
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_MELEE
    */

	//print( "shieldHitSound: " + shieldHitSound )
	return shieldHitSound
}

void function InitShieldSoundVars( entity ent )
{
    if ( !( ent in file.entNextShieldDamageSoundAllowedTime ) )
        file.entNextShieldDamageSoundAllowedTime[ ent ] <- 0.0
}

void function PlayShieldBreakEffect_Server( entity ent )
{
	entity shieldEnt = ent
	if ( IsSoul( ent ) )
	{
		shieldEnt = ent.GetTitan()
		if ( !shieldEnt )
			return
	}

	float shieldHealthFrac = GetShieldHealthFrac( shieldEnt )

	int shieldBreakFX = GetParticleSystemIndex( SHIELD_BREAK_FX )
	int attachID
	if ( shieldEnt.IsTitan() )
		attachID = shieldEnt.LookupAttachment( "exp_torso_main" )
	else
		attachID = shieldEnt.LookupAttachment( "ref" ) // TEMP

	entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( shieldEnt, shieldBreakFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
}

void function PlayShieldActivateEffect_Server( entity ent )
{
    // so... actually we do need check their spawn time because on client-side we can't recognize shield value on newly spawned entities
    float timeSinceEntSpawned = 0
    if ( ent.IsPlayer() ) // player
        timeSinceEntSpawned = Time() - GetPlayerLastRespawnTime( ent )
    else if ( ent.IsNPC() ) // npc
        timeSinceEntSpawned = Time() - ent.ai.spawnTime

    //print( "timeSinceEntSpawned: " + string( timeSinceEntSpawned ) )
    if ( timeSinceEntSpawned <= 0.2 ) // handles first 2 server frames to simulate client-side sync
    {
        //print( "not playing any shield effect!" )
        return
    }

	entity shieldEnt = ent
	if ( IsSoul( ent ) )
	{
		shieldEnt = ent.GetTitan()
		if ( !shieldEnt )
			return
	}

	float shieldHealthFrac = GetShieldHealthFrac( shieldEnt )

	int shieldBreakFX = GetParticleSystemIndex( SHIELD_BREAK_FX )
	int attachID
	if ( shieldEnt.IsTitan() )
		attachID = shieldEnt.LookupAttachment( "exp_torso_main" )
	else
		attachID = shieldEnt.LookupAttachment( "ref" ) // TEMP

	entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( shieldEnt, shieldBreakFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
}