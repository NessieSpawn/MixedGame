untyped

global function AiGunship_Init

global function GunshipThink

// don't know why are these stuffs globalized
global const SOUND_GUNSHIP_HOVER = "Gunship_Hover"
global const SOUND_GUNSHIP_EXPLODE_DEFAULT = "Goblin_Dropship_Explode" // "Gunship_Explode" is not added to TF2
global const FX_GUNSHIP_EXPLOSION = $"P_veh_exp_hornet" // was $"P_veh_exp_crow"

const bool ENABLE_GUNSHIP_DAMAGE_EFFECT = false // damaged effect now replaced with health effects
const FX_GUNSHIP_DAMAGE =  $"veh_gunship_damage_FULL" // taken from _vehicle_dropship_new.nut. why it isn't added for gunships?
const float GUNSHIP_RECENT_DAMAGE_STORE_TIME = 2.0 // we only store damage withing this time since last hit
const GUNSHIP_HEAVY_DAMAGE_THRESHOLD = 0.05 // when gunship takes a damage that is higher than this percentage of it's max health, we play FX_GUNSHIP_DAMAGE for them
const GUNSHIP_REPEAT_DAMAGE_THRESHOLD = 0.125 // when gunship takes repeatly damage within 1s that is higher than this percentage of it's max health, we play FX_GUNSHIP_DAMAGE for them


const bool ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT = true

/*
	// from cl_gunship.nut, it has some model data that we might can do them on serverside
		ModelFX_AddTagHealthFX( 0.80, "L_exhaust_front_1", $"P_impact_exp_frag_air", true )
		ModelFX_AddTagHealthFX( 0.75, "R_exhaust_front_1", $"P_impact_exp_frag_air", true )
		ModelFX_AddTagHealthFX( 0.50, "L_exhaust_front_1", $"P_impact_exp_frag_air", true )
		ModelFX_AddTagHealthFX( 0.25, "R_exhaust_front_1", $"P_impact_exp_frag_air", true )

		ModelFX_AddTagHealthFX( 0.75, "L_exhaust_rear_1", $"xo_health_smoke_white", false )
		ModelFX_AddTagHealthFX( 0.50, "L_exhaust_rear_1", $"xo_health_smoke_black", false )
		ModelFX_AddTagHealthFX( 0.25, "R_exhaust_rear_1", $"xo_health_smoke_black", false )

	// from cl_goblin_dropship.nut, it has some model data that we might can do them on serverside
		ModelFX_AddTagHealthFX( 0.80, "L_exhaust_rear_1", $"xo_health_smoke_white", false )
		ModelFX_AddTagHealthFX( 0.60, "R_exhaust_rear_2", $"xo_health_smoke_white", false )
		ModelFX_AddTagHealthFX( 0.40, "L_exhaust_rear_1", $"xo_health_smoke_black", false )
		ModelFX_AddTagHealthFX( 0.20, "R_exhaust_rear_2", $"xo_health_smoke_black", false )

	// from cl_hornet_fighet.nut
		//ModelFX_AddTagHealthFX( 0.80, "L_exhaust_rear_1", $"P_veh_crow_exp_sml", true )
		ModelFX_AddTagHealthFX( 0.80, "L_exhaust_rear_1", $"xo_health_smoke_white", false )

		//ModelFX_AddTagHealthFX( 0.75, "R_exhaust_rear_1", $"P_veh_crow_exp_sml", true )
		ModelFX_AddTagHealthFX( 0.75, "R_exhaust_rear_1", $"xo_health_smoke_white", false )

		//ModelFX_AddTagHealthFX( 0.50, "L_exhaust_rear_1", $"P_veh_crow_exp_sml", true )
		ModelFX_AddTagHealthFX( 0.50, "L_exhaust_rear_1", $"veh_chunk_trail", false )

		//ModelFX_AddTagHealthFX( 0.45, "R_exhaust_rear_1", $"P_veh_crow_exp_sml", true )
		ModelFX_AddTagHealthFX( 0.45, "R_exhaust_rear_1", $"veh_chunk_trail", false )

*/

// simplifed damage struct that we use for calculate gunship's recent taken damage
struct GunshipRecentDamageStruct
{
	float time
	int damage
}

struct
{
	table< entity, array<GunshipRecentDamageStruct> > gunshipRecentDamageTable

	table< float, table<string, asset> > gunshipDamageEffects
	table< float, table<string, asset> > gunshipHealthThresholdEffects
} file

function AiGunship_Init()
{
	PrecacheParticleSystem( FX_GUNSHIP_EXPLOSION )
	AddDeathCallback( "npc_gunship", GunshipDeath )

	// taken from _vehicle_dropship_new.nut. why it isn't added for gunships?
	// dropship uses AddDamageCallback()... that can't get calculated damage at all!
	AddPostDamageCallback( "npc_gunship", OnGunshipPostDamage )
	// modded effects
	#if ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT
		InitGunshipHealthThresholdEffects()
	#endif
}

#if ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT
// modded effects
void function InitGunshipHealthThresholdEffects()
{
	table<string, asset> damageEffect1 = { ["L_exhaust_front_1"] = $"P_impact_exp_frag_air" }
	file.gunshipDamageEffects[ 0.80 ] <- damageEffect1
	table<string, asset> damageEffect2 = { ["R_exhaust_front_1"] = $"P_impact_exp_frag_air" }
	file.gunshipDamageEffects[ 0.75 ] <- damageEffect2
	table<string, asset> damageEffect3 = { ["L_exhaust_front_1"] = $"P_impact_exp_frag_air" }
	file.gunshipDamageEffects[ 0.50 ] <- damageEffect3
	table<string, asset> damageEffect4 = { ["R_exhaust_front_1"] = $"P_impact_exp_frag_air" }
	file.gunshipDamageEffects[ 0.25 ] <- damageEffect4

	// reaper effects
	/*
	table<string, asset> healthEffect1 = { ["L_exhaust_front_1"] = $"P_sup_spectre_dam_2" }
	file.gunshipHealthThresholdEffects[ 0.5 ] <- healthEffect1
	table<string, asset> healthEffect2 = { ["R_exhaust_front_1"] = $"P_sup_spectre_dam_2" }
	file.gunshipHealthThresholdEffects[ 0.5 ] <- healthEffect2
	*/

	// dropship effects
	/*
	table<string, asset> healthEffect1 = { ["L_exhaust_rear_1"] = $"xo_health_smoke_white" }
	file.gunshipHealthThresholdEffects[ 0.80 ] <- healthEffect1
	table<string, asset> healthEffect2 = { ["R_exhaust_front_1"] = $"xo_health_smoke_white" }
	file.gunshipHealthThresholdEffects[ 0.60 ] <- healthEffect2
	table<string, asset> healthEffect3 = { ["R_exhaust_rear_1"] = $"xo_health_smoke_black" }
	file.gunshipHealthThresholdEffects[ 0.40 ] <- healthEffect3
	table<string, asset> healthEffect4 = { ["L_exhaust_front_1"] = $"xo_health_smoke_black" }
	file.gunshipHealthThresholdEffects[ 0.20 ] <- healthEffect4
	*/

	table<string, asset> healthEffect1 = { ["L_exhaust_rear_1"] = $"xo_health_smoke_white" }
	file.gunshipHealthThresholdEffects[ 0.80 ] <- healthEffect1
	table<string, asset> healthEffect2 = { ["R_exhaust_rear_1"] = $"xo_health_smoke_white" }
	file.gunshipHealthThresholdEffects[ 0.75 ] <- healthEffect2
	table<string, asset> healthEffect3 = { ["L_exhaust_rear_1"] = $"veh_chunk_trail" }
	file.gunshipHealthThresholdEffects[ 0.50 ] <- healthEffect3
	table<string, asset> healthEffect4 = { ["R_exhaust_rear_1"] = $"veh_chunk_trail" }
	file.gunshipHealthThresholdEffects[ 0.45 ] <- healthEffect4


	foreach ( healthFrac, effectTable in file.gunshipDamageEffects )
	{
		foreach ( attachment, effect in effectTable )
		{
			PrecacheParticleSystem( effect )
		}
	}

	foreach ( healthFrac, effectTable in file.gunshipHealthThresholdEffects )
	{
		foreach ( attachment, effect in effectTable )
		{
			PrecacheParticleSystem( effect )
		}
	}
}
#endif // ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT

function GunshipThink( gunship )
{
	gunship.EndSignal( "OnDeath" )

	entity owner
	entity currentTarget
	local accuracyMultiplierBase = gunship.kv.AccuracyMultiplier
	local accuracyMultiplierAgainstDrones = 100

	while( true )
	{
		wait 0.25

		//----------------------------------
		// Get owner and current enemy
		//----------------------------------
		currentTarget = expect entity( gunship.GetEnemy() )
		owner = expect entity( gunship.GetFollowTarget() )

		//----------------------------------
		// Free roam if owner is dead or HasEnemy
		//----------------------------------
		if ( ( !IsAlive( owner ) ) || ( currentTarget != null ) )
		{
			gunship.DisableBehavior( "Follow" )
		}

		//---------------------------------------------------------------------
		// If owner is alive and no enemies in sight, go back and follow owner
		//----------------------------------------------------------------------
		if ( ( IsAlive( owner ) ) && ( currentTarget == null ) )
		{
			gunship.EnableBehavior( "Follow" )
		}


		//----------------------------------------------
		// Jack up accuracy if targeting a small target (like a drone)
		//----------------------------------------------
		if ( ( currentTarget != null ) && ( IsAirDrone( currentTarget ) ) )
		{
			gunship.kv.AccuracyMultiplier = accuracyMultiplierAgainstDrones
		}
		else
		{
			gunship.kv.AccuracyMultiplier = accuracyMultiplierBase
		}
	}

}


void function GunshipDeath( entity gunship, var damageInfo )
{
	/*
	Script errors

	// Explosion effect
	entity explosion = CreateEntity( "info_particle_system" )
	explosion.SetOrigin( gunship.GetWorldSpaceCenter() )
	explosion.SetAngles( gunship.GetAngles() )
	explosion.SetValueForEffectNameKey( FX_GUNSHIP_EXPLOSION )
	explosion.kv.start_active = 1
	DispatchSpawn( explosion )
	EmitSoundAtPosition( TEAM_UNASSIGNED, gunship.GetOrigin(), SOUND_GUNSHIP_EXPLODE_DEFAULT )
	explosion.destroy( 3 )

	gunship.Destroy()

	P_veh_exp_hornet, TAG_ORIGIN, attach

	*/
	// will this make some score? or make it confirm as killing a gunship?
	// has been fixed by modifying IsValidNPCTarget() function
	//PlayerOrNPCKilled( gunship, damageInfo )

	//TEMP
	// modified here: all these fx should never hibernate on client-side...
	//PlayFX( FX_GUNSHIP_EXPLOSION, gunship.GetOrigin() )
	entity fx = PlayFX( FX_GUNSHIP_EXPLOSION, gunship.GetOrigin() )
	fx.DisableHibernation() // infinite fadedist
	// sound event, change to be not hardcoded
	//EmitSoundAtPosition( TEAM_UNASSIGNED, gunship.GetOrigin(), "Goblin_Dropship_Explode" )
	EmitSoundAtPosition( TEAM_UNASSIGNED, gunship.GetOrigin(), SOUND_GUNSHIP_EXPLODE_DEFAULT )
	// destroy the gunship because they're not handled to be hide on death by code
	// needs to add one tick period before destroy, for other death callbacks can go through
	//gunship.Destroy()
	thread DelayedDestroyGunship( gunship )
}

// modified function
void function DelayedDestroyGunship( entity gunship )
{
	gunship.EndSignal( "OnDestroy" )
	gunship.Hide() // temp hide. not using VisibilityFlags because we want to keep their jet effect on
	
	WaitFrame() // wait for other death callbacks go through
	gunship.Destroy()
}

// taken from _vehicle_dropship_new.nut. why it isn't added for gunships?
void function OnGunshipPostDamage( entity gunship, var damageInfo )
{
	#if ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT
		DoGunshipDamageEffect( gunship, int( DamageInfo_GetDamage( damageInfo ) ) )
		DoGunshipHealthThresholdEffect( gunship, int( DamageInfo_GetDamage( damageInfo ) ) )
	#endif // ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT

	// damage effect. not very good, now replaced with health effects
	#if ENABLE_GUNSHIP_DAMAGE_EFFECT
		//print( "Gunship taking damage!" )
		int maxHealth = gunship.GetMaxHealth()
		int heavyDamageThreshold = int( maxHealth * GUNSHIP_HEAVY_DAMAGE_THRESHOLD )
		int repeatDamageThreshold = int( maxHealth * GUNSHIP_REPEAT_DAMAGE_THRESHOLD )
		float damage = DamageInfo_GetDamage( damageInfo )

		//print( "heavyDamageThreshold: " + string( heavyDamageThreshold ) )
		//print( "repeatDamageThreshold: " + string( repeatDamageThreshold ) )
		//print( "damage: " + string( damage ) )

		// store some necessary damage history for npc gunships so we can calculate DPS
		// reworked. these damage should be completely in-file to avoid conflict with other damage histroy modifiers( like extra_ai_spawner.gnut )
		//DamageHistoryStruct damageHistory
		//damageHistory.damage = damage
		//damageHistory.time = Time()
		//gunship.e.recentDamageHistory.insert( 0, damageHistory )
		UpdateGunshipDamageHistory( gunship, damageInfo ) // this includes current damage for later we can get

		// get DPS( includes current damage )
		// this behavior should be completely in file
		//int damageTakenWithinSecond = int( GetTotalDamageTakenInTime( gunship, 1.0 ) )
		int damageTakenWithinSecond = GetGunshipDamageTakenInTime( gunship, 1.0 )
		//print( "damageTakenWithinSecond: " + string( damageTakenWithinSecond ) )
		vector pos = DamageInfo_GetDamagePosition( damageInfo )
		// repeat damage threshold
		if ( damageTakenWithinSecond > repeatDamageThreshold )
		{
			//print( "Gunship Repeat damage threshold triggered!" )
			// if triggered, clear out damageHistory
			// this behavior should be completely in file
			//ClearRecentDamageHistory( gunship )
			ClearGunshipRecentDamage( gunship )
			PlayFX( FX_GUNSHIP_DAMAGE, pos )
		}
		// heavy damage threshold
		else if ( damage > heavyDamageThreshold )
		{
			//print( "Gunship Heavy damage threshold triggered!" )
			PlayFX( FX_GUNSHIP_DAMAGE, pos )
		}
	#endif // ENABLE_GUNSHIP_DAMAGE_EFFECT
}

#if ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT
void function PlayGunshipEffectFromSettings( entity gunship, table< float, table<string, asset> > settings, int damage, bool attachToEnt = false )
{
	float healthRatio = HealthRatio( gunship )
	float newHealthRatio = float( gunship.GetHealth() - damage ) / gunship.GetMaxHealth()
	array<entity> fxs
	foreach ( healthFrac, effectTable in settings )
	{
		if ( healthRatio > healthFrac && newHealthRatio < healthFrac )
		{
			foreach ( attachment, effect in effectTable )
			{
				entity fx
				if ( attachToEnt )
				{
					fx = PlayLoopFXOnEntity( effect, gunship, attachment, null, null, ENTITY_VISIBLE_TO_EVERYONE )
				}
				else
				{
					int attachID = gunship.LookupAttachment( attachment )
					vector angs = gunship.GetAttachmentAngles( attachID )
					vector pos = gunship.GetAttachmentOrigin( attachID )
					entity fx = PlayFX( effect, pos, angs )
				}
				fxs.append( fx )
			}
		}
	}

	// make them have infinite fadedist
	foreach ( fx in fxs )
		fx.DisableHibernation()
}

void function DoGunshipDamageEffect( entity gunship, int damage )
{
	PlayGunshipEffectFromSettings( gunship, file.gunshipDamageEffects, damage )
}

void function DoGunshipHealthThresholdEffect( entity gunship, int damage )
{
	PlayGunshipEffectFromSettings( gunship, file.gunshipHealthThresholdEffects, damage, true )
}
#endif // ENABLE_GUNSHIP_HEALTH_THRESHOLD_EFFECT

#if ENABLE_GUNSHIP_DAMAGE_EFFECT
// this also included UpdateDamageHistory()'s effect
void function UpdateGunshipRecentDamage( entity gunship, var damageInfo )
{
	if ( !( gunship in file.gunshipRecentDamageTable ) )
		file.gunshipRecentDamageTable[ gunship ] <- []
	
	GunshipRecentDamageStruct recentDamageStruct
	recentDamageStruct.damage = int( DamageInfo_GetDamage( damageInfo ) )
	recentDamageStruct.time = Time()

	// remove old entries
	int i
	float removeTime = Time() - GUNSHIP_RECENT_DAMAGE_STORE_TIME

	for ( i = file.gunshipRecentDamageTable[ gunship ].len() - 1; i >= 0; i-- )
	{
		GunshipRecentDamageStruct recentDamage = file.gunshipRecentDamageTable[ gunship ]

		if ( recentDamage.time > removeTime )
			break // idk why vanilla UpdateDamageHistory() did a return here. shouldn't this be continue?

		file.gunshipRecentDamageTable[ gunship ].remove( i )
	}

	file.gunshipRecentDamageTable[ gunship ].insert( 0, recentDamageStruct )
}

void function ClearGunshipRecentDamage( entity gunship )
{
	if ( !( gunship in file.gunshipRecentDamageTable ) )
		return
	
	file.gunshipRecentDamageTable[ gunship ].clear()
}

// base off GetTotalDamageTakenInTime() in sh_damage_history.gnut
int function GetGunshipDamageTakenInTime( entity gunship, float hitTime )
{
	if ( !( gunship in file.gunshipRecentDamageTable ) )
		return 0

	float time = Time() - hitTime

	int total = 0
	foreach ( recentDamage in file.gunshipRecentDamageTable[ gunship ] )
	{
		if ( recentDamage.time < time )
			continue

		total += int( recentDamage.damage )
	}

	return total
}
#endif // ENABLE_GUNSHIP_DAMAGE_EFFECT