untyped

global function MeleeSyncedTitanShared_Init

// modified here, we add more execution settings
#if SERVER
global function MeleeSyncedTitan_AddExecutionRefCallback
global function MeleeSyncedTitan_ExecutionRefHasCallback
global function MeleeSyncedTitan_RunCallbacksForRef // shared with _melee_synced_titan.gnut

global function MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback
global function MeleeSyncedTitan_ExecutionRefHasLoadoutReplaceCallback
global function MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef // shared with _melee_synced_titan.gnut
global function MeleeSyncedTitan_ReplaceExecutionAttackerLoadout // called by default loadout replace callbacks

global function MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback
global function MeleeSyncedTitan_TitanShouldDoLoadoutReplaceForRef

// register some settings here
global function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker
global function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim // note that if a titan's victim valid execution array is empty, it means they can be executed by all executions

global function MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef

// shared with _melee_synced_titan.gnut
global function MeleeSyncedTitan_GetBestExecutionRefForTitanVsTitan
global function MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan

// mostly for ability or core weapon mods. remove them when loadout replacing
// currently used for titan_replace.gnut
global function MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace

// for we refresh hud visibility after player's certain weapon getting replaced
global function MeleeSyncedTitan_AddWeaponRequiresHudVisibilityUpdate

struct ExecutionSavedLoadout
{
	// can't just store a primary weapon entity, as TakeWeapon_NoDelete() will leave a weapon model in titan's hand
	// now reworked here: never take off primary weapon. instead, add another weapon for titan to use
	// if titan already got max 3 weapons we do nothing, that should only happen on modded titans and they could handle it themselves
	// this should be a better solution because player titan don't have that much weapon restrictions
	/*
	string primary = "" // primary weapon
	array<string> primaryMods = []
	int primaryAmmo
	int primarySkin
	int primaryCamo
	*/

	entity replacedPrimaryEnt

	table<int, entity> savedOffhandWeaponEnts
}

// npc specific loadout saving
// TakeWeapon_NoDelete() and TakeOffhandWeapon_NoDelete() can't be used on npcs
// they'll still consider these weapon in their inventory
// causes crash of having multiple weapons at same usage or having multiple smart ammo weapons
// this replacing logic removes their ability-related weapon mods and refreshes their weapon's ammo or cooldown rest
// but whatever, might be the only solution because respawn didn't left any useful methods for controlling a npc's firing behavior
struct ExecutionSavedLoadout_NPC
{
	string primary = "" // primary weapon
	array<string> primaryMods = []
	int primaryAmmo
	int primarySkin
	int primaryCamo
	entity replacedPrimaryEnt = null

	string special = "" // defensive
	array<string> specialMods = []

	string antiRodeo = "" // utility
	array<string> antiRodeoMods = []

	string ordnance = "" // ordnance
	array<string> ordnanceMods = []

	string melee = "" // melee
	array<string> meleeMods = []

	string equipment = "" // core
	array<string> equipmentMods = []
}

// modified settings struct
struct
{
	table< string, array<void functionref( entity, entity )> > titanExecutionRefCallbacks
	table< string, void functionref( entity ) > titanExecutionRefLoadoutReplaceCallback
	table< string, bool functionref( entity ) > titanExecutionRefShouldReplaceLoadoutCallback

	table<entity, ExecutionSavedLoadout> titanExecutionSavedLoadout
	table<entity, ExecutionSavedLoadout_NPC> titanExecutionSavedLoadout_NPC

	array<string> modsToRemoveOnLoadoutReplace

	table< string, array<string> > chassisValidExecutionRefs_Attacker
	table< string, array<string> > chassisValidExecutionRefs_Victim
	table< string, array<string> > titanCharacterSpecificExecutionRefs

	array<string> weaponsRequireHudVisibilityUpdate
} file
#endif

function MeleeSyncedTitanShared_Init()
{
	SyncedMeleeChooser chooser = CreateSyncedMeleeChooser( "titan", "titan" )

	chooser.displayMeleePrompt = false

	#if SERVER
		MeleeSyncedTitan_Init()

		// modified here, we add more execution settings
		RegisterSignal( "ReplaceExecutionAttackerLoadout" )
		RegisterSignal( "UpdateCockpitRUI" )
		MeleeSyncedTitan_InitSpecificExecutionRefSettings()
		MeleeSyncedTitan_InitDefaultRefCallbacks()
	#endif

	SyncedMelee action
	action.direction = Vector( 1, 0, 0 )
	action.distance = TITAN_EXECUTION_RANGE
	action.isAttackerRef = false

	AddSyncedMelee( chooser, action )
}

// modified here, we add more execution settings
#if SERVER
void function MeleeSyncedTitan_InitSpecificExecutionRefSettings()
{
	// atlas chassis executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_ion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_ion_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_tone" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_tone_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_vanguard" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_vanguard_kit" )
	// random 
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_random_0" ) // ion
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_random_4" ) // tone
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "atlas", "execution_random_6" ) // monarch

	// stryder chassis executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_ronin" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_ronin_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_northstar" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_northstar_prime" )
	// random 
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_random_2" ) // northstar
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "stryder", "execution_random_3" ) // ronin
	
	// ogre chassis executions
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_scorch" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_scorch_prime" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_legion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_legion_prime" )
	// random
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_random_1" ) // scorch
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "ogre", "execution_random_5" ) // legion

	// BT executions
	//MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt" ) // shouldn't be handled here. "execution_bt" is already a random execution handled by TitanVsTitan_3p()
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt_flip" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt_pilotrip" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( "buddy", "execution_bt_kickshoot" )
	// valid victim executions
	// for buddy chassis, they shouldn't be executed by tf2 melee at all
	// just add an empty ref, will lead to classic executions
	// EDIT: added workaround for these ref in _melee_sycned_titan.gnut, should be working fine now
	//MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "" )
	// anyways, they do have animations for being tf2 execution vicitim
	// but these animations are used for SP auto titans so all animations don't have AE_MELEE_KILLED, leading to bad duration
	// I've inited stuffs in Init3pExecutions(), could enable following executions if you want
	// EDIT: added workaround for these ref in _melee_sycned_titan.gnut, should be working fine now
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_ion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_tone" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_ronin" )
	// legion execution makes bt rotates weirdly, removed
	//MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_legion" )
	MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( "buddy", "execution_scorch" )

	// ion character executions
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ion", "execution_ion" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ion", "execution_ion_prime" )

	// tone character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "tone", "execution_tone" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "tone", "execution_tone_prime" )

	// monarch character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "vanguard", "executvanguard_vanguard" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "vanguard", "executvanguard_vanguard_kit" )

	// ronin character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ronin", "executronin_ronin" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ronin", "executronin_ronin_prime" )

	// northstar character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "northstar", "execution_northstar" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "northstar", "execution_northstar_prime" )

	// scorch character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "scorch", "execution_scorch" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "scorch", "execution_scorch_prime" )

	// legion character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "legion", "execution_legion" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "legion", "execution_legion_prime" )

	// BT character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "bt", "execution_bt_flip" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "bt", "execution_bt_pilotrip" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "bt", "execution_bt_kickshoot" )
}

// default execution callbacks
void function MeleeSyncedTitan_InitDefaultRefCallbacks()
{
	/* // note:
		execution_northstar_prime, 
		execution_scorch, 
		execution_scorch_prime, 
		execution_vanguard, 
		execution_vanguard_kit, 
		execution_bt_pilotrip, 
		execution_bt_flip, 

		these executions don't require weapons
	*/

	// ION
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ion", Execution_Ion )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_ion", ExecutionIon_ShouldReplaceLoadout )

	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ion_prime", Execution_Ion_Prime )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_ion_prime", ExecutionIonPrime_ShouldReplaceLoadout )

	// weapons that requires hud visibility to be updated after getting replaced
	MeleeSyncedTitan_AddWeaponRequiresHudVisibilityUpdate( "mp_titanweapon_particle_accelerator" )

	// TONE
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_tone", Execution_Tone )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_tone", ExecutionTone_ShouldReplaceLoadout )
	MeleeSyncedTitan_AddExecutionRefCallback( "execution_tone", Execution_Tone_Fix )

	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_tone_prime", Execution_Tone_Prime )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_tone_prime", ExecutionTonePrime_ShouldReplaceLoadout )

	// weapons that requires hud visibility to be updated after getting replaced
	MeleeSyncedTitan_AddWeaponRequiresHudVisibilityUpdate( "mp_titanweapon_tracker_rockets" )

	// RONIN
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ronin", Execution_Ronin )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_ronin", ExecutionRonin_ShouldReplaceLoadout )

	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ronin_prime", Execution_Ronin_Prime )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_ronin_prime", ExecutionRoninPrime_ShouldReplaceLoadout )

	// core abilty weapon mod to be removed on npc loadout replace
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "super_charged" )
	
	// NORTHSTAR
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_northstar", Execution_Northstar )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_northstar", ExecutionNorthstar_ShouldReplaceLoadout )

	// LEGION
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_legion", Execution_Legion )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_legion", ExecutionLegion_ShouldReplaceLoadout )

	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_legion_prime", Execution_Legion_Prime )
	MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( "execution_legion_prime", ExecutionLegionPrime_ShouldReplaceLoadout )

	// weapons that requires hud visibility to be updated after getting replaced
	MeleeSyncedTitan_AddWeaponRequiresHudVisibilityUpdate( "mp_titancore_siege_mode" )

	// core abilty weapon mod to be removed on npc loadout replace
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "Smart_Core" )

	// SCORCH
	// don't have any execution that requires weapon
	MeleeSyncedTitan_AddExecutionRefCallback( "execution_scorch_prime", Execution_Scorch_Prime_Fix )
	
	// BT
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_bt_kickshoot", Execution_BT_KickShoot )
}

// generic loadout replace check
bool function Generic_TitanExecutionShouldReplaceLoadout( entity titan, array<string> requiredWeapons )
{
	foreach ( weapon in requiredWeapons )
	{
		if ( !PlayerHasWeapon( titan, weapon ) ) // function name is weird. it can be used by npcs
			return true // return true means we need the loadout to be replaced
	}

	// all checks passed
	//print( "titan: " + string( titan ) + " has all required weapons for execution: " + ref )
	return false // don't replace loadout
}

void function Execution_Ion( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_particle_accelerator", [],
		"", [],		// "mp_titanweapon_vortex_shield_ion", won't use during execution
		"", [],		// "mp_titanability_laser_trip", won't use during execution
		"mp_titanweapon_laser_lite", [],
		"", [],		// "melee_titan_punch_ion", won't use during execution
		"", []		// "mp_titancore_laser_cannon", won't use during execution
	)
}

const array<string> EXECUTION_ION_REQUIRED_WEAPONS =
[
	"mp_titanweapon_particle_accelerator", 
	"mp_titanweapon_laser_lite",
] 
bool function ExecutionIon_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_ION_REQUIRED_WEAPONS )
}

void function Execution_Ion_Prime( entity attacker )
{
	string coreWeapon = "mp_titancore_laser_cannon"
	// we've add fake laser core for npc execution, should be fine now
	//if ( attacker.IsNPC() ) // saved for npc execution condition: never fire a lasercannon
	//	coreWeapon = "mp_titancore_siege_mode" // change to placeholder core weapon if a npc ever used this execution

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_particle_accelerator", won't use during execution
		"", [],		// "mp_titanweapon_vortex_shield_ion", won't use during execution
		"", [],		// "mp_titanability_laser_trip", won't use during execution
		"mp_titanweapon_laser_lite", [],
		"", [],		// "melee_titan_punch_ion", won't use during execution
		coreWeapon, []
	)
}

const array<string> EXECUTION_ION_PRIME_REQUIRED_WEAPONS =
[
	"mp_titanweapon_laser_lite", 
	"mp_titancore_laser_cannon", 
]
bool function ExecutionIonPrime_ShouldReplaceLoadout( entity titan )
{
	// npc specific checks: we always replace loadout if they have "mp_titancore_laser_cannon"
	// it will make npcs stuck forever when performing this execution
	if ( titan.IsNPC() )
	{
		if ( PlayerHasWeapon( titan, "mp_titancore_laser_cannon" ) )
			return true // always do loadout replace if so. we'll change laser core to smart core in loadout replace function
		else
			return !PlayerHasWeapon( titan, "mp_titanweapon_laser_lite" ) // npc only needs laser_lite
	}
	
	// player checks
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_ION_REQUIRED_WEAPONS )
}

void function Execution_Tone( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sticky_40mm", [],
		"", [],		// "mp_titanaility_particle_wall", won't use during execution
		"", [],		// "mp_titanability_sonar_pulse", won't use during execution
		"", [],		// "mp_titanweapon_tracker_rockets", won't use during execution
		"", [],		// "melee_titan_punch_tobe", won't use during execution
		"", []		// "mp_titancore_salvo_core", won't use during execution
	)
}

const array<string> EXECUTION_TONE_REQUIRED_WEAPONS =
[
	"mp_titanweapon_sticky_40mm", 
] 
bool function ExecutionTone_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_TONE_REQUIRED_WEAPONS )
}

void function Execution_Tone_Fix( entity attacker, entity target )
{
	// HACKY fix here: if we're holding 40mm and we don't have any ammo left
	// add 1 clip so we don't receive reloading during animation
	// don't know why respawn fixed ammo for prime execution but not this...
	entity mainWeapon = attacker.GetMainWeapons()[0]
	//print( "mainWeapon: " + string( mainWeapon ) )
	if ( IsValid( mainWeapon ) )
	{
		if ( mainWeapon.GetWeaponClassName() == "mp_titanweapon_sticky_40mm" )
		{
			if ( mainWeapon.GetWeaponPrimaryClipCount() == 0 )
				mainWeapon.SetWeaponPrimaryClipCount( 1 )
		}
	}
}

void function Execution_Tone_Prime( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sticky_40mm", [],
		"", [],		// "mp_titanaility_particle_wall", won't use during execution
		"", [],		// "mp_titanability_sonar_pulse", won't use during execution
		"", [],		// "mp_titanweapon_tracker_rockets", execution actually plays particle effect but not firing weapon
		"", [],		// "melee_titan_punch_tone", won't use during execution
		"", []		// "mp_titancore_salvo_core", won't use during execution
	)
}

const array<string> EXECUTION_TONE_PRIME_REQUIRED_WEAPONS =
[
	"mp_titanweapon_sticky_40mm", 
] 
bool function ExecutionTonePrime_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_TONE_PRIME_REQUIRED_WEAPONS )
}

void function Execution_Ronin( entity attacker )
{
	// prime sword check
	array<string> meleeMods = []
	entity soul = attacker.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanLoadoutDef loadout = soul.soul.titanLoadout
		if ( loadout.isPrime == "titan_is_prime" )
			meleeMods.append( "modelset_prime" )
	}

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_leadwall", won't use during execution
		"", [],		// "mp_titanability_basic_block", won't use during execution
		"", [],		// "mp_titanability_phase_dash", won't use during execution
		"", [],		// "mp_titanweapon_arc_wave", won't use during execution
		"melee_titan_sword", meleeMods,
		"", []		// "mp_titancore_shift_core", won't use during execution
	)
}

const array<string> EXECUTION_RONIN_REQUIRED_WEAPONS =
[
	"melee_titan_sword", 
] 
bool function ExecutionRonin_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_RONIN_REQUIRED_WEAPONS )
}

void function Execution_Ronin_Prime( entity attacker )
{
	// prime sword check
	array<string> meleeMods = []
	entity soul = attacker.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanLoadoutDef loadout = soul.soul.titanLoadout
		if ( loadout.isPrime == "titan_is_prime" )
			meleeMods.append( "modelset_prime" )
	}

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_leadwall", won't use during execution
		"", [],		// "mp_titanability_basic_block", won't use during execution
		"", [],		// "mp_titanability_phase_dash", won't use during execution
		"", [],		// "mp_titanweapon_arc_wave", execution actually plays particle effect but not firing weapon
		"melee_titan_sword", meleeMods,
		"", []		// "mp_titancore_shift_core", won't use during execution
	)
}

const array<string> EXECUTION_RONIN_PRIME_REQUIRED_WEAPONS =
[
	"melee_titan_sword", 
] 
bool function ExecutionRoninPrime_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_RONIN_PRIME_REQUIRED_WEAPONS )
}

void function Execution_Northstar( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sniper", [],
		"", [],		// "mp_titanability_tether_trap", won't use during execution
		"", [],		// "mp_titanability_hover", won't use during execution
		"", [],		// "mp_titanweapon_dumbfire_rockets", won't use during execution
		"", [],		// "melee_titan_punch_northstar", won't use during execution
		"", []		// "mp_titancore_flight_core", won't use during execution
	)
}

const array<string> EXECUTION_NORTHSTAR_REQUIRED_WEAPONS =
[
	"mp_titanweapon_sniper", 
] 
bool function ExecutionNorthstar_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_NORTHSTAR_REQUIRED_WEAPONS )
}

void function Execution_Legion( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_predator_cannon", [],
		"mp_titanability_gun_shield", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_ammo_swap", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_power_shot", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"", [],		// "melee_titan_punch_legion", won't use during execution
		"mp_titancore_siege_mode", []			// won't use during execution, but is required for overwriting other smart ammo weapons
	)
}

const array<string> EXECUTION_LEGION_REQUIRED_WEAPONS =
[
	"mp_titanweapon_predator_cannon",
	"mp_titanability_gun_shield",
	"mp_titanability_ammo_swap",
	"mp_titanability_power_shot",
	"mp_titancore_siege_mode",
] 
bool function ExecutionLegion_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_LEGION_REQUIRED_WEAPONS )
}

void function Execution_Legion_Prime( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_predator_cannon", [],
		"mp_titanability_gun_shield", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_ammo_swap", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_power_shot", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"", [],		// "melee_titan_punch_legion", won't use during execution
		"mp_titancore_siege_mode", []			// won't use during execution, but is required for overwriting other smart ammo weapons
	)
}

const array<string> EXECUTION_LEGION_PRIME_REQUIRED_WEAPONS =
[
	"mp_titanweapon_predator_cannon",
	"mp_titanability_gun_shield",
	"mp_titanability_ammo_swap",
	"mp_titanability_power_shot",
	"mp_titancore_siege_mode",
] 
bool function ExecutionLegionPrime_ShouldReplaceLoadout( entity titan )
{
	return Generic_TitanExecutionShouldReplaceLoadout( titan, EXECUTION_LEGION_PRIME_REQUIRED_WEAPONS )
}

void function Execution_Scorch_Prime_Fix( entity attacker, entity target )
{
	// HACK fix for scorch: their flame core already emitting very large sound
	// try to hide target's death sound
	//target.s.silentDeath <- true
}

void function Execution_BT_KickShoot( entity attacker )
{
	string xo16 = "mp_titanweapon_xo16_shorty"
	array<entity> weapons = attacker.GetMainWeapons()
	if ( weapons.len() > 1 ) // fakebt version, it has multiple main weapons so do more checks
	{
		int xo16Slot = -1
		foreach ( int index, entity weapon in weapons )
		{
			if ( weapon.GetWeaponClassName() == xo16 )
			{
				xo16Slot = index
				break
			}
		}
		if ( xo16Slot != -1 ) // change to xo16 if we have one
		{
			attacker.SetActiveWeaponBySlot( xo16Slot )
		}

		// this version allowing bt to use any active weapon, requires refilling ammo
		if ( attacker.IsPlayer() )
			attacker.ClearOffhand() // so they will switch to last main weapon
		entity activeWeapon = attacker.GetActiveWeapon()
		if ( IsValid( activeWeapon ) && !activeWeapon.IsWeaponOffhand() ) // try to use active main weapon
		{
			// have to try-catch this since not all main weapons can use weapon clip
			try { activeWeapon.SetWeaponPrimaryClipCount( activeWeapon.GetWeaponPrimaryClipCountMax() ) }
			catch( ex ){}
		}
	}
	else // try to give xo16 if we don't have one
	{
		entity xo16Weapon
		foreach ( entity weapon in weapons )
		{
			if ( weapon.GetWeaponClassName() == xo16 )
			{
				xo16Weapon = weapon
				break
			}
		}
		if ( IsValid( xo16Weapon ) )
		{
			attacker.SetActiveWeaponByName( xo16 )
			xo16Weapon.SetWeaponPrimaryClipCount( xo16Weapon.GetWeaponPrimaryClipCountMax() ) // don't want to make bt reload while executing
		}

		if ( !IsValid( xo16Weapon ) ) // can't find xo16
			MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( attacker, xo16 ) // replace loadout
	}
}

// utility
// best execution: if attacker execution invalid, pick any execution that is valid for current chassis
// shared with _melee_synced_titan.gnut, function DefaultCallback_OnGetTitan3pExecutionRef()
string function MeleeSyncedTitan_GetBestExecutionRefForTitanVsTitan( entity attacker, entity target, string forcedRef = "" )
{
	entity attackerSoul = attacker.GetTitanSoul()
	if ( !IsValid( attackerSoul ) )
		return "" // return empty means we needs to go into classic execution( which all titans have valid animation for that )

	entity targetSoul = target.GetTitanSoul()
	if ( !IsValid( targetSoul ) )
		return ""

	// search for best execution ref
	string executionRef = attackerSoul.soul.titanLoadout.titanExecution // default value
	if ( forcedRef != "" )
		executionRef = forcedRef
	
	//print( "executionRef before checking best one: " + executionRef )
	// chassis check
	array<string> validExecutions = GetValidExecutionsForAttackerVsTarget( attacker, target )
	if ( validExecutions.contains( executionRef ) )
	{
		//print( "Titan already have valid execution: " + executionRef )
		return executionRef // we've found our execution to use!
	}

	// bad chassis execution happening... we pick a random one from our character!
	//print( "bad chassis execution happening" )
	string attackerCharacter = GetTitanCharacterName( attacker )
	array<string> characterExecutions = GetCharacterSpecificExecutions( attackerCharacter )
	string targetChassis = GetSoulTitanSubClass( targetSoul )
	array<string> victimValidExecutions = GetVictimChassisValidExecutions( targetChassis )
	if ( characterExecutions.len() > 0 )
	{
		string lastRefFound = ""
		// normal ref, prefer finding player's equipping one
		foreach ( string otherRef in characterExecutions )
		{
			//print( "finding from ref: " + otherRef )

			// needs to be in victim's valid execution list
			if ( !victimValidExecutions.contains( otherRef ) )
				continue

			// we should at least find one from following case, otherwise we failsafe
			if ( TitanExecutionRefIsPrime( otherRef ) )
			{
				// if finding ref is prime, our ref needs also be prime
				if ( TitanExecutionRefIsPrime( executionRef ) )
				{
					//print( "both our ref and finding ref is PRIME! returning a valid prime execution" )
					return otherRef
				}
			}
			else if ( MeleeSyncedTitan_RefHasLinkedExecutions( otherRef ) ) // shared function from _melee_synced_titan.gnut
			{
				// if finding ref is random, our ref needs also be random
				if ( MeleeSyncedTitan_RefHasLinkedExecutions( executionRef ) )
				{
					//print( "both our ref and finding ref is RANDOM! returning a valid random execution" )
					array<string> linkedRefs = MeleeSyncedTitan_GetLinkedExecutionsFromRef( otherRef )  // shared function from _melee_synced_titan.gnut
					return linkedRefs[ RandomInt( linkedRefs.len() ) ]
				}
			}
			else
				lastRefFound = otherRef // if we still can't find one, use this ref as a failsafe
		}
		// we can't find anything from iterrate... use last found one
		if ( lastRefFound != "" )
			return lastRefFound
	}

	// code hits here!!! this means we can't get any valid execution, just use random one
	return MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan( attacker, target )
}

bool function TitanExecutionRefIsPrime( string ref )
{
	// _kit suffix is hardcoded for monarch, currently removed
	bool isPrimeRef = ( ref.find( "_prime" ) != null ) //|| ( ref.find( "_kit" ) != null ) 
	// debug
	//print( "TitanExecutionRefIsPrime( " + ref + " ) : " + string( isPrimeRef ) )
	return isPrimeRef
}

// random execution ref: pick anything that is valid for current chassis
// shared with _melee_synced_titan.gnut, function DefaultCallback_OnGetTitan3pExecutionRef()
string function MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan( entity attacker, entity target )
{
	entity attackerSoul = attacker.GetTitanSoul()
	if ( !IsValid( attackerSoul ) )
		return "" // return empty means we needs to go into classic execution( which all titans have valid animation for that )

	entity targetSoul = target.GetTitanSoul()
	if ( !IsValid( targetSoul ) )
		return ""

	array<string> validExecutions = GetValidExecutionsForAttackerVsTarget( attacker, target )
	if ( validExecutions.len() == 0 ) // can't find any valid execution!
		return "" // let's just use classic execution... at least it never crashes

	string randomExecution = validExecutions[ RandomInt( validExecutions.len() ) ]
	// insure we're not returning a random execution ref( their data should be empty, needs to get from linked execution )
	if ( MeleeSyncedTitan_RefHasLinkedExecutions( randomExecution ) ) // shared function from _melee_synced_titan.gnut
	{
		array<string> linkedRefs = MeleeSyncedTitan_GetLinkedExecutionsFromRef( randomExecution )  // shared function from _melee_synced_titan.gnut
		randomExecution = linkedRefs[ RandomInt( linkedRefs.len() ) ]
	}

	return randomExecution
}

array<string> function GetValidExecutionsForAttackerVsTarget( entity attacker, entity target )
{
	entity attackerSoul = attacker.GetTitanSoul()
	if ( !IsValid( attackerSoul ) )
		return []
	entity targetSoul = target.GetTitanSoul()
	if ( !IsValid( targetSoul ) )
		return []

	string attackerChassis = GetSoulTitanSubClass( attackerSoul )
	string targetChassis = GetSoulTitanSubClass( targetSoul )
	array<string> validExecutions
	array<string> attackerValidExecutions = GetAttackerChassisValidExecutions( attackerChassis )
	array<string> victimValidExecutions = GetVictimChassisValidExecutions( targetChassis )
	// find from all valid executions
	foreach ( string ref in attackerValidExecutions )
	{
		if ( victimValidExecutions.contains( ref ) )
		{
			// debug
			//print( "Found valid execution: " + ref )
			validExecutions.append( ref )
		}
	}

	return validExecutions
} 

array<string> function GetAttackerChassisValidExecutions( string chassis )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Attacker ) )
		return []
	return file.chassisValidExecutionRefs_Attacker[ chassis ]
}

// note that if a titan's victim valid execution array is empty
// it means they can be executed by all executions
array<string> function GetVictimChassisValidExecutions( string chassis )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Victim ) )
		return MeleeSyncedTitan_GetAllValidExecutionRefs() // shared from _melee_synced_titan.gnut
	return file.chassisValidExecutionRefs_Victim[ chassis ]
}

array<string> function GetCharacterSpecificExecutions( string characterName )
{
	if ( !( characterName in file.titanCharacterSpecificExecutionRefs ) )
		return []
	return file.titanCharacterSpecificExecutionRefs[ characterName ]
}

// called by default loadout replace callbacks
void function MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( entity guy, string primary = "", array<string> primaryMods = [], string special = "", array<string> specialMods = [], string antiRodeo = "", array<string> antiRodeoMods = [], string ordnance = "", array<string> ordnanceMods = [], string melee = "", array<string> meleeMods = [], string equipment = "", array<string> equipmentMods = [] )
{
	thread ReplaceExecutionAttackerLoadout_Threaded( guy, primary, primaryMods, special, specialMods, antiRodeo, antiRodeoMods, ordnance, ordnanceMods, melee, meleeMods, equipment, equipmentMods )
}

void function ReplaceExecutionAttackerLoadout_Threaded( entity guy, string primary = "", array<string> primaryMods = [], string special = "", array<string> specialMods = [], string antiRodeo = "", array<string> antiRodeoMods = [], string ordnance = "", array<string> ordnanceMods = [], string melee = "", array<string> meleeMods = [], string equipment = "", array<string> equipmentMods = [] )
{
	guy.Signal( "ReplaceExecutionAttackerLoadout" )
	guy.EndSignal( "ReplaceExecutionAttackerLoadout" )

	// player loadout saving
	if ( guy.IsPlayer() )
	{
		ExecutionSavedLoadout savedLoadout
		file.titanExecutionSavedLoadout[ guy ] <- savedLoadout

		// reworked here: never take off primary weapon. instead, add another weapon for titan to use
		//bool primarySaved = false
		table<int, bool> offhandsSaved
		// init offhand weapons data
		for ( int i = 0; i < OFFHAND_COUNT; i++ )
		{
			savedLoadout.savedOffhandWeaponEnts[ i ] <- null
			offhandsSaved[ i ] <- false
		}

		// first we take all weapons
		// primary weapon
		// reworked here: never take off primary weapon. instead, add another weapon for titan to use
		/*
		entity primaryToSave
		string primaryNameToSave
		array<string> primaryModsToSave
		array<entity> mainWeapons = guy.GetMainWeapons()
		if ( mainWeapons.len() > 0 )
			primaryToSave = mainWeapons[0]
		if ( IsValid( primaryToSave ) )
		{
			primaryNameToSave = primaryToSave.GetWeaponClassName()
			primaryModsToSave = primaryToSave.GetMods()
		}

		// save skin&camo for later we apply to temp weapon
		int skinIndex = -1
		int camoIndex = -1
		if ( IsValid( primaryToSave ) && primary != "" )
		{
			savedLoadout.primary = primaryNameToSave
			savedLoadout.primaryMods = primaryModsToSave
			try { savedLoadout.primaryAmmo = primaryToSave.GetWeaponPrimaryClipCount() } // some weapon don't have clip so try-catch it
			catch (ex) {}
			savedLoadout.primarySkin = primaryToSave.GetSkin()
			savedLoadout.primaryCamo = primaryToSave.GetCamo()

			primaryToSave.Destroy() // so we can take off exact primary weapon
			primarySaved = true // mark as primary saved
		}
		*/
		// reworked version
		array<entity> mainWeapons = guy.GetMainWeapons()
		// if titan already got max 3 weapons we do nothing
		bool shouldGivePrimary = mainWeapons.len() < 3
		// otherwise we store camo stuffs and apply to temp given weapon
		int skinIndex = -1
		int camoIndex = -1
		if ( primary != "" && shouldGivePrimary )
		{
			entity primary
			if ( mainWeapons.len() > 0 )
				primary = mainWeapons[0]
			if ( IsValid( primary ) )
			{
				skinIndex = primary.GetSkin()
				camoIndex = primary.GetCamo()
			}
		}

		// defensive
		entity specialToSave = guy.GetOffhandWeapon( OFFHAND_SPECIAL )
		if ( IsValid( specialToSave ) && special != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_SPECIAL ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_SPECIAL )
			offhandsSaved[ OFFHAND_SPECIAL ] = true // mark as special saved
		}

		// utility
		entity antiRodeoToSave = guy.GetOffhandWeapon( OFFHAND_ANTIRODEO )
		if ( IsValid( antiRodeoToSave ) && antiRodeo != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_ANTIRODEO ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_ANTIRODEO )
			offhandsSaved[ OFFHAND_ANTIRODEO ] = true // mark as special saved
		}

		// ordnance
		entity ordnanceToSave = guy.GetOffhandWeapon( OFFHAND_ORDNANCE )
		if ( IsValid( ordnanceToSave ) && ordnance != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_ORDNANCE ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_ORDNANCE )
			offhandsSaved[ OFFHAND_ORDNANCE ] = true // mark as special saved
		}

		// melee
		entity meleeToSave = guy.GetOffhandWeapon( OFFHAND_MELEE )
		if ( IsValid( meleeToSave ) && melee != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_MELEE ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_MELEE )
			offhandsSaved[ OFFHAND_MELEE ] = true // mark as special saved
		}

		// core
		entity equipmentToSave = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		if ( IsValid( equipmentToSave ) && equipment != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_EQUIPMENT ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_EQUIPMENT )
			offhandsSaved[ OFFHAND_EQUIPMENT ] = true // mark as special saved
		}

		// apply new weapons after certain weapon being taken, or game might crash because of dual smart ammo weapons
		// primary 
		// reworked here: never take off primary weapon. instead, add another weapon for titan to use
		//if ( primary != "" && primarySaved ) // insure we saved primary
		if ( primary != "" && shouldGivePrimary )
		{
			entity newWeapon = guy.GiveWeapon( primary, primaryMods )
			// also apply skin to temp weapon
			// reworked here, we no longer use primary struct
			//newWeapon.SetSkin( savedLoadout.primarySkin )
			//newWeapon.SetCamo( savedLoadout.primaryCamo )
			if ( skinIndex != -1 )
				newWeapon.SetSkin( skinIndex )
			if ( camoIndex != -1 )
				newWeapon.SetSkin( camoIndex )

			// reworked here, we no longer take off existing primary weapon, here we should change to exact weapon slot
			//guy.SetActiveWeaponByName( primary )
			int weaponSlot = guy.GetMainWeapons().find( newWeapon )
			//print( "weaponSlot: " + string( weaponSlot ) )
			guy.SetActiveWeaponBySlot( weaponSlot )
			savedLoadout.replacedPrimaryEnt = newWeapon // for later we clean up
		}
		// defensive
		if ( special != "" && offhandsSaved[ OFFHAND_SPECIAL ] ) // insure we saved special
			guy.GiveOffhandWeapon( special, OFFHAND_SPECIAL, specialMods )
		// utility
		if ( antiRodeo != "" && offhandsSaved[ OFFHAND_ANTIRODEO ] ) // insure we saved antiRodeo
			guy.GiveOffhandWeapon( antiRodeo, OFFHAND_ANTIRODEO, antiRodeoMods )
		// ordnance
		if ( ordnance != "" && offhandsSaved[ OFFHAND_ORDNANCE ] ) // insure we saved ordnance
			guy.GiveOffhandWeapon( ordnance, OFFHAND_ORDNANCE, ordnanceMods )
		// melee
		if ( melee != "" && offhandsSaved[ OFFHAND_MELEE ] ) // insure we saved melee
			guy.GiveOffhandWeapon( melee, OFFHAND_MELEE, meleeMods )
		// core
		if ( equipment != "" && offhandsSaved[ OFFHAND_EQUIPMENT ] ) // insure we saved equipment
			guy.GiveOffhandWeapon( equipment, OFFHAND_EQUIPMENT, equipmentMods )
	}

	// npc loadout saving
	if ( guy.IsNPC() )
	{
		ExecutionSavedLoadout_NPC savedLoadout
		file.titanExecutionSavedLoadout_NPC[ guy ] <- savedLoadout

		// primary weapon
		entity primaryToSave
		string primaryNameToSave
		array<string> primaryModsToSave
		bool primarySaved = false
		array<entity> mainWeapons = guy.GetMainWeapons()
		if ( mainWeapons.len() > 0 )
			primaryToSave = mainWeapons[0]
		if ( IsValid( primaryToSave ) )
		{
			primaryNameToSave = primaryToSave.GetWeaponClassName()
			primaryModsToSave = primaryToSave.GetMods()
		}

		if ( IsValid( primaryToSave ) && primary != "" )
		{
			savedLoadout.primary = primaryNameToSave
			savedLoadout.primaryMods = primaryModsToSave
			try { savedLoadout.primaryAmmo = primaryToSave.GetWeaponPrimaryClipCount() } // some weapon don't have clip so try-catch it
			catch (ex) {}
			savedLoadout.primarySkin = primaryToSave.GetSkin()
			savedLoadout.primaryCamo = primaryToSave.GetCamo()

			primaryToSave.Destroy() // so we can take off exact primary weapon
			primarySaved = true // mark as primary saved
		}

		// defensive
		entity specialToSave = guy.GetOffhandWeapon( OFFHAND_SPECIAL )
		string specialNameToSave
		array<string> specialModsToSave
		bool specialSaved = false
		if ( IsValid( specialToSave ) )
		{
			specialNameToSave = specialToSave.GetWeaponClassName()
			specialModsToSave = specialToSave.GetMods()
		}

		if ( IsValid( specialToSave ) && special != "" )
		{
			savedLoadout.special = specialNameToSave
			savedLoadout.specialMods = specialModsToSave

			guy.TakeOffhandWeapon( OFFHAND_SPECIAL )
			specialSaved = true // mark as special saved
		}

		// utility
		entity antiRodeoToSave = guy.GetOffhandWeapon( OFFHAND_ANTIRODEO )
		string antiRodeoNameToSave
		array<string> antiRodeoModsToSave
		bool antiRodeoSaved = false
		if ( IsValid( antiRodeoToSave ) )
		{
			antiRodeoNameToSave = antiRodeoToSave.GetWeaponClassName()
			antiRodeoModsToSave = antiRodeoToSave.GetMods()
		}

		if ( IsValid( antiRodeoToSave ) && antiRodeo != "" )
		{
			savedLoadout.antiRodeo = antiRodeoNameToSave
			savedLoadout.antiRodeoMods = antiRodeoModsToSave

			guy.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
			antiRodeoSaved = true // mark as antiRodeo saved
		}

		// ordnance
		entity ordnanceToSave = guy.GetOffhandWeapon( OFFHAND_ORDNANCE )
		string ordnanceNameToSave
		array<string> ordnanceModsToSave
		bool ordnanceSaved = false
		if ( IsValid( ordnanceToSave ) )
		{
			ordnanceNameToSave = ordnanceToSave.GetWeaponClassName()
			ordnanceModsToSave = ordnanceToSave.GetMods()
		}

		if ( IsValid( ordnanceToSave ) && ordnance != "" )
		{
			savedLoadout.ordnance = ordnanceNameToSave
			savedLoadout.ordnanceMods = ordnanceModsToSave

			guy.TakeOffhandWeapon( OFFHAND_ORDNANCE )
			ordnanceSaved = true // mark as ordnance saved
		}

		// melee
		entity meleeToSave = guy.GetOffhandWeapon( OFFHAND_MELEE )
		string meleeNameToSave
		array<string> meleeModsToSave
		bool meleeSaved = false
		if ( IsValid( meleeToSave ) )
		{
			meleeNameToSave = meleeToSave.GetWeaponClassName()
			meleeModsToSave = meleeToSave.GetMods()
		}

		if ( IsValid( meleeToSave ) && melee != "" )
		{
			savedLoadout.melee = meleeNameToSave
			savedLoadout.meleeMods = meleeModsToSave

			guy.TakeOffhandWeapon( OFFHAND_MELEE )
			meleeSaved = true // mark as melee saved
		}

		// core
		entity equipmentToSave = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		string equipmentNameToSave
		array<string> equipmentModsToSave
		bool equipmentSaved = false
		if ( IsValid( equipmentToSave ) )
		{
			equipmentNameToSave = equipmentToSave.GetWeaponClassName()
			equipmentModsToSave = equipmentToSave.GetMods()
		}

		if ( IsValid( equipmentToSave ) && equipment != "" )
		{
			savedLoadout.equipment = equipmentNameToSave
			savedLoadout.equipmentMods = equipmentModsToSave

			guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
			equipmentSaved = true // mark as equipment saved
		}

		if ( equipment != "" )
		{
			entity weapon = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
			if ( IsValid( weapon ) )
			{
				savedLoadout.equipment = weapon.GetWeaponClassName()
				savedLoadout.equipmentMods = weapon.GetMods()

				guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
			}
		}

		// apply new weapons after certain weapon being taken, or game might crash because of dual smart ammo weapons
		// primary 
		if ( primary != "" && primarySaved ) // insure we saved primary
		{
			entity newWeapon = guy.GiveWeapon( primary, primaryMods )
			// also apply skin to temp weapon
			newWeapon.SetSkin( savedLoadout.primarySkin )
			newWeapon.SetCamo( savedLoadout.primaryCamo )
			guy.SetActiveWeaponByName( primary )
			savedLoadout.replacedPrimaryEnt = newWeapon // for later we clean up
		}
		// defensive
		if ( special != "" && specialSaved ) // insure we saved special
			guy.GiveOffhandWeapon( special, OFFHAND_SPECIAL, specialMods )
		// utility
		if ( antiRodeo != "" && antiRodeoSaved ) // insure we saved antiRodeo
			guy.GiveOffhandWeapon( antiRodeo, OFFHAND_ANTIRODEO, antiRodeoMods )
		// ordnance
		if ( ordnance != "" && ordnanceSaved ) // insure we saved ordnance
			guy.GiveOffhandWeapon( ordnance, OFFHAND_ORDNANCE, ordnanceMods )
		// melee
		if ( melee != "" && meleeSaved ) // insure we saved melee
			guy.GiveOffhandWeapon( melee, OFFHAND_MELEE, meleeMods )
		// core
		if ( equipment != "" && equipmentSaved ) // insure we saved equipment
			guy.GiveOffhandWeapon( equipment, OFFHAND_EQUIPMENT, equipmentMods )

		// debug prints
		/*
		print( "primarySaved: " + string( primarySaved ) )
		print( "specialSaved: " + string( specialSaved ) )
		print( "antiRodeoSaved: " + string( antiRodeoSaved ) )
		print( "ordnanceSaved: " + string( ordnanceSaved ) )
		print( "meleeSaved: " + string( meleeSaved ) )
		print( "equipmentSaved: " + string( equipmentSaved ) )
		*/
	}

	OnThreadEnd
	(
		function(): ( guy )
		{
			if ( IsValid( guy ) )
			{
				// player loadout restoring
				if ( guy.IsPlayer() )
				{
					ExecutionSavedLoadout savedLoadout = file.titanExecutionSavedLoadout[ guy ]
					// restore weapons
					// primary 
					// reworked here: never take off primary weapon. instead, add another weapon for titan to use
					/*
					if ( savedLoadout.primary != "" ) // do savedast primary
					{
						entity replacedWeapon = savedLoadout.replacedPrimaryEnt
						if ( IsValid( replacedWeapon ) )
							replacedWeapon.Destroy() // so we can take off exact primary weapon
						entity newWeapon = guy.GiveWeapon( savedLoadout.primary, savedLoadout.primaryMods )
						guy.SetActiveWeaponByName( savedLoadout.primary )
						newWeapon.SetSkin( savedLoadout.primarySkin )
						newWeapon.SetCamo( savedLoadout.primaryCamo )
						RemoveInvalidModsForWeapon( newWeapon ) // remove mods that shouldn't be retained through execution
						try { newWeapon.SetWeaponPrimaryClipCount( savedLoadout.primaryAmmo ) } // some weapon don't have clip so try-catch it
						catch (ex) {}
					}
					*/

					// store all replaced weapons
					array<string> weaponsGotReplaced

					entity replacedWeapon = savedLoadout.replacedPrimaryEnt
					if ( IsValid( replacedWeapon ) ) // do have replacement weapon?
					{
						// if replacement weapon is valid it must means we have changed active weapon
						replacedWeapon.Destroy() // so we can take off exact primary weapon
						guy.SetActiveWeaponBySlot( 0 ) // change back to primary weapon!
						// primary weapon is no need to update mods because they're always in titan's hand

						// store primary weapon's name
						array<entity> mainWeapons = guy.GetMainWeapons()
						if ( mainWeapons.len() > 0 )
						{
							entity primaryWeapon = mainWeapons[0]
							if ( IsValid( primaryWeapon ) )
								weaponsGotReplaced.append( primaryWeapon.GetWeaponClassName() )
						}
					}
					
					// offhand weapons
					bool updatedOffhand = false
					for ( int i = 0; i < OFFHAND_COUNT; i++ )
					{
						entity previousOffhand = savedLoadout.savedOffhandWeaponEnts[ i ]
						if ( IsValid( previousOffhand ) )
						{
							// if previousOffhand valid it means we've replaced them
							// restore weapon
							guy.TakeOffhandWeapon( i )
							guy.GiveExistingOffhandWeapon( previousOffhand, i )
							RemoveInvalidModsForWeapon( previousOffhand ) // remove mods that shouldn't be retained through execution
						
							// store offhand weapon's name
							weaponsGotReplaced.append( previousOffhand.GetWeaponClassName() )
						}
					}

					// restoring succeeded! delete from table
					delete file.titanExecutionSavedLoadout[ guy ]

					// try to update titan cockpit visibility stuffs
					// so we won't have issue showing weapon specific huds( like ion energy bar or tone lock-on icon )
					if ( TitanRequiresHudVisibilityUpdate( guy, weaponsGotReplaced ) )
						thread UpdateCockpitRUIVisbility( guy )
				}

				// npc loadout restoring
				if ( guy.IsNPC() )
				{
					ExecutionSavedLoadout_NPC savedLoadout = file.titanExecutionSavedLoadout_NPC[ guy ]
					// restore weapons
					// primary 
					if ( savedLoadout.primary != "" ) // do savedast primary
					{
						entity replacedWeapon = savedLoadout.replacedPrimaryEnt
						if ( IsValid( replacedWeapon ) )
							replacedWeapon.Destroy() // so we can take off exact primary weapon
						entity newWeapon = guy.GiveWeapon( savedLoadout.primary, savedLoadout.primaryMods )
						guy.SetActiveWeaponByName( savedLoadout.primary )
						newWeapon.SetSkin( savedLoadout.primarySkin )
						newWeapon.SetCamo( savedLoadout.primaryCamo )
						try { newWeapon.SetWeaponPrimaryClipCount( savedLoadout.primaryAmmo ) } // some weapon don't have clip so try-catch it
						catch (ex) {}
						RemoveInvalidModsForWeapon( newWeapon ) // remove mods that shouldn't be retained after loadout replace
					}
					// defensive
					if ( savedLoadout.special != "" ) // do saved defensive
					{
						guy.TakeOffhandWeapon( OFFHAND_SPECIAL )
						guy.GiveOffhandWeapon( savedLoadout.special, OFFHAND_SPECIAL, savedLoadout.specialMods )
						RemoveInvalidModsForWeapon( guy.GetOffhandWeapon( OFFHAND_SPECIAL ) ) // remove mods that shouldn't be retained after loadout replace
					}
					// utility
					if ( savedLoadout.antiRodeo != "" ) // do saved utility
					{
						guy.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
						guy.GiveOffhandWeapon( savedLoadout.antiRodeo, OFFHAND_ANTIRODEO, savedLoadout.antiRodeoMods )
						RemoveInvalidModsForWeapon( guy.GetOffhandWeapon( OFFHAND_ANTIRODEO ) ) // remove mods that shouldn't be retained after loadout replace
					}
					// ordnance
					if ( savedLoadout.ordnance != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_ORDNANCE )
						guy.GiveOffhandWeapon( savedLoadout.ordnance, OFFHAND_ORDNANCE, savedLoadout.ordnanceMods )
						RemoveInvalidModsForWeapon( guy.GetOffhandWeapon( OFFHAND_ORDNANCE ) ) // remove mods that shouldn't be retained after loadout replace
					}
					// melee
					if ( savedLoadout.melee != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_MELEE )
						guy.GiveOffhandWeapon( savedLoadout.melee, OFFHAND_MELEE, savedLoadout.meleeMods )
						RemoveInvalidModsForWeapon( guy.GetOffhandWeapon( OFFHAND_MELEE ) ) // remove mods that shouldn't be retained after loadout replace
					}
					// core
					if ( savedLoadout.equipment != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
						guy.GiveOffhandWeapon( savedLoadout.equipment, OFFHAND_EQUIPMENT, savedLoadout.equipmentMods )
						RemoveInvalidModsForWeapon( guy.GetOffhandWeapon( OFFHAND_EQUIPMENT ) ) // remove mods that shouldn't be retained after loadout replace
					}

					// restoring succeeded! delete from table
					delete file.titanExecutionSavedLoadout_NPC[ guy ]
				}
			}
		}
	)

	guy.EndSignal( "OnDestroy" )
	guy.EndSignal( "OnDeath" )
	// signals from FirstPersonSequence()
	//guy.EndSignal( "NewFirstPersonSequence" ) // this gets called later in execution FirstPersonSequence(), which will stop current thread!
	guy.EndSignal( "ScriptAnimStop" )
	guy.WaitSignal( "SyncedMeleeComplete" ) // attacker's signal
}

// hud visibility update: refresh 
void function UpdateCockpitRUIVisbility( entity player )
{
	if ( !player.IsPlayer() )
		return

	player.Signal( "UpdateCockpitRUI" )
    player.EndSignal( "UpdateCockpitRUI" )
    player.EndSignal( "OnDestroy" )

	wait 0.5 // wait for cinematic flag from execution to end
    if ( !HasCinematicFlag( player, CE_FLAG_TITAN_3P_CAM ) )
        AddCinematicFlag( player, CE_FLAG_TITAN_3P_CAM )

    wait 0.5 // give it enough time for refreshing
    if ( HasCinematicFlag( player, CE_FLAG_TITAN_3P_CAM ) )
        RemoveCinematicFlag( player, CE_FLAG_TITAN_3P_CAM )
}

// utility!
void function MeleeSyncedTitan_AddExecutionRefCallback( string ref, void functionref( entity, entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefCallbacks ) )
		file.titanExecutionRefCallbacks[ ref ] <- [] // init
	if ( !file.titanExecutionRefCallbacks[ ref ].contains( callbackFunc ) )
		file.titanExecutionRefCallbacks[ ref ].append( callbackFunc )
}

bool function MeleeSyncedTitan_ExecutionRefHasCallback( string ref )
{
	//PrintFunc()
	if ( ref in file.titanExecutionRefCallbacks )
	{
		//print( "ref has executionCallback!" )
		return true
	}
	return false
}

void function MeleeSyncedTitan_RunCallbacksForRef( string ref, entity attacker, entity target )
{
	if ( !MeleeSyncedTitan_ExecutionRefHasCallback( ref ) )
		return
	//PrintFunc()
	foreach ( void functionref( entity, entity ) callbackFunc in file.titanExecutionRefCallbacks[ ref ] )
		callbackFunc( attacker, target )
}

void function MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( string ref, void functionref( entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) )
		file.titanExecutionRefLoadoutReplaceCallback[ ref ] <- callbackFunc
	else
		file.titanExecutionRefLoadoutReplaceCallback[ ref ] = callbackFunc
}

void function MeleeSyncedTitan_SetExecutionRefShouldDoLoadoutReplaceCallback( string ref, bool functionref( entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefShouldReplaceLoadoutCallback ) )
		file.titanExecutionRefShouldReplaceLoadoutCallback[ ref ] <- callbackFunc
	else
		file.titanExecutionRefShouldReplaceLoadoutCallback[ ref ] = callbackFunc
}

// utility
bool function MeleeSyncedTitan_TitanShouldDoLoadoutReplaceForRef( entity titan, string ref )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) ) // this ref doesn't require weapons
		return false // default case is don't replace
		
	// callback case
	if ( ref in file.titanExecutionRefShouldReplaceLoadoutCallback )
		return file.titanExecutionRefShouldReplaceLoadoutCallback[ ref ]( titan )

	return true // default case is we do loadout replace for any inited ref
}

bool function MeleeSyncedTitan_ExecutionRefHasLoadoutReplaceCallback( string ref )
{
	//PrintFunc()
	if ( ref in file.titanExecutionRefLoadoutReplaceCallback )
	{
		//print( "ref has executionCallback!" )
		return true
	}
	return false
}

void function MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef( string ref, entity attacker )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) )
		return
	//PrintFunc()
	file.titanExecutionRefLoadoutReplaceCallback[ ref ]( attacker )
}

void function MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( string mod )
{
	if ( !file.modsToRemoveOnLoadoutReplace.contains( mod ) )
		file.modsToRemoveOnLoadoutReplace.append( mod )
}

void function RemoveInvalidModsForWeapon( entity weapon )
{
	if ( !IsValid( weapon ) ) // anti-crash for whatever
		return
	
	array<string> mods = weapon.GetMods()
    array<string> replaceArray
    foreach( string mod in mods )
    {
        if ( file.modsToRemoveOnLoadoutReplace.contains( mod ) ) // skip illegal mod
            continue

        replaceArray.append( mod )
    }

	weapon.SetMods( replaceArray )
}

void function MeleeSyncedTitan_AddWeaponRequiresHudVisibilityUpdate( string weaponName )
{
	if ( !file.weaponsRequireHudVisibilityUpdate.contains( weaponName ) )
		file.weaponsRequireHudVisibilityUpdate.append( weaponName )
}

bool function TitanRequiresHudVisibilityUpdate( entity titan, array<string> weaponsGotReplaced )
{
	foreach ( weaponName in weaponsGotReplaced )
	{
		if ( file.weaponsRequireHudVisibilityUpdate.contains( weaponName ) )
			return true
	}
	
	return false
}

void function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Attacker( string chassis, string executionRef )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Attacker ) )
		file.chassisValidExecutionRefs_Attacker[ chassis ] <- []
	if ( !file.chassisValidExecutionRefs_Attacker[ chassis ].contains( executionRef ) )
		file.chassisValidExecutionRefs_Attacker[ chassis ].append( executionRef )
}

// note that if a titan's victim valid execution array is empty
// it means they can be executed by all executions
void function MeleeSyncedTitan_RegisterChassisValidExecutionRef_Victim( string chassis, string executionRef )
{
	if ( !( chassis in file.chassisValidExecutionRefs_Victim ) )
		file.chassisValidExecutionRefs_Victim[ chassis ] <- []
	if ( !file.chassisValidExecutionRefs_Victim[ chassis ].contains( executionRef ) )
		file.chassisValidExecutionRefs_Victim[ chassis ].append( executionRef )
}

void function MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( string characterName, string executionRef )
{
	if ( !( characterName in file.titanCharacterSpecificExecutionRefs ) )
		file.titanCharacterSpecificExecutionRefs[ characterName ] <- []
	if ( !file.titanCharacterSpecificExecutionRefs[ characterName ].contains( executionRef ) )
		file.titanCharacterSpecificExecutionRefs[ characterName ].append( executionRef )
}
#endif