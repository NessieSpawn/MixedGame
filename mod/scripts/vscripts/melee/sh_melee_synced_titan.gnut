untyped

global function MeleeSyncedTitanShared_Init

// modified here, we add more execution settings
#if SERVER
global function MeleeSyncedTitan_AddExecutionRefCallback
global function MeleeSyncedTitan_ExecutionRefHasCallback
global function MeleeSyncedTitan_RunCallbacksForRef // shared with _melee_synced_titan.gnut

global function MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback
global function MeleeSyncedTitan_ExecutionRefHasLoadoutReplaceCallback
global function MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef // shared with _melee_synced_titan.gnut
global function MeleeSyncedTitan_ReplaceExecutionAttackerLoadout // called by default loadout replace callbacks

// register some settings here
global function MeleeSyncedTitan_RegisterChassisSpecificExecutionRef
global function MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef

// shared with _melee_synced_titan.gnut
global function MeleeSyncedTitan_GetBestExecutionRefForTitan
global function MeleeSyncedTitan_GetRandomExecutionRefForTitan

// mostly for ability or core weapon mods. remove them when loadout replacing
// currently used for titan_replace.gnut
global function MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace

struct ExecutionSavedLoadout
{
	// can't just store a primary weapon entity, as TakeWeapon_NoDelete() will leave a weapon model in titan's hand
	string primary = "" // primary weapon
	array<string> primaryMods = []
	int primaryAmmo
	int primarySkin
	int primaryCamo

	entity replacedPrimaryEnt

	table<int, entity> savedOffhandWeaponEnts
}

// npc specific loadout saving
// TakeOffhandWeapon_NoDelete() can't be used on npcs
// they'll still consider these weapon in their inventory
// causes crash of having multiple weapons at same usage
struct ExecutionSavedLoadout_NPC
{
	string primary = "" // primary weapon
	array<string> primaryMods = []
	int primaryAmmo
	int primarySkin
	int primaryCamo
	entity replacedPrimaryEnt = null

	string special = "" // defensive
	array<string> specialMods = []

	string antiRodeo = "" // utility
	array<string> antiRodeoMods = []

	string ordnance = "" // ordnance
	array<string> ordnanceMods = []

	string melee = "" // melee
	array<string> meleeMods = []

	string equipment = "" // core
	array<string> equipmentMods = []
}

// modified settings struct
struct
{
	table< string, array<void functionref( entity, entity )> > titanExecutionRefCallbacks
	table< string, void functionref( entity ) > titanExecutionRefLoadoutReplaceCallback
	table<entity, ExecutionSavedLoadout> titanExecutionSavedLoadout
	table<entity, ExecutionSavedLoadout_NPC> titanExecutionSavedLoadout_NPC

	array<string> modsToRemoveOnLoadoutReplace

	table< string, array<string> > chassisSpecificExecutionRefs
	table< string, array<string> > titanCharacterSpecificExecutionRefs
} file
#endif

function MeleeSyncedTitanShared_Init()
{
	SyncedMeleeChooser chooser = CreateSyncedMeleeChooser( "titan", "titan" )

	chooser.displayMeleePrompt = false

	#if SERVER
		MeleeSyncedTitan_Init()

		// modified here, we add more execution settings
		RegisterSignal( "ReplaceExecutionAttackerLoadout" )
		MeleeSyncedTitan_InitDefaultSpecificExecutionRefs()
		MeleeSyncedTitan_InitDefaultRefCallbacks()
	#endif

	SyncedMelee action
	action.direction = Vector( 1, 0, 0 )
	action.distance = TITAN_EXECUTION_RANGE
	action.isAttackerRef = false

	AddSyncedMelee( chooser, action )
}

// modified here, we add more execution settings
#if SERVER
void function MeleeSyncedTitan_InitDefaultSpecificExecutionRefs()
{
	// atlas chassis executions
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "atlas", "execution_ion" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "atlas", "execution_ion_prime" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "atlas", "execution_tone" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "atlas", "execution_tone_prime" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "atlas", "execution_vanguard" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "atlas", "execution_vanguard_kit" )

	// BT executions
	//MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "buddy", "execution_bt" ) // shouldn't be handled here. "execution_bt" is already a random execution handled by TitanVsTitan_3p()
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "buddy", "execution_bt_flip" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "buddy", "execution_bt_pilotrip" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "buddy", "execution_bt_kickshoot" )

	// stryder chassis executions
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "stryder", "execution_ronin" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "stryder", "execution_ronin_prime" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "stryder", "execution_northstar" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "stryder", "execution_northstar_prime" )

	// ogre chassis executions
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "ogre", "execution_scorch" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "ogre", "execution_scorch_prime" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "ogre", "execution_legion" )
	MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( "ogre", "execution_legion_prime" )

	// ion character executions
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ion", "execution_ion" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ion", "execution_ion_prime" )

	// tone character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "tone", "execution_tone" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "tone", "execution_tone_prime" )

	// monarch character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "vanguard", "executvanguard_vanguard" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "vanguard", "executvanguard_vanguard_kit" )

	// ronin character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ronin", "executronin_ronin" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "ronin", "executronin_ronin_prime" )

	// northstar character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "northstar", "execution_northstar" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "northstar", "execution_northstar_prime" )

	// scorch character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "scorch", "execution_scorch" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "scorch", "execution_scorch_prime" )

	// legion character
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "legion", "execution_legion" )
	MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( "legion", "execution_legion_prime" )
}

// default execution callbacks
void function MeleeSyncedTitan_InitDefaultRefCallbacks()
{
	/* // note:
		execution_northstar_prime, 
		execution_scorch_prime, 
		execution_vanguard, 
		execution_vanguard_kit,
		execution_bt_pilotrip, 
		execution_bt_flip,
		these executions don't use weapons
	*/

	// ION
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ion", Execution_Ion )
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ion_prime", Execution_Ion_Prime )
	// TONE
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_tone", Execution_Tone )
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_tone_prime", Execution_Tone_Prime )
	// RONIN
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ronin", Execution_Ronin )
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_ronin_prime", Execution_Ronin_Prime )
	// NORTHSTAR
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_northstar", Execution_Northstar )
	// LEGION
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_legion", Execution_Legion )
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_legion_prime", Execution_Legion_Prime )
	// SCORCH
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_scorch", Execution_Scorch )
	// BT
	MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( "execution_bt_kickshoot", Execution_BT_KickShoot )
}

void function Execution_Ion( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_particle_accelerator", [],
		"", [],		// "mp_titanweapon_vortex_shield_ion", won't use during execution
		"", [],		// "mp_titanability_laser_trip", won't use during execution
		"mp_titanweapon_laser_lite", [],
		"", [],		// "melee_titan_punch_ion", won't use during execution
		"", []		// "mp_titancore_laser_cannon", won't use during execution
	)
}

void function Execution_Ion_Prime( entity attacker )
{
	string coreWeapon = ""
	if ( attacker.IsPlayer() ) // saved for npc execution condition: never fire a lasercannon
		coreWeapon = "mp_titancore_laser_cannon"

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_particle_accelerator", won't use during execution
		"", [],		// "mp_titanweapon_vortex_shield_ion", won't use during execution
		"", [],		// "mp_titanability_laser_trip", won't use during execution
		"mp_titanweapon_laser_lite", [],
		"", [],		// "melee_titan_punch_ion", won't use during execution
		coreWeapon, []
	)
}

void function Execution_Tone( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sticky_40mm", [],
		"", [],		// "mp_titanaility_particle_wall", won't use during execution
		"", [],		// "mp_titanability_sonar_pulse", won't use during execution
		"", [],		// "mp_titanweapon_tracker_rockets", won't use during execution
		"", [],		// "melee_titan_punch_tobe", won't use during execution
		"", []		// "mp_titancore_salvo_core", won't use during execution
	)
}

void function Execution_Tone_Prime( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sticky_40mm", [],
		"", [],		// "mp_titanaility_particle_wall", won't use during execution
		"", [],		// "mp_titanability_sonar_pulse", won't use during execution
		"", [],		// mp_titanweapon_tracker_rockets, execution actually plays particle effect but not firing weapon
		"", [],		// "melee_titan_punch_tone", won't use during execution
		"", []		// "mp_titancore_salvo_core", won't use during execution
	)
}

void function Execution_Ronin( entity attacker )
{
	// prime sword check
	array<string> meleeMods = []
	entity soul = attacker.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanLoadoutDef loadout = soul.soul.titanLoadout
		if ( loadout.isPrime == "titan_is_prime" )
			meleeMods.append( "modelset_prime" )
	}

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_leadwall", won't use during execution
		"", [],		// "mp_titanability_basic_block", won't use during execution
		"", [],		// "mp_titanability_phase_dash", won't use during execution
		"", [],		// "mp_titanweapon_arc_wave", won't use during execution
		"melee_titan_sword", meleeMods,
		"", []		// "mp_titancore_shift_core", won't use during execution
	)
}

void function Execution_Ronin_Prime( entity attacker )
{
	// prime sword check
	array<string> meleeMods = []
	entity soul = attacker.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		TitanLoadoutDef loadout = soul.soul.titanLoadout
		if ( loadout.isPrime == "titan_is_prime" )
			meleeMods.append( "modelset_prime" )
	}

	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_leadwall", won't use during execution
		"", [],		// "mp_titanability_basic_block", won't use during execution
		"", [],		// "mp_titanability_phase_dash", won't use during execution
		"", [],		// "mp_titanweapon_arc_wave", execution actually plays particle effect but not firing weapon
		"melee_titan_sword", meleeMods,
		"", []		// "mp_titancore_shift_core", won't use during execution
	)
}

void function Execution_Northstar( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_sniper", [],
		"", [],		// "mp_titanability_tether_trap", won't use during execution
		"", [],		// "mp_titanability_hover", won't use during execution
		"", [],		// "mp_titanweapon_dumbfire_rockets", won't use during execution
		"", [],		// "melee_titan_punch_northstar", won't use during execution
		"", []		// "mp_titancore_flight_core", won't use during execution
	)
}

void function Execution_Legion( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_predator_cannon", [],
		"mp_titanability_gun_shield", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_ammo_swap", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_power_shot", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"", [],		// "melee_titan_punch_legion", won't use during execution
		"mp_titancore_siege_mode", []			// won't use during execution, but is required for overwriting other smart ammo weapons
	)
}

void function Execution_Legion_Prime( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"mp_titanweapon_predator_cannon", [],
		"mp_titanability_gun_shield", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_ammo_swap", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"mp_titanability_power_shot", [],		// won't use during execution, but is required for overwriting other smart ammo weapons
		"", [],		// "melee_titan_punch_legion", won't use during execution
		"mp_titancore_siege_mode", []			// won't use during execution, but is required for overwriting other smart ammo weapons
	)
}

void function Execution_Scorch( entity attacker )
{
	MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( 
		attacker, 
		"", [],		// "mp_titanweapon_meteor", won't use during execution
		"mp_titanweapon_heat_shield", [], // not sure if this weapon gets used
		"", [],		// "mp_titanability_slow_trap", won't use during execution
		"", [],		// "mp_titanweapon_flame_wall", won't use during execution
		"", [],		// "melee_titan_punch_scorch", won't use during execution
		"", []		// "mp_titancore_flame_wave", won't use during execution
	)
}

void function Execution_BT_KickShoot( entity attacker )
{
	string xo16 = "mp_titanweapon_xo16_shorty"
	entity xo16Weapon
	array<entity> weapons = attacker.GetMainWeapons()
	if ( weapons.len() > 0 )
	{
		// fakebt version, it has multiple main weapons so do more checks
		// this version allowing bt to use any active weapon, requires refilling ammo
		attacker.ClearOffhand() // so they will switch to last main weapon
		entity activeWeapon = attacker.GetActiveWeapon()
		if ( IsValid( activeWeapon ) && !activeWeapon.IsWeaponOffhand() ) // try to use active main weapon
		{
			// have to try-catch this since not all main weapons can use weapon clip
			try { activeWeapon.SetWeaponPrimaryClipCount( activeWeapon.GetWeaponPrimaryClipCountMax() ) }
			catch( ex ){}
		}
		else // can't find active weapon, try to find xo16
		{
			foreach ( entity weapon in weapons )
			{
				if ( weapon.GetWeaponClassName() == xo16 )
				{
					xo16Weapon = weapon
					break
				}
			}
			if ( IsValid( xo16Weapon ) )
			{
				attacker.SetActiveWeaponByName( xo16 )
				xo16Weapon.SetWeaponPrimaryClipCount( xo16Weapon.GetWeaponPrimaryClipCountMax() ) // don't want to make bt reload while executing
			}

			if ( !IsValid( xo16Weapon ) ) // can't find xo16
				MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( attacker, xo16 )
		}
	}
}

// utility
string function MeleeSyncedTitan_GetBestExecutionRefForTitan( entity titan, string forcedRef = "" )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	// search for best execution ref
	string executionRef = soul.soul.titanLoadout.titanExecution
	if ( forcedRef != "" )
		executionRef = forcedRef
	
	// chassis check
	// execution is good enough if we have our chassis specific one
	string titanChassis = GetSoulTitanSubClass( soul )
	array<string> chassisExecutions = GetChassisSpecificExecutions( titanChassis )
	if ( chassisExecutions.contains( executionRef ) )
		return executionRef // safe to use!

	// bad chassis execution happening... we pick a best one from our character!
	string titanCharacter = GetTitanCharacterName( titan )
	array<string> characterExecutions = GetCharacterSpecificExecutions( titanCharacter )
	foreach ( string otherRef in characterExecutions )
	{
		// we can at least find one!
		if ( TitanExecutionRefIsPrime( executionRef ) && TitanExecutionRefIsPrime( otherRef ) )
			return otherRef
		else
			return otherRef
	}

	// nothing can be done here... the game might crush
	return executionRef
}

bool function TitanExecutionRefIsPrime( string ref )
{
	// _kit suffix is hardcoded for monarch
	bool isPrimeRef = ( ref.find( "_prime" ) != null ) || ( ref.find( "_kit" ) != null ) 
	print( "TitanExecutionRefIsPrime( " + ref + " ) : " + string( isPrimeRef ) )
	return isPrimeRef
}

// random execution ref: pick anything that is valid for current chassis
string function MeleeSyncedTitan_GetRandomExecutionRefForTitan( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string titanChassis = GetSoulTitanSubClass( soul )
	array<string> validExecutions = GetChassisSpecificExecutions( titanChassis )
	if ( validExecutions.len() > 0 )
		return validExecutions[ RandomInt( validExecutions.len() ) ]
	
	// default value
	return soul.soul.titanLoadout.titanExecution
}

array<string> function GetChassisSpecificExecutions( string chassis )
{
	if ( !( chassis in file.chassisSpecificExecutionRefs ) )
		return []
	return file.chassisSpecificExecutionRefs[ chassis ]
}

array<string> function GetCharacterSpecificExecutions( string characterName )
{
	if ( !( characterName in file.titanCharacterSpecificExecutionRefs ) )
		return []
	return file.titanCharacterSpecificExecutionRefs[ characterName ]
}

// called by default loadout replace callbacks
void function MeleeSyncedTitan_ReplaceExecutionAttackerLoadout( entity guy, string primary = "", array<string> primaryMods = [], string special = "", array<string> specialMods = [], string antiRodeo = "", array<string> antiRodeoMods = [], string ordnance = "", array<string> ordnanceMods = [], string melee = "", array<string> meleeMods = [], string equipment = "", array<string> equipmentMods = [] )
{
	thread ReplaceExecutionAttackerLoadout_Threaded( guy, primary, primaryMods, special, specialMods, antiRodeo, antiRodeoMods, ordnance, ordnanceMods, melee, meleeMods, equipment, equipmentMods )
}

void function ReplaceExecutionAttackerLoadout_Threaded( entity guy, string primary = "", array<string> primaryMods = [], string special = "", array<string> specialMods = [], string antiRodeo = "", array<string> antiRodeoMods = [], string ordnance = "", array<string> ordnanceMods = [], string melee = "", array<string> meleeMods = [], string equipment = "", array<string> equipmentMods = [] )
{
	guy.Signal( "ReplaceExecutionAttackerLoadout" )
	guy.EndSignal( "ReplaceExecutionAttackerLoadout" )

	// player loadout saving
	if ( guy.IsPlayer() )
	{
		ExecutionSavedLoadout savedLoadout
		file.titanExecutionSavedLoadout[ guy ] <- savedLoadout

		bool primarySaved = false
		table<int, bool> offhandsSaved
		// init offhand weapons data
		for ( int i = 0; i < OFFHAND_COUNT; i++ )
		{
			savedLoadout.savedOffhandWeaponEnts[ i ] <- null
			offhandsSaved[ i ] <- false
		}

		// first we take all weapons
		// primary weapon
		entity primaryToSave
		string primaryNameToSave
		array<string> primaryModsToSave
		array<entity> mainWeapons = guy.GetMainWeapons()
		if ( mainWeapons.len() > 0 )
			primaryToSave = mainWeapons[0]
		if ( IsValid( primaryToSave ) )
		{
			primaryNameToSave = primaryToSave.GetWeaponClassName()
			primaryModsToSave = primaryToSave.GetMods()
		}

		// save skin&camo for later we apply to temp weapon
		int skinIndex = -1
		int camoIndex = -1
		if ( IsValid( primaryToSave ) && primary != "" )
		{
			savedLoadout.primary = primaryNameToSave
			savedLoadout.primaryMods = primaryModsToSave
			try { savedLoadout.primaryAmmo = primaryToSave.GetWeaponPrimaryClipCount() } // some weapon don't have clip so try-catch it
			catch (ex) {}
			savedLoadout.primarySkin = primaryToSave.GetSkin()
			savedLoadout.primaryCamo = primaryToSave.GetCamo()

			primaryToSave.Destroy() // so we can take off exact primary weapon
			primarySaved = true // mark as primary saved
		}

		// defensive
		entity specialToSave = guy.GetOffhandWeapon( OFFHAND_SPECIAL )
		if ( IsValid( specialToSave ) && special != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_SPECIAL ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_SPECIAL )
			offhandsSaved[ OFFHAND_SPECIAL ] = true // mark as special saved
		}

		// utility
		entity antiRodeoToSave = guy.GetOffhandWeapon( OFFHAND_ANTIRODEO )
		if ( IsValid( antiRodeoToSave ) && antiRodeo != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_ANTIRODEO ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_ANTIRODEO )
			offhandsSaved[ OFFHAND_ANTIRODEO ] = true // mark as special saved
		}

		// ordnance
		entity ordnanceToSave = guy.GetOffhandWeapon( OFFHAND_ORDNANCE )
		if ( IsValid( ordnanceToSave ) && ordnance != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_ORDNANCE ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_ORDNANCE )
			offhandsSaved[ OFFHAND_ORDNANCE ] = true // mark as special saved
		}

		// melee
		entity meleeToSave = guy.GetOffhandWeapon( OFFHAND_MELEE )
		if ( IsValid( meleeToSave ) && melee != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_MELEE ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_MELEE )
			offhandsSaved[ OFFHAND_MELEE ] = true // mark as special saved
		}

		// core
		entity equipmentToSave = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		if ( IsValid( equipmentToSave ) && equipment != "" )
		{
			savedLoadout.savedOffhandWeaponEnts[ OFFHAND_EQUIPMENT ] = guy.TakeOffhandWeapon_NoDelete( OFFHAND_EQUIPMENT )
			offhandsSaved[ OFFHAND_EQUIPMENT ] = true // mark as special saved
		}

		// apply new weapons after certain weapon being taken, or game might crash because of dual smart ammo weapons
		// primary 
		if ( primary != "" && primarySaved ) // insure we saved primary
		{
			entity newWeapon = guy.GiveWeapon( primary, primaryMods )
			// also apply skin to temp weapon
			newWeapon.SetSkin( savedLoadout.primarySkin )
			newWeapon.SetCamo( savedLoadout.primaryCamo )

			guy.SetActiveWeaponByName( primary )
			savedLoadout.replacedPrimaryEnt = newWeapon // for later we clean up
		}
		// defensive
		if ( special != "" && offhandsSaved[ OFFHAND_SPECIAL ] ) // insure we saved special
			guy.GiveOffhandWeapon( special, OFFHAND_SPECIAL, specialMods )
		// utility
		if ( antiRodeo != "" && offhandsSaved[ OFFHAND_ANTIRODEO ] ) // insure we saved antiRodeo
			guy.GiveOffhandWeapon( antiRodeo, OFFHAND_ANTIRODEO, antiRodeoMods )
		// ordnance
		if ( ordnance != "" && offhandsSaved[ OFFHAND_ORDNANCE ] ) // insure we saved ordnance
			guy.GiveOffhandWeapon( ordnance, OFFHAND_ORDNANCE, ordnanceMods )
		// melee
		if ( melee != "" && offhandsSaved[ OFFHAND_MELEE ] ) // insure we saved melee
			guy.GiveOffhandWeapon( melee, OFFHAND_MELEE, meleeMods )
		// core
		if ( equipment != "" && offhandsSaved[ OFFHAND_EQUIPMENT ] ) // insure we saved equipment
			guy.GiveOffhandWeapon( equipment, OFFHAND_EQUIPMENT, equipmentMods )
	}

	// npc loadout saving
	if ( guy.IsNPC() )
	{
		ExecutionSavedLoadout_NPC savedLoadout
		file.titanExecutionSavedLoadout_NPC[ guy ] <- savedLoadout

		// primary weapon
		entity primaryToSave
		string primaryNameToSave
		array<string> primaryModsToSave
		bool primarySaved = false
		array<entity> mainWeapons = guy.GetMainWeapons()
		if ( mainWeapons.len() > 0 )
			primaryToSave = mainWeapons[0]
		if ( IsValid( primaryToSave ) )
		{
			primaryNameToSave = primaryToSave.GetWeaponClassName()
			primaryModsToSave = primaryToSave.GetMods()
		}

		if ( IsValid( primaryToSave ) && primary != "" )
		{
			savedLoadout.primary = primaryNameToSave
			savedLoadout.primaryMods = primaryModsToSave
			try { savedLoadout.primaryAmmo = primaryToSave.GetWeaponPrimaryClipCount() } // some weapon don't have clip so try-catch it
			catch (ex) {}
			savedLoadout.primarySkin = primaryToSave.GetSkin()
			savedLoadout.primaryCamo = primaryToSave.GetCamo()

			primaryToSave.Destroy() // so we can take off exact primary weapon
			primarySaved = true // mark as primary saved
		}

		// defensive
		entity specialToSave = guy.GetOffhandWeapon( OFFHAND_SPECIAL )
		string specialNameToSave
		array<string> specialModsToSave
		bool specialSaved = false
		if ( IsValid( specialToSave ) )
		{
			specialNameToSave = specialToSave.GetWeaponClassName()
			specialModsToSave = specialToSave.GetMods()
		}

		if ( IsValid( specialToSave ) && special != "" )
		{
			savedLoadout.special = specialNameToSave
			savedLoadout.specialMods = specialModsToSave

			guy.TakeOffhandWeapon( OFFHAND_SPECIAL )
			specialSaved = true // mark as special saved
		}

		// utility
		entity antiRodeoToSave = guy.GetOffhandWeapon( OFFHAND_ANTIRODEO )
		string antiRodeoNameToSave
		array<string> antiRodeoModsToSave
		bool antiRodeoSaved = false
		if ( IsValid( antiRodeoToSave ) )
		{
			antiRodeoNameToSave = antiRodeoToSave.GetWeaponClassName()
			antiRodeoModsToSave = antiRodeoToSave.GetMods()
		}

		if ( IsValid( antiRodeoToSave ) && antiRodeo != "" )
		{
			savedLoadout.antiRodeo = antiRodeoNameToSave
			savedLoadout.antiRodeoMods = antiRodeoModsToSave

			guy.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
			antiRodeoSaved = true // mark as antiRodeo saved
		}

		// ordnance
		entity ordnanceToSave = guy.GetOffhandWeapon( OFFHAND_ORDNANCE )
		string ordnanceNameToSave
		array<string> ordnanceModsToSave
		bool ordnanceSaved = false
		if ( IsValid( ordnanceToSave ) )
		{
			ordnanceNameToSave = ordnanceToSave.GetWeaponClassName()
			ordnanceModsToSave = ordnanceToSave.GetMods()
		}

		if ( IsValid( ordnanceToSave ) && ordnance != "" )
		{
			savedLoadout.ordnance = ordnanceNameToSave
			savedLoadout.ordnanceMods = ordnanceModsToSave

			guy.TakeOffhandWeapon( OFFHAND_ORDNANCE )
			ordnanceSaved = true // mark as ordnance saved
		}

		// melee
		entity meleeToSave = guy.GetOffhandWeapon( OFFHAND_MELEE )
		string meleeNameToSave
		array<string> meleeModsToSave
		bool meleeSaved = false
		if ( IsValid( meleeToSave ) )
		{
			meleeNameToSave = meleeToSave.GetWeaponClassName()
			meleeModsToSave = meleeToSave.GetMods()
		}

		if ( IsValid( meleeToSave ) && melee != "" )
		{
			savedLoadout.melee = meleeNameToSave
			savedLoadout.meleeMods = meleeModsToSave

			guy.TakeOffhandWeapon( OFFHAND_MELEE )
			meleeSaved = true // mark as melee saved
		}

		// core
		entity equipmentToSave = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
		string equipmentNameToSave
		array<string> equipmentModsToSave
		bool equipmentSaved = false
		if ( IsValid( equipmentToSave ) )
		{
			equipmentNameToSave = equipmentToSave.GetWeaponClassName()
			equipmentModsToSave = equipmentToSave.GetMods()
		}

		if ( IsValid( equipmentToSave ) && equipment != "" )
		{
			savedLoadout.equipment = equipmentNameToSave
			savedLoadout.equipmentMods = equipmentModsToSave

			guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
			equipmentSaved = true // mark as equipment saved
		}

		if ( equipment != "" )
		{
			entity weapon = guy.GetOffhandWeapon( OFFHAND_EQUIPMENT )
			if ( IsValid( weapon ) )
			{
				savedLoadout.equipment = weapon.GetWeaponClassName()
				savedLoadout.equipmentMods = weapon.GetMods()

				guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
			}
		}

		// apply new weapons after certain weapon being taken, or game might crash because of dual smart ammo weapons
		// primary 
		if ( primary != "" && primarySaved ) // insure we saved primary
		{
			entity newWeapon = guy.GiveWeapon( primary, primaryMods )
			// also apply skin to temp weapon
			newWeapon.SetSkin( savedLoadout.primarySkin )
			newWeapon.SetCamo( savedLoadout.primaryCamo )
			guy.SetActiveWeaponByName( primary )
			savedLoadout.replacedPrimaryEnt = newWeapon // for later we clean up
		}
		// defensive
		if ( special != "" && specialSaved ) // insure we saved special
			guy.GiveOffhandWeapon( special, OFFHAND_SPECIAL, specialMods )
		// utility
		if ( antiRodeo != "" && antiRodeoSaved ) // insure we saved antiRodeo
			guy.GiveOffhandWeapon( antiRodeo, OFFHAND_ANTIRODEO, antiRodeoMods )
		// ordnance
		if ( ordnance != "" && ordnanceSaved ) // insure we saved ordnance
			guy.GiveOffhandWeapon( ordnance, OFFHAND_ORDNANCE, ordnanceMods )
		// melee
		if ( melee != "" && meleeSaved ) // insure we saved melee
			guy.GiveOffhandWeapon( melee, OFFHAND_MELEE, meleeMods )
		// core
		if ( equipment != "" && equipmentSaved ) // insure we saved equipment
			guy.GiveOffhandWeapon( equipment, OFFHAND_EQUIPMENT, equipmentMods )

		// debug prints
		/*
		print( "primarySaved: " + string( primarySaved ) )
		print( "specialSaved: " + string( specialSaved ) )
		print( "antiRodeoSaved: " + string( antiRodeoSaved ) )
		print( "ordnanceSaved: " + string( ordnanceSaved ) )
		print( "meleeSaved: " + string( meleeSaved ) )
		print( "equipmentSaved: " + string( equipmentSaved ) )
		*/
	}

	OnThreadEnd
	(
		function(): ( guy )
		{
			if ( IsValid( guy ) )
			{
				// player loadout restoring
				if ( guy.IsPlayer() )
				{
					ExecutionSavedLoadout savedLoadout = file.titanExecutionSavedLoadout[ guy ]
					// restore weapons
					// primary 
					if ( savedLoadout.primary != "" ) // do savedast primary
					{
						entity replacedWeapon = savedLoadout.replacedPrimaryEnt
						if ( IsValid( replacedWeapon ) )
							replacedWeapon.Destroy() // so we can take off exact primary weapon
						entity newWeapon = guy.GiveWeapon( savedLoadout.primary, savedLoadout.primaryMods )
						guy.SetActiveWeaponByName( savedLoadout.primary )
						newWeapon.SetSkin( savedLoadout.primarySkin )
						newWeapon.SetCamo( savedLoadout.primaryCamo )
						RemoveInvalidModsForWeapon( newWeapon ) // remove mods that shouldn't be retained through execution
						try { newWeapon.SetWeaponPrimaryClipCount( savedLoadout.primaryAmmo ) } // some weapon don't have clip so try-catch it
						catch (ex) {}
					}
					// offhand weapons
					for ( int i = 0; i < OFFHAND_COUNT; i++ )
					{
						entity previousOffhand = savedLoadout.savedOffhandWeaponEnts[ i ]
						if ( IsValid( previousOffhand ) )
						{
							guy.TakeOffhandWeapon( i )
							guy.GiveExistingOffhandWeapon( previousOffhand, i )
							RemoveInvalidModsForWeapon( previousOffhand ) // remove mods that shouldn't be retained through execution
						}
					}

					// restoring succeeded! delete from table
					delete file.titanExecutionSavedLoadout[ guy ]
				}

				// npc loadout restoring
				if ( guy.IsNPC() )
				{
					ExecutionSavedLoadout_NPC savedLoadout = file.titanExecutionSavedLoadout_NPC[ guy ]
					// restore weapons
					// primary 
					if ( savedLoadout.primary != "" ) // do savedast primary
					{
						entity replacedWeapon = savedLoadout.replacedPrimaryEnt
						if ( IsValid( replacedWeapon ) )
							replacedWeapon.Destroy() // so we can take off exact primary weapon
						entity newWeapon = guy.GiveWeapon( savedLoadout.primary, savedLoadout.primaryMods )
						guy.SetActiveWeaponByName( savedLoadout.primary )
						newWeapon.SetSkin( savedLoadout.primarySkin )
						newWeapon.SetCamo( savedLoadout.primaryCamo )
						try { newWeapon.SetWeaponPrimaryClipCount( savedLoadout.primaryAmmo ) } // some weapon don't have clip so try-catch it
						catch (ex) {}
					}
					// defensive
					if ( savedLoadout.special != "" ) // do saved defensive
					{
						guy.TakeOffhandWeapon( OFFHAND_SPECIAL )
						guy.GiveOffhandWeapon( savedLoadout.special, OFFHAND_SPECIAL, savedLoadout.specialMods )
					}
					// utility
					if ( savedLoadout.antiRodeo != "" ) // do saved utility
					{
						guy.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
						guy.GiveOffhandWeapon( savedLoadout.antiRodeo, OFFHAND_ANTIRODEO, savedLoadout.antiRodeoMods )
					}
					// ordnance
					if ( savedLoadout.ordnance != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_ORDNANCE )
						guy.GiveOffhandWeapon( savedLoadout.ordnance, OFFHAND_ORDNANCE, savedLoadout.ordnanceMods )
					}
					// melee
					if ( savedLoadout.melee != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_MELEE )
						guy.GiveOffhandWeapon( savedLoadout.melee, OFFHAND_MELEE, savedLoadout.meleeMods )
					}
					// core
					if ( savedLoadout.equipment != "" ) // do saved ordnance
					{
						guy.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
						guy.GiveOffhandWeapon( savedLoadout.equipment, OFFHAND_EQUIPMENT, savedLoadout.equipmentMods )
					}

					// restoring succeeded! delete from table
					delete file.titanExecutionSavedLoadout_NPC[ guy ]
				}
			}
		}
	)

	guy.EndSignal( "OnDestroy" )
	guy.EndSignal( "OnDeath" )
	// signals from FirstPersonSequence()
	//guy.EndSignal( "NewFirstPersonSequence" ) // this gets called later in execution FirstPersonSequence(), which will stop current thread!
	guy.EndSignal( "ScriptAnimStop" )
	guy.WaitSignal( "SyncedMeleeComplete" ) // attacker's signal
}

// utility!
void function MeleeSyncedTitan_AddExecutionRefCallback( string ref, void functionref( entity, entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefCallbacks ) )
		file.titanExecutionRefCallbacks[ ref ] <- [] // init
	if ( !file.titanExecutionRefCallbacks[ ref ].contains( callbackFunc ) )
		file.titanExecutionRefCallbacks[ ref ].append( callbackFunc )
}

bool function MeleeSyncedTitan_ExecutionRefHasCallback( string ref )
{
	//PrintFunc()
	if ( ref in file.titanExecutionRefCallbacks )
	{
		//print( "ref has executionCallback!" )
		return true
	}
	return false
}

void function MeleeSyncedTitan_RunCallbacksForRef( string ref, entity attacker, entity target )
{
	if ( !MeleeSyncedTitan_ExecutionRefHasCallback( ref ) )
		return
	//PrintFunc()
	foreach ( void functionref( entity, entity ) callbackFunc in file.titanExecutionRefCallbacks[ ref ] )
		callbackFunc( attacker, target )
}

void function MeleeSyncedTitan_AddExecutionRefLoadoutReplaceCallback( string ref, void functionref( entity ) callbackFunc )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) )
		file.titanExecutionRefLoadoutReplaceCallback[ ref ] <- callbackFunc
	else
		file.titanExecutionRefLoadoutReplaceCallback[ ref ] = callbackFunc
}

bool function MeleeSyncedTitan_ExecutionRefHasLoadoutReplaceCallback( string ref )
{
	//PrintFunc()
	if ( ref in file.titanExecutionRefLoadoutReplaceCallback )
	{
		//print( "ref has executionCallback!" )
		return true
	}
	return false
}

void function MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef( string ref, entity attacker )
{
	if ( !( ref in file.titanExecutionRefLoadoutReplaceCallback ) )
		return
	//PrintFunc()
	file.titanExecutionRefLoadoutReplaceCallback[ ref ]( attacker )
}

void function MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( string mod )
{
	if ( !file.modsToRemoveOnLoadoutReplace.contains( mod ) )
		file.modsToRemoveOnLoadoutReplace.append( mod )
}

void function RemoveInvalidModsForWeapon( entity weapon )
{
	array<string> mods = weapon.GetMods()
    array<string> replaceArray
    foreach( string mod in mods )
    {
        if ( file.modsToRemoveOnLoadoutReplace.contains( mod ) ) // skip illegal mod
            continue

        replaceArray.append( mod )
    }

	weapon.SetMods( replaceArray )
}

void function MeleeSyncedTitan_RegisterChassisSpecificExecutionRef( string chassis, string executionRef )
{
	if ( !( chassis in file.chassisSpecificExecutionRefs ) )
		file.chassisSpecificExecutionRefs[ chassis ] <- []
	if ( !file.chassisSpecificExecutionRefs[ chassis ].contains( executionRef ) )
		file.chassisSpecificExecutionRefs[ chassis ].append( executionRef )
}

void function MeleeSyncedTitan_RegisterTitanCharacterSpecificExecutionRef( string characterName, string executionRef )
{
	if ( !( characterName in file.titanCharacterSpecificExecutionRefs ) )
		file.titanCharacterSpecificExecutionRefs[ characterName ] <- []
	if ( !file.titanCharacterSpecificExecutionRefs[ characterName ].contains( executionRef ) )
		file.titanCharacterSpecificExecutionRefs[ characterName ].append( executionRef )
}
#endif