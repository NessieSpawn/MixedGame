untyped

global function MeleeSyncedTitan_Init

global function MeleeThread_TitanVsTitan // globalize it!

// modified utility
// we want other files can get all executions we registered
global function MeleeSyncedTitan_GetAllValidExecutionRefs
global function MeleeSyncedTitan_RefHasLinkedExecutions
global function MeleeSyncedTitan_GetLinkedExecutionsFromRef

const TITANARMMODEL = $"models/weapons/arms/atlaspov.mdl"
const TEAM_JUMPJET_DBL = $"P_team_jump_jet_DBL"
// modified fix for team/passive related jump jets...
const PENEMY_JUMPJET_DBL = $"P_enemy_jump_jet_DBL"
const STEALTH_TEAM_JUMPJET_DBL = $"P_jump_jet_stealth_DBL"
const STEALTH_PENEMY_JUMPJET_DBL = $"P_jump_jet_stealth_DBL"

// modified shared utility
global function MeleeSyncedTitan_GetDefaultExecutionRefForTitanVsTitan3p // wrapped monarch and fake-bt stuffs inside
global function MeleeSyncedTitan_TitanHasPilot
global function SetCallback_OnGetTitan3pExecutionRef // modified callback that allows changing the method we get execution ref

// modified settings
global function MeleeSyncedTitan_AddBatteryRewardTitanPassives // make execution_vanguard_kit's hardcode become a setting, can add any passive that we want it rewards battery
global function MeleeSyncedTitan_RemoveBatteryRewardTitanPassives
global function MeleeSyncedTitan_ExecutionAlwaysRewardsBattery
global function MeleeSyncedTitan_ShouldApplyBatteryAfterExecution
global function MeleeSyncedTitan_DisableVanguardKitExecution
// misc fix settings
global function MeleeSyncedTitan_EnableExecutionAttackerNoTarget // attacker will become no-target during execution
// victim think is unused, as they're always invulnerable and we should always add notarget for them
//global function MeleeSyncedTitan_EnableExecutionVictimNoTarget // victim will become no-target during execution

// some execution ragdolls target, but npc target gets ragdolled will count as "destroyed", ends execution unexpectly...
// better method is we end npc target execution manually on their death, for every execution ref
// so our execution timer can get more stable and minimapIcon won't be messed up
// NOTE: this is enabled by default, as a fix. turn it off to recover vanilla behavior
// EDIT: not enabling this, instead... we now stop tracking target destroy for npcs, so attacker can always have full sequence played
global function MeleeSyncedTitan_EndExecutionOnNPCTargetDeath
global function MeleesyncedTitan_Enable3pExecutionTimerFix

// vanilla const turns to settings
global function MeleeSyncedTitan_ExecutionNotInvulnerable // TITAN_EXECUTION_ATTACKER_IS_INVULNERABLE
global function MeleeSyncedTitan_ExecutionAlwaysGiveBattery // TITAN_EXECUTION_GIVES_BATTERY

// modified to have classic execution options
global function MeleeSyncedTitan_SetSoulDoClassicExecution
global function MeleeSyncedTitan_SetSoulClassicExecutionType // atlas(buddy), stryder, ogre
global function MeleeSyncedTitan_SetSoulDoRandomExecution // pick any valid execution from current chassis, or pick any tf1 style execution

// shared utility for callbacks can use
global function MeleeSyncedTitan_GetSoulDoClassicExecution
global function MeleeSyncedTitan_GetSoulClassicExecutionType
global function MeleeSyncedTitan_GetSoulDoRandomExecution

// needs modified sh_melee_synced_titan.gnut to do callbacks
// these shouldn't be used atm
//global function MeleeSyncedTitan_SetSoulUseExecutionCallback // removed. callbacks should always be called
//global function MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution // removed. loadout replace now checking attacker's current weapon, no need to setup

global function MeleeSyncedTitan_SetSoulCanBeExecuted
global function MeleeSyncedTitan_SoulCanBeExecuted // shared with checks in AttemptScriptedExecution()( wrapped into TitanMelee_CanScriptedExecution() )

global function MeleeSyncedTitan_SetSoulExecutionTargetRequiredHealthFrac
global function MeleeSyncedTitan_GetSoulExecutionTargetRequiredHealthFrac // shared with checks in ShouldPlayerExecuteTarget()
//

// HACK for npc using ion prime execution
// npc can fire laser core at the beginning of animation, needs to get timer before do anything
global function MeleeSyncedTitan_GetTitanExecutionStartTime

enum eTitanExecutionType
{
	fistThroughCockpit
	dummy //not used yet
}

struct TitanExcutionData
{
	string attackerAnimation3p
	string attackerAnimation3p_vsAutoTitan
	table<string,string> attackerAnimation3pPilot
	table<string,string> targetAnimation3p
	table<string,string> targetAnimation3pPilot
	string sound_1p
	string sound_3p
	array<string> thirdPersonCameraAttachments
	array<string> linkedExecutions

	// modified settings: allow us tweak animation wait method
	// mostly for buddy victim animations, because they don't have AE_MELEE_KILLED instead has AE_NPC_SYNCED_MELEE_DEATH
	// for that case, we kill the target once their sequence is done, force ragdolling them
	table<string, bool> killTargetOnSequenceEnds
}

struct
{
	table<string, TitanExcutionData> executionData_3p
	// vanilla missing!!!! we want other files can get all executions we registered
	array<string> validExecutionRefs

	// modified callbacks
	string functionref( entity attacker, entity target, string forcedRef = "" ) onGetTitan3pExecutionRefCallback

	// modified settings
	array<int> titanExecutionRewardsBatteryPassives
	bool titanExecutionAlwaysRewardsBattery = false
	bool disableVanguardKitExecution = false
	// misc fix settings
	bool attackerNoTargetOnExecution = false
	//bool victimNoTargetOnExecution = false
	bool endExecutionOnNPCTargetDeath = false // this is enabled by default, as a fix. EDIT: now change to enabling titanVsTitan3pTimerFix by default
	bool enableTitanVsTitan3pTimerFix = true
	// vanilla const turns to settings
	bool titanExecutionNotInvulnerable = false
	bool titanExecutionAlwaysGiveBattery = false

	// modified to have more execution options
	table<entity, bool> soulDoClassicExecution
	table<entity, string> soulClassicExecutionType
	table<entity, bool> soulDoRandomExecution
	table<entity, bool> soulUseExecutionCallback
	table<entity, bool> soulShouldReplaceLoadout

	table<entity, bool> soulCanBeExecuted // shared with sh_melee_titan.gnut
	table<entity, float> soulExecutionTargetRequiredHealthFrac // shared with sh_melee.gnut

	// modified variables
	table<entity, float> titanExecutionStartTime // HACK for npc ion prime execution to use... npc can fire laser core at the beginning of exeuction, needs to get timer before do anything
} file

int RAGDOLL_IMPACT_TABLE_IDX = -1

function MeleeSyncedTitan_Init()
{
	RAGDOLL_IMPACT_TABLE_IDX = PrecacheImpactEffectTable( "ragdoll_human" )
	AddSyncedMeleeServerThink( GetSyncedMeleeChooser( "titan", "titan" ), MeleeThread_TitanVsTitan )

	if ( GetBugReproNum() == 129802 )
	{
		AddDeathCallback( "npc_titan", OnNPCTitanDeath )
	}

	PrecacheWeapon( "mp_titanweapon_salvo_rockets" )
	PrecacheParticleSystem( TEAM_JUMPJET_DBL )
	// modified fix for team/passive related jump jets...
	PrecacheParticleSystem( PENEMY_JUMPJET_DBL )
	PrecacheParticleSystem( STEALTH_PENEMY_JUMPJET_DBL )
	PrecacheParticleSystem( STEALTH_PENEMY_JUMPJET_DBL )

	Init3pExecutions()

	// modified settings default value
	// vanilla hardcode turns to settings
	// default: monarch energy thief
	MeleeSyncedTitan_AddBatteryRewardTitanPassives( ePassives.PAS_VANGUARD_COREMETER )
	SetCallback_OnGetTitan3pExecutionRef( DefaultCallback_OnGetTitan3pExecutionRef )
	// modified here: for we precache some effects that is used in classic executions
	InitClassicExecutionModelEffects()
	// modified signal for us handle execution after target getting destroyed
	RegisterSignal( "ForceEndTitanExecution" )
}

void function Init3pExecutions()
{
	var dataTable = GetDataTable( $"datatable/titan_executions.rpak" )
	int numRows = GetDatatableRowCount( dataTable )
	for ( int row=0; row<numRows; row++ )
	{
		TitanExcutionData data = Create_3p_ExecutionData( dataTable, row )
		string ref = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "ref" ) )
		file.executionData_3p[ref] <- data

		// vanilla missing!!!! we want other files can get all executions we registered
		if ( !file.validExecutionRefs.contains( ref ) )
			file.validExecutionRefs.append( ref )
	}

	// modified settings to allow us tweak animation length and death effects
	// init for default executionrefs
	foreach ( ref, data in file.executionData_3p )
	{
		data.killTargetOnSequenceEnds[ "atlas" ] <- false
		data.killTargetOnSequenceEnds[ "stryder" ] <- false
		data.killTargetOnSequenceEnds[ "ogre" ] <- false
	}

	// modified for buddy titan as target
	// mostly never used because we can make them unable to be executed or change model before animation starts
	// and all animations don't have AE_MELEE_KILLED, leading to bad duration
	// just to implement something here
	// EDIT: added scripted handle: killTargetOnSequenceEnds settings

	TitanExcutionData buddyRoninVictimData = file.executionData_3p[ "execution_ronin" ]
	buddyRoninVictimData.attackerAnimation3pPilot[ "buddy" ] <- "lt_execution_attacker_sword_01"
	buddyRoninVictimData.targetAnimation3p[ "buddy" ] <- "bt_execution_victim_sword_01"
	// buddy have bad pilot attachments, should be empty
	buddyRoninVictimData.targetAnimation3pPilot[ "buddy" ] <- ""
	buddyRoninVictimData.attackerAnimation3pPilot[ "buddy" ] <- ""
	// due we don't have AE_MELEE_KILLED events, target should die on their sequence ends and always ragdoll themselves
	buddyRoninVictimData.killTargetOnSequenceEnds[ "buddy" ] <- true

	TitanExcutionData buddyIonVictimData = file.executionData_3p[ "execution_ion" ]
	buddyIonVictimData.attackerAnimation3pPilot[ "buddy" ] <- "mt_execution_attacker_laser"
	buddyIonVictimData.targetAnimation3p[ "buddy" ] <- "bt_execution_victim_laser"
	// buddy have bad pilot attachments, should be empty
	buddyIonVictimData.targetAnimation3pPilot[ "buddy" ] <- ""
	buddyIonVictimData.attackerAnimation3pPilot[ "buddy" ] <- ""
	// due we don't have AE_MELEE_KILLED events, target should die on their sequence ends and always ragdoll themselves
	buddyIonVictimData.killTargetOnSequenceEnds[ "buddy" ] <- true

	TitanExcutionData buddyToneVictimData = file.executionData_3p[ "execution_tone" ]
	buddyToneVictimData.attackerAnimation3pPilot[ "buddy" ] <- "mt_execution_attacker_tone"
	buddyToneVictimData.targetAnimation3p[ "buddy" ] <- "bt_execution_victim_tone"
	// buddy have bad pilot attachments, should be empty
	// edit: might be better to let pilot being throwed for tone executions?
	buddyToneVictimData.targetAnimation3pPilot[ "buddy" ] <- "pt_execution_victim_tone"
	buddyToneVictimData.attackerAnimation3pPilot[ "buddy" ] <- ""
	// due we don't have AE_MELEE_KILLED events, target should die on their sequence ends and always ragdoll themselves
	buddyToneVictimData.killTargetOnSequenceEnds[ "buddy" ] <- true

	// legion execution makes bt rotates weirdly, removed
	/*
	TitanExcutionData buddyLegionVictimData = file.executionData_3p[ "execution_legion" ]
	buddyLegionVictimData.attackerAnimation3pPilot[ "buddy" ] <- "htPRED_MP_Sync_Execution_attacker"
	buddyLegionVictimData.targetAnimation3p[ "buddy" ] <- "t_MeleeExecuted_By_htPred"
	// buddy have bad pilot attachments, should be empty
	buddyLegionVictimData.targetAnimation3pPilot[ "buddy" ] <- ""
	buddyLegionVictimData.attackerAnimation3pPilot[ "buddy" ] <- ""
	// due we don't have AE_MELEE_KILLED events, target should die on their sequence ends and always ragdoll themselves
	buddyLegionVictimData.killTargetOnSequenceEnds[ "buddy" ] <- true
	*/

	TitanExcutionData buddyScorchVictimData = file.executionData_3p[ "execution_scorch" ]
	buddyScorchVictimData.attackerAnimation3pPilot[ "buddy" ] <- "htThermite_MP_Sync_Execution_attacker"
	buddyScorchVictimData.targetAnimation3p[ "buddy" ] <- "t_MeleeExecuted_By_htThermite"
	// buddy have bad pilot attachments, should be empty
	buddyScorchVictimData.targetAnimation3pPilot[ "buddy" ] <- ""
	buddyScorchVictimData.attackerAnimation3pPilot[ "buddy" ] <- ""
	// due we don't have AE_MELEE_KILLED events, target should die on their sequence ends and always ragdoll themselves
	buddyScorchVictimData.killTargetOnSequenceEnds[ "buddy" ] <- true
}

// vanilla missing!!!! we want other files can get all executions we registered
array<string> function MeleeSyncedTitan_GetAllValidExecutionRefs()
{
	return file.validExecutionRefs
}

bool function MeleeSyncedTitan_RefHasLinkedExecutions( string ref )
{
	if ( !MeleeSyncedTitan_GetAllValidExecutionRefs().contains( ref ) ) // invalid ref?
		return false
	
	TitanExcutionData data = file.executionData_3p[ ref ]
	return ( data.linkedExecutions.len() > 0 )
}

array<string> function MeleeSyncedTitan_GetLinkedExecutionsFromRef( string ref )
{
	if ( !MeleeSyncedTitan_RefHasLinkedExecutions( ref ) )
		return []

	TitanExcutionData data = file.executionData_3p[ ref ]
	return clone data.linkedExecutions // never touch anything inside our data, use a clone
}
//

TitanExcutionData function Create_3p_ExecutionData( var dataTable, int row )
{
	string attackerAnimation3p = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim" ) )
	string attackerAnimation3p_vsAutoTitan = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnimVsAutoTitan" ) )
	string targetAnimation3p_lt = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_lt" ) )
	string targetAnimation3p_md = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_md" ) )
	string targetAnimation3p_hv = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_hv" ) )
	string targetAnimation3pPilot_lt = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_pt_lt" ) )
	string targetAnimation3pPilot_md = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_pt_md" ) )
	string targetAnimation3pPilot_hv = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "victimAnim_pt_hv" ) )

	string attackerAnimation3pPilot_lt = ""
	if ( GetDataTableColumnByName( dataTable, "attackerAnim_pt_lt" ) != -1 )
		attackerAnimation3pPilot_lt = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim_pt_lt" ) )

	string attackerAnimation3pPilot_md = ""
	if ( GetDataTableColumnByName( dataTable, "attackerAnim_pt_mt" ) != -1 )
		attackerAnimation3pPilot_md = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim_pt_mt" ) )

	string attackerAnimation3pPilot_hv = ""
	if ( GetDataTableColumnByName( dataTable, "attackerAnim_pt_ht" ) != -1 )
		attackerAnimation3pPilot_hv = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "attackerAnim_pt_ht" ) )

	string sound_1p = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "sound_1p" ) )
	string sound_3p = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "sound_3p" ) )
	string camAttach = GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "camAttach" ) )

	array<string> camAttachments = split( camAttach, " " )

	array<string> linkedExecutionArray = SplitAndStripStringArray( GetDataTableString( dataTable, row, GetDataTableColumnByName( dataTable, "linkedExecutions" ) ) )

	TitanExcutionData data
	data.attackerAnimation3p = attackerAnimation3p
	data.attackerAnimation3p_vsAutoTitan = attackerAnimation3p_vsAutoTitan
	data.targetAnimation3p[ "stryder" ] <- targetAnimation3p_lt
	data.targetAnimation3p[ "atlas" ] <- targetAnimation3p_md
	data.targetAnimation3p[ "ogre" ] <- targetAnimation3p_hv
	data.targetAnimation3pPilot[ "stryder" ] <- targetAnimation3pPilot_lt
	data.targetAnimation3pPilot[ "atlas" ] <- targetAnimation3pPilot_md
	data.targetAnimation3pPilot[ "ogre" ] <- targetAnimation3pPilot_hv
	data.attackerAnimation3pPilot[ "stryder" ] <- attackerAnimation3pPilot_lt
	data.attackerAnimation3pPilot[ "atlas" ] <- attackerAnimation3pPilot_md
	data.attackerAnimation3pPilot[ "ogre" ] <- attackerAnimation3pPilot_hv
	data.sound_1p = sound_1p
	data.sound_3p = sound_3p
	data.thirdPersonCameraAttachments = camAttachments
	data.linkedExecutions = linkedExecutionArray

	return data
}

array<string> function SplitAndStripStringArray( string combinedString )
{
	array<string> stringArray = split( combinedString, "," )

	foreach ( i, value in stringArray )
	{
		stringArray[ i ] = strip( value )
	}

	return stringArray
}


struct MeleeThread_TitanVsTitanDataStruct
{
	bool setAttackerInvulnerable = false
	bool setAttackerDemigod = false
	// save for npc executions. don't want them to have weird rotation after animation
	vector attackerStartingAngles
	// store battery style execution here, so we can handle classic executions without having to hardcode everything
	bool executionGivesBattery = false
	// modified setting: we allow attacker to be notarget during execution, because they might got invulnerablity
	bool setAttackerNoTarget = false
	// for npc scriped execution, they don't have "PlayerMelee_" methods, have to manually set their context action state
	// though it stops them from finding new enemies, could be good for us to get their state( also prevents further animation updates )
	bool setAttackerContextActionBusy = false
	bool setTargetContextActionBusy = false
}

bool function MeleeThread_TitanVsTitan( SyncedMelee action, entity attacker, entity target )
{
	// function off for reload scripts
	return MeleeThread_TitanVsTitan_Internal( action, attacker, target )
}

bool function MeleeThread_TitanVsTitan_Internal( SyncedMelee action, entity attacker, entity target )
{
	Assert( target.IsTitan(), target + " is not Titan target" )
	Assert( attacker.IsPlayer() && attacker.IsTitan(), attacker + " is not Titan attacker" )

	#if SERVER
		printt( "Player", attacker, "attempting to melee", target, "TitanVsTitanMelee" )
	#endif

	if ( attacker.ContextAction_IsActive() || target.ContextAction_IsActive() )
	{
		printt("Either attacker or target already in ContextAction! Exiting Titan Vs Titan melee attempt")
		return false
	}

	if ( !IsAlive( attacker ) )
		return false

	if ( !IsAlive( target ) )
		return false

	void functionref( SyncedMelee action, entity attacker, entity target ) func
	func = GetTitanSyncedMeleeFunc( attacker, target )
	if ( func == null )
		return false

	attacker.GetTitanSoul().Signal( "OnSyncedMelee" ) 	//Need the signal on the soul to clean-up tether traps during synced executions.

	// JFS: signals can kill things mid frame: R2DLC-311 SCRIPT ERROR: PHONE_HOME: [SERVER] Entity is null
	if ( !IsAlive( attacker ) )
		return false

	if ( !IsAlive( target ) )
		return false

	target.GetTitanSoul().Signal( "OnSyncedMelee" )

	// JFS: signals can kill things mid frame: R2DLC-311 SCRIPT ERROR: PHONE_HOME: [SERVER] Entity is null
	if ( !IsAlive( attacker ) )
		return false

	if ( !IsAlive( target ) )
		return false
	//attacker.Signal( "OnSyncedMelee" )
	//target.Signal( "OnSyncedMelee" )

	// HACK for npc ion prime execution to use
	file.titanExecutionStartTime[ attacker ] <- Time()
	//

	MeleeThread_TitanVsTitanDataStruct dataStruct

	OnThreadEnd(
		function() : ( attacker, target, dataStruct )
		{
			if ( IsValid( attacker ) )
			{
				if ( dataStruct.setAttackerInvulnerable )
				{
					attacker.ClearInvulnerable()
					// attacker should be ignored while executing a target, cause they get invulnerablility
					// breaks vanilla behavior but whatever
					// EDIT: make it a setting so we don't break vanilla behavior
					//attacker.SetNoTarget( false )
				}

				if ( dataStruct.setAttackerDemigod )
					DisableDemigod( attacker )

				// modified settings cleanup
				if ( dataStruct.setAttackerNoTarget )
					attacker.SetNoTarget( false )
				if ( dataStruct.setAttackerContextActionBusy )
				{
					if ( attacker.ContextAction_IsBusy() )
						attacker.ContextAction_ClearBusy()
				}
				if ( dataStruct.setTargetContextActionBusy )
				{
					if ( target.ContextAction_IsBusy() )
						target.ContextAction_ClearBusy()
				}
				//

				if( attacker.IsPlayer() ) // saved for npc executions
					attacker.PlayerMelee_SetState( PLAYER_MELEE_STATE_NONE )
				else // npc execution ends
				{
					vector angles = attacker.GetAngles()
					// reset their x, z angles
					angles.x = dataStruct.attackerStartingAngles.x
					angles.z = dataStruct.attackerStartingAngles.z
					attacker.SetAngles( angles )
				}

				// modified here: we handle battery style execution here
				// so we don't have to hardcode everything into classic execution case
				//#if TITAN_EXECUTION_GIVES_BATTERY // use my own check!
				if ( file.titanExecutionAlwaysGiveBattery )
					Rodeo_GiveExecutingTitanABattery( attacker )
				else //#else
				{
					if ( dataStruct.executionGivesBattery )
						Rodeo_GiveExecutingTitanABattery( attacker )
				}
				//#endif

				// clean up modified variable
				delete file.titanExecutionStartTime[ attacker ]
			}
		}
	)

	string titanSubClass = GetSoulTitanSubClass( attacker.GetTitanSoul() )

	entity burnCardTarget
	entity bossPlayer = target.GetBossPlayer()
	if ( target.IsNPC() )
	{
		if ( IsValid( bossPlayer ) )
			burnCardTarget = bossPlayer
	}
	else
	{
		burnCardTarget = target
	}

	if( attacker.IsPlayer() ) // save for npc executions
		attacker.PlayerMelee_ExecutionStartAttacker( 0 )
	target.PlayerMelee_ExecutionStartTarget( attacker )

	if( attacker.IsPlayer() ) // save for npc executions
		attacker.Lunge_ClearTarget()

	ForceTitanSustainedDischargeEnd( target )

	//#if TITAN_EXECUTION_ATTACKER_IS_INVULNERABLE // use my own check!
	if( !file.titanExecutionNotInvulnerable )
	{
		dataStruct.setAttackerInvulnerable = true
		attacker.SetInvulnerable()
		// attacker should be ignored while executing a target, cause they get invulnerablility
		// breaks vanilla behavior but whatever
		// EDIT: make it a setting so we don't break vanilla behavior
		//attacker.SetNoTarget( true )
	}
	else //#else
	{
		if( attacker.IsPlayer() )
		{
			dataStruct.setAttackerDemigod = true
			EnableDemigod( attacker )
		}
	}
	//#endif

	// modified function: set attacker to notarget during execution
	if ( file.attackerNoTargetOnExecution && !attacker.GetNoTarget() )
	{
		dataStruct.setAttackerNoTarget = true
		attacker.SetNoTarget( true )
	}
	//

	// modified for npc scripted executions: add context action state for attacker
	// npcs don't have "PlayerMelee_" methods, have to manually set their context action state
	// though it stops them from finding new enemies, could be good for us to get their state( also prevents further animation updates )
	if ( attacker.IsNPC() && !attacker.ContextAction_IsActive() && !attacker.ContextAction_IsBusy() )
	{
		dataStruct.setAttackerContextActionBusy = true
		attacker.ContextAction_SetBusy()
	}
	if ( target.IsNPC() && !target.ContextAction_IsActive() && !target.ContextAction_IsBusy() )
	{
		dataStruct.setTargetContextActionBusy = true
		target.ContextAction_SetBusy()
	}


	// modified: if function reaches here it must means titan being executed
#if MP
	ExecutedTitanDropWeapon( target ) // we delay 1 frame and drop their weapon
#endif
	//

	// save for npc executions. don't want them to have weird rotation after animation
	dataStruct.attackerStartingAngles = attacker.GetAngles()
	//

	// we add battery for attacker when this thread ends, so it can handle classic execution case
	dataStruct.executionGivesBattery = MeleeSyncedTitan_ShouldApplyBatteryAfterExecution( attacker )
	//

	waitthread func( action, attacker, target )

	if ( !IsValid( attacker ) )
		return true

	attacker.Signal( "SyncedMeleeComplete" )
	#if MP
	if( IsValid( attacker ) )
	{
		if ( attacker.IsPlayer() )
		{
			if( IsValid( target ) ) // defensive fix
				AddPlayerScore( attacker, "Execution", target )
			else
				AddPlayerScore( attacker, "Execution" )
		}
	}
	#endif
	return true
}

void functionref( SyncedMelee action, entity attacker, entity target ) function GetTitanSyncedMeleeFunc( entity attacker, entity target )
{
	entity soul = attacker.GetTitanSoul()
	// modified here... could get some tf1 execution
	bool useClassicExecution = MeleeSyncedTitan_GetSoulDoClassicExecution( soul )

	#if SP
	TitanLoadoutDef loadout = GetTitanLoadoutForCurrentMap()
	#else
	TitanLoadoutDef loadout = soul.soul.titanLoadout // GetActiveTitanLoadout( attacker )
	#endif

	string executionRef = MeleeSyncedTitan_GetDefaultExecutionRefForTitanVsTitan3p( attacker, target )
	//if ( executionRef in file.executionData_3p )
	if ( executionRef in file.executionData_3p && !useClassicExecution ) // only do 3p execution if we have an ref registered
		return TitanVsTitan_3p


	// below must be tf1 execution, remove cinematic
	ForceRemoveExecutionCinematic( attacker )
	ForceRemoveExecutionCinematic( target )

	// auto-titan case classic execution
	if ( !MeleeSyncedTitan_TitanHasPilot( target ) )
	{
		return MeleeThread_AtlasVsTitanShort
	}

	// using modified classic execution type, because all titans have animations for each tf1 execution
	string classicExecutionType = MeleeSyncedTitan_GetSoulClassicExecutionType( soul )

	// using modified classic execution type, because all titans have animations for tf1 each execution
	//switch ( attackerType )
	switch ( classicExecutionType )
	{
		case "stryder":
			//return MeleeThread_StyderVsTitan // vanilla having incorrect spelling
			return MeleeThread_StryderVsTitan

		case "ogre":
			return MeleeThread_OgreVsTitan

		case "atlas":
		case "buddy":
			return MeleeThread_AtlasVsTitan
	}

	return null
}

// modified: wrap any execution ref changes into this function
string function MeleeSyncedTitan_GetDefaultExecutionRefForTitanVsTitan3p( entity attacker, entity target, string forcedRef = "" )
{
	// if we have callback, run it
	if ( file.onGetTitan3pExecutionRefCallback != null )
		return file.onGetTitan3pExecutionRefCallback( attacker, target, forcedRef )

	return ""
}

// default function
string function DefaultCallback_OnGetTitan3pExecutionRef( entity attacker, entity target, string forcedRef = "" )
{
	entity attackerSoul = attacker.GetTitanSoul()
	entity targetSoul = target.GetTitanSoul()

	// default execution ref: from loadout
	string executionRef = attackerSoul.soul.titanLoadout.titanExecution
	if ( forcedRef != "" )
		executionRef = forcedRef

	// for invalid ref case, let's just do classic executions
	if ( !MeleeSyncedTitan_GetAllValidExecutionRefs().contains( executionRef ) )
		return ""

	// start checking!
	string attackerType = GetSoulTitanSubClass( attackerSoul )
	string targetType = GetSoulTitanSubClass( targetSoul )
	bool attackerTitanHasPilot = MeleeSyncedTitan_TitanHasPilot( attacker )
	bool targetTitanHasPilot = MeleeSyncedTitan_TitanHasPilot( target )

	// monarch kit execution
	if ( !file.disableVanguardKitExecution ) // modified settings to nerf monarch
	{
		if ( attackerType == "atlas" ) // anti crash: only atlas titans have such animation
		{
			if ( SoulHasPassive( attackerSoul, ePassives.PAS_VANGUARD_COREMETER ) )
				executionRef = "execution_vanguard_kit"
			
			// modified: extra check for npc monarch executions -- spawn with no passive and ref "execution_random_6", uses random execution!
			// removed because we're now using passives for rewarding battery, this can't handle anymore
			/*
			#if NPC_TITAN_PILOT_PROTOTYPE
				if ( !SoulHasPassive( attackerSoul, ePassives.PAS_VANGUARD_COREMETER ) )
				{
					if ( targetTitanHasPilot && executionRef == "execution_random_6" )
					{
						if ( CoinFlip() ) 
							executionRef = "execution_vanguard_kit"
					}
				}
			#endif
			*/
		}
	}
	//

	// modified: add a condition for bt can use random executions
	if ( executionRef == "execution_bt" ) // if we're using unnamed bt execution
	{
		// select a random one
		// now we change to make kickshoot always enable
		/*
		array<string> btExecutions = ["execution_bt_flip"] // always enabled
		
		if ( targetTitanHasPilot ) // try to use pilotrip only if target has a seated pilot model
			btExecutions.append( "execution_bt_pilotrip" )
		if ( attacker.GetMainWeapons().len() > 0 ) // try to use kickshoot only if attacker has at least one main weapon
			btExecutions.append( "execution_bt_kickshoot" )

		// some misc fix here: bt's "back" bodygroup can be hidden
		// if we find some other execution for bt to use, remove execution_bt_flip
		if ( btExecutions.len() > 1 )
		{
			int bodyGroupIndex = attacker.FindBodyGroup( "back" )
			if ( bodyGroupIndex > -1 )
			{
				int currentState = attacker.GetBodyGroupState( bodyGroupIndex )
				if ( currentState > 0 ) // has been set to "doomed" or "hidden"
					btExecutions.fastremovebyvalue( "execution_bt_flip" ) // don't do flip because this execution rely on rocket salvo for killing
			}
		}
		*/

		array<string> btExecutions = ["execution_bt_kickshoot"] // always enabled
		if ( targetTitanHasPilot ) // try to use pilotrip only if target has a seated pilot model
			btExecutions.append( "execution_bt_pilotrip" )
		// some misc fix here: bt's "back" bodygroup can be hidden, which contains the rocket pod model
		// we only do execution_bt_flip if rocket pod is visible
		int bodyGroupIndex = attacker.FindBodyGroup( "back" )
		if ( bodyGroupIndex > -1 )
		{
			int currentState = attacker.GetBodyGroupState( bodyGroupIndex )
			if ( currentState == 0 ) // still visible!
				btExecutions.append( "execution_bt_flip" )
		}
		executionRef = btExecutions[ RandomInt( btExecutions.len() ) ]
	}
	//

	// re-exam execution ref after all modifications done
	// shared from sh_melee_synced_titan.gnut
	string bestExecutionRef = MeleeSyncedTitan_GetBestExecutionRefForTitanVsTitan( attacker, target, executionRef )
	if ( bestExecutionRef != executionRef ) // we don't have good enough execution!
		executionRef = bestExecutionRef

	// pick random execution for current chassis if we've enabled settings
	// shared from sh_melee_synced-titan.gnut
	if ( MeleeSyncedTitan_GetSoulDoRandomExecution( attacker.GetTitanSoul() ) )
	{
		string randomExecutionRef = MeleeSyncedTitan_GetRandomExecutionRefForTitanVsTitan( attacker, target )
		if ( randomExecutionRef != executionRef ) // we've got a random execution ref!
			executionRef = randomExecutionRef
	}
	
	// debug
	//print( "Titan: " + string( attacker ) + " got execution " + executionRef )
	return executionRef
}

// modified function for sharing checks
bool function MeleeSyncedTitan_TitanHasPilot( entity titan )
{
	bool titanHasPilot = titan.IsPlayer()
	#if HAS_BOSS_AI
		titanHasPilot = titanHasPilot || ( IsBossTitan( titan ) )
	#elseif NPC_TITAN_PILOT_PROTOTYPE // modified condition
		titanHasPilot = titanHasPilot || TitanHasNpcPilot( titan )
	#endif

	return titanHasPilot
}

// modified callback: allow change ref through callbacks
// default ref checks only gets running if we're not setting any callback
void function SetCallback_OnGetTitan3pExecutionRef( string functionref( entity attacker, entity target, string forcedRef = "" ) callbackFunc )
{
	file.onGetTitan3pExecutionRefCallback = callbackFunc
}

// modified: forced cleanup or sound fixes
void function ForceRemoveExecutionCinematic( entity ent )
{
	if( ent.IsPlayer() )
	{
		RemoveCinematicFlag( ent, CE_FLAG_EXECUTION )
		RemoveCinematicFlag( ent, CE_FLAG_TITAN_3P_CAM )
	}
}

// we delay player becomes pilot, so they can have cockpit model
// hard to control, don't do it. just screen fade to cockpit open?
/*
void function DelayedTitanBecomesPilot( entity player, entity titan, float delay )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	// temp change model to player's, for playing animation( HACKY as hell )
	asset pilotModel = GetPlayerSettingsAssetForClassName( player.s.storedPlayerSettings, "bodymodel" )
	player.SetModel( pilotModel )
	wait delay

	TitanBecomesPilot( player, titan )
}
*/

void function ClassicExecutionScreenFadeFromBlack( entity ent, float fadeTime, float holdTime )
{
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnAnimationDone" )
	ent.EndSignal( "OnAnimationInterrupted" )

	// fake the CE flag like when we disembarking
	AddCinematicFlag( ent, CE_FLAG_DISEMBARK )
	OnThreadEnd
	(
		function(): ( ent )
		{
			if ( IsValid( ent ) )
				RemoveCinematicFlag( ent, CE_FLAG_DISEMBARK )
		}
	)

	ScreenFade( ent, 0, 1, 0, 255, fadeTime, holdTime, FFADE_IN | FFADE_PURGE )

	wait fadeTime + holdTime // wait till full fade ends( similar to pilot disembark )
}

// for emitting some sound that isn't valid for both target and attacker
void function EmitSoundOnEntityForPlayersInRange( entity ent, string sound, float range, array<entity> excludedPlayers = [] )
{
	foreach ( entity player in GetPlayerArray() )
	{
		if ( Distance( player.GetOrigin(), ent.GetOrigin() ) > range )
			continue

		if ( excludedPlayers.contains( player ) )
			continue

		EmitSoundOnEntityOnlyToPlayer( ent, player, sound )
	}
}

// precaching particles that used in model effects thread
void function InitClassicExecutionModelEffects()
{
	PrecacheParticleSystem( $"P_impact_exp_frag_air" )
	PrecacheParticleSystem( $"xo_health_fire_vent" )
	PrecacheParticleSystem( $"P_impact_exp_lrg_metal" )
}

// for displaying effects that not working from .qc files...
// mostly because respawn give attachments incorrect case
// wait, effects seem to working fine, but where do tf1's effects go? like cracking open the hatch
// let's play those on server-side, maybe? is it because tf2 changed some of effects so tf1 effects no longer working well?
void function ClassicExecutionParticleEffect( entity ent, asset effect, string attachment, int attachType, int visibilityFlags = ENTITY_VISIBLE_TO_EVERYONE )
{
	int attachmentIndex = ent.LookupAttachment( attachment )
	int particleIndex = GetParticleSystemIndex( effect )
	
	entity particle = StartParticleEffectOnEntity_ReturnEntity( ent, particleIndex, attachType, attachmentIndex )
	particle.SetOwner( ent )
	particle.kv.VisibilityFlags = visibilityFlags
	thread TrackClassicExecutionParticleLifeTime( ent, particle )
}

void function TrackClassicExecutionParticleLifeTime( entity ent, entity particle )
{
	particle.EndSignal( "OnDestroy" )
	WaitSignal( ent, "OnDeath", "OnDestroy", "OnAnimationDone", "OnAnimationInterrupted" )

	EffectStop( particle )
}

function AtlasVsTitanShortSoundEvent( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// auto-titan synced melee won't do titan transfer, safe to handle target sequence
	target.EndSignal( "OnAnimationDone" )
	target.EndSignal( "OnAnimationInterrupted" )

	wait 0.7

	// shared view: target gets punch
	if ( IsAlive( target ) )
	{
		EmitSoundOnEntity( target, "monarch_battery_execution_part_03_titans" )
	}
}

function AtlasVsTitanShortModelEffects( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// auto-titan synced melee won't do titan transfer, safe to handle target sequence
	target.EndSignal( "OnAnimationDone" )
	target.EndSignal( "OnAnimationInterrupted" )

	// attacker animation: "at_melee_sync_frontkill_autotitan"
	// reworked: client-side effects seems to working fine, we need server-side only ones
	/*
	const attackerAnimFPS = 30.0
	// { event AE_CL_CREATE_PARTICLE_EFFECT 15 "xo_damage_exp_1 follow_attachment exp_r_elbow" }
	wait 15.0 / attackerAnimFPS
	if ( IsAlive( attacker ) )
		ClassicExecutionParticleEffect( attacker, $"xo_damage_exp_1", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )
	*/

	// server-side effects
	wait 0.7
	// cracking open the hatch
	//if ( IsAlive( target ) )
	//	ClassicExecutionParticleEffect( target, $"P_impact_exp_frag_air", "PROPGUN", FX_PATTACH_POINT_FOLLOW )
	if ( IsAlive( attacker ) )
		ClassicExecutionParticleEffect( attacker, $"P_impact_exp_frag_air", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )
}

function StryderVsTitanSoundEvent( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// no signals for target sequence because tf1 excutions can change target entity( from titan to pilot )
	
	wait 0.3

	// shared view: target being ripped out and attacker prepare to crush pilot
	if ( IsAlive( attacker ) )
	{
		EmitSoundOnEntity( attacker, "northstar_prime_execution_part_01" )
	}

	//wait 2.4
	// shared view: crush the target
	// now handled by MeleePinkMist()
	/*
	print( "target alive: " + string( IsAlive( target ) ) )
	if ( IsAlive( target ) )
	{
		EmitSoundOnEntity( target, "monarch_battery_execution_bone_crush" )
	}
	*/
}

function StryderVsTitanModelEffects( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// no signals for target sequence because tf1 excutions can change target entity( from titan to pilot )

	// attacker animation: "at_melee_sync_frontkill"
	// reworked: client-side effects seems to working fine, we need server-side only ones
	/*
	const attackerAnimFPS = 30.0
	// { event AE_CL_CREATE_PARTICLE_EFFECT 21 "xo_damage_exp_1 follow_attachment exp_r_elbow" }
	wait 21.0 / attackerAnimFPS
	if ( IsAlive( attacker ) )
		ClassicExecutionParticleEffect( attacker, $"xo_damage_exp_1", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )
	*/

	// server-side effects
	wait 0.7
	// cracking open the hatch
	if ( IsAlive( attacker ) )
		ClassicExecutionParticleEffect( attacker, $"P_impact_exp_frag_air", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )
}

function AtlasVsTitanSoundEvent( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// no signals for target sequence because tf1 excutions can change target entity( from titan to pilot )
	
	wait 0.4

	// at this point target should have transferred to pilot
	entity targetTitan = target
	if ( IsAlive( target ) && target.IsPlayer() )
		targetTitan = target.GetPetTitan()
	// shared view: target being ripped out
	if ( IsAlive( targetTitan ) )
	{
		//EmitSoundOnEntityOnlyToPlayer( targetTitan, target, "monarch_execution_part_03_2ch_v1_01" )
		EmitSoundOnEntity( targetTitan, "monarch_execution_part_03_2ch_v1_01" )
	}

	wait 0.5
	// non-attacker view: attacker preparing throw
	if ( IsAlive( attacker ) )
	{
		if ( attacker.IsPlayer() )
			EmitSoundOnEntityExceptToPlayer( attacker, attacker, "tone_dlc_execution_part_02" )
		else
			EmitSoundOnEntity( attacker, "tone_dlc_execution_part_02" )
	}

	wait 0.1
	// attacker view: attacker preparing throw
	if ( IsAlive( attacker ) )
	{
		if ( attacker.IsPlayer() )
			EmitSoundOnEntityOnlyToPlayer( attacker, attacker, "tone_dlc_execution_part_02" )
	}

	wait 1.35
	// at this point npc titan should have spawned their embarked pilot
	// npc titan should've been ragdolled at this point, we update target if it's invalid or it's a npc
	if ( !IsValid( target ) || target.IsNPC() )
		target = expect entity( executionTable.target )
	// others view: target being throw out
	if ( IsAlive( attacker ) )
	{
		if ( IsAlive( target ) && !attacker.IsPlayer() && !target.IsPlayer() ) // npc executing npc case
			EmitSoundOnEntity( attacker, "tone_execution_part_03" )
		else // one of attacker/target is player
		{
			// we don't want either target nor attacker hearing the sound
			// so maybe we should emit the sound to all other players in sound range?
			// using a utility function
			EmitSoundOnEntityForPlayersInRange( attacker, "tone_execution_part_03", 1024, [attacker, target] )
		}
	}
	// target view: target being throw out
	if ( IsAlive( target ) )
	{
		if ( target.IsPlayer() )
			EmitSoundOnEntityOnlyToPlayer( target, target, "tone_execution_part_03" )
	}

	wait 0.2 // was 0.25, needs testing. EDIT: 0.2 is better
	// attacker view: target being throw out
	if ( IsAlive( attacker ) )
	{
		if ( attacker.IsPlayer() )
			EmitSoundOnEntityOnlyToPlayer( attacker, attacker, "tone_execution_part_03" )
	}
}

function AtlasVsTitanModelEffects( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// no signals for target sequence because tf1 excutions can change target entity( from titan to pilot )

	// attacker animation: "at_melee_sync_frontkill"
	// reworked: client-side effects seems to working fine, we need server-side only ones
	/*
	const attackerAnimFPS = 30.0
	// { event AE_CL_CREATE_PARTICLE_EFFECT 15 "xo_damage_exp_1 follow_attachment exp_r_elbow" }
	wait 15.0 / attackerAnimFPS
	if ( IsAlive( attacker ) )
		ClassicExecutionParticleEffect( attacker, $"xo_damage_exp_1", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )
	*/

	// server-side effects
	wait 0.4
	// cracking open the hatch
	if ( IsAlive( attacker ) )
		ClassicExecutionParticleEffect( attacker, $"P_impact_exp_frag_air", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )
}

function OgreVsTitanSoundEvent( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// ogre synced melee won't do titan transfer, safe to handle target sequence
	target.EndSignal( "OnAnimationDone" )
	target.EndSignal( "OnAnimationInterrupted" )
	
	// starting sound
	if ( IsAlive( attacker ) )
	{
		EmitSoundOnEntity( attacker, "legion_prime_execution_part_01" )
	}

	// target view: right arm being ripped
	if ( IsAlive( target ) )
	{
		if ( target.IsPlayer() )
			EmitSoundOnEntityOnlyToPlayer( target, target, "ion_execution_part_02" )
	}
	// non-target view: attacker rip right arm
	if ( IsAlive( attacker ) )
	{
		if ( IsAlive( target ) && !target.IsPlayer() )
			EmitSoundOnEntity( attacker, "ion_execution_part_02" )
		else
			EmitSoundOnEntityExceptToPlayer( attacker, target, "ion_execution_part_02" )
	}

	wait 1.5
	// target view: left arm being ripped
	if ( IsAlive( target ) )
	{
		if ( target.IsPlayer() )
			EmitSoundOnEntityOnlyToPlayer( target, target, "ion_execution_part_02" )
	}
	// non-target view: attacker rip left arm
	if ( IsAlive( attacker ) )
	{
		if ( IsAlive( target ) && !target.IsPlayer() )
			EmitSoundOnEntity( attacker, "ion_execution_part_02" )
		else
			EmitSoundOnEntityExceptToPlayer( attacker, target, "ion_execution_part_02" )
	}

	wait 1.4
	// shared view: throw arms to face
	if ( IsAlive( target ) )
	{
		EmitSoundOnEntity( target, "legion_prime_execution_part_02" )
	}
}

function OgreVsTitanModelEffects( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )
	// no target destroyed or death endsignal because we get them separently
	// ogre synced melee won't do titan transfer, safe to handle target sequence
	target.EndSignal( "OnAnimationDone" )
	target.EndSignal( "OnAnimationInterrupted" )

	// victim animation: "og_melee_armrip_victim"
	// reworked: client-side effects seems to working fine, we need server-side only ones
	/*
	const targetAnimFPS = 30.0
	// { event AE_CL_CREATE_PARTICLE_EFFECT 40 "xo_damage_exp_1 follow_attachment pod_r" }
	wait 40.0 / targetAnimFPS
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"xo_damage_exp_1", "POD_R", FX_PATTACH_POINT_FOLLOW )

	// { event AE_CL_CREATE_PARTICLE_EFFECT 62 "xo_damage_exp_1 follow_attachment pod_l" }
	wait ( 62.0 - 40.0 ) / targetAnimFPS
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"xo_damage_exp_1", "POD_L", FX_PATTACH_POINT_FOLLOW )

	// { event AE_CL_CREATE_PARTICLE_EFFECT 94 "xo_damage_exp_2 follow_attachment pod_l" }
	wait ( 94.0 - 62.0 ) / targetAnimFPS
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"xo_damage_exp_2", "POD_L", FX_PATTACH_POINT_FOLLOW )

	// { event AE_CL_CREATE_PARTICLE_EFFECT 100 "xo_damage_exp_1 follow_attachment pod_l" }
	wait ( 100.0 - 94.0 ) / targetAnimFPS
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"xo_damage_exp_1", "POD_L", FX_PATTACH_POINT_FOLLOW )
	*/

	// server-side effects
	// start ripping arms, make arms become ignited
	if ( IsAlive( target ) )
	{
		ClassicExecutionParticleEffect( target, $"xo_health_fire_vent", "exp_L_shoulder", FX_PATTACH_POINT_FOLLOW )
		ClassicExecutionParticleEffect( target, $"xo_health_fire_vent", "exp_R_shoulder", FX_PATTACH_POINT_FOLLOW )
	}

	wait 0.7
	// right arm being ripped out
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"P_impact_exp_lrg_metal", "exp_R_elbow", FX_PATTACH_POINT_FOLLOW )

	wait 1.4
	// left arm being ripped out
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"P_impact_exp_lrg_metal", "exp_L_elbow", FX_PATTACH_POINT_FOLLOW )	

	wait 0.9
	// throw arms to face
	if ( IsAlive( target ) )
		ClassicExecutionParticleEffect( target, $"P_impact_exp_frag_air", "exp_torso_up", FX_PATTACH_POINT_FOLLOW )	
}

void function OgreVsTitanScriptedAnimEvent( entity attacker, entity target, executionTable )
{
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	attacker.EndSignal( "SyncedMeleeComplete" )

	target.EndSignal( "OnDestroy" )
	target.EndSignal( "OnDeath" )
	target.EndSignal( "OnAnimationDone" )
	target.EndSignal( "OnAnimationInterrupted" )

	// fake target anim event: do UP explosion effect when about to die
	// similar to GlobalAnimEvent_TitanGib() does
	// this is extremely hack!

	// { event AE_MELEE_KILLED 108 "" } run on 30fps
	// we wait 0.1s less before that is triggered!
	wait 108.0 / 30.0 - 0.1
	if ( !TitanHasBeenGibbed( target ) )
	{
		PlayTitanDeathFxUp_Ragdoll( target )
		GibTitan( target )
		if ( target.IsNPC() ) // npc target plays death animation if not becoming a ragdoll
			target.e.forceRagdollDeath = true
	}
}
// modified functions end

void function MeleeThread_AtlasVsTitanShort( SyncedMelee action, entity attacker, entity target )
{
	if ( !IsAlive( attacker ) )
		return

	if ( !IsAlive( target ) )
		return

	string attackerAnimation1p = "atpov_melee_sync_frontkill_autotitan"
	string attackerAnimation3p = "at_melee_sync_frontkill_autotitan"
	string targetAnimation3p = "at_melee_sync_frontdeath_autotitan"

	target.Signal( "TitanStopsThinking" ) // in future, need to make titan scripted anims co-exist better and not require gotcha stuff like this -Mackey

	target.EndSignal( "OnDestroy" ) // needs to track target destroy because this type of termination won't do titan transfer

	local e = {}
	e.attackerViewBody <- null

	e.attackerStartOrg <- attacker.GetOrigin()

	entity ref = CreateMeleeScriptMoverBetweenEnts( attacker, target )

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"

	FirstPersonSequenceStruct targetSequence = clone attackerSequence

	attackerSequence.thirdPersonAnim = attackerAnimation3p
	// attackerSequence.thirdPersonAnimIdle = "at_melee_sync_frontkill_end_idle"

	attackerSequence.firstPersonAnim = attackerAnimation1p
	targetSequence.thirdPersonAnim = targetAnimation3p
	targetSequence.blendTime = 0.25

	target.e.syncedMeleeAttacker = attacker

	//	attacker.SetInvulnerable()
	target.SetInvulnerable()    //HACK: Have to SetInvulnerable first before attacker holsters weapon, because if the attacker is vortexing, holster will release bullets caught and kill off the victim if low enough health
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	// modified
	if ( attacker.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		// it's better to use holster attacker weapon for tf-1 executions I think
		// we're in first person and wants to re-deploy weapon after animation
		attacker.DisableWeaponViewModel() // we still need disable viewmodel, so player can't see weapon holster animation
		attacker.HolsterWeapon()
		attacker.Server_TurnOffhandWeaponsDisabledOn()
		
		attacker.ClearOffhand() // since this is first person execution, should clear out player's offhand weapon( eg.melee )
		attacker.Anim_StopGesture( 0 ) // ttf1 executions lasts short, should instant stop their animation and set to executions
	}

	//HACK! This function was originally for NPCs only, but now that it is being used for players, we need to holster their weapon
	// modified
	//if ( target.IsPlayer() )
	//	HolsterAndDisableWeapons( target )
	if ( target.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.DisableWeaponViewModel()
		target.Server_TurnOffhandWeaponsDisabledOn()
		
		target.Anim_StopGesture( 0 )
	}
	else
	{
		DisableWeapons( target, [] )
		// vanilla missing behavior: npc target can have scripted animation playing, needs to stop that
		target.Anim_Stop()
	}

	// should always holster main weapon! moved up
	//if ( ShouldHolsterWeaponForSyncedMelee( attacker ) )
	//	HolsterAndDisableWeapons( attacker )

	local attackerViewBody

	// needs shortened verions
	EmitDifferentSoundsOnEntityForPlayerAndWorld( "Titan_1p_Sync_Melee_vs_AutoTitan", "Titan_3p_Sync_Melee_vs_AutoTitan", attacker, attacker )
	// manually do some titanfall2 sounds
	thread AtlasVsTitanShortSoundEvent( attacker, target, e )
	// manually fix model fx
	thread AtlasVsTitanShortModelEffects( attacker, target, e )

	local soul = target.GetTitanSoul()
	soul.SetInvalidHealthBarEnt( true )

	// some tf1 execution is missing this callback
	// let's just call it manually on execution start
	//AddAnimEvent( target, "rider_rodeo_over", ForceTitanRodeoToEnd  )
	ForceTitanRodeoToEnd( target )

	target.SetInvulnerable() //Setting target of execution as invulnerable to prevent them dying mid-way
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	OnThreadEnd(
		function() : ( ref, attacker, target, e  )
		{
			if ( IsValid( ref ) )
			{
				if ( IsValid( attacker ) )
					attacker.ClearParent()

				if ( IsValid( target ) )
					target.ClearParent()

				AssertNoPlayerChildren( ref )
				ref.Destroy()
			}

			if ( IsValid( attacker ) )
			{
				// saved for ai executions
				attacker.ClearParent()
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker )
					// modified
					//DeployAndEnableWeapons( attacker )
					//DeployViewModelAndEnableWeapons( attacker )

					// it's better to use holster attacker weapon for tf-1 executions I think
					// we're in first person and wants to re-deploy weapon after animation
					if ( IsAlive( attacker ) )
						attacker.EnableWeaponViewModel()
					attacker.DeployWeapon() // deploy should always happen, unlike enableViewModel should only happen when player alive
					attacker.Server_TurnOffhandWeaponsDisabledOff()

					attacker.PlayerMelee_ExecutionEndAttacker()
				}
				else
				{
					// modified
					//EnableWeapons( attacker, [] )
					//Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
				}

				//attacker.ClearInvulnerable()

				// changed for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker )
				//DeployAndEnableWeapons( attacker )
				//attacker.PlayerMelee_ExecutionEndAttacker()

				if ( IsAlive( attacker ) )
				{
					// if we got into solid, teleport back to safe place
					if ( !PutEntityInSafeSpot( attacker, null, null, expect vector( e.attackerStartOrg ), attacker.GetOrigin() ) )
                    {
						printt( "PutEntityInSafeSpot failed, putting him back at the start origin" )
						attacker.SetOrigin( expect vector( e.attackerStartOrg ) )
                    }
				}

				// modified condition
				if ( !IsValid( target ) ) // target gets destroyed early
					attacker.Anim_Stop() // stop attacker sequence
			}

			if ( IsValid( target ) )
			{
				if ( !target.IsNPC() )
				{
					target.PlayerMelee_ExecutionEndTarget()
					ClearPlayerAnimViewEntity( target )
					// modified
					//DeployAndEnableWeapons( target )
					//DeployViewModelAndEnableWeapons( target )
					if ( IsAlive( target ) )
						target.EnableWeaponViewModel()
					target.Server_TurnOffhandWeaponsDisabledOff()
				}
				else
					EnableWeapons( target, [] )

				if ( IsAlive( target ) )
				{
					local attack = attacker
					if ( !IsValid( attack ) )
						attack = null

					target.Die( attack, attack, { scriptType = 0, damageSourceId = eDamageSourceId.titan_execution } )
				}

				target.e.syncedMeleeAttacker = null

				if ( HasAnimEvent( target, "rider_rodeo_over" ) )
					DeleteAnimEvent( target, "rider_rodeo_over" )
			}
		}
	)

	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	thread FirstPersonSequence( targetSequence, target, ref )
	waitthread FirstPersonSequence( attackerSequence, attacker, ref )

	//wait ( 50.0 / 30.0 ) // 37 frames in
}

// vanilla having incorrect spelling
//void function MeleeThread_StyderVsTitan( SyncedMelee action, entity attacker, entity target )
void function MeleeThread_StryderVsTitan( SyncedMelee action, entity attacker, entity target )
{
	table e
	e.gib <- true
	e.attackerAnimation1p <- "strypov_melee_sync_frontkill"
	e.attackerAnimation3p <- "stry_melee_sync_frontkill"
	e.targetAnimation3p <- "stry_melee_sync_frontdeath"
	e.targetPilotAnimationForAttacker <- "pt_stry_melee_sync_front_pilotkill_1st"
	e.targetPilotAnimationForObserver <- "pt_stry_melee_sync_front_pilotkill_3rd"
	e.targetPilotAnimationForObserver1st <- "ptpov_stry_tvtmelee_targetdeath"
	e.TitanSpecific1pSyncMeleeSound <- "Stryder_1p_Sync_Melee"
	e.TitanSpecific3pSyncMeleeSound <- "Stryder_3p_Sync_Melee" // empty sound in ttf2
	// we delay player becomes pilot, so they can have cockpit model
	// hard to control, don't do it. just screen fade to cockpit open?
	//e.playerTitanBecomePilotDelay <- 0.4

	// fake the screen fade on disembark
	// same fadeout time, longer hold
	if ( target.IsPlayer() )
		thread ClassicExecutionScreenFadeFromBlack( target, 0.2, 0.7 )
	// manually add some sound using titanfall 2's sounds
	thread StryderVsTitanSoundEvent( attacker, target, e )
	// manually fix model fx
	thread StryderVsTitanModelEffects( attacker, target, e )
	
	MeleeThread_TitanRipsPilot( e, action, attacker, target )
}

void function MeleeThread_AtlasVsTitan( SyncedMelee action, entity attacker, entity target )
{
	table e
	e.gib <- false
	e.attackerAnimation1p <- "atpov_melee_sync_frontkill"
	e.attackerAnimation3p <- "at_melee_sync_frontkill"
	e.targetAnimation3p <- "at_melee_sync_frontdeath"
	e.targetPilotAnimationForAttacker <- "pt_melee_sync_front_pilotkill_1st"
	e.targetPilotAnimationForObserver <- "pt_melee_sync_front_pilotkill_3rd"
	e.targetPilotAnimationForObserver1st <- "ptpov_tvtmelee_targetdeath"
	e.TitanSpecific1pSyncMeleeSound <- "Atlas_1p_Sync_Melee" // empty sound in ttf2
	e.TitanSpecific3pSyncMeleeSound <- "Atlas_3p_Sync_Melee"
	// we delay player becomes pilot, so they can have cockpit model
	// hard to control, don't do it. just screen fade to cockpit open?
	//e.playerTitanBecomePilotDelay <- 0.4

	// fake the screen fade on disembark
	// same fadeout time, longer hold
	if ( target.IsPlayer() )
		thread ClassicExecutionScreenFadeFromBlack( target, 0.2, 0.45 )
	// manually add some sound using titanfall 2's sounds
	thread AtlasVsTitanSoundEvent( attacker, target, e )
	// manually fix model fx
	thread AtlasVsTitanModelEffects( attacker, target, e )

	MeleeThread_TitanRipsPilot( e, action, attacker, target )
}

function MeleeThread_TitanRipsPilot( table e, SyncedMelee action, entity attacker, entity target )
{
	e.attackerViewBody <- null
	e.attacker <- attacker
	e.attackerStartOrg <- attacker.GetOrigin()

	entity ref = CreateMeleeScriptMoverBetweenEnts( attacker, target )

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"

	FirstPersonSequenceStruct targetSequence = clone attackerSequence

	attackerSequence.thirdPersonAnim = expect string ( e.attackerAnimation3p )
	// attackerSequence.thirdPersonAnimIdle = "at_melee_sync_frontkill_end_idle"

	attackerSequence.firstPersonAnim = expect string( e.attackerAnimation1p )
	targetSequence.thirdPersonAnim = expect string ( e.targetAnimation3p )
	targetSequence.blendTime = 0.25

	target.e.syncedMeleeAttacker = attacker

	//	attacker.SetInvulnerable()
	target.SetInvulnerable()    //HACK: Have to SetInvulnerable first before attacker holsters weapon, because if the attacker is vortexing, holster will release bullets caught and kill off the victim if low enough health
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	// modified, always holster!!!
	//if ( ShouldHolsterWeaponForSyncedMelee( attacker ) )
	//{
	//	if ( attacker.IsPlayer() )
	//		HolsterAndDisableWeapons( attacker )
	//	else
	//		DisableWeapons( attacker, [] )
	//}
	if ( attacker.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		// it's better to use holster attacker weapon for tf-1 executions I think
		// we're in first person and wants to re-deploy weapon after animation
		attacker.DisableWeaponViewModel() // we still need disable viewmodel, so player can't see weapon holster animation
		attacker.HolsterWeapon()
		attacker.Server_TurnOffhandWeaponsDisabledOn()
		
		attacker.ClearOffhand() // since this is first person execution, should clear out player's offhand weapon( eg.melee )
		attacker.Anim_StopGesture( 0 ) // ttf1 executions lasts short, should instant stop their animation and set to executions
	}

	// modified
	//if ( !target.IsNPC() )
	//	HolsterAndDisableWeapons( target )
	if ( target.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.DisableWeaponViewModel()
		target.Server_TurnOffhandWeaponsDisabledOn()
		
		target.Anim_StopGesture( 0 )
	}
	else
	{
		DisableWeapons( target, [] )
		// vanilla missing behavior: npc target can have scripted animation playing, needs to stop that
		target.Anim_Stop()
	}

	EmitDifferentSoundsOnEntityForPlayerAndWorld( expect string ( e.TitanSpecific1pSyncMeleeSound ), expect string ( e.TitanSpecific3pSyncMeleeSound ), attacker, attacker )

	entity attackerViewBody
	bool targetIsPlayer = target.IsPlayer()

	// modified here: only create atackerViewBody for player attackers
	if ( attacker.IsPlayer() )
	{
		// MODIFIED here: wrap everything into function
		// don't be confused by this name: "attackerViewBody" means "the body used for attacker's view"
		// so we need to create target's pilot model
		attackerViewBody = CreateTitanExecutionViewBody( target )
		
		attackerViewBody.SetOrigin( ref.GetOrigin() )
		e.attackerViewBody = attackerViewBody
		attackerViewBody.SetOwner( attacker )
		attackerViewBody.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
		attackerViewBody.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
		attackerViewBody.SetContinueAnimatingAfterRagdoll( true )
	}

	FirstPersonSequenceStruct attackerBodySequence
	attackerBodySequence.attachment = "ref"
	attackerBodySequence.teleport = true
	attackerBodySequence.thirdPersonAnim = expect string ( e.targetPilotAnimationForAttacker )

	FirstPersonSequenceStruct targetBodySequence
	targetBodySequence.attachment = "ref"
	targetBodySequence.blendTime = 0.25
	targetBodySequence.thirdPersonAnim = expect string ( e.targetPilotAnimationForObserver )
	targetBodySequence.firstPersonAnim = expect string ( e.targetPilotAnimationForObserver1st )


	entity targetSoul = target.GetTitanSoul()
	targetSoul.SetInvalidHealthBarEnt( true )

	entity targetTitan
	if ( targetIsPlayer )
	{
		// setup signal for us tracking execution progress
		// end execution if target gets destroyed without dying( eg.disconnect )
		attacker.EndSignal( "ForceEndTitanExecution" )
		thread TrackTitanExecutionValidTime( attacker, target )

		// we won't change class, no need to reset settings
		//e.oldPlayerSettings <- target.s.storedPlayerSettings
		//target.s.storedPlayerSettings = "pilot_titan_cockpit" // Makes player have titan cockpit temporarily. Turned off to avoid having extra checks all over in script
		targetTitan = CreateAutoTitanForPlayer_ForTitanBecomesPilot( target ) //TargetTitan is the NPC Titan that is created temporarily during execution
		DispatchSpawn( targetTitan )

		// we delay player becomes pilot, so they can have cockpit model
		// hard to control, don't do it. just screen fade to cockpit open?
		TitanBecomesPilot( target, targetTitan )
		//thread DelayedTitanBecomesPilot( target, targetTitan, expect float( e.playerTitanBecomePilotDelay ) )
		DisableTitanRodeo( targetTitan )
		targetTitan.SetOwner( target )
		targetTitan.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) //owner cant see
		targetTitan.PlayerMelee_ExecutionStartTarget( attacker )
    	e.target <- target

		// modified for titanpick!
		// don't drop weapon on this titan. CreateAutoTitanForPlayer_ForTitanBecomesPilot() won't spawn a soul, so we get soul after player transfer their titanSoul(through TitanBecomesPilot) to this targetTitan
		entity soul = targetTitan.GetTitanSoul()
		if ( IsValid( soul ) )
			TitanPick_SoulSetEnableWeaponDrop( soul, false )
	}
	else
	{
		targetTitan = target

		// setup signal for us tracking execution progress
		// end execution if target gets destroyed without dying
		// for npcs, we track titan because our ripped target is always valid to kill
		attacker.EndSignal( "ForceEndTitanExecution" )
		thread TrackTitanExecutionValidTime( attacker, targetTitan )

		// modified for titanpick!
		// don't drop weapon on this titan
		// fix: the target is still a titan, not transfering, guess no need to manually disable weapon drop
		//entity soul = targetTitan.GetTitanSoul()
		//if ( IsValid( soul ) )
		//	TitanPick_SoulSetEnableWeaponDrop( soul, false )

		// npc pilot variant
		#if NPC_TITAN_PILOT_PROTOTYPE
			// here's a fake pilot. score is handled by the titan because script will still think there's a npc pilot inside of it
			// reworked to make them no longer fake, we've handled score events properly
			//target = CreateNPC( "npc_pilot_elite", targetTitan.GetTeam(), targetTitan.GetOrigin(), < 0,0,0 > )
			//DispatchSpawn( target )
			//TakeAllWeapons( target )
			
			// add a little workaround: killing a npc pilot won't be displayed in obit, leaving only titan obit
			// but NpcTitanBecomesPilot() changes titan title to "XXX's Auto-Titan"
			// here we reset title back to start, so they will display titan's title( Ion, Tone etc. ) in obit
			string titanTitle = targetTitan.GetTitle()
			target = NpcTitanBecomesPilot( targetTitan )
			targetTitan.SetTitle( titanTitle )
		#else // vnilla behavior: target is now a random dude
			target = CreateSoldier( target.GetTeam(), Vector(0,0,0), Vector(0,0,0) ) // they can still speak though
			DispatchSpawn( target )

			target.SetModel( GetNpcTitanPilotModel( targetTitan ) )

			// modified: mark as silentDeath so they don't scream( mostly for grunts )
			target.s.silentDeath <- true
			// if target is a npc, they must be fake bodies. never do npc killed event for player
			// this only changes MeleePinkMist() and MeleeThrowIntoWallSplat(). MeleeKilledRagdoll() for the titan will work as normal
			e.attacker = target // make them suicide!
		#endif // NPC_TITAN_PILOT_PROTOTYPE

		// because we're using disembarked npc pilot, this should only be in vanilla behavior
		//target.SetModel( GetNpcTitanPilotModel( targetTitan ) )

		e.target <- target

		// vanilla missing: target should always be invulnerable and notarget at this point
		target.SetInvulnerable()
		target.SetNoTarget( true )

		// modified: because we're using this guy as a fake body, needs to hide their name stuffs
		HideName( target )
	}

	//AddAnimEvent( targetTitan, "rider_rodeo_over", ForceTitanRodeoToEnd  )
	// manually call rodeo stop
	ForceTitanRodeoToEnd( targetTitan )
	AddAnimEvent( targetTitan, "melee_killed_ragdoll", MeleeKilledRagdoll, attacker )

	targetTitan.SetInvulnerable() //Setting target of execution as invulnerable to prevent them dying mid-way
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	targetTitan.SetNoTarget( true )

	// setOwner is bad. the proper way is we hide target and spawn a target viewbody
	// we can't make only two players can't see targetViewBody... now revert back to SetOwner()
	// but we don't do NpcTitanBecomesPilot() so the pilot isn't there for players to kill, score can be handled by checking TitanHasNpcPilot() on titans
	// EDIT: now we're using NpcTitanBecomesPilot() because score event checks has been reworked! can be handled properly
	// now with one modification: only set owner for player attackers
	if ( attacker.IsPlayer() )
	{
		target.SetOwner( attacker )
		target.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY) //owner cant see
	}

	e.targetTitan <- targetTitan

	if ( GetBugReproNum() == 129802 )
		thread OnNPCTitanSignalDeath( targetTitan )

	OnThreadEnd(
		function() : ( ref, attacker, target, targetTitan, e )
		{
			// modified here: we've added failsafe timer for melee throw
			// if throw succeeded we delay the cleanup
			local targetInFlight = IsAlive( target ) && e.thrown && !e.thrownKilled

			if ( IsValid( ref ) )
			{
				if ( IsValid( attacker ) )
				{
					attacker.ClearParent()
				}
				else
				{
					TryClearParent( attacker )
				}

				// modified here: we've added failsafe timer for melee throw
				// if throw succeeded we should delay cleanup these stuffs
				if ( !targetInFlight ) // target should be killed! if target gets throwed, cleanup handled by CleanUpSyncedMeleeOnThrownTargetDeathOrAnimDone()
				{
					if ( IsValid( target ) )
					{
						target.ClearParent()
					}
					else
					{
						TryClearParent( target )
					}

					AssertNoPlayerChildren( ref )
					ref.Kill_Deprecated_UseDestroyInstead()
				}
			}

			if ( IsValid( attacker ) )
			{
				attacker.ClearParent()
				// saved for npc executions
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker ) 
					// modified
					//DeployAndEnableWeapons( attacker )
					//DeployViewModelAndEnableWeapons( attacker )

					// it's better to use holster attacker weapon for tf-1 executions I think
					// we're in first person and wants to re-deploy weapon after animation
					if ( IsAlive( attacker ) )
						attacker.EnableWeaponViewModel()
					attacker.DeployWeapon() // deploy should always happen, unlike enableViewModel should only happen when player alive
					attacker.Server_TurnOffhandWeaponsDisabledOff()
					attacker.PlayerMelee_ExecutionEndAttacker()
				}
				else
				{
					EnableWeapons( attacker, [] )
					//Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
				}

				// change for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker ) 
				//DeployAndEnableWeapons( attacker )
				//attacker.PlayerMelee_ExecutionEndAttacker()

				if ( IsAlive( attacker ) )
				{
					// if we got into solid, teleport back to safe place
					PutEntityInSafeSpot( attacker, null, null, expect vector( e.attackerStartOrg ), attacker.GetOrigin() )
				}
			}

			if ( IsValid( target ) )
			{
				// modified here: we've added failsafe timer for melee throw
				// if throw succeeded we never pinkmist them
				// shared cleanup
				if ( HasAnimEvent( target, "pink_mist" ) )
					DeleteAnimEvent( target, "pink_mist" )

				if ( targetInFlight ) // still in throw flight...
				{
					//print( "Player still in throw flight after melee thread! delay the cleanup" )
					// do a special think for throwing case
					// this also cleans up ref
					thread CleanUpSyncedMeleeOnThrownTargetDeathOrAnimDone( target, ref )
				}
				else // vanilla behavior
				{
					target.SetOwner( null ) // defensive cleanup

					if ( !target.IsNPC() )
					{
						target.PlayerMelee_ExecutionEndTarget()
						ClearPlayerAnimViewEntity( target )
						// modified
						//DeployAndEnableWeapons( target )
						//DeployViewModelAndEnableWeapons( target )
						if ( IsAlive( target ) )
							target.EnableWeaponViewModel()
						target.Server_TurnOffhandWeaponsDisabledOff()
					}
					
					// modified: only do pinkmist if not thrown...
					if ( !e.thrown && IsAlive( expect entity( e.target ) ) )
					{
						// debug
						//print( "Doing meleePinkMist!" )
						MeleePinkMist( e )
					}

					target.e.syncedMeleeAttacker = null
				}
			}

			if ( IsValid( e.attackerViewBody ) )
				e.attackerViewBody.Kill_Deprecated_UseDestroyInstead()

			if ( GetBugReproNum() != 129802 && IsAlive( targetTitan ) )
			{
				if ( IsValid( attacker ) )
					targetTitan.Die( attacker, attacker, { scriptType = DF_MELEE, damageSourceId = eDamageSourceId.titan_execution } )
				else
					targetTitan.Die()

				if ( GetBugReproNum() == 129815 )
				{
					targetTitan.SetContinueAnimatingAfterRagdoll( true )
					targetTitan.BecomeRagdoll( Vector(0,0,0), false )
				}
			}
		}
	)

	target.EndSignal( "OnRespawnPlayer" ) // northstar scripts didn't use this often... this is signaled in CPlayer::RespawnPlayer()
	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	waitthread TitanSyncedMeleeAnimationsPlay( attackerBodySequence, attackerViewBody, ref, targetBodySequence, target, attackerSequence, attacker, targetSequence, targetTitan, e )
}

// modified
void function CleanUpSyncedMeleeOnThrownTargetDeathOrAnimDone( entity target, entity ref )
{
	target.EndSignal( "OnDestroy" )
	WaitSignal( target, "OnDeath", "OnAnimationDone", "OnAnimationInterrupted" )

	//print( "player killed by melee throw!" )

	// clean up ref
	if ( IsValid( target ) )
	{
		target.ClearParent()
	}
	else
	{
		TryClearParent( target )
	}

	if ( IsValid( ref ) )
	{
		AssertNoPlayerChildren( ref )
		ref.Kill_Deprecated_UseDestroyInstead()
	}

	// target stuffs cleanup
	//target.SetOwner( null ) // defensive cleanup. should already be handled by MeleeWallSplatKillTarget()

	if ( !target.IsNPC() )
	{
		target.PlayerMelee_ExecutionEndTarget()
		ClearPlayerAnimViewEntity( target )
		if ( IsAlive( target ) )
			target.EnableWeaponViewModel()
		target.Server_TurnOffhandWeaponsDisabledOff()
	}

	target.e.syncedMeleeAttacker = null
}

// new utility function: handle both npc and player model creation
entity function CreateTitanExecutionViewBody( entity titan )
{
	entity pilotModel
	if ( titan.IsPlayer() )
	{
		pilotModel = Wallrun_CreateCopyOfPilotModel( titan )
		// vanilla missing: highlights for player viewbody
		SetDefaultMPEnemyHighlight( pilotModel )
	}
	else
		pilotModel = CreateNpcTitanPilotModel( titan )
	
	return pilotModel
}

entity function CreateNpcTitanPilotModel( entity titan )
{
	// reworked to have more setup on model
	asset modelName = GetNpcTitanPilotModel( titan )
	//return CreatePropDynamic( modelName )
	
	entity pilotModel = CreatePropDynamic( modelName )
	//entity pilotModel = CreatePropDynamic( modelName, titan.GetAttachmentAngles( titan.LookupAttachment( "hijack" ) ) ) // spawn right under titan, won't have the model "flash" into titans.
	// vanilla missing
	SetTeam( pilotModel, titan.GetTeam() ) // so prop will have team lights

	// modified here: run callbacks for every pilot model creation
	// Added via Wallrun_AddCallback_OnCreatingPilotModel
	Wallrun_RunCallbacks_OnCreatingPilotModel( pilotModel, titan )

	return pilotModel
}

asset function GetNpcTitanPilotModel( entity titan )
{
	asset modelName = TEAM_IMC_GRUNT_MODEL

	#if HAS_BOSS_AI
		if ( IsBossTitan( titan ) )
		{
			modelName = GetBossTitanCharacterModel( titan )
		}
	#elseif NPC_TITAN_PILOT_PROTOTYPE // modified condition
		if( TitanHasNpcPilot( titan ) )
		{
			entity titanSoul = titan.GetTitanSoul()
			modelName = titanSoul.soul.seatedNpcPilot.modelAsset
		}
	#endif

	return modelName
}

function TitanSyncedMeleeAnimationsPlay( FirstPersonSequenceStruct attackerBodySequence, entity attackerViewBody, entity ref, FirstPersonSequenceStruct targetBodySequence, entity target, FirstPersonSequenceStruct attackerSequence, entity attacker, FirstPersonSequenceStruct targetSequence, entity targetTitan, table e )
{
	e.thrown <- false
	e.thrownKilled <- false // if throw takes too long, target will be killed by MeleePinkMist()
	OnThreadEnd (
		function () : ( targetTitan, target, attacker, e )
		{
			// insure visibility
			if ( IsValid( targetTitan ) )
				targetTitan.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE

			// might be missing behavior here
			// after targetTitan is shown, really should stop attacker sequence
			// they're too long and titanfall 2 executions will deploy weapon after target dies
			// no need to do recover animation, will softlock player for a moment

			// hardcoded for stryder execution! atlas needs to wait for target hits a wall, handled by MonitorMeleeThrowAnimation()
			// welp, atlas execution won't hit this line because their target gets killed pretty late
			// but still needs to hardcode for stryder, for whatever reason
			if ( e.attackerAnimation3p == "stry_melee_sync_frontkill" )
			{
				if ( IsAlive( attacker ) && !IsAlive( target ) )
				{
					attacker.Anim_Stop()
				}
			}

			if ( !IsAlive( attacker ) )
			{
				if ( IsValid( attacker ) )
					attacker.Anim_Stop()

				// show target now only happens for stryder syncedmelee
				// atlas one is handled by MeleeWallSplatKillTarget(), attacker sequence handled by MonitorMeleeThrowAnimation()
				if ( !e.thrown && IsAlive( target ) )
				{
					target.Anim_Stop()

					target.SetOwner( null )
					target.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE // needs to show target

					if ( target.IsPlayer() )
					{
						ClearPlayerAnimViewEntity( target )
						target.GetFirstPersonProxy().Anim_Stop()
						// we won't change class, no need to reset settings
						//target.SetPlayerSettings( e.oldPlayerSettings )
					}

				}
			}
		}
	)

	attacker.EndSignal( "OnDeath" )
	target.EndSignal( "OnDestroy" )
	target.EndSignal( "OnRespawnPlayer" ) // northstar scripts didn't use this often... this is signaled in CPlayer::RespawnPlayer()

	if ( !attacker.IsPlayer() ) // save for npc titans
	{
		// don't do first person anims if we're not a player
		attackerBodySequence.firstPersonAnim = ""
		attackerBodySequence.firstPersonAnimIdle = ""
	}

	// due to modifications in TitanRipsPilot, attackerViewBody can now be invalid when attacker is npc
	if ( IsValid( attackerViewBody ) )
		thread FirstPersonSequence( attackerBodySequence, attackerViewBody, ref )
	
	if ( !target.IsPlayer() )
	{
		// don't do first person anims if we're not a player
		targetBodySequence.firstPersonAnim = ""
		targetBodySequence.firstPersonAnimIdle = ""
	}

	thread FirstPersonSequence( targetBodySequence, target, ref )
	thread FirstPersonSequence( attackerSequence, attacker, ref )
	thread FirstPersonSequence( targetSequence, targetTitan, ref )
	targetTitan.Anim_AdvanceCycleEveryFrame( true )
	local duration = attacker.GetSequenceDuration( attackerSequence.thirdPersonAnim )

	if ( e.targetAnimation3p == "at_melee_sync_frontdeath" )
	{
		thread MeleeThrowIntoWallSplat( attacker, target, e, duration )
		// modified: we stop animation after certain delay, don't have to wait for animation fully ends
		// end signals to allow intterupt animation
		// this will cause throw less likely to success
		attacker.EndSignal( "OnAnimationDone" )
		attacker.EndSignal( "OnAnimationInterrupted" )
		thread MonitorMeleeThrowAnimation( attacker, target, e, duration )
	}
	else
	{
		AddAnimEvent( target, "pink_mist", MeleePinkMistAnimEvent, e )
	}

	float timer
	// modified here: we can't hardcode titan type anymore because we've added random execution case
	/*
	string titanType = GetSoulTitanSubClass( attacker.GetTitanSoul() )
	switch ( titanType )
	{
		case "stryder":
			timer = 0.9
			break
		case "atlas":
		case "buddy":
			timer = 0.45
			break
		default:
			Assert( 0, "Unknown titan type " + titanType )
	}
	*/
	// try to check animations
	string target3pAnim = targetSequence.thirdPersonAnim
	switch ( target3pAnim )
	{
		// add shorter timer because tf2 don't have pilot titan cockpit model and we've added screen fade
		// stryder one may seem bad but whatever
		case "stry_melee_sync_frontdeath":
			timer = 0.8
			break
		case "at_melee_sync_frontdeath":
			timer = 0.4
			break
		
		// failsafe: are we using ogre execution inside this function?
		default:
			timer = 0.0
			break
	}

	wait timer

	// first the victim cant see his titan, as a pilot, and then he can
	// vanilla missing validation checks
	if ( IsValid( targetTitan ) )
	{
		targetTitan.SetNextThinkNow()
		targetTitan.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
		targetTitan.SetNextThinkNow()
	}
	wait duration - timer
}

void function MeleePinkMistAnimEvent( entity target ) //parameter isn't used, but function signature is like this because it's being called from an anim event
{
	table e = expect table( GetOptionalAnimEventVar( target, "pink_mist" ) )

	MeleePinkMist( e )
}

void function MeleePinkMist( table e )
{
	entity target = expect entity( e.target )

	if ( !IsAlive( target ) )
		return

	// attacker visual effect
	entity attackerViewBody = expect entity ( e.attackerViewBody )
	if ( IsValid( attackerViewBody ) )
	{
		// attacker sound fix
		if ( !e.thrown && IsValid( e.attacker ) && e.attacker.IsPlayer() ) // only do sound fix if we're not throwing target
			EmitSoundAtPositionOnlyToPlayer( target.GetTeam(), attackerViewBody.GetOrigin(), e.attacker, "monarch_battery_execution_bone_crush" )
		
		// use wrapped function MeleePinkMistFakeBody(), which includes misc fixes
		//e.attackerViewBody.Dissolve( ENTITY_DISSOLVE_PINKMIST, Vector( 0, 0, 0 ), 0 )
		MeleePinkMistFakeBody( attackerViewBody )
	}
	if ( IsValid( e.attacker ) ) // target dying
	{
		// non-attacker sound event fix
		if ( !e.thrown ) // only do sound fix if we're not throwing target. because if throw sequence going too long it will also trigger this function as a failsafe case, which seems bad to fix sound
		{
			if ( IsValid( e.attacker ) && e.attacker.IsPlayer() )
				EmitSoundAtPositionExceptToPlayer( target.GetTeam(), target.GetOrigin(), e.attacker, "monarch_battery_execution_bone_crush" )
			else
				EmitSoundAtPosition( target.GetTeam(), target.GetOrigin(), "monarch_battery_execution_bone_crush" )
		}

		target.Die( e.attacker, e.attacker, { damageSourceId = eDamageSourceId.titan_execution, scriptType = DF_GIB } )
	}
	else // attacker invalid, guess execution has failed... no need to fix sound
	{
		target.Die( e.target, target, { damageSourceId = eDamageSourceId.titan_execution, scriptType = DF_GIB } )
	}

	if ( target.IsPlayer() )
		ClearPlayerAnimViewEntity( target )

	target.ClearInvulnerable()
	// target should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( false )
}

// modified to add duration parameter
//function MeleeThrowIntoWallSplat( entity attacker, entity target, e )
function MeleeThrowIntoWallSplat( entity attacker, entity target, e, duration )
{
	expect table( e ) // for MeleePinkMist can use

	OnThreadEnd(
		function () : ( attacker, target, e )
		{
			if ( IsValid( target ) )
			{
				target.ClearParent()
				target.Anim_Stop()
				target.ClearInvulnerable()
				// target should be ignored while being executed
				// breaks vanilla behavior but whatever
				target.SetNoTarget( false )
			}

			// vanilla missing: if target hits a wall earlier than we expected, should end attacker sequence
			// makes execution sequence's duration not stable, but ttf2's execution do need this
			// removed this. it's now all handled by MonitorMeleeThrowAnimation(), so we can have a constant execution timer
			//if ( IsValid( attacker ) && e.thrownKilled )
			//	attacker.Anim_Stop()
		}
	)

	target.EndSignal( "OnDeath" )
	target.EndSignal( "OnDestroy" ) // vanilla missing

	e.startOrigin <- target.GetOrigin()
	wait 2.8
	e.thrown = true


	// attacker got killed? saved!
	if ( !IsAlive( attacker ) )
		return

	local angles = attacker.GetAngles()
	angles = AnglesCompose( angles, Vector( -15, 0, 0 ) )
	local forward = AnglesToForward( angles )

	// removed attacker trace
	//local endPos
	// add failsafe timer, we always ragdoll the target if timer ends...
	float endTime = Time() + expect float( duration ) - 2.8 // besure to minus 2.8s wait above
	//print( "duration: " + string( duration ) )
	bool hitsWall = false // only do sound if actually hits a wall
	float throwStartTime = Time()
	float hitWallTime
	//for ( ;; )
	while ( Time() < endTime )
	{
		if ( !target.Anim_IsActive() )
			break

		local org = target.GetOrigin()
		// removed attacker trace
		// we stop animation after certain delay so player don't have to wait
		/*
		if ( IsAlive( attacker ) )
		{
			TraceResults titanPilotTrace = TraceLine( attacker.EyePosition(), org, attacker )

			if ( titanPilotTrace.fraction < 1.0 )
			{
				endPos = titanPilotTrace.endPos
				break
			}
		}
		*/


		TraceResults result = TraceLine( org, org + forward * 200 )
		if ( result.fraction < 1.0 )
		{
			hitsWall = true // mark as we hit a wall!
			hitWallTime = Time() // get hit time before delay

			wait result.fraction * 0.06
			break
		}

		WaitFrame()
	}

	// removed attacker trace
	/*
	if ( endPos )
	{
		target.SetOrigin( endPos )
	}
	*/

	//Assert( IsAlive( target ) )

	// if code hits here, we can consider that our throwing killed the target
	e.thrownKilled = true

	// modified: if target hits wall too early, shouldn't leave their ragdoll
	// otherwise in attacker view there'll be two ragdolls together( one for target, one for viewbody. VisibilityFlag can't help with it )
	if ( e.gib || ( hitsWall && hitWallTime - throwStartTime < 0.7 ) )
	{
		//print( "hit wall too early!" )
		// insure visibility before gibs target
		target.SetOwner( null )
		target.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
		// gib them
		MeleePinkMist( e )
		return
	}

	// modified: only do sound if target actually hits a wall
	// call it earlier than becomeragdoll because a npc gets ragdolled is considered as dead
	if ( hitsWall )
	{
		EmitSoundOnEntity( target, "Titan_Victim_Wall_Splat" )
		
		// Titan_Victim_Wall_Splat isn't good enough for tf2, needs to fix some
		if ( IsValid( attacker ) && attacker.IsPlayer() ) // this sound shouldn't be played on attacker
		{
			EmitSoundAtPositionExceptToPlayer( target.GetTeam(), target.GetOrigin(), attacker, "titan_grunt_squish" )
			EmitSoundAtPositionExceptToPlayer( target.GetTeam(), target.GetOrigin(), attacker, "phys_imp_bodyfall_human_hard_default" )
		}
		else
		{
			EmitSoundAtPosition( target.GetTeam(), target.GetOrigin(), "titan_grunt_squish" )
			//EmitSoundOnEntity( target, "titan_punch_human_impact" )
			EmitSoundAtPosition( target.GetTeam(), target.GetOrigin(), "phys_imp_bodyfall_human_hard_default" )
		}
	}

	// kill target
	target.ClearInvulnerable()
	// target should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( false )
	
	//print( "meleeWallSplat target killed, attacker: " + string( attacker ) )
	// ragdoll version
	local ragdollVelocity = Vector(0,0,0)
	if ( !hitsWall ) // didn't hit wall! needs to inherit animation velocity
		ragdollVelocity = forward * 1000 + Vector(0,0,500)
	if ( target.IsNPC() )
	{
		// npc pilot case
		// here we should kill them before ragdolling because they're not fake bodies
		#if NPC_TITAN_PILOT_PROTOTYPE
			MeleeThrowIntoWallSplatKillTarget( target, e )
		#endif
		//print( "target.kv.VisibilityFlags: " + string( target.kv.VisibilityFlags ) )
		target.BecomeRagdoll( ragdollVelocity, false ) // gets destroyed
		return
	}
	else
		target.BecomeRagdoll( ragdollVelocity, false )
	
	WaitFrame() // player ragdoll take hold! for victim themselves can see their ragdoll

	MeleeThrowIntoWallSplatKillTarget( target, e )

	// insure visibility after target becomes ragdoll
	target.SetOwner( null )
	target.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
}

function MeleeThrowIntoWallSplatKillTarget( entity target, e )
{
	entity killCreditAttacker = target // by default they suicide so other killed callbacks can go through
	if ( IsValid( e.attacker ) )
		killCreditAttacker = expect entity( e.attacker )
	target.Die( killCreditAttacker, killCreditAttacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
}

// modified think
// we stop animation after certain delay, don't have to wait for animation fully ends
function MonitorMeleeThrowAnimation( entity attacker, entity target, e, duration )
{
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnDestroy" )
	// end signals. should only trigger them at the end of function
	attacker.EndSignal( "OnAnimationDone" )
	attacker.EndSignal( "OnAnimationInterrupted" )
	// stop adding target endsignal on throw, so we can make throw anim duration constant?
	//target.EndSignal( "OnDeath" )
	//target.EndSignal( "OnDestroy" )

	//wait duration - 0.45 // same timer as TitanSyncedMeleeAnimationsPlay() does
	// due to animation handling method change, timer is bit increased
	wait duration - 0.3
	//print( "melee throw attacker sequence ends!" )
	// remove thrownKilled checks because animation is now all handled by this function, MeleeThrowIntoWallSplat() no longer do anything
	//if ( !e.thrownKilled ) // if target isn't killed by thrown yet, stop attacker animation
	//{
		//print( "End animation with MonitorMeleeThrowAnimation()!" )
		if ( attacker.IsPlayer() )
		{
			ClearPlayerAnimViewEntity( attacker )
			attacker.GetFirstPersonProxy().Anim_Stop()
		}
		attacker.Anim_Stop()
	//}
}

function MeleeAnimThrow( attacker, target, throwDuration )
{
	attacker.EndSignal( "OnDeath" )
	target.EndSignal( "OnDeath" )
	wait throwDuration - 0.2

	local angles = attacker.GetAngles()
	local forward = AnglesToForward( angles )
	target.ClearParent()
	target.SetVelocity( forward * 500 )


	target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
}

///////////////////////////////////////
// OGRE MELEES
///////////////////////////////////////
void function MeleeThread_OgreVsTitan( SyncedMelee action, entity attacker, entity target )
{
	target.EndSignal( "OnDestroy" ) // needs to track target destroy because this type of termination won't do titan transfer
	
	string attackerAnimation1p = "ogpov_melee_armrip_attacker"
	string attackerAnimation3p = "og_melee_armrip_attacker"
	string targetAnimation1p = "ogpov_melee_armrip_victim"
	string targetAnimation3p = "og_melee_armrip_victim"

	table e = {}
	e.attackerStartOrg <- attacker.GetOrigin()
	e.lostArm <- false
	e.targetStartOrg <- target.GetOrigin()

	entity ref = CreateMeleeScriptMoverBetweenEnts( attacker, target )

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"

	FirstPersonSequenceStruct targetSequence = clone attackerSequence

	attackerSequence.thirdPersonAnim = attackerAnimation3p
	attackerSequence.firstPersonAnim = attackerAnimation1p

	if ( target.IsPlayer() )
		targetSequence.firstPersonAnim = targetAnimation1p

	targetSequence.thirdPersonAnim = targetAnimation3p
	targetSequence.blendTime = 0.25

	target.e.syncedMeleeAttacker = attacker

	// modified
	//DisableWeapons( attacker, [] )
	if ( attacker.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		// it's better to use holster attacker weapon for tf-1 executions I think
		// we're in first person and wants to re-deploy weapon after animation
		attacker.DisableWeaponViewModel() // we still need disable viewmodel, so player can't see weapon holster animation
		attacker.HolsterWeapon()
		attacker.Server_TurnOffhandWeaponsDisabledOn()
		
		attacker.ClearOffhand() // since this is first person execution, should clear out player's offhand weapon( eg.melee )
		attacker.Anim_StopGesture( 0 ) // ttf1 executions lasts short, should instant stop their animation and set to executions
	}

	// manually call rodeo stop
	ForceTitanRodeoToEnd( target )

	// modified
	//DisableWeapons( target, [] ) 
	//	attacker.SetInvulnerable() // set from main thread
	target.SetInvulnerable()
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	if ( target.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.DisableWeaponViewModel()
		target.Server_TurnOffhandWeaponsDisabledOn()
		
		target.Anim_StopGesture( 0 )
	}
	else
	{
		DisableWeapons( target, [] )
		// vanilla missing behavior: npc target can have scripted animation playing, needs to stop that
		target.Anim_Stop()
	}

	entity soul = target.GetTitanSoul()
	soul.SetInvalidHealthBarEnt( true )

	OnThreadEnd(
		function() : ( ref, attacker, target, e  )
		{
			if ( IsValid( ref ) )
			{
				if ( IsValid( attacker ) )
					attacker.ClearParent()

				if ( IsValid( target ) )
					target.ClearParent()

				AssertNoPlayerChildren( ref )
				ref.Kill_Deprecated_UseDestroyInstead()
			}

			if ( IsValid( attacker ) )
			{
				// save for npc executions
				attacker.ClearParent()
				//EnableWeapons( attacker, [] )
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker )
					attacker.PlayerMelee_ExecutionEndAttacker()
					// modified
					//DeployViewModelAndEnableWeapons( attacker ) // so ogre titans can have their weapon back
					
					// it's better to use holster attacker weapon for tf-1 executions I think
					// we're in first person and wants to re-deploy weapon after animation
					if ( IsAlive( attacker ) )
						attacker.EnableWeaponViewModel()
					attacker.DeployWeapon() // deploy should always happen, unlike enableViewModel should only happen when player alive
					attacker.Server_TurnOffhandWeaponsDisabledOff()
				}
				else // npc
				{
					//Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
					EnableWeapons( attacker, [] )
				}

				// changed for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker )
				//EnableWeapons( attacker, [] )
				//attacker.PlayerMelee_ExecutionEndAttacker()

				if ( IsAlive( attacker ) )
				{
					// if we got into solid, teleport back to safe place
					PutEntityInSafeSpot( attacker, null, null, expect vector( e.attackerStartOrg ), attacker.GetOrigin() )
					attacker.SetActiveWeaponBySlot( 0 ) // so ogre titans can have their weapon back, doesn't seem necessary
				}

				// modified condition
				if ( !IsValid( target ) ) // target gets destroyed early
					attacker.Anim_Stop() // stop attacker sequence
			}

			if ( IsValid( target ) )
			{
				if( HasAnimEvent( target, "lost_arm" ) )
					DeleteAnimEvent( target, "lost_arm" )

				target.e.syncedMeleeAttacker = null

				target.ClearParent()
				target.ClearInvulnerable()
				// target should be ignored while being executed
				// breaks vanilla behavior but whatever
				target.SetNoTarget( false )

				if ( target.IsPlayer() )
				{
					ClearPlayerAnimViewEntity( target )
					// modified
					//DeployAndEnableWeapons( target )
					//DeployViewModelAndEnableWeapons( target )
					if ( IsAlive( target ) )
						target.EnableWeaponViewModel()
					target.Server_TurnOffhandWeaponsDisabledOff()
				}
				else
					EnableWeapons( target, [] )

				if ( !target.IsNPC() )
					target.PlayerMelee_ExecutionEndTarget()

				// remove lostArm check. ttf2 titan executions always kill target
				//if ( e.lostArm && IsAlive( target ) )
				if ( IsAlive( target ) )
				{
					//print( "hits failsafe kill!" )
					target.Anim_Stop()
					// removed. in ttf1, titan will go explode when killed by ogre execution
					// npc titan may play death animation after death, but I don't care
					//target.e.forceRagdollDeath = true // properway to make titan become ragdoll, they won't do explode fx which gets destroyed on manually ragdoll
					target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
					return
				}
				else if ( target.IsPlayer() )
				{
					PutEntityInSafeSpot( target, null, null, expect vector( e.targetStartOrg ), target.GetOrigin() )
				}

				// fix for death animation
				// in older version player will show a spectator model on ground
				// with fixed base_gametype_mp this should no longer be a issue
				// but it's still good to make victim become ragdoll rather than make them staying at ground
				// also we need ragdoll to hide their client-side modelFX
				// failsafe case handled by target.e.forceRagdollDeath, AE_MELEE_KILLED case handled by lostArm animevent
				// no need to use this anymore
				//if ( IsValid( target ) && !IsAlive( target ) ) // target killed!
				//	target.BecomeRagdoll( < 0, 0, 0 >, false )

				// EDIT: we still need to manually ragdoll npcs because they can play death animation after full sequence done
				// that will seem pretty weird
				// welp, vanilla 3p titan executions also having this problem, should I keep identical?
				// guess I'll do so. removing this fix
				// EDIT2: vanilla monarch execution has been fixed, we add this back
				// EDIT3: now fix this by marking forceRagdollDeath in OgreVsTitanScriptedAnimEvent()
				//if ( IsValid( target ) && !IsAlive( target ) && target.IsNPC() ) // npc target killed!
				//	thread RagdollNPCTargetAfterAnimDone( target )
			}
		}
	)

	attacker.EndSignal( "OnDeath" )
	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	EmitDifferentSoundsOnEntityForPlayerAndWorld( "Ogre_1p_Sync_Melee", "Ogre_3p_Sync_Melee", attacker, attacker )
	// manually do some titanfall2 sounds
	thread OgreVsTitanSoundEvent( attacker, target, e )
	// manually fix model fx
	thread OgreVsTitanModelEffects( attacker, target, e )
	// manually anim event fix
	thread OgreVsTitanScriptedAnimEvent( attacker, target, e )

	AddAnimEvent( target, "lost_arm", TitanLostArm, e )


	thread FirstPersonSequence( targetSequence, target, ref )
	waitthread FirstPersonSequence( attackerSequence, attacker, ref )
}

// temp fix for npc being executed by ogre
void function RagdollNPCTargetAfterAnimDone( entity target )
{
	if ( !target.IsNPC() )
		return
	//print( "RUNNING RagdollNPCTargetAfterAnimDone()" )
	target.EndSignal( "OnDestroy" )

	WaittillAnimDone( target ) // this will wait for their titan gib to be done, then we're safe to ragdoll them
	//print( "npc target died! ragdolling them" )
	target.BecomeRagdoll( < 0, 0, 0 >, false )
}

//Very similar to the above function for now, eventually won't have the 1st person component at all.
void function TitanVsTitan_3p( SyncedMelee action, entity attacker, entity target )
{
	if ( !IsAlive( attacker ) )
		return

	if ( !IsAlive( target ) )
		return

	entity attackerSoul = attacker.GetTitanSoul()
#if SP
	TitanLoadoutDef loadout = GetTitanLoadoutForCurrentMap()
	string executionRef = loadout.titanExecution
	TitanExcutionData data = file.executionData_3p[ executionRef ]
#else
	TitanLoadoutDef loadout = attackerSoul.soul.titanLoadout // GetActiveTitanLoadout( attacker )
	string executionRef = loadout.titanExecution
	
	// linked executions
	array<string> linkedExecutions = MeleeSyncedTitan_GetLinkedExecutionsFromRef( executionRef ) // wrapped into this function!
	if ( linkedExecutions.len() > 0 )
		executionRef = linkedExecutions.getrandom() // this array is already a clone, can modify it directly
	
	TitanExcutionData data = file.executionData_3p[ executionRef ]
#endif

	// moving these checks to MeleeThread_TitanVsTitan_Internal(), so it can handle classic execution case
	//bool shouldApplyBatteryAfterRodeo = false
	string attackerType = GetSoulTitanSubClass( attackerSoul )

	// get execution ref from default value
	string defaultExecution = MeleeSyncedTitan_GetDefaultExecutionRefForTitanVsTitan3p( attacker, target, executionRef )
	bool notUsingDefaultExecution = false
	if ( executionRef != defaultExecution )
	{
		//print( "attacker: " + string( attacker ) + " changing execution ref for titan termination" )
		notUsingDefaultExecution = true // we'll need to update loadout because it's not best one
		// update it to use best one
		executionRef = defaultExecution
		data = file.executionData_3p[ executionRef ]
	}
	//

	// modified: using passives for checking executions that rewards battery
	// instead of hardcoding "execution_vanguard_kit"
	// moving these checks to MeleeThread_TitanVsTitan_Internal(), so it can handle classic execution case
	//if ( MeleeSyncedTitan_ShouldApplyBatteryAfterExecution( attacker ) )
	//	shouldApplyBatteryAfterRodeo = true
	
	//print( "executionRef is: " + executionRef )
	// modified: callbacks in sh_melee_synced_titan.gnut, callback for certain executionRef
	// checks removed. we should always do callback
	//if ( GetSoulUseExecutionCallback( attacker.GetTitanSoul() ) )
	//	MeleeSyncedTitan_RunCallbacksForRef( executionRef, attacker, target )
	MeleeSyncedTitan_RunCallbacksForRef( executionRef, attacker, target )
	

	string victimType = GetSoulTitanSubClass( target.GetTitanSoul() )

	table e = {}
	e.attackerStartOrg <- attacker.GetOrigin()
	e.lostArm <- false
	e.targetStartOrg <- target.GetOrigin()

	FirstPersonSequenceStruct attackerSequence
	attackerSequence.blendTime = 0.25
	attackerSequence.attachment = "ref"
	attackerSequence.thirdPersonCameraAttachments = clone data.thirdPersonCameraAttachments
	attackerSequence.thirdPersonCameraVisibilityChecks = true
	attackerSequence.viewConeFunction = ViewConeZero
	attackerSequence.noViewLerp = true

	FirstPersonSequenceStruct targetSequence = clone attackerSequence
	attackerSequence.thirdPersonAnim = data.attackerAnimation3p
	
	attackerSequence.firstPersonAnim = ""

	if ( target.IsPlayer() )
		targetSequence.firstPersonAnim = ""

	targetSequence.thirdPersonAnim = data.targetAnimation3p[ victimType ]
	
	targetSequence.thirdPersonCameraEntity = target

	target.e.syncedMeleeAttacker = attacker

	// mp version handled in sh_melee_synced_titan.gnut, Execution_BT_KickShoot()
	// HACK FOR SP!!!
	e.replacedPrimary <- false
	string xo16 = "mp_titanweapon_xo16_shorty"
	array<entity> weapons = attacker.GetMainWeapons()
	if ( IsSingleplayer() && attacker.IsPlayer() && data.attackerAnimation3p == "bt_synced_titan_execute_kickshoot_A" )
	{
		if ( weapons[0].GetWeaponClassName() != xo16 )
		{
			e.replacedPrimary = true
			e.oldPrimary <- weapons[0].GetWeaponClassName()
			attacker.SetActiveWeaponBySlot( 0 )
			attacker.ReplaceActiveWeapon( xo16 ) //this assumes the active weapon is the weapon in slot 0 so we need to set active weapon to the one in slot 0
		}
	}
	// END HACK FOR SP!!!

	if ( !target.IsNPC() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( target )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		target.DisableWeaponViewModel()
		target.Server_TurnOffhandWeaponsDisabledOn()
	}
	else
		DisableWeapons( target, [] )

	// vanilla missing behavior: needs to stop npc animation, otherwise they can trigger animevents earlier than expected
	// put here is to run before MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef(), so we don't mess up that
	// removed. this can sometimes cause issue and make attacker stop playing animation, also can't fix animevent issues
	//if ( attacker.IsNPC() )
	//	attacker.Anim_Stop()

	// modified: loadout replace think in sh_melee_synced_titan.gnut
	// force attacker to use certain execution's weapon, to avoid visual issues
	// this should also happen when player using random execution or have their execution replaced with best choice
	// checks removed. we're now checking weapons to decide whether we do loadout replace or not
	//bool doLoadoutReplace = GetSoulReplaceLoadoutOnExecution( attacker.GetTitanSoul() )
	//						|| notUsingDefaultExecution

	// if we don't have required weapons for execution, replace attacker loadout until it ends
	// put here is to run before attacker.DisableWeaponViewModel(), so we can change their current holding weapon
	bool doLoadoutReplace = MeleeSyncedTitan_TitanShouldDoLoadoutReplaceForRef( attacker, executionRef )
	//print( "doLoadoutReplace: " + string( doLoadoutReplace ) )
	if ( doLoadoutReplace )
	{
		//print( "attacker: " + string( attacker ) + " doing loadout replace for termination" )
		MeleeSyncedTitan_RunLoadoutReplaceCallbackForRef( executionRef, attacker )
	}

	if ( attacker.IsPlayer() )
	{
		// this will sometimes make executions disable player's offhands forever idk why
		//HolsterViewModelAndDisableWeapons( attacker )  //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		attacker.DisableWeaponViewModel()
		attacker.Server_TurnOffhandWeaponsDisabledOn()
		
		attacker.Anim_StopGesture( DEFAULT_SCRIPTED_ANIMATION_BLEND_TIME )
	}

	if ( target.IsPlayer() ) // vanilla missing! target should also stop gesture animation!
		target.Anim_StopGesture( DEFAULT_SCRIPTED_ANIMATION_BLEND_TIME )
	else // vanilla missing behavior: npc target can have scripted animation playing, needs to stop that
		target.Anim_Stop()

	//	attacker.SetInvulnerable()
	target.SetInvulnerable()
	// targets should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( true )

	entity targetViewBody
	FirstPersonSequenceStruct targetBodySequence
	entity attackerViewBody
	FirstPersonSequenceStruct attackerBodySequence

	// reworked to use wrapped function
	/*
	bool titanHasPilot = target.IsPlayer()
	#if HAS_BOSS_AI
		titanHasPilot = titanHasPilot || ( IsBossTitan( target ) )
	#elseif NPC_TITAN_PILOT_PROTOTYPE // modified condition
		titanHasPilot = titanHasPilot || TitanHasNpcPilot( target )
	#endif
	*/
	// also added attackerTitanHasPilot for npc execution case
	bool attackerTitanHasPilot = MeleeSyncedTitan_TitanHasPilot( attacker )
	bool targetTitanHasPilot = MeleeSyncedTitan_TitanHasPilot( target )

	if ( attacker.IsPlayer() )
	{
		Remote_CallFunction_Replay( attacker, "SCB_StopTitanCockpitSounds" )
	}

	if ( target.IsPlayer() )
	{
		Remote_CallFunction_Replay( target, "SCB_StopTitanCockpitSounds" )
	}

	// adding attackerHasPilot checks
	//if ( data.targetAnimation3pPilot[ victimType ] != "" && titanHasPilot )
	if ( data.targetAnimation3pPilot[ victimType ] != "" && targetTitanHasPilot )
	{
		// MODIFIED here: wrap everything into function
		targetViewBody = CreateTitanExecutionViewBody( target )

		targetViewBody.SetOrigin( target.GetOrigin() )
		targetViewBody.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
		targetViewBody.SetContinueAnimatingAfterRagdoll( true )

		targetBodySequence.attachment = "ref"
		targetBodySequence.teleport = true
		targetBodySequence.thirdPersonAnim = data.targetAnimation3pPilot[ victimType ]

		AddAnimEvent( targetViewBody, "pink_mist", MeleePinkMistFakeBody )
	}

	// modified for npc executions!
	// adding attackerHasPilot checks
	//if ( data.attackerAnimation3pPilot[ victimType ] != "" && attacker.IsPlayer() )
	if ( data.attackerAnimation3pPilot[ victimType ] != "" && attackerTitanHasPilot )
	{
		// MODIFIED here: wrap everything into function
		attackerViewBody = CreateTitanExecutionViewBody( attacker )

		attackerViewBody.SetOrigin( attacker.GetOrigin() )
		attackerViewBody.SetRagdollImpactFX( RAGDOLL_IMPACT_TABLE_IDX )
		attackerViewBody.SetContinueAnimatingAfterRagdoll( true )

		attackerBodySequence.attachment = "ref"
		attackerBodySequence.teleport = true
		attackerBodySequence.thirdPersonAnim = data.attackerAnimation3pPilot[ victimType ]
	}

	if ( !IsValid( targetViewBody ) )
	{
		if( attackerSequence.thirdPersonAnim == data.attackerAnimation3p )
			attackerSequence.thirdPersonAnim = data.attackerAnimation3p_vsAutoTitan
	}

	entity soul = target.GetTitanSoul()
	soul.SetInvalidHealthBarEnt( true )
	
	// this isn't very accrate, won't pass the value modified below OnThreadEnd() scope is placed
	bool isAttackerRef = false
	if ( GetConVarBool( "melee_titan_execution_attacker_can_be_ref" ) )
	{
		isAttackerRef = IsAttackerRef( null, target )
	}

	// fix npc target animation for executions that has shorter attacker sequence than target's( monarch ones )
	e.attackerSequenceEnds <- false

	OnThreadEnd(
		// moving shouldApplyBatteryAfterRodeo checks to MeleeThread_TitanVsTitan_Internal()
		// so it can handle classic execution case
		// and it's now using structs for saving a non-entity variable, more accurate
		// pass data inside OnThreadEnd() to let us have more stuffs can get
		//function() : ( attacker, target, e, attackerViewBody, targetViewBody, shouldApplyBatteryAfterRodeo, isAttackerRef )
		function() : ( attacker, target, e, attackerViewBody, targetViewBody, isAttackerRef, data )
		{
			if ( IsValid( attacker ) )
			{
				// wrapped anim event cleanup into function
				/*
				if( HasAnimEvent( attacker, "synced_melee_enable_planting" ) )
					DeleteAnimEvent( attacker, "synced_melee_enable_planting" )
				if( HasAnimEvent( attacker, "rocket_pod_fire_left" ) )
					DeleteAnimEvent( attacker, "rocket_pod_fire_left" )
				if( HasAnimEvent( attacker, "rocket_pod_fire_right" ) )
					DeleteAnimEvent( attacker, "rocket_pod_fire_right" )
				*/
				// modified behavior start
				CleanUpAttackerAnimEvents( attacker )

				// save for npc executions
				attacker.ClearParent()
				ForceTitanSustainedDischargeEnd( attacker )
				if( attacker.IsPlayer() )
				{
					attacker.UnforceStand()
					ClearPlayerAnimViewEntity( attacker )
					attacker.PlayerMelee_ExecutionEndAttacker()
					//DeployViewModelAndEnableWeapons( attacker )
					if ( IsAlive( attacker ) )
						attacker.EnableWeaponViewModel()
					attacker.Server_TurnOffhandWeaponsDisabledOff()
				}
				else
				{
					EnableWeapons( attacker, [] )
					//Highlight_ClearEnemyHighlight( attacker ) // this only resets victim's highlights for some reason
				}

				// changed for npc executions
				//attacker.UnforceStand()
				//attacker.ClearParent()
				//ClearPlayerAnimViewEntity( attacker )
				//attacker.PlayerMelee_ExecutionEndAttacker()
				//ForceTitanSustainedDischargeEnd( attacker )
				//DeployViewModelAndEnableWeapons( attacker ) //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
				
				if ( IsAlive( attacker ) )
				{
					if ( !isAttackerRef && IsValid( target ) )
					{
						PutEntityInSafeSpot( attacker, target, null, target.GetOrigin(), attacker.GetOrigin() )
					}
					else
					{
						PutEntityInSafeSpot( attacker, target, null, attacker.GetOrigin(), attacker.GetOrigin() )
					}

					if ( attacker.IsTitan() )
					{
						// changed for npc executions
						if( attacker.IsPlayer() )
							Remote_CallFunction_Replay( attacker, "SCB_PlayTitanCockpitSounds" )

						// moving these checks to MeleeThread_TitanVsTitan_Internal(), so it can handle classic execution case
						/*
						#if TITAN_EXECUTION_GIVES_BATTERY
							Rodeo_GiveExecutingTitanABattery( attacker )
						#else
							if ( shouldApplyBatteryAfterRodeo )
								Rodeo_GiveExecutingTitanABattery( attacker )
						#endif
						*/
					}

					if ( IsSingleplayer() )
					{
						if ( e.replacedPrimary )
						{
							attacker.ReplaceActiveWeapon( e.oldPrimary )
						}
					}
					else
                    {
						attacker.Anim_Stop() // if you are fighting an NPC, then they can get destroyed early the moment they explode.  But sometimes, your animation isn't done playing yet so you can't move
                    }
				}

			}

			// modified: if attacker sequence is shorter than target's, npc victim animation will be messed up
			// seems only happen with monarch executions. player won't be ragdolled but also don't have weird animation sets
			// in that case, target won't trigger AE_MELEE_KILLED but was killed by this script, might also miss other animevents such as predator_killed_ragdoll
			// for handling that, we do some special checks, delay our cleanup
			// note: to keep vanilla behavior, add a setting for toggling
			
			// EDIT: this is too much complicated, and player victim will have their CE flags out when death is delayed
			// forceRagdoll fix is pretty good enough

			// attacker sequence ends but target still alive!!!
			// EDIT: removing this think
			/*
			if ( file.enableTitanVsTitan3pTimerFix 
				 && e.attackerSequenceEnds 
				 && IsAlive( target ) && IsValid( attacker ) )
			{
				thread DelayedCleanUpTargetSyncedMelee( target, attacker, targetViewBody, isAttackerRef )
			}
			else // vanilla behavior
			{
			*/
				// MODIFIED here: move all these stuffs to a wrapped function
				// so we don't have to duplicate code in DelayedCleanUpTargetSyncedMelee()
				if ( IsValid( target ) )
				{
					CleanUpTargetSyncedMelee( target )

					if ( IsAlive( target ) ) //Should have no need to PlayTitanCockpitSounds for target because the target is going to die
					{
						// modified: if attacker sequence is shorter than target's, npc victim animation will be messed up
						// seems only happen with monarch executions. player won't be ragdolled but also don't have weird animation sets
						// to keep both execution case identical, I'll use forceRagdollDeath for both
						if ( e.attackerSequenceEnds )
							target.e.forceRagdollDeath = true

						target.Die( attacker, attacker, { scriptType = DF_KILLSHOT, damageSourceId = eDamageSourceId.titan_execution } )
					}
					else if ( target.IsPlayer() )
					{
						if ( isAttackerRef && IsValid( attacker ) )
						{
							PutEntityInSafeSpot( target, attacker, null, attacker.GetOrigin(), target.GetOrigin() )
						}
						else
						{
							PutEntityInSafeSpot( target, attacker, null, target.GetOrigin(), target.GetOrigin() )
						}
					}
				}

				if ( IsValid( targetViewBody ) )
				{
					targetViewBody.Hide()
					targetViewBody.Destroy()
				}
			// EDIT: removing this think
			/*
			}
			*/

			if ( IsValid( attackerViewBody ) )
			{
				// anti-crash
				//DeleteAnimEvent( attackerViewBody, "rodeo_battery_rip" )
				// wrapped anim event cleanup into function
				/*
				if( HasAnimEvent( attackerViewBody, "execution_battery_pilot" ) )
					DeleteAnimEvent( attackerViewBody, "execution_battery_pilot" )
				if( HasAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" ) )
					DeleteAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" )
				*/
				// modded behavior
				CleanUpAttackerViewBodyAnimEvents( attackerViewBody )
				attackerViewBody.Hide()
				attackerViewBody.Destroy()
			}

			// moving this up for us handling modified execution timer
			/*
			if ( IsValid( targetViewBody ) )
			{
				targetViewBody.Hide()
				targetViewBody.Destroy()
			}
			*/
		}
	)

	attacker.EndSignal( "OnDeath" )
	entity bossPlayer = target.GetBossPlayer()
	if ( IsValid( bossPlayer ) ) //Executing an auto-Titan, when the pilot disconnects it destroys the auto-titan creating weird circumstances.
		bossPlayer.EndSignal( "OnDestroy" )
	// modified stuffs here: npc victim being ragdoll will be destroyed on next frame
	// to avoid that interrupts attacker animation, don't end think on npc target destroy could be better
	//target.EndSignal( "OnDestroy" )
	// add another signal on attacker for us tracking
	// this breaks vanilla behavior, so make it a setting
	if ( file.enableTitanVsTitan3pTimerFix )
	{
		attacker.EndSignal( "ForceEndTitanExecution" )
		thread TrackTitanExecutionValidTime( attacker, target )
	}
	else // vanilla behavior
		target.EndSignal( "OnDestroy" )

	// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
	// needs to end execution if target respawned
	if ( target.IsPlayer() )
	{
		// make respawning cleans up execution
		EndThreadOnPlayerRespawn( target )
	}
	//

	if ( isAttackerRef )
	{
		thread ClearParentOnDeathOrDestroy( target, attacker )
	}
	else
	{
		thread ClearParentOnDeathOrDestroy( attacker, target )
	}

	EmitDifferentSoundsOnEntityForPlayerAndWorld( data.sound_1p, data.sound_3p, attacker, attacker )

	// wrap anim event settings into function
	/*
	AddAnimEvent( target, "rider_rodeo_over", ForceTitanRodeoToEnd  )
	AddAnimEvent( target, "melee_killed_ragdoll", PredatorMeleeKilledRagdoll )
	AddAnimEvent( attacker, "synced_melee_enable_planting", EnablePlantingOnEntity )
	AddAnimEvent( attacker, "rocket_pod_fire_left", Northstar_Rocket_Pod_Left, target )
	AddAnimEvent( attacker, "rocket_pod_fire_right", Northstar_Rocket_Pod_Right, target )
	AddAnimEvent( target, "execution_battery_show", Execution_ShowBattery )
	AddAnimEvent( target, "execution_battery_hide", Execution_HideBattery )
	*/
	// modified behavior start
	SetUpTargetAnimEvents( target )
	SetUpAttackerAnimEvents( attacker, target )

	if ( attackerViewBody != null )
	{
		// wrap anim event settings into function
		/*
		AddAnimEvent( attackerViewBody, "execution_battery_pilot", Execution_GivePilotBattery )
		AddAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets", Execution_BatteryStealJumpJets )
		*/
		// modified behavior start
		SetUpAttackerViewBodyAnimEvents( attackerViewBody, attacker )
	}


	if ( isAttackerRef )
	{
		attackerSequence.enablePlanting = true
		attackerSequence.playerPushable = true
		targetSequence.useAnimatedRefAttachment = true
	}
	else
	{
		targetSequence.enablePlanting = true
		targetSequence.playerPushable = true
		attackerSequence.useAnimatedRefAttachment = true
	}

	array<entity> ignoreEnts = [ attacker, target ]

	vector refAngles = GetRefAnglesBetweenEnts( attacker, target )

	if ( !attacker.IsOnGround() )
	{
		refAngles = <0,refAngles.y,0>
	}

	vector fwd = AnglesToForward( refAngles )
	fwd *= -1
	vector targetAngles = VectorToAngles( fwd )
	if ( !target.IsNPC() )
	{
		targetAngles.x = 0
		target.SetAngles( targetAngles )
	}

	target.SetAngles( targetAngles )

	if ( attackerViewBody != null )
	{
		attackerBodySequence.useAnimatedRefAttachment = true
		thread FirstPersonSequence( attackerBodySequence, attackerViewBody, attacker )
	}

	if ( targetViewBody != null )
	{
		targetBodySequence.useAnimatedRefAttachment = true
		thread FirstPersonSequence( targetBodySequence, targetViewBody, target )
	}

	// Fake First person exeuction
	if ( GetCurrentPlaylistVarInt( "fp_embark_enabled", 0 ) == 1 )
	{
		if ( attacker.IsPlayer() )
		{
			if ( IsValid( attackerViewBody ) )
			{
				// hide viewbody for attacker
				attackerViewBody.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE & ~ENTITY_VISIBLE_TO_OWNER
				attackerViewBody.SetOwner( attacker )

				entity attackerViewBodyProxy = Wallrun_CreateCopyOfPilotModel( attacker )
				// use existing ownerProxy, don't create thirdPersonProxy, don't hide player
				FirstPersonSequenceForce1P( attackerBodySequence, attacker, attacker, FORCE1P_PILOT_BODYTYPE, attackerViewBodyProxy, null, false, false )
				ScreenFadeFromBlack( attacker, 1.0, 0.5 ) // faking disembarking screen effect( bit longer so the sequence actually starts )
			}
			else // titan execution
			{
				entity fakeFPSequenceTarget = isAttackerRef ? null : target
				FirstPersonSequenceForce1P( attackerSequence, attacker, fakeFPSequenceTarget )
			}
			RemoveCinematicFlag( attacker, CE_FLAG_EXECUTION ) // stop execution DOF
		}
		if ( target.IsPlayer() )
		{
			if ( IsValid( targetViewBody ) )
			{
				// hide viewbody for target
				targetViewBody.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE & ~ENTITY_VISIBLE_TO_OWNER
				targetViewBody.SetOwner( target )

				entity targetViewBodyProxy = Wallrun_CreateCopyOfPilotModel( target )
				// use existing ownerProxy, don't create thirdPersonProxy, don't hide player
				FirstPersonSequenceForce1P( targetBodySequence, target, target, FORCE1P_PILOT_BODYTYPE, targetViewBodyProxy, null, false, false )
				ScreenFadeFromBlack( target, 1.0, 0.5 ) // faking disembarking screen effect( bit longer so the sequence actually starts )
			}
			else // titan execution
			{
				entity fakeFPSequenceAttacker = isAttackerRef ? attacker : null // target is reversed: attacker handled by attackerRef
				FirstPersonSequenceForce1P( targetSequence, target, fakeFPSequenceAttacker )
			}
			RemoveCinematicFlag( target, CE_FLAG_EXECUTION ) // stop execution DOF
		}
	}
	//

	// fix for executing npc target:
	// some execution ragdolls target, but npc target gets ragdolled will count as "destroyed", ends execution unexpectly...
	// better method is we end npc target execution manually on their death, for every execution ref
	// so our execution timer can get more stable and minimapIcon won't be messed up
	if ( file.endExecutionOnNPCTargetDeath && target.IsNPC() )
		target.EndSignal( "OnDeath" )

	if ( isAttackerRef )
	{
		thread FirstPersonSequence( attackerSequence, attacker )
		waitthread FirstPersonSequence( targetSequence, target, attacker )
	}
	else
	{
		// modified settings handle
		string targetType = GetSoulTitanSubClass( soul )
		// modified settings: we allow target sequence to force kill target on it's end
		// basically for BT animations, they don't have AE_MELEE_KILLED for player titan to takedown them
		bool trackTargetSequence = targetType in data.killTargetOnSequenceEnds && data.killTargetOnSequenceEnds[ targetType ]
		
		if ( trackTargetSequence )
			thread TrackTargetSequenceEnd( attacker, target, targetSequence )
		else // vanilla behavior
			thread FirstPersonSequence( targetSequence, target )
		waitthread FirstPersonSequence( attackerSequence, attacker, target )
	}

	// if code hits here, we consider that attacker sequence has fully ends
	e.attackerSequenceEnds = true
}

// modified function: signal "ForceEndTitanExecution" to end exection if target getting destroyed without dying
void function TrackTitanExecutionValidTime( entity attacker, entity target )
{
	attacker.EndSignal( "OnDeath" )
	attacker.EndSignal( "OnDestroy" )
	attacker.EndSignal( "SyncedMeleeComplete" )

	table signalData = WaitSignal( target, "OnDeath", "OnDestroy" )
	if ( signalData.signal == "OnDestroy" ) // target destroyed without dying!
		attacker.Signal( "ForceEndTitanExecution" ) // for that case, we end execution
}

// modified function: call CodeCallback_OnMeleeKilled() at the end of target sequence
void function TrackTargetSequenceEnd( entity attacker, entity target, FirstPersonSequenceStruct targetSequence )
{
	target.EndSignal( "OnDestroy" )
	target.EndSignal( "OnDeath" )

	// if we using this function, the titan won't have "rider_rodeo_over" event
	// here we do it manually
	ForceTitanRodeoToEnd( target )

	// npc getting parented with another npc will trigger AE_NPC_SYNCED_MELEE_DEATH
	// with that code kill, their kill credit will become unstable, mainly depending on GetLastAttacker() checks
	// here we just manually set a lastAttackInfo manually, so attacker can garantee their kill credit
	if ( attacker.IsNPC() )
	{
		entity soul = target.GetTitanSoul()
		if ( IsValid( soul ) )
		{
			local fakeLastAttackInfo = {}
			fakeLastAttackInfo.attacker <- attacker
			soul.lastAttackInfo = fakeLastAttackInfo
		}
		else // though at normal case a npc shouldn't cound towards lastAttacker, but this is abnormal case so...
			target.e.lastAttacker = attacker
	}

	// force ragdoll is to prevent target gets killed by npc attacker
	// which script can't get that target will be ragdolled and do bad explosion effect
	// adding this script mark
	target.e.forceRagdollDeath = true
	waitthread FirstPersonSequence( targetSequence, target )
	CodeCallback_OnMeleeKilled( target )
}

void function CleanUpTargetSyncedMelee( entity target )
{
	CleanUpTargetAnimEvents( target )
	target.e.syncedMeleeAttacker = null

	target.ClearParent()
	target.ClearInvulnerable()
	// target should be ignored while being executed
	// breaks vanilla behavior but whatever
	target.SetNoTarget( false )

	if ( target.IsPlayer() )
	{
		ClearPlayerAnimViewEntity( target )
		//DeployViewModelAndEnableWeapons( target ) //Melee anims need to use this to stop players from firing weapons but for the weapon to still show up in the 3p anims
		if ( IsAlive( target ) )
			target.EnableWeaponViewModel()
		target.Server_TurnOffhandWeaponsDisabledOff()
	}

	if ( !target.IsNPC() && target.ContextAction_IsMeleeExecution() )
		target.PlayerMelee_ExecutionEndTarget()
}
// fix for the cases execution attacker sequence is shorter than victim's( mostly because )
void function DelayedCleanUpTargetSyncedMelee( entity target, entity attacker, entity targetViewBody, bool isAttackerRef )
{
	target.EndSignal( "OnDestroy" )

	// clean up target viewbody on think end
	OnThreadEnd
	(
		function(): ( target, targetViewBody )
		{
			if ( IsValid( targetViewBody ) )
			{
				targetViewBody.Hide()
				targetViewBody.Destroy()
			}
		}
	)

	// clean up stuffs on death
	target.WaitSignal( "OnDeath" )
	//print( "cleaning up target synced melee after delay!!!" )
	CleanUpTargetSyncedMelee( target )
	if ( target.IsPlayer() )
	{
		if ( isAttackerRef && IsValid( attacker ) )
		{
			PutEntityInSafeSpot( target, attacker, null, attacker.GetOrigin(), target.GetOrigin() )
		}
		else
		{
			PutEntityInSafeSpot( target, attacker, null, target.GetOrigin(), target.GetOrigin() )
		}
	}
}

// fix for modified deathcam: player can respawn before attacker sequence ends, causes them being killed again, or cause PutEntityInSafeSpot() teleports attacker
// needs to end execution if target respawned
void function EndThreadOnPlayerRespawn( entity player )
{
	player.EndSignal( "RespawnMe" )
	player.EndSignal( "OnRespawned" )
	player.EndSignal( "PlayerRespawnStarted" )
}
//

// wrap anim event settings into function
// added HasAnimEvent() checks into setup
void function SetUpTargetAnimEvents( entity target )
{
	if ( !HasAnimEvent( target, "rider_rodeo_over" ) )
		AddAnimEvent( target, "rider_rodeo_over", ForceTitanRodeoToEnd  )
	if ( !HasAnimEvent( target, "melee_killed_ragdoll" ) )
		AddAnimEvent( target, "melee_killed_ragdoll", PredatorMeleeKilledRagdoll )
	// DLC
	if ( !HasAnimEvent( target, "execution_battery_show" ) )
		AddAnimEvent( target, "execution_battery_show", Execution_ShowBattery )
	if ( !HasAnimEvent( target, "execution_battery_hide" ) )
		AddAnimEvent( target, "execution_battery_hide", Execution_HideBattery )
}

void function SetUpAttackerAnimEvents( entity attacker, entity target )
{
	if ( !HasAnimEvent( attacker, "synced_melee_enable_planting" ) )
		AddAnimEvent( attacker, "synced_melee_enable_planting", EnablePlantingOnEntity )
	// DLC
	if ( !HasAnimEvent( attacker, "rocket_pod_fire_left" ) )
		AddAnimEvent( attacker, "rocket_pod_fire_left", Northstar_Rocket_Pod_Left, target )
	if ( !HasAnimEvent( attacker, "rocket_pod_fire_right" ) )
		AddAnimEvent( attacker, "rocket_pod_fire_right", Northstar_Rocket_Pod_Right, target )
}

void function SetUpAttackerViewBodyAnimEvents( entity attackerViewBody, entity attacker )
{
	// DLC
	if( !HasAnimEvent( attackerViewBody, "execution_battery_pilot" ) )
		AddAnimEvent( attackerViewBody, "execution_battery_pilot", Execution_GivePilotBattery )
	if( !HasAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" ) )
	{
		// try to pass titan entity inside, so we can handle low profile jump jets
		//AddAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets", Execution_BatteryStealJumpJets )
		AddAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets", Execution_BatteryStealJumpJets, attacker )
	}
}

void function CleanUpTargetAnimEvents( entity target )
{
	if ( HasAnimEvent( target, "melee_killed_ragdoll" ) )
		DeleteAnimEvent( target, "melee_killed_ragdoll" )
	if ( HasAnimEvent( target, "rider_rodeo_over" ) )
		DeleteAnimEvent( target, "rider_rodeo_over" )
	// DLC
	if ( HasAnimEvent( target, "execution_battery_show" ) )
		DeleteAnimEvent( target, "execution_battery_show" )
	if ( HasAnimEvent( target, "execution_battery_hide" ) )
		DeleteAnimEvent( target, "execution_battery_hide" )
}

void function CleanUpAttackerAnimEvents( entity attacker )
{
	if( HasAnimEvent( attacker, "synced_melee_enable_planting" ) )
		DeleteAnimEvent( attacker, "synced_melee_enable_planting" )
	if( HasAnimEvent( attacker, "rocket_pod_fire_left" ) )
		DeleteAnimEvent( attacker, "rocket_pod_fire_left" )
	if( HasAnimEvent( attacker, "rocket_pod_fire_right" ) )
		DeleteAnimEvent( attacker, "rocket_pod_fire_right" )
}

void function CleanUpAttackerViewBodyAnimEvents( entity attackerViewBody )
{
	if( HasAnimEvent( attackerViewBody, "execution_battery_pilot" ) )
		DeleteAnimEvent( attackerViewBody, "execution_battery_pilot" )
	if( HasAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" ) )
		DeleteAnimEvent( attackerViewBody, "execution_battery_pilot_jump_jets" )
}

// fix for some executions that has longer attacker sequence than target's( mostly monarch ones )
// welp this can't help, because target always die at the end of execution, after attacker sequence ends
// maybe just do fix with RagdollNPCTargetAfterAnimDone()?
// EDIT: target.e.forceRagdollDeath is good enough
void function CleanUpTargetAnimEventsOnDeathOrAnimDone( entity target )
{
	target.EndSignal( "OnDestroy" )
	WaitSignal( target, "OnDeath", "OnAnimationDone", "OnAnimationInterrupted" )

	CleanUpTargetAnimEvents( target )
}

void function Execution_ShowBattery( entity titan )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) ) //Out of bounds
		return
	string titanType = GetSoulTitanSubClass( titanSoul )
	entity batteryContainer = titanSoul.soul.batteryContainer
	Assert( IsValid( titanSoul.soul.batteryContainer ), " need to find the repro for this" )
	if ( !IsValid( titanSoul.soul.batteryContainer ) )
		return

	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_up_idle" )  )

	// welp, vanilla monarch battery execution is missing "rider_rodeo_over" event
	// I'll handle it here so rodeo rider won't notice their battery has grown back
	// breaks vanilla behavior but that's respawn's issue, not mine
	ForceTitanRodeoToEnd( titan )
}

void function Execution_HideBattery( entity titan )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) ) //Out of bounds
		return
	string titanType = GetSoulTitanSubClass( titanSoul )
	entity batteryContainer = titanSoul.soul.batteryContainer
	Assert( IsValid( titanSoul.soul.batteryContainer ), " need to find the repro for this" )
	if ( !IsValid( titanSoul.soul.batteryContainer ) )
		return

	batteryContainer.Anim_Play( GetAnimFromAlias( titanType, "hatch_rodeo_down_idle" )  )
	EmitSoundOnEntity( batteryContainer, GetAudioFromAlias( titanType, "rodeo_battery_steal_3p" ) )
}

void function Execution_GivePilotBattery( entity fakePilotModel )
{
	entity tempBattery3p = CreatePropDynamic( RODEO_BATTERY_MODEL_FOR_RODEO_ANIMS )
	tempBattery3p.SetParent( fakePilotModel, "R_HAND", false, 0.0 )
	tempBattery3p.RemoveFromSpatialPartition()
	tempBattery3p.Show()
	Battery_StartFX( tempBattery3p )
}


void function Execution_BatteryStealJumpJets( entity fakePilotModel )
{
	// now try to add team-based jump jets
	/*
	int attachmentIndex = fakePilotModel.LookupAttachment( "vent_left" )
	int fxIndex = GetParticleSystemIndex( TEAM_JUMPJET_DBL )
	StartParticleEffectOnEntity( fakePilotModel, fxIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )

	attachmentIndex = fakePilotModel.LookupAttachment( "vent_right" )
	StartParticleEffectOnEntity( fakePilotModel, fxIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
	*/

	entity titan = expect entity( GetOptionalAnimEventVar( fakePilotModel, "execution_battery_pilot_jump_jets" ) )
	// useless misc fix here: if titan isn't a player, their pilot should be a npc...
	// because npc's jump jet isn't handled by client-side, we also don't handle it on server-side
	if ( !titan.IsPlayer() )
		return
	
	bool pilotHasStealthMovement = PlayerHasPassive( titan, ePassives.PAS_STEALTH_MOVEMENT )
	const array<string> jetAttachments = ["vent_left", "vent_right"]
	foreach ( string attachment in jetAttachments )
	{
		int attachmentIndex = fakePilotModel.LookupAttachment( attachment )
		if ( attachmentIndex <= 0 ) // anti-crash
			continue

		int fxIndex = GetParticleSystemIndex( TEAM_JUMPJET_DBL )
		if ( pilotHasStealthMovement )
			fxIndex = GetParticleSystemIndex( STEALTH_TEAM_JUMPJET_DBL )
		entity friendlyEffect = StartParticleEffectOnEntity_ReturnEntity( fakePilotModel, fxIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		SetTeam( friendlyEffect, titan.GetTeam() )
		friendlyEffect.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY

		fxIndex = GetParticleSystemIndex( PENEMY_JUMPJET_DBL )
		if ( pilotHasStealthMovement )
			fxIndex = GetParticleSystemIndex( STEALTH_PENEMY_JUMPJET_DBL )
		entity enemyEffect = StartParticleEffectOnEntity_ReturnEntity( fakePilotModel, fxIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		SetTeam( enemyEffect, titan.GetTeam() )
		enemyEffect.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	}
}

/*
void function RodeoBatteryRemoval( entity pilot )
{
	entity titan = GetTitanBeingRodeoed( pilot )
	if ( !IsValid( titan ) )
		return

	// THROW RODEO RIDER OFF
	entity soul = titan.GetTitanSoul()
	string titanType = GetSoulTitanSubClass( soul )

	soul.SetLastRodeoHitTime( Time() )

	RodeoBatteryPackRemovalDamage( pilot, titan, soul )

	if ( !PlayerHasBattery( pilot ) )
	{
		AddPlayerScore( pilot, "PilotBatteryStolen" )
		entity battery = Rodeo_CreateBatteryPack( titan )
		Rodeo_PilotPicksUpBattery( pilot, battery )
		thread BatteryThiefHighlight( pilot )

		if ( titan.IsPlayer() )
		{
			EmitSoundOnEntityOnlyToPlayer( titan, titan, TITAN_GOT_BATTERY_RIPPED_SOUND ) //Consider playing this in world once we get sounds that aren't just notification beeps
		}
	}

	vector direction = CalculateDirectionToThrowOffBatteryThief( pilot, titan )

	ThrowRiderOff( pilot, titan, direction ) //This signals RodeoOver
}
*/

void function ClearParentOnDeathOrDestroy( entity clearParentEntity, entity onDeathOrDestroyEntity )
{
	Assert( IsValid( clearParentEntity ) )
	Assert( IsAlive( clearParentEntity ) )

	Assert( IsValid( onDeathOrDestroyEntity ) )
	Assert( IsAlive( onDeathOrDestroyEntity ) )

	OnThreadEnd(
		function() : ( clearParentEntity, onDeathOrDestroyEntity )
		{
			if ( IsValid( clearParentEntity ) )
			{
				clearParentEntity.ClearParent()

				if ( IsValid( onDeathOrDestroyEntity ) )
				{
					PutEntityInSafeSpot( clearParentEntity, onDeathOrDestroyEntity, null, onDeathOrDestroyEntity.GetOrigin(), clearParentEntity.GetOrigin() )
				}
			}
		}
	)

	onDeathOrDestroyEntity.EndSignal( "OnDeath" )
	onDeathOrDestroyEntity.WaitSignal( "OnDestroy" )
}

void function PredatorMeleeKilledRagdoll( entity titan )
{
	//print( "Calling PredatorMeleeKilledRagdoll()" )
	titan.e.forceRagdollDeath = true
}

void function MeleePinkMistFakeBody( entity target )
{
	// clean up highlights before pinkmist, to fake that they're being killed
	Highlight_ClearEnemyHighlight( target )
	Highlight_ClearFriendlyHighlight( target )

	target.Dissolve( ENTITY_DISSOLVE_PINKMIST, < 0, 0, 0 >, 0 )
}

void function TitanLostArm( entity titan )
{
	table e = expect table( GetOptionalAnimEventVar( titan, "lost_arm" ) )

	e.lostArm = true // this is actually marked the titan for death, but in titanfall 2 termination always kills target titan, currently no where uses this variable

	// titan should be killed after this point
	// needs to hide titan's arm bodygroup so their ragdoll won't show that
	// doesn't really help with ragdoll... maybe ttf1 makes them explode? I don't care
	/*
	const array<string> bodyGroupsToHide = ["left_arm", "right_arm"]
	foreach ( bodyGroup in bodyGroupsToHide )
	{
		int bodyGroupIndex = titan.FindBodyGroup( bodyGroup )
		if ( bodyGroupIndex > -1 )
		{
			//The last body group should be empty
			int stateIndex = titan.GetBodyGroupModelCount( bodyGroupIndex ) -1
			titan.SetBodygroup( bodyGroupIndex, stateIndex )
		}
	}
	*/
	
	// removed. in ttf1, titan will go explode when killed by ogre execution
	// npc titan may play death animation after death, but I don't care
	//titan.e.forceRagdollDeath = true // properway to make titan become ragdoll, they won't do explode fx which gets destroyed on manually ragdoll
}

void function MeleeKilledRagdoll( entity titan ) // this is actually "pilot" inside the titan 
{
	entity attacker = expect entity( GetOptionalAnimEventVar( titan, "melee_killed_ragdoll" ) )

	if ( !IsValid( attacker ) )
		return
	// has been modified to handle npc executions
	if( !IsAlive( titan ) )
	{
		if( !titan.IsPlayer() )
			return
		titan = titan.GetPetTitan()
		if( IsAlive( titan ) )
		{
			//print( "pet titan gets killed! " + string( titan ) )
			titan.e.forceRagdollDeath = true // this is the proper way to ragdoll a titan, they won't do explode fx which gets destroyed on manually ragdoll
			titan.Die( attacker, attacker, { scriptType = DF_MELEE, damageSourceId = eDamageSourceId.titan_execution } )
			//titan.SetContinueAnimatingAfterRagdoll( true ) // never allow animating, just die
			//titan.BecomeRagdoll( < 0, 0, 0 >, false )
			return
		}
	}
	//print( "titan gets killed! " + string( titan ) )
	titan.e.forceRagdollDeath = true // this is the proper way to ragdoll a titan, they won't do explode fx which gets destroyed on manually ragdoll
	titan.Die( attacker, attacker, { scriptType = DF_MELEE, damageSourceId = eDamageSourceId.titan_execution } )
	//titan.SetContinueAnimatingAfterRagdoll( true ) // never allow animating, just die
	//titan.BecomeRagdoll( < 0, 0, 0 >, false )
}

void function OnNPCTitanDeath( entity titan, var damageInfo ) //Debug function, for bug 129802
{
	PrintFunc()
}

void function OnNPCTitanSignalDeath( entity titan ) //Debug function, for bug 129802
{
	PrintFunc()

	titan.WaitSignal( "OnDeath" )

	printt( "titan : " + titan + " recieved OnDeath Signal in OnNPCTitanSignalDeath" )
}


void function Northstar_Rocket_Pod_Left( entity guy )
{
	entity victim = expect entity( GetOptionalAnimEventVar( guy, "rocket_pod_fire_left" ) )
	// defensive fixes here, for ronin usage
	//Rocket_Pod( guy, "muzzle_flash", victim )
	string tag = "muzzle_flash" // default, left rocket pod
	int attachID = guy.LookupAttachment( tag )
	if ( attachID <= 0 ) // not valid!
	{
		tag = "HAND_L" // try to use left hand
		attachID = guy.LookupAttachment( tag )
		if ( attachID <= 0 ) // still not valid!
			return
	}
	Rocket_Pod( guy, tag, victim )
}

void function Northstar_Rocket_Pod_Right( entity guy )
{
	entity victim = expect entity( GetOptionalAnimEventVar( guy, "rocket_pod_fire_right" ) )
	// defensive fixes here, for ronin usage
	//Rocket_Pod( guy, "muzzle_flash2", victim )
	string tag = "muzzle_flash2" // default, right rocket pod
	int attachID = guy.LookupAttachment( tag )
	if ( attachID <= 0 ) // not valid!
	{
		tag = "HAND_R" // try to use right hand
		attachID = guy.LookupAttachment( tag )
		if ( attachID <= 0 ) // still not valid!
			return
	}
	Rocket_Pod( guy, tag, victim )
}

void function Rocket_Pod( entity guy, string tag, entity victim )
{
	entity oldOffhandWeapon = guy.GetOffhandWeapon( 0 )
	guy.TakeOffhandWeapon( 0 )
	guy.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", 0, [ "northstar_prime_execution" ] )

	entity newOffhandWeapon = guy.GetOffhandWeapon( 0 )
	int attachID = guy.LookupAttachment( tag )
	vector angles = guy.GetAttachmentAngles( attachID )
	WeaponPrimaryAttackParams params
	params.pos = guy.GetAttachmentOrigin( attachID )
	params.dir = AnglesToForward( angles )

	if ( IsAlive( victim ) && victim.IsTitan() )
	{
		vector victimTagPos = victim.GetAttachmentOrigin( victim.LookupAttachment( "CHESTFOCUS" ) ) + RandomVec( 30 )
		params.dir = Normalize( victimTagPos - params.pos )
		StartParticleEffectInWorld(GetParticleSystemIndex( $"P_muzzleflash_predator" ), params.pos, VectorToAngles( params.dir ) )
	}

	// DebugDrawSphere(params.pos, 10, 255,0,0, true, 1.0 )
	// DebugDrawLine( params.pos, params.pos + params.dir*200, 255,0,0, true, 1.0 )

	thread OnWeaponPrimaryAttack_titanweapon_salvo_rockets( newOffhandWeapon, params )

	guy.TakeOffhandWeapon( 0 )

	if ( oldOffhandWeapon )
 		guy.GiveOffhandWeapon( oldOffhandWeapon.GetWeaponClassName(), 0, oldOffhandWeapon.GetMods() )
}


////////////////////
///// MODIFIED /////
////////////////////
#if MP
void function ExecutedTitanDropWeapon( entity titan )
{
	thread ExecutedTitanDropWeapon_Threaded( titan )
}

void function ExecutedTitanDropWeapon_Threaded( entity titan )
{
	if ( titan.GetMainWeapons().len() == 0 )
		return

	titan.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDeath" ) // if titan won't drop weapon on being executed, will be handled by OnTitanKilled()
	
	table results = {}
	results.droppedWeapon <- false

	// create weaponProp here, to prevent messed up by AE_DROP_WEAPON, hide it for now
	if ( !TitanPick_ShouldTitanDropWeapon( titan ) )
		return
	entity weaponProp = TitanPick_TitanDropWeapon( titan )
	if ( !IsValid( weaponProp ) )
		return
	weaponProp.NotSolid() // prevent it mess up execution
	weaponProp.Hide()
	weaponProp.UnsetUsable()
	// don't drop weapon again for this soul
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		TitanPick_SoulSetEnableWeaponDrop( soul, false )

	OnThreadEnd
	(
		function(): ( weaponProp, results )
		{
			if ( IsValid( weaponProp ) )
			{
				if ( results.droppedWeapon ) // dropped another weapon in this func?
				{
					//print( "should destroy existing weaponProp!" )
					weaponProp.Destroy()
					return
				}
				// show weaponProp again
				weaponProp.Solid()
				weaponProp.Show()
				weaponProp.SetUsable()
			}
		}
	)

	entity weaponToDrop = titan.GetMainWeapons()[0]
	string name = weaponToDrop.GetWeaponClassName()
	array<string> mods = weaponToDrop.GetMods()
	int skin = weaponToDrop.GetSkin()
	int camo = weaponToDrop.GetCamo()
	int ammoLeft = 0
	try { ammoLeft = weaponToDrop.GetWeaponPrimaryClipCount() }
    catch(ex) {}

	// manually handle AE_DROP_WEAPON, wait for this weapon being dropped, then create a new one and drop it
	while ( TitanHasWeaponEntity( titan, weaponToDrop ) )
		WaitFrame()
	
	// AE_DROP_WEAPON triggered! re-enable weapon drop
	if ( IsValid( soul ) )
		TitanPick_SoulSetEnableWeaponDrop( soul, true )

	//print( "TitanPick_ShouldTitanDropWeapon( titan ): " + string( TitanPick_ShouldTitanDropWeapon( titan ) ) )
	if ( !TitanPick_ShouldTitanDropWeapon( titan ) )
		return

	//print( "Titan dropped weapon for being executed" )
	// temp give a weapon
	foreach ( entity weapon in titan.GetMainWeapons() )
		titan.TakeWeapon( weapon.GetWeaponClassName() )
	entity newWeapon = titan.GiveWeapon( name, mods )
	newWeapon.SetSkin( skin )
	newWeapon.SetCamo( camo )
	try { newWeapon.SetWeaponPrimaryClipCount( ammoLeft ) }
	catch(ex1) {}

	TitanPick_TitanDropWeapon( titan ) // drop this weapon
	results.droppedWeapon = true // mark as we dropped weapon!
	newWeapon.Destroy()

	// don't drop weapon again for this soul
	if ( IsValid( soul ) )
		TitanPick_SoulSetEnableWeaponDrop( soul, false )
}

bool function TitanHasWeaponEntity( entity titan, entity weapon )
{
	foreach ( entity holdingWeapon in titan.GetMainWeapons() )
	{
		//print( "holdingWeapon: " + string( holdingWeapon ) )
		//print( "weapon: " + string( weapon ) )
		if ( holdingWeapon == weapon )
			return true
	}
	return false
}
#endif

//
void function MeleeSyncedTitan_AddBatteryRewardTitanPassives( int passive )
{
	if ( !file.titanExecutionRewardsBatteryPassives.contains( passive ) )
		file.titanExecutionRewardsBatteryPassives.append( passive )
}

void function MeleeSyncedTitan_RemoveBatteryRewardTitanPassives( int passive )
{
	if ( file.titanExecutionRewardsBatteryPassives.contains( passive ) )
		file.titanExecutionRewardsBatteryPassives.fastremovebyvalue( passive )
}

void function MeleeSyncedTitan_ExecutionAlwaysRewardsBattery( bool always )
{
	file.titanExecutionAlwaysRewardsBattery = always
}

bool function MeleeSyncedTitan_ShouldApplyBatteryAfterExecution( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return false

	// settings check
	if ( file.titanExecutionAlwaysRewardsBattery )
		return true
	
	// passive check
	foreach ( int passive in file.titanExecutionRewardsBatteryPassives )
	{
		if ( SoulHasPassive( soul, passive ) )
			return true // return true if we every had a passive that rewards battery
	}

	return false
}

void function MeleeSyncedTitan_DisableVanguardKitExecution( bool disable )
{
	file.disableVanguardKitExecution = disable
}

// misc fix settings
void function MeleeSyncedTitan_EnableExecutionAttackerNoTarget( bool enable )
{
	file.attackerNoTargetOnExecution = enable
}

// victim think is unused, as they're always invulnerable and we should always add notarget for them
/*
void function MeleeSyncedTitan_EnableExecutionVictimNoTarget( bool enable )
{
	file.victimNoTargetOnExecution = enable
}
*/

void function MeleeSyncedTitan_EndExecutionOnNPCTargetDeath( bool enable )
{
	file.endExecutionOnNPCTargetDeath = enable
}

void function MeleesyncedTitan_Enable3pExecutionTimerFix( bool enable )
{
	file.enableTitanVsTitan3pTimerFix = enable
}

// vanilla const turns to settings
void function MeleeSyncedTitan_ExecutionNotInvulnerable( bool notInvulnerable )
{
	file.titanExecutionNotInvulnerable = notInvulnerable
}

void function MeleeSyncedTitan_ExecutionAlwaysGiveBattery( bool alwaysGive )
{
	file.titanExecutionAlwaysGiveBattery = alwaysGive
}
//

void function MeleeSyncedTitan_SetSoulDoClassicExecution( entity titanSoul, bool doClassic )
{
	if ( !( titanSoul in file.soulDoClassicExecution ) )
		file.soulDoClassicExecution[ titanSoul ] <- false // default value
	file.soulDoClassicExecution[ titanSoul ] = doClassic
}

bool function MeleeSyncedTitan_GetSoulDoClassicExecution( entity titanSoul )
{
	// playlistvar overrides script settings
	if ( GetCurrentPlaylistVarInt( "classic_execution", 0 ) == 1 )
		return true
	
	if ( !( titanSoul in file.soulDoClassicExecution ) )
		return false // default value
	return file.soulDoClassicExecution[ titanSoul ]
}

void function MeleeSyncedTitan_SetSoulDoRandomExecution( entity titanSoul, bool doRandom )
{
	if ( !( titanSoul in file.soulDoRandomExecution ) )
		file.soulDoRandomExecution[ titanSoul ] <- false // default value
	file.soulDoRandomExecution[ titanSoul ] = doRandom
}

bool function MeleeSyncedTitan_GetSoulDoRandomExecution( entity titanSoul )
{
	// playlistvar overrides script settings
	if ( GetCurrentPlaylistVarInt( "random_titan_execution", 0 ) == 1 )
		return true
	
	if ( !( titanSoul in file.soulDoRandomExecution ) )
		return false // default value
	return file.soulDoRandomExecution[ titanSoul ]
}

void function MeleeSyncedTitan_SetSoulClassicExecutionType( entity titanSoul, string executionType )
{
	if ( !( titanSoul in file.soulClassicExecutionType ) )
		file.soulClassicExecutionType[ titanSoul ] <- GetSoulTitanSubClass( titanSoul ) // default value
	file.soulClassicExecutionType[ titanSoul ] = executionType
}

string function MeleeSyncedTitan_GetSoulClassicExecutionType( entity titanSoul )
{
	// hardcode "random" type
	if ( MeleeSyncedTitan_GetSoulDoRandomExecution( titanSoul ) )
	{
		array<string> validExecutionTypes = ["atlas", "stryder"]
		// atlas and stryder pov model don't have "ogpov_melee_armrip_attacker" animation
		// should only add them for ogre titans
		if ( GetSoulTitanSubClass( titanSoul ) == "ogre" )
			validExecutionTypes.append( "ogre" )
		return validExecutionTypes[ RandomInt( validExecutionTypes.len() ) ]
	}

	if ( !( titanSoul in file.soulClassicExecutionType ) )
		return GetSoulTitanSubClass( titanSoul ) // default value, using titan chassis

	// atlas and stryder pov model don't have "ogpov_melee_armrip_attacker" animation
	// never use them on atlas or stryder titans even if it has been set
	if ( file.soulClassicExecutionType[ titanSoul ] == "ogre" && GetSoulTitanSubClass( titanSoul ) != "ogre" )
		return GetSoulTitanSubClass( titanSoul ) // default value, using titan chassis

	return file.soulClassicExecutionType[ titanSoul ]
}

// these shouldn't be used atm
/*
void function MeleeSyncedTitan_SetSoulUseExecutionCallback( entity titanSoul, bool useCallback )
{
	if ( !( titanSoul in file.soulUseExecutionCallback ) )
		file.soulUseExecutionCallback[ titanSoul ] <- true // default value
	file.soulUseExecutionCallback[ titanSoul ] = useCallback
}

bool function GetSoulUseExecutionCallback( entity titanSoul )
{
	if ( !( titanSoul in file.soulUseExecutionCallback ) )
		return true // default value
	return file.soulUseExecutionCallback[ titanSoul ]
}

void function MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( entity titanSoul, bool useCallback )
{
	if ( !( titanSoul in file.soulShouldReplaceLoadout ) )
		file.soulShouldReplaceLoadout[ titanSoul ] <- false // default value
	file.soulShouldReplaceLoadout[ titanSoul ] = useCallback
}

bool function GetSoulReplaceLoadoutOnExecution( entity titanSoul )
{
	if ( !( titanSoul in file.soulShouldReplaceLoadout ) )
		return false // default value
	return file.soulShouldReplaceLoadout[ titanSoul ]
}
*/

// shared with sh_melee_titan.gnut
void function MeleeSyncedTitan_SetSoulCanBeExecuted( entity soul, bool canBeExecuted )
{
	if ( !( soul in file.soulCanBeExecuted ) )
		file.soulCanBeExecuted[ soul ] <- true // default value
	file.soulCanBeExecuted[ soul ] = canBeExecuted
}

bool function MeleeSyncedTitan_SoulCanBeExecuted( entity soul )
{
	if ( !IsValid( soul ) ) // soul invalid?
		return false
	if ( !( soul in file.soulCanBeExecuted ) ) // no settings
		return true // default value
	return file.soulCanBeExecuted[ soul ]
}

void function MeleeSyncedTitan_SetSoulExecutionTargetRequiredHealthFrac( entity soul, float healthFracRequired )
{
	if ( !( soul in file.soulExecutionTargetRequiredHealthFrac ) )
		file.soulExecutionTargetRequiredHealthFrac[ soul ] <- 0.0 // default value. 0.0 means we need target titan to be doomed before executing them
	file.soulExecutionTargetRequiredHealthFrac[ soul ] = healthFracRequired
}

float function MeleeSyncedTitan_GetSoulExecutionTargetRequiredHealthFrac( entity soul )
{
	if ( !( soul in file.soulExecutionTargetRequiredHealthFrac ) ) // no settings
		return 0.0 // default value. 0.0 means we need target titan to be doomed before executing them
	return file.soulExecutionTargetRequiredHealthFrac[ soul ]
}

// HACK for npc using ion prime execution
// npc can fire laser core at the beginning of animation, needs to get timer before do anything
float function MeleeSyncedTitan_GetTitanExecutionStartTime( entity titan )
{
	if ( !( titan in file.titanExecutionStartTime ) )
		return -1 // invalid timer
	
	return file.titanExecutionStartTime[ titan ]
}
///////////////
///// END /////
///////////////