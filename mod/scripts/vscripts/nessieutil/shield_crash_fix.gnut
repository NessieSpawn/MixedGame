untyped // to use ent.s and untyped variables
// this is to fix respawn's weird client-side crash
// use in-file shield value for non-titan heavy armor target
// needs to replace all GetShieldHealth(), SetShieldHealth(), GetShieldHealthMax() and SetShieldHealthMax() function with functions in this file

// IMPORTANT CONST! should adjust value based on different branch
const bool CLIENT_HAS_FIXED_SHIELD_CRASH = true // for NSCN, client-side shield crash has already been fixed, safe to use vanilla shield behavior

global function Nessie_Shield_Crash_Fix_Init

global function SetShieldHealthWithFix
global function GetShieldHealthWithFix
global function SetShieldHealthMaxWithFix
global function GetShieldHealthMaxWithFix

// replacement func to handle native think
// prevents crits from happening on scripted shield entities
global function IsCriticalHit_WithScriptedShieldCheck
global function EntCanHaveShield

// effects from cl_player_common.gnut
const asset SHIELD_BODY_FX = $"P_xo_armor_body_CP"
const asset SHIELD_HIT_FX = $"P_xo_armor_impact"
const asset SHIELD_HIT_FX_VICTIM = $"impact_metal" // not working fine
const asset SHIELD_HIT_FX_EXTRA = $"P_impact_xo_shield_cp"
const asset SHIELD_BREAK_FX = $"P_xo_armor_break_CP"

// main functioning array
const array<string> USE_SCRIPTED_SHIELD_CLASSES =
[
    "npc_super_spectre",
    "npc_stalker",
]

struct
{
    table<entity, int> entMaxShieldValue
    table<entity, int> entShieldValue

    // in-file tables
	table<entity, float> entNextShieldDamageSoundAllowedTime
    table<entity, entity> entTargetShieldEffect
    table<entity, entity> entNeutralShieldEffect
} file

void function Nessie_Shield_Crash_Fix_Init()
{
    PrecacheParticleSystem( SHIELD_BODY_FX )
    PrecacheParticleSystem( SHIELD_HIT_FX )
    PrecacheParticleSystem( SHIELD_HIT_FX_VICTIM )
    PrecacheParticleSystem( SHIELD_HIT_FX_EXTRA )
    PrecacheParticleSystem( SHIELD_BREAK_FX )
    PrecacheParticleSystem( $"impact_flesh_victim" ) // just for debugging
    PrecacheParticleSystem( $"P_impact_flesh_attacker" )
    PrecacheParticleSystem( $"impact_flesh" )

    // change effect to be handled by server
    // play in final damage callback because it's where shield health isn't modified yet
    foreach ( string className in USE_SCRIPTED_SHIELD_CLASSES )
    {
        AddDamageFinalCallback( className, OnScriptedShieldEntDamage )
        // modified callback in _codecallbacks_common.gnut, handles damage that failed to pass through
        // this is for us playing a fake shield impact effect and sound
        AddDamageFailedCallback( className, OnScriptedShieldEntDamageFailed )
    }
    // removes client-side effect and crit indicator
    // modified callback in _base_gametype.gnut
    AddCallback_PlayerDamageFeedback( ScriptedShieldPlayerFeedbackFix )
}

// replacement func to handle native think
// prevents crits from happening on scripted shield entities
// needs to be fully untyped so we can handle vanilla usages...
bool function IsCriticalHit_WithScriptedShieldCheck( attacker, victim, hitbox, damageAmount, damageTypes )
{
    expect entity( victim )
    bool victimHasShield = GetShieldHealthWithFix( victim ) > 0 && GetShieldHealthMaxWithFix( victim ) > 0
    return IsCriticalHit( attacker, victim, hitbox, damageAmount, damageTypes ) && !victimHasShield
}

void function OnScriptedShieldEntDamage( entity ent, var damageInfo )
{
    // fix shield hit effect on scripted shield entity
    // can't fix impact effect and sound, those are native stuff
    // normally this effect is only played when player hits this entity
    // but we don't have impact effect, doing this for all players is good enough
    if ( !EntCanHaveShield( ent ) && GetShieldHealthWithFix( ent ) > 0 )
    {
        PlayShieldHitEffect_Server( ent, damageInfo )
        // shield hit sound is disabled on attacker, to avoid sound delay
        // actually works pretty fine! we can't handle everything as we want, doing a sound works really fine
        PlayShieldHitSound_Server( ent, damageInfo )
        // debugging
        //EmitSoundOnEntity( ent, "titanshield_light_bulletimpact_1p_vs_3p" )
    }
}

void function OnScriptedShieldEntDamageFailed( entity ent, var damageInfo )
{
    if ( !EntCanHaveShield( ent ) && GetShieldHealthWithFix( ent ) > 0 )
    {
        PlayShieldHitEffect_Server( ent, damageInfo, true )
        PlayShieldHitSound_Server( ent, damageInfo )
    }
}

void function ScriptedShieldPlayerFeedbackFix( entity victim, var damageInfo, PlayerDamageFeedbackStruct feedbackStruct )
{
    if ( !EntCanHaveShield( victim ) )
    {
        bool victimHasShield = GetShieldHealthWithFix( victim ) > 0 && GetShieldHealthMaxWithFix( victim ) > 0
        // removes client-side effect and crit indicator
        if ( victimHasShield )
        {
            if ( feedbackStruct.customDamageType & DF_CRITICAL )
                feedbackStruct.customDamageType = feedbackStruct.customDamageType & ~DF_CRITICAL
            if ( feedbackStruct.customDamageType & DF_SHIELD_DAMAGE )
                feedbackStruct.customDamageType = feedbackStruct.customDamageType & ~DF_SHIELD_DAMAGE
        }
    }
}

void function InitFakeShieldValue( entity ent )
{
    if ( !EntCanHaveShield( ent ) )
    {
        if ( !( ent in file.entShieldValue ) )
        {
            file.entMaxShieldValue[ ent ] <- 0
            file.entShieldValue[ ent ] <- 0
        }
    }
}

// for non-titan heavy armor unit, use scripted shield health
bool function EntCanHaveShield( entity ent )
{
    // if our client has been fixed, no need to use scripted shield value
    #if CLIENT_HAS_FIXED_SHIELD_CRASH
        return true
    #endif

    string className = ent.GetClassName()
    if ( USE_SCRIPTED_SHIELD_CLASSES.contains( className ) )
        return false

    return true
}

bool function EntCritHidden( entity ent )
{
    // script handle
    if ( "critHiddenByScript" in ent.s )
        return true

    int bodyGroupIndex = ent.FindBodyGroup( "hitpoints" )

	if ( bodyGroupIndex == -1 )
		return false

	return ent.GetBodyGroupState( bodyGroupIndex ) == 1
}

void function SetShieldHealthWithFix( entity ent, var targetShield )
{
    InitFakeShieldValue( ent )

    // shield value before updating
    int oldShieldValue = GetShieldHealthWithFix( ent )
    // type casting
    int intShieldValue = typeof( targetShield ) == "int" ? expect int( targetShield ) : int( targetShield )

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
    {
        file.entShieldValue[ ent ] = intShieldValue
        // due we can't make client-side get shield they left
        // try to hide on server-side
        if ( intShieldValue > 0 && GetShieldHealthMaxWithFix( ent ) > 0 )
        {
            //print( "trying to hide crit for entity..." )
            if ( !EntCritHidden( ent ) )
            {
                //print( "crit hidden!" )
                HideCrit( ent )
                ent.s.critHiddenByScript <- true
            }
        }
        else
        {
            //print( "trying to show crit for entity..." )
            if ( "critHiddenByScript" in ent.s ) // only recover crit for those getting hidden by this file
            {
                //print( "crit shown!" )
                ShowCrit( ent )
                delete ent.s.critHiddenByScript
            }
        }

        // fake effect: shield up / shield down
        int maxShieldValue = GetShieldHealthMaxWithFix( ent )
        if ( GetShieldHealthMaxWithFix( ent ) > 0 )
        {
            // behavior from cl_code_callbacks_mp.gnut
            if ( maxShieldValue > 0 )
            {
                if ( oldShieldValue > 0 && intShieldValue <= 0 )
                    PlayShieldBreakEffect_Server( ent )
                else if ( oldShieldValue != maxShieldValue && intShieldValue == maxShieldValue )
                    PlayShieldActivateEffect_Server( ent )
            }
        }
    }
    else // otherwise we use vanilla behavior
        ent.SetShieldHealth( intShieldValue )
}

int function GetShieldHealthWithFix( entity ent )
{
    InitFakeShieldValue( ent )

    // if entity has no max shield, don't do anything
    if ( GetShieldHealthMaxWithFix( ent ) <= 0 )
        return 0

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
        return file.entShieldValue[ ent ]
  
    // safe to use vanilla behavior
    return ent.GetShieldHealth()
}

void function SetShieldHealthMaxWithFix( entity ent, var targetMaxShield )
{
    InitFakeShieldValue( ent )

    // type casting
    int intShieldValue = typeof( targetMaxShield ) == "int" ? expect int( targetMaxShield ) : int( targetMaxShield )

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
    {
        file.entMaxShieldValue[ ent ] = intShieldValue
        // due we can't make client-side get shield they left
        // try to hide on server-side
        if ( intShieldValue > 0 && GetShieldHealthWithFix( ent ) > 0 )
        {
            //print( "trying to hide crit for entity..." )
            if ( !EntCritHidden( ent ) )
            {
                //print( "crit hidden!" )
                HideCrit( ent )
                ent.s.critHiddenByScript <- true
            }
        }
        else
        {
            //print( "trying to show crit for entity..." )
            if ( "critHiddenByScript" in ent.s ) // only recover crit for those getting hidden by this file
            {
                //print( "crit shown!" )
                ShowCrit( ent )
                delete ent.s.critHiddenByScript
            }
        }
    }
    else // otherwise we use vanilla behavior
        ent.SetShieldHealthMax( intShieldValue )
}

int function GetShieldHealthMaxWithFix( entity ent )
{
    InitFakeShieldValue( ent )

    if ( !EntCanHaveShield( ent ) ) // update scripted shield health if ent is non-titan heavy armor unit
        return file.entMaxShieldValue[ ent ]
  
    // safe to use vanilla behavior
    return ent.GetShieldHealthMax()
}

// effects taken from cl_player.gnut
void function PlayShieldHitEffect_Server( entity ent, var damageInfo, bool neutralEffect = false )
{
    int shieldbodyFX = GetParticleSystemIndex( SHIELD_BODY_FX )
	int attachID
	if ( ent.IsTitan() )
		attachID = ent.LookupAttachment( "exp_torso_main" )
	else
		attachID = ent.LookupAttachment( "ref" ) // TEMP

    // white shield: play to others to fake shield hit effects( WIP ). also gets played if damage failed to pass through
    // don't need anymore
    /*
    entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( ent, shieldbodyFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, < 1, 1, 1 > )
    */
    entity shieldFXHandle

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    if ( IsValid( attacker ) )
    {
        // maybe also try shield hit effect
        // only do when inflictor is weapon
        entity inflictor = DamageInfo_GetInflictor( damageInfo )
        entity weapon = DamageInfo_GetWeapon( damageInfo )
        if ( IsValid( weapon ) )
            inflictor = weapon
        if ( IsValid( inflictor ) && (inflictor instanceof CWeaponX) )
        {
            int shieldHitFX = GetParticleSystemIndex( SHIELD_HIT_FX )
            vector pos = DamageInfo_GetDamagePosition( damageInfo )
            // maybe we could trace attacker
            /*
            vector entPos = ent.GetOrigin()
            vector entEyePos = ent.EyePosition()
            float entCenterDot = ( entEyePos.z + entPos.z ) / 2
            vector entCenterPos = < entPos.x, entPos.y, entCenterDot >
            vector victimFacePos = VectorToAngles( Normalize( entCenterPos - pos ) )
            */
            vector victimFacePos = VectorToAngles( Normalize( attacker.EyePosition() - pos ) )

            // control point won't work
            /*
            entity shieldHitFXHandle = StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos )
            //EffectSetControlPointVector( shieldHitFXHandle, 0, < 115, 247, 255 > ) // this hides the effect idk
            EffectSetControlPointVector( shieldHitFXHandle, 1, < 115, 247, 255 > ) // blue
            */
            
            // wth this works
            StartParticleEffectInWorldWithControlPoint( shieldHitFX, pos, victimFacePos, < 115, 247, 255 > )

            // bad effect
            /*
            int shieldHitFXVictim = GetParticleSystemIndex( SHIELD_HIT_FX_VICTIM )
            StartParticleEffectOnEntity_ReturnEntity( ent, shieldHitFXVictim, FX_PATTACH_POINT_FOLLOW, attachID )
            */
            //SHIELD_HIT_FX_EXTRA

            // debugging for fun
            // still can't get correct blood spray effect
            /*
            shieldHitFX = GetParticleSystemIndex( $"P_impact_flesh_attacker" )
            EffectSetControlPointVector( StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos ), 1, < 255, 255, 255 > )
            shieldHitFX = GetParticleSystemIndex( $"impact_flesh" )
            StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos )
            StartParticleEffectInWorldWithControlPoint( GetParticleSystemIndex( $"impact_flesh" ), pos, victimFacePos, < 255, 255, 255 > )
            StartParticleEffectInWorldWithControlPoint( GetParticleSystemIndex( $"P_impact_flesh_attacker" ), pos, victimFacePos, < 255, 255, 255 > )
            */

            // extra effect
            // does not work
            /*
            shieldHitFX = GetParticleSystemIndex( SHIELD_HIT_FX_EXTRA )
            entity shieldHitFXHandle = StartParticleEffectInWorld_ReturnEntity( shieldHitFX, pos, victimFacePos )
            EffectSetControlPointVector( shieldHitFXHandle, 0, < 115, 247, 255 > ) // blue
            */

            // still can't control CP
            /*
            entity shieldHitFXHandle = StartParticleEffectOnEntity_ReturnEntity( ent, shieldHitFX, FX_PATTACH_POINT_FOLLOW, ent.LookupAttachment( "CHESTFOCUS" ) )
            EffectSetControlPointVector( shieldHitFXHandle, 1, < 115, 247, 255 > ) // blue
            */
        }

        // colored shield: only play to player attacker
        if ( !neutralEffect && attacker.IsPlayer() )
        {
            float shieldHealthFrac = GetShieldHealthFrac( ent )

            shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( ent, shieldbodyFX, FX_PATTACH_POINT_FOLLOW, attachID )
            EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
            // TO OWNER ONLY
            shieldFXHandle.SetOwner( attacker )
            shieldFXHandle.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
        }
    }
}

const table SHIELD_COLOR_CHARGE_FULL = { r = 115, g = 247, b = 255 }    // blue
const table SHIELD_COLOR_CHARGE_MED  = { r = 200, g = 128, b = 80 } // orange
const table SHIELD_COLOR_CHARGE_EMPTY = { r = 200, g = 80, b = 80 } // red

const SHIELD_COLOR_CROSSOVERFRAC_FULL2MED    = 0.75  // from zero to this fraction, fade between full and medium charge colors
const SHIELD_COLOR_CROSSOVERFRAC_MED2EMPTY    = 0.95  // from "full2med" to this fraction, fade between medium and empty charge colors

function GetShieldEffectCurrentColor( shieldHealthFrac )
{
	local color1 = SHIELD_COLOR_CHARGE_FULL
	local color2 = SHIELD_COLOR_CHARGE_MED
	local color3 = SHIELD_COLOR_CHARGE_EMPTY

	local crossover1 = SHIELD_COLOR_CROSSOVERFRAC_FULL2MED  // from zero to this fraction, fade between color1 and color2
	local crossover2 = SHIELD_COLOR_CROSSOVERFRAC_MED2EMPTY  // from crossover1 to this fraction, fade between color2 and color3

	local colorVec = < 0, 0, 0 >
	// 0 = full charge, 1 = no charge remaining
	if ( shieldHealthFrac < crossover1 )
	{
		colorVec.x = Graph( shieldHealthFrac, 0, crossover1, color1.r, color2.r )
		colorVec.y = Graph( shieldHealthFrac, 0, crossover1, color1.g, color2.g )
		colorVec.z = Graph( shieldHealthFrac, 0, crossover1, color1.b, color2.b )
	}
	else if ( shieldHealthFrac < crossover2 )
	{
		colorVec.x = Graph( shieldHealthFrac, crossover1, crossover2, color2.r, color3.r )
		colorVec.y = Graph( shieldHealthFrac, crossover1, crossover2, color2.g, color3.g )
		colorVec.z = Graph( shieldHealthFrac, crossover1, crossover2, color2.b, color3.b )
	}
	else
	{
		// for the last bit of overload timer, keep it max danger color
		colorVec.x = color3.r
		colorVec.y = color3.g
		colorVec.z = color3.b
	}

	return colorVec
}

// keep similar as _health_regen.gnut does
// not all damage works fine with sound
// all the sound has "_1p_vs_3p", "_3p_vs_1p" and "_3p_vs_3p" suffix for us to use
const string SHIELD_DAMAGE_SOUND_PREFIX = "titanshield_light_bulletimpact" // sound when getting hit by bullets( sadly "titanshield_heavy_bulletimpact_3p_vs_1p" sounds identical to light impact one )
// only bullet damage plays the sound every time, other damage types have a sound interval because we can't ignore radius damage like native does
// btw it seems that projectile impacts mostly won't do shield effect... guess we could handle only hitscan weapons?
const string SHIELD_DAMAGE_SOUND_PREFIX_EXPLOSION = "titanshield_explosive_bulletimpact" // sound when getting hit by explosive damage
const string SHIELD_DAMAGE_SOUND_PREFIX_ELECTRICAL = "titanshield_energy_bulletimpact" // sound when getting hit by electrical damage
const string SHIELD_DAMAGE_SOUND_PREFIX_MELEE = "titanshield_meleeimpact" // sound when getting hit by melee

const float SHIELD_DAMAGE_SOUND_INTERVAL_MIN = 0.4 // prevent sound spaming
const float SHIELD_DAMAGE_SOUND_INTERVAL_MAX = 0.5

void function PlayShieldHitSound_Server( entity ent, var damageInfo )
{
    InitShieldSoundVars( ent )

    entity attacker = DamageInfo_GetAttacker( damageInfo )
    // shield on-hit sound
	int damageTypes = DamageInfo_GetCustomDamageType( damageInfo )
	string shieldHitSound = GetShieldDamagedSound( damageTypes )
    // only bullet damage plays the sound every time, other damage types have a sound interval because we can't ignore radius damage like native does
    // only do when inflictor is weapon
    entity inflictor = DamageInfo_GetInflictor( damageInfo )
    entity weapon = DamageInfo_GetWeapon( damageInfo )
    if ( IsValid( weapon ) )
        inflictor = weapon
    if ( IsValid( inflictor ) && (inflictor instanceof CWeaponX) )
    {
        if ( shieldHitSound == SHIELD_DAMAGE_SOUND_PREFIX )
            ShieldHitSoundByType( ent, attacker, shieldHitSound )
        else 
        {
            if ( Time() > file.entNextShieldDamageSoundAllowedTime[ ent ] )
            {
                ShieldHitSoundByType( ent, attacker, shieldHitSound )
                // add sound cooldown
                float nextSoundInterval = RandomFloatRange( SHIELD_DAMAGE_SOUND_INTERVAL_MIN, SHIELD_DAMAGE_SOUND_INTERVAL_MAX )
                file.entNextShieldDamageSoundAllowedTime[ ent ] = Time() + nextSoundInterval
            }
            //else
            //	print( "player still in shield damage sound cooldown!" )
        }
    }
}

void function ShieldHitSoundByType( entity ent, entity attacker, string soundPrefix )
{
    // attacker sound
    if ( IsValid( attacker ) && attacker.IsPlayer() )
    {
        EmitSoundOnEntityOnlyToPlayer( ent, attacker, soundPrefix + "_1p_vs_3p" )
        EmitSoundOnEntityExceptToPlayer( ent, attacker, soundPrefix + "_3p_vs_3p" )
    }
    else // netual sound
        EmitSoundOnEntity( ent, soundPrefix + "_3p_vs_3p" )
}

string function GetShieldDamagedSound( int damageTypes )
{
	string shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX // default sound

	if ( damageTypes & DF_EXPLOSION ) // explosion damage specific sound, overrides bullets
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_EXPLOSION
	if ( damageTypes & DF_ELECTRICAL ) // electrical damage specific sound, overrides explosion and bullets
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_ELECTRICAL
	if ( damageTypes & DF_MELEE ) // melee damage specific sound, has highest priority
		shieldHitSound = SHIELD_DAMAGE_SOUND_PREFIX_MELEE

	//print( "shieldHitSound: " + shieldHitSound )
	return shieldHitSound
}

void function InitShieldSoundVars( entity ent )
{
    if ( !( ent in file.entNextShieldDamageSoundAllowedTime ) )
        file.entNextShieldDamageSoundAllowedTime[ ent ] <- 0.0
}

void function PlayShieldBreakEffect_Server( entity ent )
{
	entity shieldEnt = ent
	if ( IsSoul( ent ) )
	{
		shieldEnt = ent.GetTitan()
		if ( !shieldEnt )
			return
	}

	float shieldHealthFrac = GetShieldHealthFrac( shieldEnt )

	int shieldBreakFX = GetParticleSystemIndex( SHIELD_BREAK_FX )
	int attachID
	if ( shieldEnt.IsTitan() )
		attachID = shieldEnt.LookupAttachment( "exp_torso_main" )
	else
		attachID = shieldEnt.LookupAttachment( "ref" ) // TEMP

	entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( shieldEnt, shieldBreakFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
}

void function PlayShieldActivateEffect_Server( entity ent )
{
	entity shieldEnt = ent
	if ( IsSoul( ent ) )
	{
		shieldEnt = ent.GetTitan()
		if ( !shieldEnt )
			return
	}

	float shieldHealthFrac = GetShieldHealthFrac( shieldEnt )

	int shieldBreakFX = GetParticleSystemIndex( SHIELD_BREAK_FX )
	int attachID
	if ( shieldEnt.IsTitan() )
		attachID = shieldEnt.LookupAttachment( "exp_torso_main" )
	else
		attachID = shieldEnt.LookupAttachment( "ref" ) // TEMP

	entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( shieldEnt, shieldBreakFX, FX_PATTACH_POINT_FOLLOW, attachID )
	EffectSetControlPointVector( shieldFXHandle, 1, GetShieldEffectCurrentColor( 1 - shieldHealthFrac ) )
}