// 11.27: Changed all settings to "titan_soul" entity instead of player
untyped // I really don't like this thing but .SetPlayerSettings() need it...

global function TitanReplace_Enabled_Init // for enabling in loadedinits_after
global function TitanReplace_Init

// settings
global function TitanReplace_SetEnabled
global function TitanReplace_MonarchUpgradeAfterDrop // monarch loadout keep upgrades after pickup

global function TitanReplace_UseGunnerBisonVariant // bison variant

// fixes and rebalances, always gets applied no matter titan_replace is enabled or not
global function TitanReplace_EnableRoninMiscFix // fix ronin's sword core behavior
global function TitanReplace_EnableIonMiscFix // fix fd laser core bar( WIP: fix splitter rifle damage scaling )

global function TitanReplace_EnableNorthstarReBalance // rebalance northstar's railgun
global function TitanReplace_EnableMonarchReBalance // rebalance monarch's xo-16, energy siphon and disable battery executions

///// acrossFile utilities
global function TitanReplace_GiveTitanLoadoutReplace
global function TitanReplace_GetSoulStartingPassive // passive which titan spawn with
global function TitanReplace_GetSoulStartingExecutionRef // executionref which titan spawn with

// title
global function TitanReplace_UpdateSoulTitanTitle
global function TitanReplace_GetSoulSavedTitanTitle

// passive
global function TitanReplace_RegisterPassiveType
global function TitanReplace_RegisterCharacterOwnedPassives
global function TitanReplace_GetPassiveType
global function TitanReplace_RemoveUnmatchedPassivesForTitan // this actually uses TitanPick_GetTitanWeaponDropCharacterName() for getting character name!!

global enum eTitanReplacePassiveTypes
{
	WEAPON
	DEFENSE,
	UTILITY,
	OFFENSE,
	CORE,
}

///// titanType utilities
global function TitanReplace_BecomeIon
global function TitanReplace_BecomeTone
global function TitanReplace_BecomeAtlas
global function TitanReplace_BecomeRonin
global function TitanReplace_BecomeNorthstar
global function TitanReplace_BecomeStryder
global function TitanReplace_BecomeScorch
global function TitanReplace_BecomeLegion
global function TitanReplace_BecomeOgre
global function TitanReplace_BecomeBison
global function TitanReplace_BecomeGunnerBison // bison variant
global function TitanReplace_BecomeMonarch
global function TitanReplace_BecomeArchon
global function TitanReplace_BecomeBrute

// client install required
global function TitanReplace_BecomeModdedBrute4
global function TitanReplace_BecomeModdedArchon


const array<string> moddedPlayers = 
[ 
	"1007270968017", 	// VoyageDB
	"1003302185211", 	// DZ
	"2311706887", 		// mite
	"1011338569992", 	// G41
	"1007340426216", 	// Jerry_Wang#8123
	"1010087865132", 	// chillyue#5400
	"1007606851794", 	// 军团#7939
	"1000374987953", 	// RCtd#0852
	"1006403284636", 	// wodemaya#0028
	"1007932882179", 	// 抑郁寡欢Z骡子#1903
	"1011146305825", 	// H_A#3930
	"1006393068081", 	// 一位屑中屑的屑铁驭屑铁驭#3838
	"1011667472349", 	// COOPER#7592
	"1007468387616", 	// LOGIC0214( logic#0886 )
	"1003338759893", 	// R9390X#1342
	"1008061878974", 	// yogre416#1123
	"1013455793584", 	// 114514#1281
	"1006799764479"		// ILoveSteam#6158
]

// monarch upgrade specific
struct MonarchUpgrades
{
	// upgrade core has been reworked: it now uses "upgradeCount" to count effective upgrades only( replenish shield don't count as effective one )
	// and use it's in-file variable to store total upgrades
	int effectiveUpgradeCount
	int totalUpgradeCount
	array<int> receivedUpgradePassives
	table<int, int> titanModifiedUpgrades
}

struct
{
	// settings
	bool defaultReplaceEnabled
	bool upgradeAllowedAfterDrop = false // monarch hack: if TitanReplace_MonarchUpgradeAfterDrop() turns off, only owner monarch can upgrade their offhands

	// titan variant
	bool useGunnerBison

	// fixes
	bool roninMiscFixEnabled
	bool ionMiscFixEnabled

	// balances
	bool northstarReBalanceEnabled
	bool monarchReBalanceEnabled

	// entity table
	table<entity, string> soulTitleTable
	table<entity, int> soulPassiveTable // for saving player's starting passive
	table<entity, string> soulExecutionRefTable // for saving player's starting executions

	// registered stuffs
	table<int, int> titanPassiveType
	table< string, array<int> > titanCharacterOwnedPassives

	// monarch upgrade specific
	table<entity, MonarchUpgrades> droppedMonarchUpgrades
	table< entity, table<int, bool> > soulMonarchCorePassives
	table< entity, table<int, bool> > droppedMonarchCorePassives
	// if we're not enabling upgradeAllowedAfterDrop, needs to store modified upgrades and drop it to ground
	table< entity, table<int, int> > soulSavedModifiedUpgradesTable
} file

void function TitanReplace_Enabled_Init()
{
	TitanReplace_SetEnabled( true )
}

void function TitanReplace_Init() 
{
	AddSoulInitFunc( TitanReplace_InitSoulSettings )
	AddSpawnCallback( "npc_titan", OnTitanSpawned )
	AddCallback_OnPilotBecomesTitan( SetPlayerTitanTitle )

	RegisterDefaultTitanPickCharacters()
}

void function TitanReplace_SetEnabled( bool enabled )
{
	file.defaultReplaceEnabled = enabled
}

void function TitanReplace_MonarchUpgradeAfterDrop( bool enable )
{
    file.upgradeAllowedAfterDrop = enable
}

void function TitanReplace_UseGunnerBisonVariant( bool use )
{
	file.useGunnerBison = use
}

// fixes
void function TitanReplace_EnableRoninMiscFix( bool enable )
{
	file.roninMiscFixEnabled = enable
}

void function TitanReplace_EnableIonMiscFix( bool enable )
{
	file.ionMiscFixEnabled = enable
}

// balances
void function TitanReplace_EnableNorthstarReBalance( bool enable )
{
	file.northstarReBalanceEnabled = enable
}

void function TitanReplace_EnableMonarchReBalance( bool enable )
{
	file.monarchReBalanceEnabled = enable
	if ( !enable ) // bind together behavior: disable battery executions
	{
		MeleeSyncedTitan_DisableVanguardKitExecution( true ) // bind together to nerf monarch
    	MeleeSyncedTitan_RemoveBatteryRewardTitanPassives( ePassives.PAS_VANGUARD_COREMETER ) // remove monarch energy thief
	}
}

void function OnTitanSpawned( entity titan )
{
	TitanReplace_GiveTitanLoadoutReplace( titan )
}

// default replace
void function TitanReplace_GiveTitanLoadoutReplace( entity titan )
{
	// always init everything
	entity titanSoul = titan.GetTitanSoul()
	if( !IsValid( titanSoul ) ) // soul not spawned yet, mostly because disembarking, no worries
		return

	// following are player titans( pet titans )
	entity player = GetPetTitanOwner( titan )
	if( !IsValid( player ) )
		return
	if ( "spawnWithoutSoul" in titan.s )
	{
		// this is defined in CreateAutoTitanForPlayer_ForTitanTitanReplace_BecomesPilot(), mark the titan as "disembarked" not "hotdropping"
		if ( expect bool ( titan.s.spawnWithoutSoul ) )
			return
	}

	// get passives and executionrefs here
	file.soulPassiveTable[ titanSoul ] = _PassiveFromEnum[titanSoul.soul.titanLoadout.passive2] // for saving player's starting passive
	file.soulExecutionRefTable[ titanSoul ] = titanSoul.soul.titanLoadout.titanExecution // for saving player's starting executions
	//print( "soul " + string( titanSoul ) + " 's executionRef is: " + file.soulExecutionRefTable[ titanSoul ] )

	asset modelName = titan.GetModelName()
	//print( "modelName is: " + string( modelName ) )

	// titan fixes and balance, always run
	switch( modelName )
	{
		// ronin fix...
		case $"models/titans/light/titan_light_locust.mdl":
			if ( file.roninMiscFixEnabled )
			{
				entity coreWeapon = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
				if ( IsValid( coreWeapon ) )
				{
					coreWeapon.AddMod( "sword_core_fix" )
				}
			}
			break

		// ion fix...
		case $"models/titans/medium/titan_medium_ajax.mdl":
			if ( file.ionMiscFixEnabled )
			{
				entity coreWeapon = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
				if ( IsValid( coreWeapon ) )
				{
					coreWeapon.AddMod( "laser_core_fix" )
				}
			}
			break
		
		// northstar balance...
		case $"models/titans/light/titan_light_raptor.mdl":
			if ( file.northstarReBalanceEnabled )
			{
				if ( titan.GetMainWeapons().len() > 0 )
				{
					entity mainWeapon = titan.GetMainWeapons()[0]
					mainWeapon.AddMod( "rebalanced_weapon" )
				}
			}
			break
		
		// monarch balance...
		case $"models/titans/medium/titan_medium_vanguard.mdl":
			if ( file.monarchReBalanceEnabled )
			{
				if ( titan.GetMainWeapons().len() > 0 )
				{
					entity mainWeapon = titan.GetMainWeapons()[0]
					mainWeapon.AddMod( "rebalanced_weapon" )
				}

				entity defenseWeapon = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
				if ( IsValid( defenseWeapon ) )
				{
					defenseWeapon.AddMod( "rebalanced_weapon" )
				}
			}
			break
	}

	// loadout replace
	if( file.defaultReplaceEnabled ) // don't run loadout functions automatically if settings disabled
	{
		switch( modelName )
		{
			case $"models/titans/medium/titan_medium_vanguard.mdl":
				// fakeBT stuffs now all handled in it's file
				//TitanPick_SoulSetEnableWeaponPick( titanSoul, false ) // set players unable to replace weapons from ground
				break

			case $"models/titans/medium/titan_medium_tone_prime.mdl":
				SendHudMessage(player, "已啓用天圖泰坦裝備，取消至尊泰坦以使用原版強力",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1)
				TitanReplace_BecomeAtlas( titan, false, true )
				break

			case $"models/titans/heavy/titan_heavy_legion_prime.mdl":
				SendHudMessage(player, "已啓用巨妖泰坦裝備，取消至尊泰坦以使用原版軍團",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeOgre( titan, false, true )
				break

			case $"models/titans/light/titan_light_ronin_prime.mdl":
				SendHudMessage(player, "已啓用游俠泰坦裝備，取消至尊泰坦以使用原版浪人",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeStryder( titan, false, true )
				break

			case $"models/titans/heavy/titan_heavy_scorch_prime.mdl":
				SendHudMessage(player, "已啓用野牛泰坦裝備，取消至尊泰坦以使用原版烈焰",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				if ( file.useGunnerBison ) // bison vairant
				{
					// Gunner Bison
					TitanReplace_BecomeGunnerBison( titan, false, true )
				}
				else
				{
					// Melee Bison
					TitanReplace_BecomeBison( titan, false, true )
				}
				break

			case $"models/titans/medium/titan_medium_ion_prime.mdl":
				SendHudMessage(player, "已啓用執政官泰坦裝備，取消至尊泰坦以使用原版離子",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeArchon( titan, false, true )
				break
			
			case $"models/titans/light/titan_light_northstar_prime.mdl":
				SendHudMessage(player, "已啓用野獸泰坦裝備，取消至尊泰坦以使用原版北極星",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeBrute( titan, false, true )
				break
		}
	}

	//temp fix, these are client install required titans
	/* // removed for now, we've got other server-side titans
	if( moddedPlayers.contains( player.GetUID() ) )
	{
		switch( modelName )
		{
			case $"models/titans/medium/titan_medium_ion_prime.mdl":
				SendHudMessage(player, "已啓用執政官泰坦裝備，取消至尊泰坦以使用原版離子",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeModdedArchon( titan, false, true )
				break
			case $"models/titans/light/titan_light_northstar_prime.mdl":
				SendHudMessage(player, "已啓用野獸四號泰坦裝備，取消至尊泰坦以使用原版北極星",  -1, 0.3, 200, 200, 225, 255, 0.15, 5, 1);
				TitanReplace_BecomeModdedBrute4( titan, false, true )
				break
		}
	}
	*/
}

int function TitanReplace_GetSoulStartingPassive( entity soul )
{
	return file.soulPassiveTable[ soul ]
}

string function TitanReplace_GetSoulStartingExecutionRef( entity soul )
{
	return file.soulExecutionRefTable[ soul ]
}

void function TitanReplace_UpdateSoulTitanTitle( entity soul, string newTitle )
{
	file.soulTitleTable[ soul ] = newTitle
}

string function TitanReplace_GetSoulSavedTitanTitle( entity soul )
{
	return file.soulTitleTable[ soul ]
}

void function SetPlayerTitanTitle( entity player, entity titan )
{
	thread SetPlayerTitanTitle_Threaded( player ) // needs thread, to make soul valid
}

void function SetPlayerTitanTitle_Threaded( entity player )
{
	player.EndSignal( "OnDestroy" )
	WaitEndFrame() // wait for titan transfer set titan title

	entity titanSoul = player.GetTitanSoul()
	if( !IsValid( titanSoul ) )
		return
	string soulSaveTitle = TitanReplace_GetSoulSavedTitanTitle( titanSoul )
	if( soulSaveTitle != "" )
	{
		//print( "soulSaveTitle: " + soulSaveTitle )
		if( IsAlive( player ) )
			player.SetTitle( soulSaveTitle )
	}
	//else
	//	print( "can't find titan's title!" )
}

///// settings functions!
void function TitanReplace_InitSoulSettings( entity titanSoul ) // both using for players and titanSouls
{
	if ( !( titanSoul in file.soulTitleTable ) )
		file.soulTitleTable[ titanSoul ] <- ""
	if ( !( titanSoul in file.soulPassiveTable ) )
		file.soulPassiveTable[ titanSoul ] <- -1
	if ( !( titanSoul in file.soulExecutionRefTable ) )
		file.soulExecutionRefTable[ titanSoul ] <- ""
}
///////////


///// loadout functions
void function TitanReplace_BecomeIon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_ION" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ion" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 離子 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_ION" )
			}

			// spawn as ion
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
                {
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon"])
                    GivePassive( titan, ePassives.PAS_ION_WEAPON )
                }
                else if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator", ["pas_ion_weapon_ads"])
					GivePassive( titan, ePassives.PAS_ION_WEAPON_ADS )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_particle_accelerator")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL, ["pas_ion_vortex"] )
					GivePassive( titan, ePassives.PAS_ION_VORTEX )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL)

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["pas_ion_tripwire"] )
					GivePassive( titan, ePassives.PAS_ION_TRIPWIRE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_laser_lite", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["pas_ion_lasercannon"] )
					GivePassive( titan, ePassives.PAS_ION_LASERCANNON )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
            }
			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_ion", "execution_random_0" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeTone( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_TONE" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "tone" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 強力 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#TITAN_TONE" )
			}

			// spawn as tone
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_weapon"])
					GivePassive( titan, ePassives.PAS_TONE_WEAPON )
				}
				else if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm", ["pas_tone_burst"])
					GivePassive( titan, ePassives.PAS_TONE_BURST )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sticky_40mm")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["pas_tone_wall"] )
					GivePassive( titan, ePassives.PAS_TONE_WALL )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL)

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO, ["pas_tone_sonar"] )
					GivePassive( titan, ePassives.PAS_TONE_SONAR )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE, ["pas_tone_rockets"] )
					GivePassive( titan, ePassives.PAS_TONE_ROCKETS )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_tracker_rockets", OFFHAND_ORDNANCE )
				
				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_salvo_core", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE )
            }

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_tone", "execution_random_4" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeAtlas( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#CHASSIS_ATLAS_NAME" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "atlas" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, true )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, true )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 天圖 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#CHASSIS_ATLAS_NAME" )
			}

			// spawn as atlas
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				// smoke disabled on spawn. this also replaces PAS_ANTI_RODEO with PAS_HYPER_CORE
				thread TakeTitanEarnMeterSmoke( titan ) 

				//Weapon
                entity newWeapon = titan.GiveWeapon( "mp_titanweapon_sticky_40mm", ["atlas_40mm"] )
				// pending funny mods: ["fd_tone_weapon_2_fixed", "extended_ammo_fixed", "fast_reload", "mortar_shots", "atlas_40mm", "atlas_40mm_burst", "pas_tone_burst"]
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex", "impact_drain_vortex"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_smoke", OFFHAND_ANTIRODEO, ["fast_warmup"] )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE, ["upgradeCore_Vanguard", "atlas_rockets"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_amp_core", OFFHAND_EQUIPMENT, ["damage_core"] )
			
				//Melee, dash punch
				//titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE, ["berserker", "berserker_nerfed_damage", "dash_punch"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE )
				// "big_punch_anim_berserker" is for atlas chassis animation
				titan.GiveOffhandWeapon( "melee_titan_punch_tone", OFFHAND_MELEE, ["dash_punch", "big_punch", "big_punch_anim_berserker"] )
			}

			//Executions
			// for classic execution titans, always restore to starting execution
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul )
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
			// change to atlas classic execution
			MeleeSyncedTitan_SetSoulClassicExecutionType( soul, "atlas" )

			// Weapon mod update on pickup
			UpdateTitanBigPunchAnimMod( titan )
		}
	}
}

void function TitanReplace_BecomeRonin( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_RONIN" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ronin" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
           		SendHudMessage( player, "更換至 浪人 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_RONIN" )
			}

			// spawn as ronin
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_leadwall", ["pas_ronin_weapon"])
					GivePassive( titan, ePassives.PAS_RONIN_WEAPON )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_leadwall")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				titan.GiveOffhandWeapon("mp_titanability_basic_block", OFFHAND_SPECIAL )

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_autoshift"] )
					GivePassive( titan, ePassives.PAS_RONIN_AUTOSHIFT )
				}
				else if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO, ["pas_ronin_phase"] )
					GivePassive( titan, ePassives.PAS_RONIN_PHASE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_phase_dash", OFFHAND_ANTIRODEO)
				
				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE, ["pas_ronin_arcwave"] )
					GivePassive( titan, ePassives.PAS_RONIN_ARCWAVE )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_arc_wave", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["pas_ronin_swordcore"] )
					GivePassive( titan, ePassives.PAS_RONIN_SWORDCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )
            }

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_ronin", "execution_random_3" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeNorthstar( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
            
			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_NORTHSTAR" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "northstar" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 北極星 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_NORTHSTAR" )
			}

			// spawn as northstar
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				
				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_weapon"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_WEAPON )
				}
				else if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
					newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper", ["pas_northstar_optics"])
					GivePassive( titan, ePassives.PAS_NORTHSTAR_OPTICS )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_sniper")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL, ["pas_northstar_trap"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_TRAP )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_tether_trap", OFFHAND_SPECIAL )

				//Tacticals, northstar is a bit special
				if( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO, ["pas_northstar_flightcore"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO)

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_CLUSTER )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["pas_northstar_flightcore"] )
					GivePassive( titan, ePassives.PAS_NORTHSTAR_FLIGHTCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
			}
		
            //Melee
            titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "stryder" ) // stryder titan
				{
					ChangeSoulTitanExecution( soul, "execution_northstar", "execution_random_2" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeStryder( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#CHASSIS_STRYDER_NAME" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "stryder" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, true )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, true )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 游俠 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#CHASSIS_STRYDER_NAME" )
			}

			// spawn as stryder
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				// smoke disabled on spawn. this also replaces PAS_ANTI_RODEO with PAS_HYPER_CORE
				thread TakeTitanEarnMeterSmoke( titan )

				//Weapon
                //titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream" )
				entity newWeapon = titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["stryder_xo16"] )
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				// stryder reworked: don't want to make it use rocket pods, since ronin don't have such a bodygroup
				//Defence
				//titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL, ["pas_vanguard_shield", "stryder_laser"] ) // was["energy_field", "stryder_laser"]
				titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield"] )

				//Tactical
				//titan.GiveOffhandWeapon("mp_titanability_hover", OFFHAND_ANTIRODEO )
				titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["pas_ion_tripwire", "stryder_tripwire"] )

				//Offence
				//titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )
				//titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["stryder_rockets"] )
				
				//titan.GiveOffhandWeapon( "mp_titanweapon_arc_wave", OFFHAND_ORDNANCE, ["modelset_prime", "stryder_fire_wave"] )
				// flame wall mod for fire wave
				titan.GiveOffhandWeapon( "mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["stryder_fire_wave"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["dash_core"] )
				// testing tesla core
				//titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["tesla_core"] )

				//Melee, dash punch
				//titan.GiveOffhandWeapon( "melee_titan_sword", OFFHAND_MELEE )
				//titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE, ["berserker", "berserker_nerfed_damage", "dash_punch"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
				// "big_punch_anim_punch" is for stryder and ogre chassis animation
				titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE, ["dash_punch", "big_punch", "big_punch_anim_punch"] )
			}

			//Executions
			// for classic execution titans, always restore to starting execution
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul )
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
			// change to stryder classic execution
			MeleeSyncedTitan_SetSoulClassicExecutionType( soul, "stryder" )
			
			// Weapon mod update on pickup
			UpdateTitanBigPunchAnimMod( titan )
		}
	}
}

void function TitanReplace_BecomeScorch( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_SCORCH" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "scorch" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulClassicExecutionType( soul, "ogre" )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 烈焰 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_SCORCH" )
			}

			// spawn as scorch
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_meteor", ["pas_scorch_weapon"])
					GivePassive( titan, ePassives.PAS_SCORCH_WEAPON )
				}
				else
                    newWeapon = titan.GiveWeapon ("mp_titanweapon_meteor")
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}
				
				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL, ["pas_scorch_shield"] )
					GivePassive( titan, ePassives.PAS_SCORCH_SHIELD )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL )

				//Tacticals, scorch is a bit special
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
					GivePassive( titan, ePassives.PAS_SCORCH_SELFDMG )
				titan.GiveOffhandWeapon("mp_titanability_slow_trap", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["pas_scorch_firewall"] )
					GivePassive( titan, ePassives.PAS_SCORCH_FIREWALL )
				}
				else
					titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["pas_scorch_flamecore"] )
					GivePassive( titan, ePassives.PAS_SCORCH_FLAMECORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )
            }

			// pick up scorch loadout
			if ( isPickup )
			{
				//Passives
				if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
					soul.SetPreventCrits( true )

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_scorch", "execution_random_1" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeLegion( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_LEGION" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "legion" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulClassicExecutionType( soul, "ogre" )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 軍團 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_LEGION" )
			}

			// spawn as legion
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
                if( passiveType == eTitanReplacePassiveTypes.WEAPON )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_weapon"])
					GivePassive( titan, ePassives.PAS_LEGION_WEAPON)
				}
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
				{
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon", ["pas_legion_spinup"])
					GivePassive( titan, ePassives.PAS_LEGION_SPINUP )
				}
				else
                    titan.GiveWeapon ("mp_titanweapon_predator_cannon")
				
				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL, ["pas_legion_gunshield"] )
					GivePassive( titan, ePassives.PAS_LEGION_GUNSHIELD )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_gun_shield", OFFHAND_SPECIAL )

				//Tacticals
				titan.GiveOffhandWeapon("mp_titanability_ammo_swap", OFFHAND_ANTIRODEO )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
				{
					titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE, ["pas_legion_chargeshot"] )
					GivePassive( titan, ePassives.PAS_LEGION_CHARGESHOT )
				}
				else
					titan.GiveOffhandWeapon("mp_titanability_power_shot", OFFHAND_ORDNANCE )
				
				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
				{
					titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT, ["pas_legion_smartcore"] )
					GivePassive( titan, ePassives.PAS_LEGION_SMARTCORE )
				}
				else
					titan.GiveOffhandWeapon( "mp_titancore_siege_mode", OFFHAND_EQUIPMENT )
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE )
            }
			
			//Executions
			if ( isPickup )
			{
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_legion", "execution_random_5" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeOgre( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#CHASSIS_OGRE_NAME" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "ogre" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, true )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, false )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, true )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 巨妖 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#CHASSIS_OGRE_NAME" )
			}

			// spawn as ogre
            if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				// smoke disabled on spawn. this also replaces PAS_ANTI_RODEO with PAS_HYPER_CORE
				thread TakeTitanEarnMeterSmoke( titan )

				//Weapon
                titan.GiveWeapon ("mp_titanweapon_triplethreat", ["ogre_triplethreat"])

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_heat_shield", OFFHAND_SPECIAL, ["ogre_shield"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO ) //["ogre_sonar"]

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_homing_rockets", OFFHAND_ORDNANCE, ["ogre_rockets"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT, ["shield_core"] )
				soul.SetTitanSoulNetInt( "upgradeCount", 3 )
				//SetShieldHealthWithFix( soul, 3500 )

				//Melee, dash punch
				//titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE, ["berserker", "berserker_nerfed_damage", "dash_punch"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE )
				// "big_punch_anim_punch" is for stryder and ogre chassis animation
				titan.GiveOffhandWeapon( "melee_titan_punch_legion", OFFHAND_MELEE, ["dash_punch", "big_punch", "big_punch_anim_punch"] )
			}

			//Executions
			// for classic execution titans, always restore to starting execution
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul )
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		
			// only change to ogre classic execution if we're ogre
			// atlas and stryder pov model don't have "ogpov_melee_armrip_attacker" animation
			string titanChassis = GetSoulTitanSubClass( soul )
			if ( titanChassis == "ogre" ) // ogre titan
				MeleeSyncedTitan_SetSoulClassicExecutionType( soul, "ogre" )
			else
				MeleeSyncedTitan_SetSoulClassicExecutionType( soul, titanChassis ) // reset to default

			// Weapon mod update on pickup
			UpdateTitanBigPunchAnimMod( titan )
		}
	}
}

void function TitanReplace_BecomeBison( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			// localized string "#NPC_TITAN_OGRE_FIGHTER" isn't good enough, guess we'll use hardcoded string
			TitanReplace_UpdateSoulTitanTitle( soul, "野牛" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // cannot execute bison

			TitanPick_SoulSetEnableWeaponDrop( soul, false ) // set titans won't drop weapon
			TitanPick_SoulSetEnableWeaponPick( soul, false ) // set players unable to replace weapons from ground

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 野牛 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "野牛" ) // hardcoded string!!!
			}

			// spawn as bison
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				foreach( entity weapon in titan.GetMainWeapons() )
				{
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Defence
				titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield", "molting_dome", "bison_dome"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_ability_grapple", OFFHAND_ANTIRODEO, ["bison_grapple"] )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster", "fd_twin_cluster"] )
				//titan.GiveOffhandWeapon("mp_titanweapon_flame_wall", OFFHAND_ORDNANCE, ["wrecking_ball"] )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["ground_slam"] )
				
				//Melee, primary weapon for bison
				titan.GiveOffhandWeapon( "melee_titan_punch_fighter", OFFHAND_MELEE, ["berserker", "allow_as_primary", "dash_punch", "bison_punch"] )
				titan.SetActiveWeaponByName( "melee_titan_punch_fighter" ) // needs to setup

				// version2: try to use mp_weapon_gunship_missile as a melee primary placeholder
				//titan.GiveWeapon( "mp_weapon_gunship_missile", ["titan_electric_fist_primary"] )
				//titan.GiveOffhandWeapon( "melee_titan_punch_fighter", OFFHAND_MELEE, ["berserker", "dash_punch", "bison_punch"] )
				//titan.SetActiveWeaponByName( "mp_weapon_gunship_missile" )

				// Execution
    			soul.soul.titanLoadout.titanExecution = "execution_scorch_prime" 
			}
		}
	}
}

// bison variant
void function TitanReplace_BecomeGunnerBison( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_OGRE_FIGHTER" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "bison_gunner" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // can execute gunner bison

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 野牛 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#NPC_TITAN_OGRE_FIGHTER" )
			}

			// spawn as bison
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Bison have damage reduction
				//Gunner bison shouldn't have?
				soul.SetPreventCrits( true )
				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}
				//Weapon
				entity newWeapon = titan.GiveWeapon( "mp_titanweapon_xo16_shorty", ["gunner_bison_xo16", "extended_ammo"] ) // removed "electric_rounds", it's horribles
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL, ["pas_vanguard_shield"] )

				//Tactical
				titan.GiveOffhandWeapon("mp_ability_heal", OFFHAND_ANTIRODEO, ["bc_long_stim1", "pas_power_cell"] )

				//Offence
				// can't handle sharedEnergyTotal without modifying bison_util.nut, just temp removed here
				// needs to add a weapon mod named "gunner_bison_laser", and do SetSharedEnergyTotal() in bison util checks
				// should be handled by weapon's OwnerChanged callbacks...
				// it's WIP now
				// Finished in 9/26 2023
				titan.GiveOffhandWeapon("mp_titanweapon_laser_lite", OFFHAND_ORDNANCE, ["gunner_bison_laser"] )
				//titan.GiveOffhandWeapon("mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["berserker_core"] )

				//Melee, primary weapon for bison
				titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )

				// Execution
    			soul.soul.titanLoadout.titanExecution = "execution_scorch_prime" 
			}

			// pick up bison loadout
			if ( isPickup )
			{
				//Passives
				soul.SetPreventCrits( true )

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "ogre" ) // ogre titan
				{
					ChangeSoulTitanExecution( soul, "execution_scorch_prime", "execution_random_1" )
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
		}
	}
}

void function TitanReplace_BecomeMonarch( entity titan, bool isPickup = false, bool isSpawning = false )
{
    if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
            if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#TITAN_VANGUARD" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "vanguard" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
            	SendHudMessage( player, "更換至 帝王 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
            	player.SetTitle( "#TITAN_VANGUARD" )
			}

			// spawn as monarch
			if ( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon = titan.GiveWeapon ("mp_titanweapon_xo16_vanguard")
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				
				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_SPECIAL )

				//Tactical
				titan.GiveOffhandWeapon("mp_titanability_rearm", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_upgrade", OFFHAND_EQUIPMENT )
				//soul.SetTitanSoulNetInt( "upgradeCount", 3 ) // so player can't upgrade, they can only receive shields
			
				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_vanguard", OFFHAND_MELEE )
			}

			// switch to monarch loadout
			if ( isPickup )
			{
				int upgradeCount = soul.GetTitanSoulNetInt( "upgradeCount" )
				// bodygroup
				if ( upgradeCount >= 1 ) // upgraded
				{
					int statesIndex = titan.FindBodyGroup( "states" )
					if ( statesIndex > -1 )
						titan.SetBodygroup( statesIndex, 1 )
				}

				//Passives
				// this is called earlier than Monarch_OnTitanPickupWeapon()
				// can't handle stuffs, moved into ApplyMonarchUpgrades()
				/*
				// modified upgrades handle
				entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
				bool hasModifiedUpgrades = IsValid( core ) && UpgradeCore_WeaponHasModifiedUpgrades( core )

				// maelstrom
				bool hasMaelStrom = upgradeCount >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 )
				if ( hasModifiedUpgrades )
					hasMaelStrom = UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE5 )
				// debug
				//print( "hasMaelStrom: " + string( hasMaelStrom ) )
				if ( hasMaelStrom )
				{
					entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
					if ( IsValid( smokeWeapon ) )
					{
						array<string> mods = smokeWeapon.GetMods()
						mods.append( "maelstrom" )
						smokeWeapon.SetMods( mods )
					}
				}

				// superior chassis
				bool hasSuperiorChassis = upgradeCount >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 )
				if ( hasModifiedUpgrades )
					hasSuperiorChassis = UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE8 )
				// debug
				//print( "hasSuperiorChassis: " + string( hasSuperiorChassis ) )
				if ( hasSuperiorChassis )
				{
					if ( !GetDoomedState( titan ) && IsAlive( titan ) )
					{
						array<string> settingMods = titan.GetPlayerSettingsMods()
						settingMods.append( "core_health_upgrade" )
						// update health and class
						float healthFrac = GetHealthFrac( titan )
						titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), settingMods )
						int maxHealth = titan.GetMaxHealth()
						titan.SetHealth( int( maxHealth * healthFrac ) )

						//Hacky Hack - Append core_health_upgrade to setFileMods so that we have a way to check that this upgrade is active.
						soul.soul.titanLoadout.setFileMods.append( "core_health_upgrade" )
					}
					
					// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
					soul.SetPreventCrits( true )
				}
				*/

				//Executions
				if ( GetSoulTitanSubClass( soul ) == "atlas" ) // atlas titan
				{
					ChangeSoulTitanExecution( soul, "execution_vanguard", "execution_random_6", false ) // monarch don't have _prime suffix ones
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, false )
				}
				else // other titans
				{
					soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
					//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
				}
			}
        }
	}
}

void function TitanReplace_BecomeArchon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }
			
			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_STRYDER_ARC" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "archon" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
				SendHudMessage( player, "更換至 執政官 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ARC" )
			}

			// spawn as archon
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon = titan.GiveWeapon( "mp_titanweapon_meteor", ["storm_launcher", "fd_wpn_upgrade_1"] )
				newWeapon.SetSkin( skinIndex )
				newWeapon.SetCamo( camoIndex )

				//Defence
				titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield_ion", OFFHAND_SPECIAL, ["vortex_blocker"] )
				
				// Utility
				titan.GiveOffhandWeapon("mp_titanability_sonar_pulse", OFFHAND_ANTIRODEO, ["archon_stun_impact"] )

				//Offence
				titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_laser", "energy_transfer"] ) // energy_transfer have a laser visual effect

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["tesla_core", "archon_tesla"] )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

void function TitanReplace_BecomeBrute( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_STRYDER_ROCKET" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "brute" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
				SendHudMessage( player, "更換至 野獸 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ROCKET" )
			}

			// spawn as brute
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				foreach( entity weapon in titan.GetMainWeapons() )
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				titan.GiveWeapon ( "mp_titanweapon_rocketeer_rocketstream", ["brute_rocket", "disable_run_and_gun_server"] )

				//Defence
				titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex", "impact_drain_vortex"] )
				
				// Utility
				titan.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_ANTIRODEO )

				//Offence
				titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE )

				//Titan Core
				titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

// modded titans, client install required
void function TitanReplace_BecomeModdedBrute4( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_ATLAS_ROCKETEER" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "brute4_modded" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )

			if( !isSpawning ) // got loadout switch
			{
				SendHudMessage( player, "更換至 野獸四號 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_ATLAS_ROCKETEER" )
			}

			// spawn as archon
			if( !isPickup )
			{
				//Passives
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				if( passiveType == eTitanReplacePassiveTypes.WEAPON )
					titan.GiveWeapon ("mp_titanweapon_rocketeer_rocketstream", ["brute4_quad_rocket", "straight_shot"])
				else
					titan.GiveWeapon ("mp_titanweapon_rocketeer_rocketstream", ["brute4_quad_rocket"])

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield", "molting_dome"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_mobile_dome_shield"] )

				//Tactical
				if( passiveType == eTitanReplacePassiveTypes.UTILITY )
					titan.GiveOffhandWeapon("mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO, ["brute4_cluster_payload", "explosive_reserves"] )
				else
					titan.GiveOffhandWeapon("mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO, ["brute4_cluster_payload"] )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
					titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley", "magnetic_rollers"] )
				else
					titan.GiveOffhandWeapon("mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_volley"] )

				//Titan Core
				if( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["brute4_barrage_core", "rapid_detonator"] )
				else
					titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["brute4_barrage_core"] )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

void function TitanReplace_BecomeModdedArchon( entity titan, bool isPickup = false, bool isSpawning = false )
{
	if( !titan.IsTitan() )
		return
	if (IsValid( titan )) 
	{
		entity soul = titan.GetTitanSoul()
		entity player = titan
		if( !titan.IsPlayer() )
		{
			player = GetPetTitanOwner( titan )
		}
		if (IsValid( soul ) && IsValid( player ))
		{
			if( IsTitanCoreFiring( player ) )
            {
                SendHudMessage( player, "核心啓用期間不可更換裝備", -1, 0.3, 255, 255, 0, 0, 0, 3, 0 )
                return
            }

			TitanReplace_UpdateSoulTitanTitle( soul, "#NPC_TITAN_AUTO_STRYDER_ARC" )
			TitanPick_SoulSetWeaponDropTitanCharacterName( soul, "archon_modded" )
			//TitanEmbark_SetSoulFirstPersonEmbarkEnabled( soul, false )
			PlayerEarnMeter_SetSoulEarnMeterSmokeEnabled( soul, true )
			MeleeSyncedTitan_SetSoulDoClassicExecution( soul, false )
			MeleeSyncedTitan_SetSoulCanBeExecuted( soul, true )
			
			if( !isSpawning ) // got loadout switch
			{
				SendHudMessage( player, "更換至 執政官 泰坦技能組" + GenerateTitanDamageScaleString( titan ), -1, 0.3, 255, 255, 0, 0, 0.15, 6, 0.15 )
				player.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ARC" )
			}

			// spawn as archon
			if( !isPickup )
			{
				int passiveType = TitanReplace_GetPassiveType( TitanReplace_GetSoulStartingPassive( soul ) )
				TitanReplace_RemoveUnmatchedPassivesForTitan( titan )

				//Skin & Camo
				int skinIndex
				int camoIndex
				bool foundSkin = false
				foreach( entity weapon in titan.GetMainWeapons() )
				{
					if ( !foundSkin )
					{
						skinIndex = weapon.GetSkin()
						camoIndex = weapon.GetCamo()
						foundSkin = true
					}
					titan.TakeWeaponNow( weapon.GetWeaponClassName() )
				}
				foreach( entity offhand in titan.GetOffhandWeapons() )
				{
					if ( offhand.GetWeaponClassName() != CORE_SMOKE_WEAPON )
						titan.TakeWeaponNow( offhand.GetWeaponClassName() )
				}

				//Weapon
				entity newWeapon
				if( passiveType == eTitanReplacePassiveTypes.WEAPON )
					newWeapon = titan.GiveWeapon ("mp_titanweapon_arc_cannon", ["archon_arc_cannon", "chain_reaction"])
				else if( passiveType == eTitanReplacePassiveTypes.UTILITY )
					newWeapon = titan.GiveWeapon ("mp_titanweapon_arc_cannon", ["archon_arc_cannon", "static_feedback"])
				else
					newWeapon = titan.GiveWeapon ("mp_titanweapon_arc_cannon", ["archon_arc_cannon"])
				if ( IsValid( newWeapon ) )
				{
					newWeapon.SetSkin( skinIndex )
					newWeapon.SetCamo( camoIndex )
				}

				//Defence
				if( passiveType == eTitanReplacePassiveTypes.DEFENSE )
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["archon_shock_shield", "bolt_from_the_blue"] )
				else
					titan.GiveOffhandWeapon("mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["archon_shock_shield"] )
					
				//Tactical
				//if(SoulHasPassive( soul, ePassives.PAS_ION_LASERCANNON ))
				//	titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node", "dual_nodes"] )
				//else
					titan.GiveOffhandWeapon("mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node"] )

				//Offence
				if( passiveType == eTitanReplacePassiveTypes.OFFENSE )
					titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball", "thylord_module"] )
				else
					titan.GiveOffhandWeapon("mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball"] )

				//Titan Core
				/*
				if( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["archon_storm_core", "bring_the_thunder"] )
				else
					titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["archon_storm_core"] )
				*/
				if ( passiveType == eTitanReplacePassiveTypes.CORE )
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["archon_storm_core", "bring_the_thunder"]  )
				else
					titan.GiveOffhandWeapon( "mp_titancore_laser_cannon", OFFHAND_EQUIPMENT, ["archon_storm_core"] )

				//Melee
				titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )
			}

			//Executions
			// for modded titans, always try to use callbacks
			soul.soul.titanLoadout.titanExecution = TitanReplace_GetSoulStartingExecutionRef( soul ) // restore to starting execution
			//MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // enable execution callbacks for them
		}
	}
}

///// titan pick loadout functions
void function RegisterDefaultTitanPickCharacters()
{
	RegisterIonTitanCharacter()
	RegisterToneTitanCharacter()
	RegisterMonarchTitanCharacter()
	RegisterAtlasTitanCharacter()
	RegisterRoninTitanCharacter()
	RegisterNorthstarTitanCharacter()
	RegisterStryderTitanCharacter()
	RegisterScorchTitanCharacter()
	RegisterLegionTitanCharacter()
	RegisterOgreTitanCharacter()
	RegisterGunnerBisonTitanCharacter() // bison variant
	RegisterArchonTitanCharacter()
	RegisterBruteTitanCharacter()

	RegisterModdedArchonTitanCharacter()
	RegisterModdedBrute4TitanCharacter()
}

// ion
void function RegisterIonTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_VORTEX, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_TRIPWIRE, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_WEAPON_ADS, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_ION_LASERCANNON, eTitanReplacePassiveTypes.CORE )
	
	TitanReplace_RegisterCharacterOwnedPassives( 
		"ion",							// character name
		[	// passives array
			ePassives.PAS_ION_WEAPON,
			ePassives.PAS_ION_VORTEX,
			ePassives.PAS_ION_TRIPWIRE,
			ePassives.PAS_ION_WEAPON_ADS,
			ePassives.PAS_ION_LASERCANNON,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "ion", IonWeaponWeaponPropFunc, IonWeaponDisplayNameFunc, TitanReplace_BecomeIon )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_ION_TRIPWIRE )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_VORTEX )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_LASERCANNON )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_WEAPON )
	TitanPick_AddChangablePassive( ePassives.PAS_ION_WEAPON_ADS )

	// classmods
	TitanPick_AddChangableClassMod( "fd_energy_regen" )
	TitanPick_AddChangableClassMod( "fd_energy_max" )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "ion", "atlas", 1.0 ) // atlas chassis using ion loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "ion", "stryder", 0.9 ) // stryder chassis using ion loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "ion", "ogre", 1.0 ) // ogre chassis using ion loadout: 100% damage
}

entity function IonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_particle_accelerator/w_titan_particle_accelerator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function IonWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_particle_accelerator" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "離子 技能組"
	if ( SoulHasPassive( soul, ePassives.PAS_ION_WEAPON ) || primaryMods.contains( "pas_ion_weapon" ) )
		displayName += "【纏結能量】"
	else if ( antiRodeoMods.contains( "pas_ion_tripwire" ) )
		displayName += "【零點絆線】"
	else if ( specialMods.contains( "pas_ion_vortex" ) )
		displayName += "【漩渦擴大器】"
	else if ( coreMods.contains( "pas_ion_lasercannon" ) )
		displayName += "【大型火砲】"
	else if ( primaryMods.contains( "pas_ion_weapon_ads" ) )
		displayName += "【折射鏡片】"

	return displayName
}

// tone
void function RegisterToneTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_WALL, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_SONAR, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_ROCKETS, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_TONE_BURST, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"tone",							// character name
		[	// passives array
			ePassives.PAS_TONE_WEAPON,
			ePassives.PAS_TONE_WALL,
			ePassives.PAS_TONE_SONAR,
			ePassives.PAS_TONE_ROCKETS,
			ePassives.PAS_TONE_BURST,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "tone", ToneWeaponWeaponPropFunc, ToneWeaponDisplayNameFunc, TitanReplace_BecomeTone )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_BURST )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_ROCKETS )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_SONAR )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_WALL )
	TitanPick_AddChangablePassive( ePassives.PAS_TONE_WEAPON )

	// Titan Loadout Switch
	TitanLoadoutSwitch_AddCooldownIgnoredWeaponName( "mp_titanweapon_tracker_rockets" )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "tone", "atlas", 1.0 ) // atlas chassis using tone loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "tone", "stryder", 0.9 ) // stryder chassis using tone loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "tone", "ogre", 1.05 ) // ogre chassis using tone loadout: 105% damage
}

entity function ToneWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/thr_40mm/w_thr_40mm.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ToneWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return "" // return empty will cancel the weapon drop

	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	
	string displayName = "強力 技能組"
	if ( primaryMods.contains( "pas_tone_weapon" ) )
        displayName += "【強化追蹤彈藥】"
	else if ( SoulHasPassive( soul, ePassives.PAS_TONE_WALL ) || specialMods.contains( "pas_tone_wall" ) )
		displayName += "【強化粒子障壁】"
	else if ( antiRodeoMods.contains( "pas_tone_sonar" ) )
		displayName += "【脈衝回波】"
	else if ( ordnanceMods.contains( "pas_tone_rockets" ) )
		displayName += "【脈衝回波】"
	else if ( primaryMods.contains( "pas_tone_burst" ) )
		displayName += "【連發填充器】"

	return displayName
}

// atlas
void function RegisterAtlasTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "atlas", AtlasWeaponWeaponPropFunc, AtlasWeaponDisplayNameFunc, TitanReplace_BecomeAtlas )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "atlas", "atlas", 1.0 ) // atlas chassis using atlas loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "atlas", "stryder", 0.9 ) // stryder chassis using atlas loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "atlas", "ogre", 1.0 ) // ogre chassis using atlas loadout: 100% damage
}

entity function AtlasWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return // return empty will cancel the weapon drop

	if ( !mods.contains( "atlas_40mm" ) )
		return

	asset modelName = $"models/weapons/thr_40mm/w_thr_40mm.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function AtlasWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sticky_40mm" )
		return "" // return empty will cancel the weapon drop

	if ( !mods.contains( "atlas_40mm" ) )
        return ""

	return "天圖 技能組"
}

// ronin
void function RegisterRoninTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_AUTOSHIFT, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_PHASE, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_ARCWAVE, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_RONIN_SWORDCORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"ronin",							// character name
		[	// passives array
			ePassives.PAS_RONIN_WEAPON,
			ePassives.PAS_RONIN_AUTOSHIFT,
			ePassives.PAS_RONIN_PHASE,
			ePassives.PAS_RONIN_ARCWAVE,
			ePassives.PAS_RONIN_SWORDCORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "ronin", RoninWeaponWeaponPropFunc, RoninWeaponDisplayNameFunc, TitanReplace_BecomeRonin )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "super_charged" )
	//MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "super_charged" ) // vanilla titan. init done in sh_melee_synced_titan.gnut

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_ARCWAVE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_AUTOSHIFT )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_PHASE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_SWORDCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_RONIN_WEAPON )

	// Titan Loadout Switch
	TitanLoadoutSwitch_AddCooldownIgnoredWeaponName( "mp_titanability_basic_block" )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "ronin", "atlas", 1.0 ) // atlas chassis using ronin loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "ronin", "stryder", 1.0 ) // stryder chassis using ronin loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "ronin", "ogre", 1.05 ) // ogre chassis using ronin loadout: 105% damage
}

entity function RoninWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_leadwall" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_triple_threat/w_titan_triple_threat.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function RoninWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_leadwall" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "浪人 技能組"
	if ( primaryMods.contains( "pas_ronin_weapon" ) )
		displayName += "【彈跳彈藥】"
	else if ( ordnanceMods.contains( "pas_ronin_arcwave" ) )
		displayName += "【雷暴】"
	else if ( SoulHasPassive( soul, ePassives.PAS_RONIN_AUTOSHIFT ) || antiRodeoMods.contains( "pas_ronin_autoshift" ) )
		displayName += "【瞬間反應】"
	else if ( SoulHasPassive( soul, ePassives.PAS_RONIN_SWORDCORE ) || coreMods.contains( "pas_ronin_swordcore" ) )
		displayName += "【高地戰士】"
	else if ( antiRodeoMods.contains( "pas_ronin_phase" ) )
		displayName += "【時間異常】"

	return displayName
}

// northstar
void function RegisterNorthstarTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_TRAP, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_OPTICS, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_CLUSTER, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_NORTHSTAR_FLIGHTCORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"northstar",						// character name
		[	// passives array
			ePassives.PAS_NORTHSTAR_WEAPON,
			ePassives.PAS_NORTHSTAR_TRAP,
			ePassives.PAS_NORTHSTAR_OPTICS,
			ePassives.PAS_NORTHSTAR_CLUSTER,
			ePassives.PAS_NORTHSTAR_FLIGHTCORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "northstar", NorthstarWeaponWeaponPropFunc, NorthstarWeaponDisplayNameFunc, TitanReplace_BecomeNorthstar )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_CLUSTER )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_FLIGHTCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_OPTICS )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_TRAP )
	TitanPick_AddChangablePassive( ePassives.PAS_NORTHSTAR_WEAPON )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "northstar", "atlas", 1.0 ) // atlas chassis using northstar loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "northstar", "stryder", 1.0 ) // stryder chassis using northstar loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "northstar", "ogre", 1.0 ) // ogre chassis using northstar loadout: 100% damage
}

entity function NorthstarWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_sniper" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_sniper_rifle/w_titan_sniper_rifle.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function NorthstarWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_sniper" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "北極星 技能組"
	if ( primaryMods.contains( "pas_northstar_weapon" ) )
		displayName += "【穿刺射擊】"
	else if ( ordnanceMods.contains( "pas_northstar_cluster" ) )
		displayName += "【強化負載重量】"
	else if ( specialMods.contains( "pas_northstar_trap" ) )
		displayName += "【雙重陷阱】"
	else if ( SoulHasPassive( soul, ePassives.PAS_NORTHSTAR_FLIGHTCORE ) || coreMods.contains( "pas_northstar_flightcore" ) )
		displayName += "【毒蛇推進器】"
	else if ( primaryMods.contains( "pas_northstar_optics" ) )
		displayName += "【威脅光鏡】"

	return displayName
}

// stryder
void function RegisterStryderTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "stryder", StryderWeaponWeaponPropFunc, StryderWeaponDisplayNameFunc, TitanReplace_BecomeStryder )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "stryder", "atlas", 1.0 ) // atlas chassis using stryder loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "stryder", "stryder", 1.0 ) // stryder chassis using stryder loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "stryder", "ogre", 1.0 ) // ogre chassis using stryder loadout: 100% damage
}

entity function StryderWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return // return empty will cancel the weapon drop

	if ( !mods.contains( "stryder_xo16" ) )
		return

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function StryderWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "stryder_xo16" ) )
		return ""

	return "游俠 技能組"
}

// scorch
void function RegisterScorchTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_SHIELD, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_SELFDMG, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_FIREWALL, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_SCORCH_FLAMECORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"scorch",							// character name
		[	// passives array
			ePassives.PAS_SCORCH_WEAPON,
			ePassives.PAS_SCORCH_SHIELD,
			ePassives.PAS_SCORCH_SELFDMG,
			ePassives.PAS_SCORCH_FIREWALL,
			ePassives.PAS_SCORCH_FLAMECORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "scorch", ScorchWeaponWeaponPropFunc, ScorchWeaponDisplayNameFunc, TitanReplace_BecomeScorch, SwitchOffScorchLoadout )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_FIREWALL )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_FLAMECORE )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_SELFDMG )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_SHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_SCORCH_WEAPON )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "scorch", "atlas", 0.9 ) // atlas chassis using scorch loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "scorch", "stryder", 0.8 ) // stryder chassis using scorch loadout: 80% damage
	TitanPick_AddPickedWeaponDamageScale( "scorch", "ogre", 1.0 ) // ogre chassis using scorch loadout: 100% damage
}

entity function ScorchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_meteor" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ScorchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_meteor" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "烈焰 技能組"
	if ( primaryMods.contains( "pas_scorch_weapon" ) )
		displayName += "【野火投射器】"
	else if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
		displayName += "【回火加工武裝】"
	else if ( specialMods.contains( "pas_scorch_shield" ) )
		displayName += "【煉獄護罩】"
	else if ( ordnanceMods.contains( "pas_scorch_firewall" ) )
		displayName += "【增強火力】"
	else if ( coreMods.contains( "pas_scorch_flamecore" ) )
		displayName += "【一片焦土】"

	return displayName
}

void function SwitchOffScorchLoadout( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		if ( SoulHasPassive( soul, ePassives.PAS_SCORCH_SELFDMG ) )
			soul.SetPreventCrits( false ) // clean up
	}
}

// legion
void function RegisterLegionTitanCharacter()
{
	// Titan Replace( current file )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_WEAPON, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_GUNSHIELD, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_SPINUP, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_CHARGESHOT, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_LEGION_SMARTCORE, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"legion",							// character name
		[	// passives array
			ePassives.PAS_LEGION_WEAPON,
			ePassives.PAS_LEGION_GUNSHIELD,
			ePassives.PAS_LEGION_SPINUP,
			ePassives.PAS_LEGION_CHARGESHOT,
			ePassives.PAS_LEGION_SMARTCORE,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "legion", LegionWeaponWeaponPropFunc, LegionWeaponDisplayNameFunc, TitanReplace_BecomeLegion )
	
	// invalid mods
	// smart core
	TitanPick_AddIllegalWeaponMod( "Smart_Core" )
	//MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "Smart_Core" ) // vanilla titan. init done in sh_melee_synced_titan.gnut
	// close range mode
	TitanPick_AddIllegalWeaponMod( "CloseRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_CloseRangePowerShot" )
	// long range mode
	TitanPick_AddIllegalWeaponMod( "LongRangeAmmo" )
	TitanPick_AddIllegalWeaponMod( "LongRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "pas_LongRangePowerShot" )
	TitanPick_AddIllegalWeaponMod( "power_shot_ranged_mode" ) // mp_titanability_power_shot icon
	TitanPick_AddIllegalWeaponMod( "ammo_swap_ranged_mode" ) // mp_titanability_ammo_swap icon

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_CHARGESHOT )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_GUNSHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_SMARTCORE )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_SPINUP )
	TitanPick_AddChangablePassive( ePassives.PAS_LEGION_WEAPON )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "legion", "atlas", 0.9 ) // atlas chassis using legion loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "legion", "stryder", 0.8 ) // stryder chassis using legion loadout: 80% damage
	TitanPick_AddPickedWeaponDamageScale( "legion", "ogre", 1.0 ) // ogre chassis using legion loadout: 100% damage

	// Titan Loadout Switch
	TitanLoadoutSwitch_AddCooldownIgnoredWeaponName( "mp_titanability_ammo_swap" )
}

entity function LegionWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return // return empty will cancel the weapon drop
	
	asset modelName = $"models/weapons/titan_predator/w_titan_predator.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function LegionWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_predator_cannon" )
		return "" // return empty will cancel the weapon drop
	
	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	array<string> coreMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	if ( IsValid( core ) )
		coreMods = core.GetMods()

	string displayName = "軍團 技能組"
	if ( primaryMods.contains( "pas_legion_weapon" ) )
		displayName += "【強化彈藥容量】"
	else if ( coreMods.contains( "pas_legion_smartcore" ) )
		displayName += "【感測器陣列】"
	else if ( SoulHasPassive( soul, ePassives.PAS_LEGION_GUNSHIELD ) || specialMods.contains( "pas_legion_gunshield" ) )
		displayName += "【堡壘】"
	else if ( primaryMods.contains( "pas_legion_spinup" ) )
		displayName += "【輕合金】"
	else if ( ordnanceMods.contains( "pas_legion_chargeshot" ) )
		displayName += "【隱藏部件】"

	return displayName
}

// ogre
void function RegisterOgreTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "ogre", OgreWeaponWeaponPropFunc, OgreWeaponDisplayNameFunc, TitanReplace_BecomeOgre )

	// specific weapon cooldown
	TitanLoadoutSwitch_AddWeaponNameUsesBurstFireDelayAsCooldown( "mp_titanweapon_homing_rockets" )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "ogre", "atlas", 0.9 ) // atlas chassis using ogre loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "ogre", "stryder", 0.8 ) // stryder chassis using ogre loadout: 80% damage
	TitanPick_AddPickedWeaponDamageScale( "ogre", "ogre", 1.0 ) // ogre chassis using ogre loadout: 100% damage
}

entity function OgreWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_triplethreat" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "ogre_triplethreat" ) )
		return
	
	asset modelName = $"models/weapons/titan_triple_threat_og/w_titan_triple_threat_og.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function OgreWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_triplethreat" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "ogre_triplethreat" ) )
		return ""

	return "巨妖 技能組"
	/* // unused
	if ( mods.contains( "rolling_rounds" ) )
		return "三連環榴彈【滾動彈藥】"
	if ( mods.contains( "hydraulic_launcher" ) )
		return "三連環榴彈【液壓驅動】"
	if ( mods.contains( "mine_field" ) )
		return "三連環榴彈【地雷區】"
	return "三連環榴彈"
	*/
}

// bison shouldn't drop any weapon

// bison gunner variant
void function RegisterGunnerBisonTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "bison_gunner", GunnerBisonWeaponWeaponPropFunc, GunnerBisonWeaponDisplayNameFunc, TitanReplace_BecomeGunnerBison, SwitchOffGunnerBisonLoadout )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "bison_gunner", "atlas", 0.9 ) // atlas chassis using bison loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "bison_gunner", "stryder", 0.8 ) // stryder chassis using bison loadout: 80% damage
	TitanPick_AddPickedWeaponDamageScale( "bison_gunner", "ogre", 1.0 ) // ogre chassis using bison loadout: 100% damage
}

entity function GunnerBisonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_shorty" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "gunner_bison_xo16" ) )
		return

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function GunnerBisonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_xo16_shorty" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "gunner_bison_xo16" ) )
		return ""

	return "野牛 技能組"
}

void function SwitchOffGunnerBisonLoadout( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		soul.SetPreventCrits( false ) // clean up
	}
}

// monarch, code name is "vanguard", should we use that?
void function RegisterMonarchTitanCharacter()
{
	// Titan Replace( current file )
	// monarch only have 4 kits, and they're mostly not related with monarch itself
	// guess I'll use core upgrades
	// NOTE: in general this will only take first valid upgrade

	// Arc Rounds and XO16 Accelerator count as "WEAPON"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE1, eTitanReplacePassiveTypes.WEAPON )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE9, eTitanReplacePassiveTypes.WEAPON )
	
	// Energy Transfer and Energy Field count as "DEFENSE"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE3, eTitanReplacePassiveTypes.DEFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE6, eTitanReplacePassiveTypes.DEFENSE )

	// Rapid Rearm and Superior Chassis count as "UTILITY"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE6, eTitanReplacePassiveTypes.UTILITY )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE6, eTitanReplacePassiveTypes.UTILITY )
	
	// Missile Racks and Multi-Target Missiles count as "OFFENSE"
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE2, eTitanReplacePassiveTypes.OFFENSE )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE7, eTitanReplacePassiveTypes.OFFENSE )
	
	// Maelstrom count as "CORE"( cuz they earn from core )
	TitanReplace_RegisterPassiveType( ePassives.PAS_VANGUARD_CORE5, eTitanReplacePassiveTypes.CORE )

	TitanReplace_RegisterCharacterOwnedPassives( 
		"vanguard",							// character name
		[	// passives array
			ePassives.PAS_VANGUARD_COREMETER,
			ePassives.PAS_VANGUARD_SHIELD,
			ePassives.PAS_VANGUARD_REARM,
			ePassives.PAS_VANGUARD_DOOM,
			ePassives.PAS_VANGUARD_CORE1,
			ePassives.PAS_VANGUARD_CORE2,
			ePassives.PAS_VANGUARD_CORE3,
			ePassives.PAS_VANGUARD_CORE4,
			ePassives.PAS_VANGUARD_CORE5,
			ePassives.PAS_VANGUARD_CORE6,
			ePassives.PAS_VANGUARD_CORE7,
			ePassives.PAS_VANGUARD_CORE8,
			ePassives.PAS_VANGUARD_CORE9,
		]
	)

	// Titan Pick
	TitanPick_RegisterTitanWeaponDrop( "vanguard", MonarchWeaponWeaponPropFunc, MonarchWeaponDisplayNameFunc, TitanReplace_BecomeMonarch, SwitchOffMonarchLoadout )
	TitanPick_AddCallback_OnTitanWeaponDropped( Monarch_OnTitanDropWeapon )
	TitanPick_AddCallback_OnTitanPickupWeapon( Monarch_OnTitanPickupWeapon )

	// external init func
	AddSoulInitFunc( InitMonarchTitanSoul )

	// passives
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_COREMETER )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_SHIELD )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_REARM )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_DOOM )

	// core upgrades
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE1 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE2 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE3 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE4 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE5 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE6 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE7 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE8 )
	TitanPick_AddChangablePassive( ePassives.PAS_VANGUARD_CORE9 )

	// classmods
	//TitanPick_AddChangableClassMod( "core_health_upgrade" ) // should be handled by switchoff funcs

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "vanguard", "atlas", 1.0 ) // atlas chassis using vanguard loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "vanguard", "stryder", 0.85 ) // stryder chassis using vanguard loadout: 85% damage
	TitanPick_AddPickedWeaponDamageScale( "vanguard", "ogre", 1.0 ) // ogre chassis using vanguard loadout: 100% damage
}

entity function MonarchWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()

	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return // return empty will cancel the weapon drop

	asset modelName = $"models/weapons/titan_xo16_shorty/w_xo16shorty.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function MonarchWeaponDisplayNameFunc( entity weapon )
{
	entity titan = weapon.GetWeaponOwner()
	if ( !IsValid( titan ) )
		return ""
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return ""

	string weaponName = weapon.GetWeaponClassName()
	if ( weaponName != "mp_titanweapon_xo16_vanguard" )
		return "" // return empty will cancel the weapon drop

	array<string> primaryMods = weapon.GetMods()
	entity special = titan.GetOffhandWeapon( OFFHAND_SPECIAL )
	entity ordnance = titan.GetOffhandWeapon( OFFHAND_ORDNANCE )
	entity antiRodeo = titan.GetOffhandWeapon( OFFHAND_ANTIRODEO )
	array<string> specialMods = []
	array<string> ordnanceMods = []
	array<string> antiRodeoMods = []
	if ( IsValid( special ) )
		specialMods = special.GetMods()
	if ( IsValid( ordnance ) )
		ordnanceMods = ordnance.GetMods()
	if ( IsValid( antiRodeo ) )
		antiRodeoMods = antiRodeo.GetMods()
	
	// mornach has various mods
	// passives
	string passive = ""
	if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_SHIELD ) || specialMods.contains( "pas_vanguard_shield" ) )
		passive = "防護罩放大器"
	else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) )
		passive = "能量盜取"
	else if ( antiRodeoMods.contains( "pas_vanguard_rearm" ) )
		passive = "疾速武裝"
	else if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_DOOM ) )
		passive = "適者生存"
	
	// upgrade 1
	string firstUpgrade = ""
	// upgrade 2
	string secondUpgrade = ""
	// upgrade 3
	string finalUpgrade = ""
	// effective upgrade count
	string effectiveUpgrades = ""
	
	// get modified upgrades will be too much compilicated, ignore if so
	// not a good idea to use weapon for stroing modified upgrades--- they can be easily destroyed
	//entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	//bool hasModifiedUpgrades = IsValid( core ) && UpgradeCore_WeaponHasModifiedUpgrades( core )
	bool hasModifiedUpgrades = UpgradeCore_TitanHasModifiedUpgrades( titan )
	if ( !hasModifiedUpgrades )
	{
		// upgrade 1
		if ( primaryMods.contains( "arc_rounds" ) || primaryMods.contains( "arc_rounds_with_battle_rifle" ) )
			firstUpgrade = "電弧彈藥"
		else if ( specialMods.contains( "energy_transfer" ) || specialMods.contains( "energy_field_energy_transfer" ) )
			firstUpgrade = "能量轉換"
		else if ( ordnanceMods.contains( "missile_racks" ) || ordnanceMods.contains( "upgradeCore_MissileRack_Vanguard" ) )
			firstUpgrade = "飛彈架"
		// upgrade 2
		if ( primaryMods.contains( "rapid_reload" ) )
			secondUpgrade = "快速武裝"
		else if ( specialMods.contains( "energy_field" ) || specialMods.contains( "energy_field_energy_transfer" ) )
			secondUpgrade = "能量場"
		else if ( soul.GetTitanSoulNetInt( "upgradeCount" ) >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ) )
			secondUpgrade = "漩渦"
		// upgrade 3
		if ( weapon.HasMod( "battle_rifle" ) || weapon.HasMod( "arc_rounds_with_battle_rifle" ) )
			finalUpgrade = "加速器"
		else if ( ordnance.HasMod( "upgradeCore_Vanguard" ) || ordnance.HasMod( "upgradeCore_MissileRack_Vanguard" ) )
			finalUpgrade = "多目標飛彈"
		else if ( soul.GetTitanSoulNetInt( "upgradeCount" ) >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) )
			finalUpgrade = "高級機種"
	}
	else // have modified upgrades
	{
		// display it's effective upgrade count is enough
		string upgradeStr = string( soul.GetTitanSoulNetInt( "upgradeCount" ) + 1 )
		effectiveUpgrades = "階段" + upgradeStr
	}

	string displayName = "帝王 技能組"
	if ( passive != "" || firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" || effectiveUpgrades != "" )
		displayName += "【" // start

	if ( passive != "" )
		displayName += passive
	if ( firstUpgrade != "" )
		displayName += " " + firstUpgrade // add a space
	if ( secondUpgrade != "" )
		displayName += " " + secondUpgrade // add a space
	if ( finalUpgrade != "" )
		displayName += " " + finalUpgrade // add a space
	if ( effectiveUpgrades )
		displayName += " " + effectiveUpgrades // add a space

	if ( passive != "" || firstUpgrade != "" || secondUpgrade != "" || finalUpgrade != "" || effectiveUpgrades != "" )
		displayName += "】" // end

	return displayName
}

void function SwitchOffMonarchLoadout( entity titan )
{
	// bodygroup
	int statesIndex = titan.FindBodyGroup( "states" )
	if ( statesIndex > -1 )
		titan.SetBodygroup( statesIndex, 0 )

	// maelstrom
    entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
    if ( IsValid( smokeWeapon ) ) // take off maelstrom, will be given by loadout funcs
    {
        array<string> mods = smokeWeapon.GetMods()
        mods.removebyvalue( "maelstrom" )
        smokeWeapon.SetMods( mods )
    }

    // superior chassis
    entity soul = titan.GetTitanSoul()
    if ( IsValid( soul ) )
    {
        if ( titan.IsPlayer() )
        {
            array<string> settingMods = titan.GetPlayerSettingsMods()
            if ( settingMods.contains( "core_health_upgrade" ) ) // monarch upgrade
			{
				if ( !GetDoomedState( titan ) && IsAlive( titan ) )
				{
					settingMods.removebyvalue( "core_health_upgrade" ) // remove existing classmod
					// update health and class
					float healthFrac = GetHealthFrac( titan )
					titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), settingMods )
					int maxHealth = titan.GetMaxHealth()
					titan.SetHealth( int( maxHealth * healthFrac ) )

					soul.soul.titanLoadout.setFileMods.removebyvalue( "core_health_upgrade" ) // remove from setFileMods
				}

				// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
				soul.SetPreventCrits( false ) // clean up
			}
        }
    }
}

// handling monarch upgrades
array<int> MONARCH_PASSIVES = 
[
    ePassives.PAS_VANGUARD_COREMETER,
    ePassives.PAS_VANGUARD_SHIELD,
    ePassives.PAS_VANGUARD_REARM,
    ePassives.PAS_VANGUARD_DOOM,
]

array<int> MONARCH_CORE_PASSIVES = 
[
    ePassives.PAS_VANGUARD_CORE1,
    ePassives.PAS_VANGUARD_CORE2,
    ePassives.PAS_VANGUARD_CORE3,
    ePassives.PAS_VANGUARD_CORE4,
    ePassives.PAS_VANGUARD_CORE5,
    ePassives.PAS_VANGUARD_CORE6,
    ePassives.PAS_VANGUARD_CORE7,
    ePassives.PAS_VANGUARD_CORE8,
    ePassives.PAS_VANGUARD_CORE9,
]

array<int> MONARCH_FIRST_UPGRADE_PASSIVES = 
[
    ePassives.PAS_VANGUARD_CORE1,
    ePassives.PAS_VANGUARD_CORE2,
    ePassives.PAS_VANGUARD_CORE3,
]

array<int> MONARCH_SECOND_UPGRADE_PASSIVES = 
[
    ePassives.PAS_VANGUARD_CORE4,
    ePassives.PAS_VANGUARD_CORE5,
    ePassives.PAS_VANGUARD_CORE6,
]

array<int> MONARCH_FINAL_UPGRADE_PASSIVES = 
[
    ePassives.PAS_VANGUARD_CORE7,
    ePassives.PAS_VANGUARD_CORE8,
    ePassives.PAS_VANGUARD_CORE9,
]

void function InitMonarchTitanSoul( entity soul )
{
    if ( !( soul in file.soulMonarchCorePassives ) )
    {
        file.soulMonarchCorePassives[ soul ] <- {}
        thread DelayedInitSoulMornachPassives( soul )
    }
}

void function DelayedInitSoulMornachPassives( entity soul )
{
    soul.EndSignal( "OnDestroy" )
    WaitFrame() // wait for loadout being given
    file.soulMonarchCorePassives[ soul ] = GetMonarchCorePassivesTable( soul )
}

void function Monarch_OnTitanDropWeapon( entity titan, entity weaponProp, bool droppedByPickup )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// loadout owner think
		if ( !droppedByPickup ) // dropped by titan death
		{
			file.droppedMonarchCorePassives[ weaponProp ] <- GetMonarchCorePassivesTable( titan )
		}
		else // dropped by weapon switching
		{
			file.droppedMonarchCorePassives[ weaponProp ] <- file.soulMonarchCorePassives[ soul ]
		}

		// upgrade count
		MonarchUpgrades emptyStruct
		file.droppedMonarchUpgrades[ weaponProp ] <- emptyStruct
		file.droppedMonarchUpgrades[ weaponProp ].effectiveUpgradeCount = soul.GetTitanSoulNetInt( "upgradeCount" )
		file.droppedMonarchUpgrades[ weaponProp ].totalUpgradeCount = UpgradeCore_GetTitanUpgradeCount( titan )
		file.droppedMonarchUpgrades[ weaponProp ].receivedUpgradePassives = UpgradeCore_GetTitanReceivedUpgradePassives( titan )
		file.droppedMonarchUpgrades[ weaponProp ].titanModifiedUpgrades = UpgradeCore_GetTitanModifiedUpgradesTable( titan )
		if ( soul in file.soulSavedModifiedUpgradesTable ) // we may saved our modified upgrades?
		{
			// restore it
			file.droppedMonarchUpgrades[ weaponProp ].titanModifiedUpgrades = file.soulSavedModifiedUpgradesTable[ soul ]
			delete file.soulSavedModifiedUpgradesTable[ soul ]
		}
	}
}

void function Monarch_OnTitanPickupWeapon( entity titan, entity weaponProp, entity newWeaponProp )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// get passive from dropped weapon
		table<int, bool> newMonarchCorePassives = file.droppedMonarchCorePassives[ weaponProp ]
		// transfer passives table
		file.soulMonarchCorePassives[ soul ] = newMonarchCorePassives

		// pass upgrades to new owner
		MonarchUpgrades upgradeStruct = clone file.droppedMonarchUpgrades[ weaponProp ]
		soul.SetTitanSoulNetInt( "upgradeCount", upgradeStruct.effectiveUpgradeCount )
		UpgradeCore_SetTitanUpgradeCount( titan, upgradeStruct.totalUpgradeCount )
		UpgradeCore_SetTitanReceivedUpgradePassives( titan, upgradeStruct.receivedUpgradePassives )
		UpgradeCore_SetTitanUpgradePassivesTable( titan, upgradeStruct.titanModifiedUpgrades )

		// debug
		//print( "Titan: " + string( titan ) + " picked up weapon" )
		//print( "upgradeStruct.effectiveUpgradeCount: " + string( upgradeStruct.effectiveUpgradeCount ) )
		//print( "upgradeStruct.totalUpgradeCount: " + string( upgradeStruct.totalUpgradeCount ) )
		//print( "upgradeStruct.receivedUpgradePassives: " )
		foreach ( int passive in upgradeStruct.receivedUpgradePassives )
		{
			foreach( passiveName, passveId in _PassiveFromEnum )
			{
				if ( passive == passveId )
					print( "	" + passiveName )
			}
		}
	}

	// check whether we can maintain upgrade progress on pickup
	bool canKeepUpgrading = ShouldTitanMaintainUpgradeProgressForPickUp( titan, weaponProp )
	ApplyMonarchUpgrades( titan, canKeepUpgrading )

	// if we can't keep upgrading, needs to store upgrade table and remove modified upgrades
	// restore saved upgrade table on weapon drop
	if ( !canKeepUpgrading )
	{
		if ( IsValid( soul ) )
		{
			file.soulSavedModifiedUpgradesTable[ soul ] <- UpgradeCore_GetTitanModifiedUpgradesTable( titan )
			UpgradeCore_RemoveTitanModifiedUpgrades( titan )
		}
	}
}

bool function ShouldTitanMaintainUpgradeProgressForPickUp( entity titan, entity weaponProp )
{
    bool upgradeAfterPickup = file.upgradeAllowedAfterDrop || GetCurrentPlaylistVarInt( "monarch_upgrade_after_drop", 0 ) != 0
    //print( "upgradeAfterDrop: " + string( upgradeAfterDrop ) )
    if ( upgradeAfterPickup )
        return true

    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return false
    
	// only allow original owner to upgrade!
    entity loadoutOwnerSoul = TitanPick_GetTitanLoadoutOwnerSoul( titan )
    //print( "loadoutOwnerSoul is: " + string( loadoutOwnerSoul ) )
    //print( "checking titanSoul is: " + string( soul ) )
    if ( !IsValid( loadoutOwnerSoul ) || loadoutOwnerSoul != soul )
        return false
	
    // all checks passed
    return true
}

void function ApplyMonarchUpgrades( entity titan, bool keepUpgrading = false )
{
    entity soul = titan.GetTitanSoul()
    if ( IsValid( soul ) )
    {
        // monarch upgrades
        if ( titan.IsPlayer() || IsPetTitan( titan ) )
        {
			GiveSavedMonarchPassives( titan )

			// hack check for maelstrom and superior chassis
			// needs to add back weapon mod and classmod for titan
			int upgradeCount = soul.GetTitanSoulNetInt( "upgradeCount" )
			bool hasMaelStrom = upgradeCount >= 2 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 )
			bool hasSuperiorChassis = upgradeCount >= 3 && SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 )
			
			// modified upgrades handle
			// not a good idea to use weapon for stroing modified upgrades--- they can be easily destroyed
			//entity core = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
			//bool hasModifiedUpgrades = IsValid( core ) && UpgradeCore_WeaponHasModifiedUpgrades( core )
			bool hasModifiedUpgrades = UpgradeCore_TitanHasModifiedUpgrades( titan )
			if ( hasModifiedUpgrades )
			{
				// check if we have upgraded index
				hasMaelStrom = UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE5 )
				hasSuperiorChassis = UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE8 )
			}

			// debug
			//print( "upgradeCount: " + string( upgradeCount ) )
			//print( "SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ): " +	string( SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE5 ) ) )
			//print( "SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ): " +	string( SoulHasPassive( soul, ePassives.PAS_VANGUARD_CORE8 ) ) )
			//print( "UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE5 ): " + string( UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE5 ) ) )
			//print( "UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE8 ): " + string( UpgradeCore_GetTitanReceivedUpgradePassives( titan ).contains( ePassives.PAS_VANGUARD_CORE8 ) ) )

            entity player = titan.IsPlayer() ? titan : GetPetTitanOwner( titan )
            if ( keepUpgrading ) // can keep upgrading
            {
                // upgrade core icon
                string passive4 = GetMonarchFirstUpgradeName( titan )
                string passive5 = GetMonarchSecondUpgradeName( titan )
                string passive6 = GetMonarchFinalUpgradeName( titan )
                if ( passive4 != "" )
                    player.SetPersistentVar( "activeTitanLoadout.passive4", passive4 )
                if ( passive5 != "" )
                    player.SetPersistentVar( "activeTitanLoadout.passive5", passive5 )
                if ( passive6 != "" )
                    player.SetPersistentVar( "activeTitanLoadout.passive6", passive6 )
                //print( "passive4 is: " + passive4 )
                //print( "passive5 is: " + passive5 )
                //print( "passive6 is: " + passive6 )
            }
            else // can't upgrade
            {
				TakeAllMonarchCorePassives( titan ) // take off passives after we get upgrading stuffs

				// use passive's icon instead, for notifying player that they cannot upgrade
				string replaceIcon = GetMonarchPassiveName( titan )
				player.SetPersistentVar( "activeTitanLoadout.passive4", replaceIcon )
				player.SetPersistentVar( "activeTitanLoadout.passive5", replaceIcon )
				player.SetPersistentVar( "activeTitanLoadout.passive6", replaceIcon )
            }

			// restore special core upgrades
			if ( hasMaelStrom )
			{
				if ( !hasModifiedUpgrades )
					GivePassive( soul, ePassives.PAS_VANGUARD_CORE5 )
				
				entity smokeWeapon = titan.GetOffhandWeapon( OFFHAND_INVENTORY )
				if ( IsValid( smokeWeapon ) )
				{
					array<string> mods = smokeWeapon.GetMods()
					mods.append( "maelstrom" )
					smokeWeapon.SetMods( mods )
				}
			}
			if ( hasSuperiorChassis )
			{
				if ( !hasModifiedUpgrades )
					GivePassive( soul, ePassives.PAS_VANGUARD_CORE8 )
				
				if ( !GetDoomedState( titan ) && IsAlive( titan ) )
				{
					array<string> settingMods = titan.GetPlayerSettingsMods()
					settingMods.append( "core_health_upgrade" )
					// update health and class
					float healthFrac = GetHealthFrac( titan )
					titan.SetPlayerSettingsWithMods( titan.GetPlayerSettings(), settingMods )
					int maxHealth = titan.GetMaxHealth()
					titan.SetHealth( int( maxHealth * healthFrac ) )

					//Hacky Hack - Append core_health_upgrade to setFileMods so that we have a way to check that this upgrade is active.
					soul.soul.titanLoadout.setFileMods.append( "core_health_upgrade" )
				}
				
				// here goes a problem: a monarch with superior chassis cannot update it's health bar if it switch to another final upgrade with same upgradeCount
				soul.SetPreventCrits( true )
			}
        }
    }
}

void function GiveSavedMonarchPassives( entity titan )
{
    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return

    table<int, bool> corePassives = file.soulMonarchCorePassives[ soul ]
    foreach ( int passive, bool enabled in corePassives )
    {
        //print( PassiveEnumFromBitfield( passive ) + " has been set to: " + string( enabled ) )
        // this method seems bad, it can't trigger client passive change callbacks( or maybe serverside after we adding feature )
        //soul.passives[ passive ] = enabled // apply passives
        //if ( enabled && titan.IsPlayer() )
        //    titan.GivePassive( passive )
        // reworked stuffs
        // titan passive handled by soul entity
        if ( enabled )
            GivePassive( soul, passive )
        else
            TakePassive( soul, passive )
    }
}

void function TakeAllMonarchCorePassives( entity titan )
{
    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return

    foreach ( passive, enabled in soul.passives )
    {
        expect int( passive )
        expect bool( enabled )
        if ( MONARCH_CORE_PASSIVES.contains( passive ) )
        {
            //print( PassiveEnumFromBitfield( passive ) + " has been disabled" )
            // this method seems bad, it can't trigger client passive change callbacks( or maybe serverside after we adding feature )
            //soul.passives[ passive ] = false // disable existing passive!
            //if ( titan.IsPlayer() )
            //    titan.RemovePassive( passive )
            // reworked stuffs
            TakePassive( soul, passive ) // titan passive handled by soul entity
        }
    }
}

table<int, bool> function GetMonarchCorePassivesTable( entity titan )
{
    table<int, bool> corePassives
    entity soul = IsSoul( titan ) ? titan : titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return corePassives
    
    foreach ( passive, enabled in soul.passives )
    {
        expect int( passive )
        expect bool( enabled )
        if ( MONARCH_CORE_PASSIVES.contains( passive ) )
        {
            //print( "passive: " + PassiveEnumFromBitfield( passive ) + " has been saved: " + string( enabled ) )
            corePassives[ passive ] <- enabled // add to table
        }
    }

    return corePassives
}

string function GetMonarchPassiveName( entity titan )
{
    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return "pas_bubbleshield" // have to return a value

    foreach ( int passive in MONARCH_PASSIVES )
    {
        if ( SoulHasPassive( soul, passive ) )
            return PassiveEnumFromBitfield( passive )
    }
    return "pas_bubbleshield" // have to return a value
}

string function GetMonarchFirstUpgradeName( entity titan )
{
    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return ""

    foreach ( int passive in MONARCH_FIRST_UPGRADE_PASSIVES )
    {
        if ( SoulHasPassive( soul, passive ) )
            return PassiveEnumFromBitfield( passive )
    }

    return ""
}

string function GetMonarchSecondUpgradeName( entity titan )
{
    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return ""

    foreach ( int passive in MONARCH_SECOND_UPGRADE_PASSIVES )
    {
        if ( SoulHasPassive( soul, passive ) )
            return PassiveEnumFromBitfield( passive )
    }

    return ""
}

string function GetMonarchFinalUpgradeName( entity titan )
{
    entity soul = titan.GetTitanSoul()
    if ( !IsValid( soul ) )
        return ""

    foreach ( int passive in MONARCH_FINAL_UPGRADE_PASSIVES )
    {
        if ( SoulHasPassive( soul, passive ) )
            return PassiveEnumFromBitfield( passive )
    }

    return ""
}

// archon
void function RegisterArchonTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "archon", ArchonWeaponWeaponPropFunc, ArchonWeaponDisplayNameFunc, TitanReplace_BecomeArchon )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "tesla_core_charged" )
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "tesla_core_charged" )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "archon", "atlas", 1.0 ) // atlas chassis using archon loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "archon", "stryder", 0.9 ) // stryder chassis using archon loadout: 90% damage
	TitanPick_AddPickedWeaponDamageScale( "archon", "ogre", 1.05 ) // ogre chassis using archon loadout: 105% damage
}

entity function ArchonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_meteor" )
		return // return empty will cancel the weapon drop

	if ( !mods.contains( "storm_launcher" ) )
		return 

	asset modelName = $"models/weapons/titan_thermite_launcher/w_titan_thermite_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )
	PlayFXOnEntity( $"wpn_arc_cannon_electricity", weaponProp, "muzzle_flash" ) // do a visual effect on weapon

	return weaponProp
}

string function ArchonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_meteor" )
		return "" // return empty will cancel the weapon drop

	if ( !mods.contains( "storm_launcher" ) )
		return ""

	return "執政官 技能組"
}

// brute
void function RegisterBruteTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "brute", BruteWeaponWeaponPropFunc, BruteWeaponDisplayNameFunc, TitanReplace_BecomeBrute )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "brute", "atlas", 1.0 ) // atlas chassis using brute loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "brute", "stryder", 1.0 ) // stryder chassis using brute loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "brute", "ogre", 1.1 ) // ogre chassis using brute loadout: 110% damage
}

entity function BruteWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute_rocket" ) )
		return

	asset modelName = $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function BruteWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute_rocket" ) )
		return ""

	return "野獸 技能組"
}

// brute4(modded)
void function RegisterModdedBrute4TitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "brute4_modded", ModdedBrute4WeaponWeaponPropFunc, ModdedBrute4WeaponDisplayNameFunc, TitanReplace_BecomeModdedBrute4 )
	
	// invalid mods
	TitanPick_AddIllegalWeaponMod( "brute4_cluster_payload_ammo" )
	MeleeSyncedTitan_AddModToRemoveOnLoadoutReplace( "brute4_cluster_payload_ammo" ) 

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "brute4_modded", "atlas", 1.0 ) // atlas chassis using brute4 loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "brute4_modded", "stryder", 1.0 ) // stryder chassis using brute4 loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "brute4_modded", "ogre", 1.05 ) // ogre chassis using brute4 loadout: 105% damage
}

entity function ModdedBrute4WeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute4_quad_rocket" ) )
		return

	asset modelName = $"models/weapons/titan_rocket_launcher/titan_rocket_launcher.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )

	return weaponProp
}

string function ModdedBrute4WeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_rocketeer_rocketstream" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "brute4_quad_rocket" ) )
		return ""

	return "野獸四號 技能組"
	/* // unused
	if( mods.contains( "straight_shot" ) )
		return "四段火箭(野獸四號) [直射系統]"
	if( mods.contains( "rapid_detonator" ) )
		return "四段火箭(野獸四號) [快速引爆]"
	return "四段火箭(野獸四號)"
	*/
}

// archon(modded)
void function RegisterModdedArchonTitanCharacter()
{
	TitanPick_RegisterTitanWeaponDrop( "archon_modded", ModdedArchonWeaponWeaponPropFunc, ModdedArchonWeaponDisplayNameFunc, TitanReplace_BecomeModdedArchon )

	// damage balancing
	TitanPick_AddPickedWeaponDamageScale( "archon_modded", "atlas", 1.0 ) // atlas chassis using archon loadout: 100% damage
	TitanPick_AddPickedWeaponDamageScale( "archon_modded", "stryder", 0.85 ) // stryder chassis using archon loadout: 85% damage
	TitanPick_AddPickedWeaponDamageScale( "archon_modded", "ogre", 1.0 ) // ogre chassis using archon loadout: 100% damage
}

entity function ModdedArchonWeaponWeaponPropFunc( entity weapon, vector origin, vector angles )
{
	string weaponName = weapon.GetWeaponClassName()
	array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sniper" )
		return // return empty will cancel the weapon drop
	
	if ( !mods.contains( "archon_arc_cannon" ) )
		return

	asset modelName = $"models/weapons/titan_arc_rifle/w_titan_arc_rifle.mdl"
	entity weaponProp = CreatePropDynamic( modelName, origin, angles, SOLID_VPHYSICS )
	PlayFXOnEntity( $"wpn_arc_cannon_electricity", weaponProp, "muzzle_flash" ) // do a visual effect on weapon

	return weaponProp
}

string function ModdedArchonWeaponDisplayNameFunc( entity weapon )
{
	string weaponName = weapon.GetWeaponClassName()
    array<string> mods = weapon.GetMods()

	if ( weaponName != "mp_titanweapon_sniper" )
		return "" // return empty will cancel the weapon drop
	
	if ( !mods.contains( "archon_arc_cannon" ) )
		return ""

	return "執政官 技能組"
	/* // unused
	if ( mods.contains( "capacitor" ) )
		return "電弧機炮 [電容器]"
	if ( mods.contains( "chain_reaction" ) )
		return "電弧機炮 [連鎖反應]"
	if ( mods.contains( "generator_mod" ) )
		return "電弧機炮 [發電裝置]"
	return "電弧機炮"
	*/
}


///// utilities
void function TakeTitanEarnMeterSmoke( entity titan )
{
	titan.EndSignal( "OnDestroy" )

	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	
	// change PAS_ANTI_RODEO to PAS_HYPER_CORE
	if ( SoulHasPassive( soul, ePassives.PAS_ANTI_RODEO ) )
	{
		TakePassive( soul, ePassives.PAS_ANTI_RODEO )
		GivePassive( soul, ePassives.PAS_HYPER_CORE )
		if ( TitanDamageRewardsTitanCoreTime() )
			SoulTitanCore_SetNextAvailableTime( soul, 0.20 )
	}

	WaitEndFrame() // wait for titan get smoke weapon

	titan.TakeOffhandWeapon( OFFHAND_INVENTORY )
}

void function UpdateTitanBigPunchAnimMod( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		entity meleeWeapon = titan.GetOffhandWeapon( OFFHAND_MELEE )
		if ( IsValid( meleeWeapon ) && meleeWeapon.HasMod( "big_punch" ) )
		{
			string modToRemove = ""
			string modToAdd = ""

			bool titanIsAtlas = GetSoulTitanSubClass( soul ) == "atlas"
			// change animation mod to punch if it is not atlas who picked them up
			if ( !titanIsAtlas && meleeWeapon.HasMod( "big_punch_anim_berserker" ) )
			{
				modToRemove = "big_punch_anim_berserker"
				modToAdd = "big_punch_anim_punch"
			}
			// atlas pickup but animation mod is punch, change to berserker
			else if ( titanIsAtlas && meleeWeapon.HasMod( "big_punch_anim_punch" ) )
			{
				modToRemove = "big_punch_anim_punch"
				modToAdd = "big_punch_anim_berserker"
			}

			if ( modToRemove != "" && modToAdd != "" )
			{
				array<string> mods = meleeWeapon.GetMods()
				mods.fastremovebyvalue( modToRemove )
				mods.append( modToAdd )
				//print( "modToAdd: " + modToAdd )
				meleeWeapon.SetMods( mods )
			}
		}
	}
}

string function GenerateTitanDamageScaleString( entity titan )
{
	float damageScale = TitanPick_GetTitanDamageScale( titan )
	if ( damageScale == 1.0 ) // no damage modifier
		return ""

	string generatedStr = "\n當前機體傷害倍率：" + string( int( damageScale * 100 + 0.001 ) ) + "%"
	return generatedStr
}

void function TitanReplace_RegisterPassiveType( int passive, int passiveType )
{
	if ( !( passive in file.titanPassiveType ) )
		file.titanPassiveType[ passive ] <- passiveType
	else
	{
		print( "[TITAN REPLACE] Passive index " + string( passive ) + " Has already been registered" )
	}
}

void function TitanReplace_RegisterCharacterOwnedPassives( string characterName, array<int> passives )
{
	if ( !( characterName in file.titanCharacterOwnedPassives ) )
		file.titanCharacterOwnedPassives[ characterName ] <- passives
	else
	{
		print( "[TITAN REPLACE] Titan characer " + characterName + " already have owned passives registered" )
	}
}

// change to settings, no longer hardcoded
int function TitanReplace_GetPassiveType( int passive )
{
	if ( !( passive in file.titanPassiveType ) )
		return -1 // invalid!

	return file.titanPassiveType[ passive ]
}

void function TitanReplace_RemoveUnmatchedPassivesForTitan( entity titan )
{
    if( !titan.IsTitan() )
		return

	string charaName = TitanPick_GetTitanWeaponDropCharacterName( titan )
	// for npcs, we take passives from their soul
	if ( !titan.IsPlayer() )
	{
		titan = titan.GetTitanSoul()
		if ( !IsValid( titan ) )
			return
	}

	foreach ( name, passives in file.titanCharacterOwnedPassives )
	{
		if ( charaName != name )
		{
			foreach ( passive in passives )
			{
				// debug
				/*
				string passiveName
				foreach ( name, index in _PassiveFromEnum )
				{
					if ( index == passive )
						passiveName = name
				}
				print( "REMOVING passive: " + passiveName )
				*/
				TakePassive( titan, passive )
			}
		}
	}
}

void function ChangeSoulTitanExecution( entity soul, string desiredRef, string desiredRandomRef, bool checkPrime = true )
{
	TitanLoadoutDef loadout = soul.soul.titanLoadout
	
	string curRef = loadout.titanExecution
	bool isRandom = curRef.find( "random" ) != null //
	//print( "isRandom: " + string ( isRandom ) )
	if ( isRandom )
	{
		//print( "soul has random execution, try changing to new one: " + desiredRandomRef )
		soul.soul.titanLoadout.titanExecution = desiredRandomRef
		return
	}

	// non-random checks
	string primeSuffix = ""
	if ( checkPrime && loadout.isPrime == "titan_is_prime" )
		primeSuffix = "_prime"
	string newRef = desiredRef + primeSuffix
	//print( "try changing to execution: " + newRef )
	soul.soul.titanLoadout.titanExecution = newRef
}