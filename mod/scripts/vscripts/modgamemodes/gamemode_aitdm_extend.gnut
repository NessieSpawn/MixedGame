// basically a copy of gruntmode. with only npcs spawns, players are still pilots

untyped
global function Modded_Gamemode_AITdm_Extended_Init

// npc counts default value
// can be modified by playlistvar
const int SQUADS_PER_TEAM = 5
//const int SQUADS_PER_TEAM_MORE_PLAYERS = 3 // maybe do reduced squad if we have more players and reached higher level
const int SQUADS_PER_TEAM_HIGH_LEVEL = 3 // maybe do reduced squad if we have reached higher level

const int MARVINS_PER_TEAM = 0
const int PROWLERS_PER_TEAM = 3 // was 4
const int PROWLER_SQUADS_PER_TEAM = 0 // prowler squad: 2 cqb prowler with 3 small prowlers

const int REAPERS_PER_TEAM = 3 // was 3, reduced reaper spawn since we're using tick spawner reapers
const int GUNSHIPS_PER_TEAM = 0 // was 2, removed and left for settings to enable manually

const int PILOTS_PER_TEAM = 4
const int TITANS_PER_TEAM = 0

// escalator default value
// can be modified by playlistvar
const int LEVEL_SPECTRES = 150
const int LEVEL_STALKERS = 380 // 230 for scorelimit 650
const int LEVEL_REAPERS = 600 // 350 for scorelimit 650
//const int LEVEL_GUNSHIPS = 280 // has been merged to reaper spawns
const int LEVEL_TITANS = 0

// RNG default value
// can be modified by playlistvar
const float RARE_SPECIALIST_GRUNT_PICK_CHANCE = 0.30 // 30% chance of spawning a rare specialist grunt
const float BOSS_TITAN_REPLACE_CHANCE = 0.20 // was 0.30. scale down because boss titans are more powerful now

// scores
const int PLAYER_SCORE_AMOUNT = 5
const int PILOT_SCORE_AMOUNT = 5
const int GUNSHIP_SCORE_AMOUNT = 5
const int MARVIN_SCORE_AMOUNT = 1
const int GRUNT_SCORE_AMOUNT = 1
const int SPECIALIST_GRUNT_SCORE_AMOUNT = 2
const int SPECTRE_SCORE_AMOUNT = 1 // was 2. spectres shouldn't have too many score
const int STALKER_SCORE_AMOUNT = 2
const int PROWLER_SCORE_AMOUNT = 2
const int SMALL_PROWLER_SCORE_AMOUNT = 1
const int REAPER_SCORE_AMOUNT = 5
const int DRONE_SCORE_AMOUNT = 0
const int TITAN_SCORE_AMOUNT = 10

// APRIL FOOLS SPECIAL scores
const int HUMAN_TITAN_WEAPON_SCORE_MULTIPLYER = 2 // humansized unit with titan weapons awarding more score

// fake coop
// npc spawn
const float FAKE_COOP_PLAYER_TEAM_NPC_PERCENT = 0.7 // 3-2 squads, 2 prowlers, 1 reaper and gunship, 2 titans
const float FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MIN = 1.0
const float FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_INCREMENT = 0.5 // 4 players = max spawn
const float FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MAX = 2.5 // 12-7 squads, 10 prowlers, 5 reapers and gunships, 7 titans
// scoring
const float FAKE_COOP_PLAYER_PILOT_SCORE_MULTIPLIER = 2.0 // gets applied on npc killing player team pilot
const float FAKE_COOP_PLAYER_TITAN_SCORE_MULTIPLIER = 3.0 // gets applied on npc killing player team titan

// struct used by function Escalate()
struct AITdmEscalatorstruct
{
	int scoreRequired
	void functionref( int team ) spawnSettingsFunc
	array<int> usedByTeams
}

struct
{
	// Due to team based escalation everything is an array

	// reworked to use structs
	//array< int > levels = [] //[ LEVEL_SPECTRES, LEVEL_SPECTRES ] // modified, since we added playlistvar should leave this init inside functions
	array<AITdmEscalatorstruct> levelEscalators

	// spawn contents
	array< array< string > > podEntities = [ [ "npc_soldier" ], [ "npc_soldier" ] ] // also handling spectres and stalkers
	
	array< bool > marvins = [ false, false ] // bind with spectres

	array< bool > prowlers = [ false, false ] // bind with stalkers

	array< bool > reapers = [ false, false ]
	array< bool > gunships = [ false, false ] // bind with reapers

	array< bool > titans = [ false, false ]
	array< bool > pilots = [ false, false ] // bind with titans


	// spawn settings
	int squadCount
	int squadCountHighLevel
	int prowlerCount
	int reaperCount
	int gunshipCount
	int pilotCount
	// escalator settings
	int levelSpectres
	int levelStalkers
	int levelReapers
	int levelTitans

	// fake coop
	// npc spawn
	float friendlyNPCPercent
	float enemyNPCMinPercent
	float enemyNPCIncrementPerPlayer
	float enemyNPCMaxPercent
	// scoring
	float teamPilotScoreMultiplier
	float teamTitanScoreMultiplier

	// in-file variables
	// for cleaning up idle npcs
	table<entity, bool> npcWaitingToBeCleanUp
	table<entity, float> npcCleanUpStartTime
	table<entity, float> npcIdleStartTime
	table<entity, vector> npcLastTickOrigin

	// APRIL FOOLS SPECIAL variables
	array<entity> weaponSafePlayers // players with mod installed should be safe to use our modded weapons, but we need to disable replay if not all of players have mod installed
	table<entity, bool> playerUsingDangerousWeapon // if player using a weapon that may crash other clients, we disable replay for them
	array<string> squadsAssignedTitanWeapon // for chaos mode. each squad's first npc has chance to get a titan weapon
	array<entity> npcsUsingTitanWeapon
} file


void function Modded_Gamemode_AITdm_Extended_Init()
{
	// this is incorrect. gamemode_tdm spawns are for AITdm
	//SetSpawnpointGamemodeOverride( ATTRITION ) // use bounty hunt spawns as vanilla game has no spawns explicitly defined for aitdm
	SetSpawnpointGamemodeOverride( TEAM_DEATHMATCH )

	AddCallback_GameStateEnter( eGameState.Prematch, OnPrematchStart )
	AddCallback_GameStateEnter( eGameState.Playing, OnPlaying )

	// scoring
	SetUpAITdmExtendedScoreEvent() // score setup
	AddCallback_OnPlayerKilled( HandleScoreForPlayerOrNPCKill )
	AddCallback_OnNPCKilled( HandleScoreForPlayerOrNPCKill )
	// modified callback in _score.nut: for handling doomed health loss titans
	AddCallback_TitanDoomedScoreEvent( HandleTitanDoomedScore )

	AddCallback_OnClientConnected( OnPlayerConnected )

	AddCallback_NPCLeeched( AITdmExtend_OnNPCLeeched )

    // game settings
	Highlight_SetCustomHighlightFunction( AITdmExtend_Highlight ) // highlight handle for phase shift and such
    // npc executions
	MeleeSyncedNPC_EnableAll_Init() // npc executions for fun

    // ai configs
	AddSpawnCallback( "npc_soldier", GruntConfig )
	AddSpawnCallback( "npc_pilot_elite", PilotConfig )
	AddSpawnCallback( "npc_marvin", MarvinConfig )
	AddSpawnCallback( "npc_prowler", ProwlerConfig )
	AddSpawnCallback( "npc_spectre", SpectreConfig )
	AddSpawnCallback( "npc_stalker", StalkerConfig )
	AddSpawnCallback( "npc_super_spectre", ReaperConfig )
	AddSpawnCallback( "npc_titan", TitanConfig )
	AddSpawnCallback( "npc_drone", DroneConfig )
	AddSpawnCallback( "npc_gunship", GunshipConfig )
	AddSpawnCallback( "npc_dropship", DropshipConfig )
	AddSpawnCallback( "npc_frag_drone", TickConfig )
	AddCallback_OnReaperLaunchedFragDroneSpawned( OnLaunchedFragDroneSpawned ) // this callback is from modified _ai_superspectre.nut
	AddSpawnCallback( "npc_turret_sentry", TurretConfig )

	// ai damages
	DamageUtility_EnableNPCLocationBasedDamage( true ) // modified function in sh_damage_utility.gnut. allow npcs to deal headshot damages
	SmartPistol_DisableOneShotInfantry( true ) // modified function in sh_smart_ammo.gnut. make smart pistol no longer one-shot kill any infantry classes

	// tempfix specifics
	SetShouldPlayDefaultMusic( true ) // play music when score or time reaches some point
	EarnMeterMP_SetPassiveGainProgessEnable( true ) // enable earnmeter gain progressing like vanilla

	// init npc spawn settings
	InitModdedSpawnSettings()

	// APRIL FOOLS SPECIAL loadout: no optics, fake nessy weapon
	// basically no R-101 due to scope issue, no Kraber, LStar and DMR due to client-side crashes, no Alternator due to desync...
	// maybe we could release client-side version of this mod and disable killreplay to make players able to use them
	AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerChangeLoadout )

	// APRIL FOOLS SPECIAL settings
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// random player model
		AltPilot_SetPlayerModelAllRandom( true )
		AltPilot_SetShouldReplacePlayerSettings( true )
		SetPlayerBodyTypeDependOnSurfaceProp( true ) // fix gib effects

		// model stuffs
		Nessie_AutoSpawnCostumeForPlayers( true ) // allow player costume
		//NessyAprilFools_ChangeNPCHumanGrenadesToNessy( true ) // npc grenades model update
		NessyAprilFools_ChangeAllNPCProjectilesToNessy( true )

		SetWeaponDropsEnabled( false ) // don't let players pick up kraber stuffs
	
		// temp for us get client-side that have kraber mod installed
		AddCallback_OnClientSideWithMixedGameInstalledConnected( OnModdedPlayerConnected )
		AddCallback_OnClientDisconnected( OnPlayerDisconnected )

		// ANTI-CRASH for client-side: don't do replay for player without mod installed if we have at least one other player installed the mod
		AddCallback_ShouldDoReplay( AprilFoolsShouldDoReplay )

		// CHAOTIC needs more health( player can still easily get oneshot though )
		HealthRegen_SetCustomRegenDelay( 3.0, 1.5, 1.2 ) // *0.6 regen delay 
		HealthRegen_SetCustomRegenRate( 8.0, 16.0 ) // 2x regen rate
	}
}

// ANTI-CRASH
bool function AprilFoolsShouldDoReplay( entity player, entity attacker, float replayTime, int methodOfDeath )
{
	// don't do replay for player without mod installed if we have at least one other player installed the mod
	ArrayRemoveInvalid( file.weaponSafePlayers )
	if ( file.weaponSafePlayers.len() != GetPlayerArray().len() ) // replay should be safe if all players installed the mod
	{
		if ( file.weaponSafePlayers.len() > 0 && IsValid( attacker ) && attacker.IsPlayer() )
			return false
	}

	// default returning true to let other callbacks go through
	return true
}

void function OnModdedPlayerConnected( entity player, string modType )
{
	if ( modType != "FULL" && modType != "AITDM_NESSY" ) // checking FULL mod or AITDM_NESSY
		return
	
	if ( !file.weaponSafePlayers.contains( player ) )
		file.weaponSafePlayers.append( player )
}

void function OnPlayerDisconnected( entity player )
{
	ArrayRemoveInvalid( file.weaponSafePlayers )
	file.weaponSafePlayers.removebyvalue( player )
}

// APRIL FOOLS SPECIAL loadout: no optics, fake nessy weapon
const array<string> WEAPON_MODS_TO_REMOVE = 
[
	"hcog",
	"holosight",
	"redline_sight",
	"threat_scope",
	"scope_4x",
	"pro_screen",
]
// basically no R-101 due to scope issue, no Kraber, LStar and DMR due to client-side crashes, no Alternator due to desync...
// DMR is replaced with G2 while Kraber is replaced with Doubletake
// maybe we could release client-side version of this mod and disable killreplay to make players able to use them
const table<string, string> WEAPON_REPLACEMENTS =
{
	["mp_weapon_rspn101_og"]		= "mp_weapon_rspn101",
	["mp_weapon_sniper"] 			= "mp_weapon_doubletake",
	["mp_weapon_dmr"]				= "mp_weapon_g2",
	["mp_weapon_alternator_smg"]	= "mp_weapon_hemlok_smg",
	["mp_weapon_lstar"]				= "mp_weapon_esaw",
}
// list of all valid replacement weapon mods
const array<string> ALL_VALID_MODS =
[
	"extended_ammo", // kraber and segmented reload weapons won't work fine with this... idk how to handle, shall we hardcode them?
	"pas_fast_reload",
	"pas_fast_swap",
	"pas_fast_ads",
	"tactical_cdr_on_kill",
	"pas_run_and_gun", // sniper rifles can't use this, so never replace other weapons with sniper
]
void function OnPlayerChangeLoadout( entity player, PilotLoadoutDef p )
{
	// APRIL FOOLS SPECIAL loadout: no optics, fake nessy weapon
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// remove pilot skin
		player.SetSkin( 0 )
		player.SetCamo( 0 )

		// NOT WORKING FINE
		//player.GiveExtraWeaponMod( "fake_nessy_weapon" )

		foreach ( entity weapon in player.GetMainWeapons() )
		{
			// BAD WEAPON handle
			if ( !file.weaponSafePlayers.contains( player ) )
			{
				string weaponName = weapon.GetWeaponClassName()
				if ( weaponName in WEAPON_REPLACEMENTS )
				{
					array<string> validMods
					array<string> mods = weapon.GetMods()
					foreach ( string mod in mods )
					{
						if ( ALL_VALID_MODS.contains( mod ) )
							validMods.append( mod )
					}
					weapon.Destroy() // to take away weapon at specific slot
					weapon = player.GiveWeapon( WEAPON_REPLACEMENTS[weaponName], validMods )
				}
			}
			else // player with mod installed
			{
				// HARDCODED for mozambique
				if ( weapon.GetWeaponClassName() == "mp_weapon_shotgun_pistol" )
				{
					// become nessy launcher
					weapon.Destroy()
					weapon = player.GiveWeapon( "mp_weapon_shotgun_pistol", ["apex_nessie", "nessie_doll_launcher", "rgb_nessie", "pas_run_and_gun"] )
				}
			}

			array<string> weaponMods = weapon.GetMods()
			foreach ( string mod in weaponMods )
			{
				if ( WEAPON_MODS_TO_REMOVE.contains( mod ) )
					weapon.RemoveMod( mod )
			}

			// HARDCODED for kraber
			if ( weapon.GetWeaponClassName() == "mp_weapon_sniper" )
				weapon.RemoveMod( "extended_ammo" ) // kraber with "fake_nessy_weapon" only have 1 ammo clip

			// seems we'll have to use SetMod() to change weapon model
			weapon = GiveNessyProjectileMod( player, weapon ) // this actually destroyes org weapon
			// wants to update fp bodygroup, so optics won't show
			// GiveNessyProjectileMod() now re-gives weapon, already handled that case
			/*
			HolsterWeapons( player )
			DeployWeapons( player )
			*/

			// update weapon clip size after mod change... though GiveExtraWeaponMod() should already handled it
			try { weapon.SetWeaponPrimaryClipCount( weapon.GetWeaponPrimaryClipCountMax() ) } // anti-crash for charge weapons
			catch(ex1) {}
		}

		foreach ( entity weapon in player.GetOffhandWeapons() )
			GiveNessyProjectileMod( player, weapon )
	}
}

void function InitModdedSpawnSettings()
{
	// update settings from playlistvar, with default values implemented
	file.squadCount = GetCurrentPlaylistVarInt( "modaitdm_squad_count", SQUADS_PER_TEAM )
	file.squadCountHighLevel = GetCurrentPlaylistVarInt( "modaitdm_squad_count", SQUADS_PER_TEAM_HIGH_LEVEL )
	file.prowlerCount = GetCurrentPlaylistVarInt( "modaitdm_prowler_count", PROWLERS_PER_TEAM )
	file.reaperCount = GetCurrentPlaylistVarInt( "modaitdm_reaper_count", REAPERS_PER_TEAM )
	file.gunshipCount = GetCurrentPlaylistVarInt( "modaitdm_gunship_count", GUNSHIPS_PER_TEAM )
	file.pilotCount = GetCurrentPlaylistVarInt( "modaitdm_pilot_count", PILOTS_PER_TEAM )

	file.levelSpectres = GetCurrentPlaylistVarInt( "modaitdm_spectre_spawn_score", LEVEL_SPECTRES )
	file.levelStalkers = GetCurrentPlaylistVarInt( "modaitdm_stalker_spawn_score", LEVEL_STALKERS )
	file.levelReapers = GetCurrentPlaylistVarInt( "modaitdm_reaper_spawn_score", LEVEL_REAPERS )
	file.levelTitans = GetCurrentPlaylistVarInt( "modaitdm_titan_spawn_score", LEVEL_TITANS )
	// reworked to use Escalator_Init()
	//file.levels = [ file.levelSpectres, file.levelSpectres ] // init levels

	// fake coop
	// everything is based on GetPlayerArray()[0]( listen server host, or the first joined player )
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1 )
	{
		// npc spawn
		file.friendlyNPCPercent = GetCurrentPlaylistVarFloat( "aitdm_coop_friendly_npc_percent", FAKE_COOP_PLAYER_TEAM_NPC_PERCENT )
		file.enemyNPCMinPercent = GetCurrentPlaylistVarFloat( "aitdm_coop_enemy_npc_min_percent", FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MIN )
		file.enemyNPCIncrementPerPlayer = GetCurrentPlaylistVarFloat( "aitdm_coop_enemy_npc_increment_per_player", FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_INCREMENT )
		file.enemyNPCMaxPercent = GetCurrentPlaylistVarFloat( "aitdm_coop_enemy_npc_max_percent", FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MAX )

		// scoring
		file.teamPilotScoreMultiplier = GetCurrentPlaylistVarFloat( "aitdm_coop_pilot_score_multiplier", FAKE_COOP_PLAYER_PILOT_SCORE_MULTIPLIER )
		file.teamTitanScoreMultiplier = GetCurrentPlaylistVarFloat( "aitdm_coop_titan_score_multiplier", FAKE_COOP_PLAYER_TITAN_SCORE_MULTIPLIER )

		// start updating all player's team
		UpdateCOOPPlayerTeam()
	}

	// all values init done, start init escatator
	Escalator_Init()
}

// init the structs used in function Escalate()
void function Escalator_Init()
{
	// spectres and marvins
	AITdmEscalatorstruct spectreSpawn
	spectreSpawn.scoreRequired = file.levelSpectres
	spectreSpawn.spawnSettingsFunc = SpawnLevel_Spectre
	file.levelEscalators.append( spectreSpawn )

	// stalkers and prowlers
	AITdmEscalatorstruct stalkerSpawn
	stalkerSpawn.scoreRequired = file.levelStalkers
	stalkerSpawn.spawnSettingsFunc = SpawnLevel_Stalker
	file.levelEscalators.append( stalkerSpawn )

	// reapers and gunships
	AITdmEscalatorstruct reaperSpawn
	reaperSpawn.scoreRequired = file.levelReapers
	reaperSpawn.spawnSettingsFunc = SpawnLevel_Reaper
	file.levelEscalators.append( reaperSpawn )

	// titans and pilots
	AITdmEscalatorstruct titanSpawn
	titanSpawn.scoreRequired = file.levelTitans
	titanSpawn.spawnSettingsFunc = SpawnLevel_Titan
	file.levelEscalators.append( titanSpawn )
}

void function SpawnLevel_Spectre( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	file.podEntities[ index ].append( "npc_spectre" ) // add spectres into droppod and dropship
	file.marvins[ index ] = true // enable marvin spawn
	SetGlobalNetInt( defcon, 2 ) // Enemy Spectres Incoming
}

void function SpawnLevel_Stalker( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	//file.marvins[ index ] = false // never remove marvin spawns ;)
	file.podEntities[ index ].append( "npc_stalker" ) // add stalkers into droppod and dropship
	file.prowlers[ index ] = true // enable prowler spawn
	SetGlobalNetInt( defcon, 3 ) // Enemy Stalkers Incoming
}

void function SpawnLevel_Reaper( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	file.reapers[ index ] = true // enable reaper spawn
	file.gunships[ index ] = true // enable gunship spawn
	SetGlobalNetInt( defcon, 4 ) // Enemy Reapers Incoming

	// start cleanup ticks spawned by reapers( might also clean up specialist grunt ticks )
	CleanUpOverloadedTicks()
}

void function SpawnLevel_Titan( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	file.titans[ index ] = true // enable titan spawn
	file.pilots[ index ] = true // enable npc pilot spawn
	SetGlobalNetInt( defcon, 6 ) // this will show nothing
}
//

void function AITdmExtend_Highlight( entity ent )
{
	// friendly highlight
	// shouldn't apply to friendly decoy entities!
	if ( !ent.IsPlayerDecoy() )
		AITdmExtend_FriendlyHighlight( ent )

	// highlights think
	string className = ent.GetClassName()
	switch ( className )
	{
		case "npc_pilot_elite":
			ent.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
			Highlight_SetEnemyHighlight( ent, "enemy_player" )
			break
		case "npc_super_spectre":
		case "npc_gunship":
			ent.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
			Highlight_SetEnemyHighlight( ent, "enemy_titan" )
			break

		default:
			// default highlight setting
			if ( ent.IsTitan() )
				Highlight_SetEnemyHighlight( ent, "enemy_titan" )
			else
				Highlight_SetEnemyHighlight( ent, "enemy_player" )
			break
	}

	// after adding highlights to titan termination viewbody, this enables player to see their own viewbody's highlight
	// don't want to hack for that...
}

void function AITdmExtend_FriendlyHighlight( entity ent )
{
	// sp_enemy_pilot kinda bad, visible through viewmodel
	//Highlight_SetFriendlyHighlight( ent, "sp_enemy_pilot" )
	Highlight_SetFriendlyHighlight( ent, "sp_friendly_pilot" )
	ent.Highlight_SetParam( 1, 0, < 2, 2, 2 > )
}

// used for high threat npcs such as tick
void function AITdmExtend_EnemyThreatenHighlight( entity ent )
{
	Highlight_SetEnemyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 2, 0, < 2, 0, 0 > )
}


// fake coop utility
// leader player: GetPlayerArray()[0]( listen server host, or the first joined player )
entity function GetCOOPLeaderPlayer()
{
	if ( GetPlayerArray().len() >= 1 )
		return GetPlayerArray()[0]

	return null
}

// npc spawn count modifier
int function GetTeamNPCSpawnCountModifier( int expectedSpawn, int team = -1 )
{
	bool coopEnabled = GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1
	entity coopLeader = GetCOOPLeaderPlayer()
	if ( team > TEAM_UNASSIGNED && coopEnabled && IsValid( coopLeader ) )
	{
		// friendly team
		if ( team == coopLeader.GetTeam() )
			return int( float( expectedSpawn ) * file.friendlyNPCPercent )
		else // enemy team
		{
			int playersOtherThanLeader = GetPlayerArray().len() - 1
			float npcSpawnModifier = file.enemyNPCMinPercent + ( file.enemyNPCIncrementPerPlayer * playersOtherThanLeader )
			npcSpawnModifier = min( file.enemyNPCMaxPercent, npcSpawnModifier )
			// debug
			//print( "spawnModifier: " + string( int( float( expectedSpawn ) * npcSpawnModifier ) ) )
			return int( float( expectedSpawn ) * npcSpawnModifier )
		}
	}

	return expectedSpawn // no modifier, just return default value
}

// player team updating
void function UpdateCOOPPlayerTeam()
{
	thread UpdateCOOPPlayerTeam_Threaded()
}

void function UpdateCOOPPlayerTeam_Threaded()
{
	while ( true )
	{
		WaitFrame()

		entity leaderPlayer = GetCOOPLeaderPlayer()
		if ( !IsValid( leaderPlayer ) )
			continue

		int leaderTeam = leaderPlayer.GetTeam()
		foreach ( entity player in GetPlayerArray() )
		{
			if ( player.GetTeam() != leaderTeam )
				SetTeam( player, leaderTeam )
		}
	}	
}

////////////////////////////////
///// NPC CONFIG FUNCTIONS /////
////////////////////////////////

// APRIL FOOLS SPECIAL: random titan weapon assignment
// not featuring modded weapons rn
const array<string> VALID_TITANWEAPONS =
[
	"mp_titanweapon_particle_accelerator",
	"mp_titanweapon_xo16_vanguard",
	"mp_titanweapon_sniper",
	"mp_titanweapon_sticky_40mm",
	"mp_titanweapon_meteor",
	"mp_titanweapon_leadwall",
	"mp_titanweapon_predator_cannon",
]
void function GiveHumanTitanWeapon( entity soldier )
{
	thread GiveHumanTitanWeapon_Threaded( soldier )
}

void function GiveHumanTitanWeapon_Threaded( entity soldier )
{
	soldier.EndSignal( "OnDestroy" )
	soldier.EndSignal( "OnDeath" )
	WaitEndFrame() // droppod npcs' squad name gets assigned later after spawn, needs to handle it

	string squadName = expect string( soldier.kv.squadname )
	if ( file.squadsAssignedTitanWeapon.contains( squadName ) ) // each squad can only have 1 npc holding titan weapon
		return

	TakeAllWeapons( soldier )
	string newWeapon = VALID_TITANWEAPONS[ RandomInt( VALID_TITANWEAPONS.len() ) ]
	entity weapon = soldier.GiveWeapon( newWeapon )
	weapon = GiveNessyProjectileMod( soldier, weapon ) // this actually destroyes org weapon
	soldier.SetActiveWeaponByName( newWeapon )
	file.squadsAssignedTitanWeapon.append( squadName )

	// doubled health + half shield( health taking damage will mostly making them vulnerable, while  )
	// may look weird on stalkers & reapers if we're not using nscn fixes but whatever
	soldier.SetMaxHealth( soldier.GetMaxHealth() * 2 )
	soldier.SetHealth( soldier.GetMaxHealth() )
	SetShieldHealthMaxWithFix( soldier, soldier.GetMaxHealth() * 0.5 )
	SetShieldHealthWithFix( soldier, GetShieldHealthMaxWithFix( soldier ) )

	// explode on getting stepped by titan. stalkers also do so( which means they deal even more damage )
	AddEntityCallback_OnKilled( soldier, ExplodeOnTitanStep )
	file.npcsUsingTitanWeapon.append( soldier )
}

void function ExplodeOnTitanStep( entity soldier, var damageInfo )
{
	int sourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	if ( sourceId == eDamageSourceId.damagedef_titan_step )
	{
		// 300 dmg
		Explosion_DamageDefSimple(
			damagedef_stalker_powersupply_explosion_large,
			soldier.GetOrigin(),
			soldier,
			soldier,
			soldier.GetOrigin()
		)
		// 150 dmg. not applied to stalkers
		if ( soldier.GetClassName() != "npc_stalker" )
		{
			Explosion_DamageDefSimple(
				damagedef_stalker_powersupply_explosion_small,
				soldier.GetOrigin(),
				soldier,
				soldier,
				soldier.GetOrigin()
			)
		}
	}
}

entity function GiveNessyProjectileMod( entity ent, entity weapon )
{
	array<string> allMods = GetWeaponMods_Global( weapon.GetWeaponClassName() )
	// don't have nessy mod
	if ( !allMods.contains( "fake_nessy_weapon" ) )
		return weapon // org weapon can still be recogniczed

	// seems we'll have to use SetMod() to change weapon model
	// still not working fine...  do we have to replace the weapon manually?
	array<string> mods = weapon.GetMods()
	foreach ( string mod in mods )
	{
		if ( WEAPON_MODS_TO_REMOVE.contains( mod ) )
			mods.removebyvalue( mod )
	}
	mods.append( "fake_nessy_weapon" )

	// main weapons
	if ( !weapon.IsWeaponOffhand() )
	{
		// destroy original weapon and give new one
		string weaponName = weapon.GetWeaponClassName()
		weapon.Destroy()
		entity newWeapon = ent.GiveWeapon( weaponName, mods )

		// remove weapon skin
		weapon.SetSkin( 0 )
		weapon.SetCamo( 0 )
		return newWeapon // make sure we can still find this weapon
	}

	// offhand weapons
	weapon.SetMods( mods )
	return weapon
}

// hardcoded here
const array<string> SPECIALIST_GRUNTS =
[
	"npc_soldier_shield_captain",
	"npc_soldier_drone_summoner",
	"npc_soldier_sidearm",
	"npc_soldier_pve_eliteguard",
	"npc_soldier_training_sentry",
]

const array<string> SPECIALIST_GRUNTS_RARE = // specialist class in this array will have less picking rate
[
	"npc_soldier_shield_captain",
	"npc_soldier_training_sentry",
]

const array<string> EARNMETER_BUFF_GRUNTS = // buff earnmeter earn from these grunts
[
	"npc_soldier_shield_captain",
]

// APRIL FOOLS SPECIAL: random model from teams
const array<asset> VALID_GRUNT_MODELS =
[
	$"models/humans/grunts/mlt_grunt_lmg.mdl",
	$"models/humans/grunts/imc_grunt_lmg.mdl",
	$"models/humans/grunts/mlt_grunt_smg.mdl",
	$"models/humans/grunts/imc_grunt_smg.mdl",
	$"models/humans/grunts/mlt_grunt_shotgun.mdl",
	$"models/humans/grunts/imc_grunt_shotgun.mdl",
	$"models/humans/grunts/mlt_grunt_rifle.mdl",
	$"models/humans/grunts/imc_grunt_rifle.mdl",
]
void function GruntConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// hardcoded here
	string aiSetName = soldier.GetAISettingsName()
	bool isSpecialistGrunt = SPECIALIST_GRUNTS.contains( aiSetName )
	if ( !isSpecialistGrunt ) // normal grunts
	{
		soldier.SetMaxHealth( 80 )
		soldier.SetHealth( 80 )
	}
	
	thread GruntTitleThink( soldier ) // specialist grunts may spawn from dropship, do a think here

	// grunt executions: 
	Melee_SetExecutionRefsOverride( 
		soldier, 
		// execution_face_stab_combat is a modified execution ref
		["execution_neck_snap", "execution_face_stab_combat", "execution_backshot"]
	)

	// don't easily die from specific damage
	ExtraSpawner_EnableNPCKnockBackImmune( soldier, true )
	ExtraSpawner_EnableNPCDieOnAnyDamageImmune( soldier, true )

	bool higherEarnValue = EARNMETER_BUFF_GRUNTS.contains( aiSetName )
	if ( higherEarnValue )
		ScoreEvent_SetEntityEarnValueOverride( soldier, "KillGrunt", 0.04, 0.03, 0.67 )

	// APRIL FOOLS SPECIAL
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// random model from teams
		if ( VALID_GRUNT_MODELS.contains( soldier.GetModelName() ) )
			soldier.SetModel( VALID_GRUNT_MODELS[ RandomInt( VALID_GRUNT_MODELS.len() ) ] )
		
		// random titan weapon assignment
		if ( GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
			GiveHumanTitanWeapon( soldier )
	}
}

void function GruntTitleThink( entity soldier )
{
	soldier.EndSignal( "OnDestroy" )
	soldier.EndSignal( "OnDeath" )

	float endTime = Time() + 5
	while ( Time() <= endTime )
	{
		WaitFrame()
		string aiSetName = soldier.GetAISettingsName()
		bool isSpecialistGrunt = SPECIALIST_GRUNTS.contains( aiSetName )
		if ( !isSpecialistGrunt )
			continue
		WaitFrame() // they may get a title from spawn function, we wait a frame before changing again
		soldier.SetTitle( GetMilitiaTitle() ) // funny in _ai_soldiers.gnut
		return
	}
}

void function PilotConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// pilot executions: 
	Melee_SetExecutionRefsOverride( 
		soldier, 
		["execution_telefrag", "execution_stim", "execution_grapple", "execution_pulseblade", "execution_cloak", "execution_holopilot", "execution_ampedwall"]
	)

	// setup damage scale
	// do reduced damage because we've enabled npc headshots
	ExtraSpawner_SetNPCPilotBulletDamageScale( soldier, 1.5 )

	// don't easily die from specific damage
	ExtraSpawner_EnableNPCKnockBackImmune( soldier, true )
	ExtraSpawner_EnableNPCDieOnAnyDamageImmune( soldier, true )

	// APRIL FOOLS SPECIAL: grants shield
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 && GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
	{
		SetShieldHealthMaxWithFix( soldier, soldier.GetMaxHealth() )
		SetShieldHealthWithFix( soldier, GetShieldHealthMaxWithFix( soldier ) )
	}
}

void function MarvinConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 300 )
	soldier.SetHealth( 300 )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function ProwlerConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// so they won't block teammates( won't work )
	// actually it's pretty fun seeing them collide with player titans
	//soldier.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
	// this can fix their collision
	// no this can't!!! it crashes server immediately
	//soldier.SetHullType( "HULL_HUMAN" )

	soldier.SetMaxHealth( 350 )
	soldier.SetHealth( 350 )

	// APRIL FOOLS SPECIAL: grants shield, higher damage
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 && GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
	{
		ExtraSpawner_SetProwlerMeleeDamageScale( soldier, 0.6, 8.0 )
		SetShieldHealthMaxWithFix( soldier, soldier.GetMaxHealth() )
		SetShieldHealthWithFix( soldier, GetShieldHealthMaxWithFix( soldier ) )
	}
}

void function SpectreConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 190 )
	soldier.SetHealth( 190 )

	// spectre executions: 
	Melee_SetExecutionRefsOverride( 
		soldier, 
		["execution_combo", "execution_knockout"]
	)

	// don't easily die from specific damage
	ExtraSpawner_EnableNPCKnockBackImmune( soldier, true )
	ExtraSpawner_EnableNPCDieOnAnyDamageImmune( soldier, true )

	// APRIL FOOLS SPECIAL
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// random titan weapon assignment
		if ( GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
			GiveHumanTitanWeapon( soldier )
	}
}

// APRIL FOOLS SPECIAL: random model from teams
const array<asset> VALID_STALKER_MODELS =
[
	$"models/robots/stalker/robot_stalker.mdl",
	$"models/robots/stalker/robot_stalker_red.mdl",
]
void function StalkerConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 350 ) // they gets disarmed by shooting weakpoint though
	soldier.SetHealth( 350 )

	// don't easily die from specific damage
	ExtraSpawner_EnableNPCKnockBackImmune( soldier, true )
	ExtraSpawner_EnableNPCDieOnAnyDamageImmune( soldier, true )

	// in our gamemode, stalkers are dangerous vs titans!
	// don't let them able to hurt titan without their awareness
	// settings modfied in _ai_stalker.gnut
	AiStalker_SetCreateHeavyArmorDangerousArea( soldier, true )

	// we want headshot killing them award more score
	SetUpNPCHeadshotReward( soldier )

	// APRIL FOOLS SPECIAL
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// random model from teams
		if ( VALID_STALKER_MODELS.contains( soldier.GetModelName() ) )
			soldier.SetModel( VALID_STALKER_MODELS[ RandomInt( VALID_STALKER_MODELS.len() ) ] )

		// random titan weapon assignment
		if ( GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
			GiveHumanTitanWeapon( soldier )
	}
}

void function SetUpNPCHeadshotReward( entity soldier )
{
	// basically npcs will remove their headshot score value
	// but we can add them back for certain npcs
	ScoreEvent_SetEntityEarnValueOverride( soldier, "Headshot", 0.0, 0.02, 0.0 )
}

void function ReaperConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// even stronger
	soldier.SetMaxHealth( 6500 ) // was 5500
	soldier.SetHealth( 6500 )

	// debugging
	//ExtraSpawner_EnableNPCNoPainOnDamage( true ) // npc won't pain on taking damage
	//ExtraSpawner_SetNPCFlinchProtectionScale( soldier, 1.0 )

	ExtraSpawner_SetNPCFlinchProtectionScale( soldier, 0.5 ) // less likely can be in pain animation( at least 1500 damage / 3600 repeat damage required )

	// APRIL FOOLS SPECIAL: add aggressive_ai and fake_nessy_weapon, grants shield
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 && GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
	{
		if ( soldier.GetMainWeapons().len() > 0 )
		{
			soldier.GetMainWeapons()[0].AddMod( "aggressive_ai" )
			soldier.GetMainWeapons()[0].AddMod( "fake_nessy_weapon" )
		}

		SetShieldHealthMaxWithFix( soldier, soldier.GetMaxHealth() * 0.5 )
		SetShieldHealthWithFix( soldier, GetShieldHealthMaxWithFix( soldier ) )
	}
}

// APRIL FOOLS SPECIAL: random model as same chassis
const array<asset> VALID_STRYDER_TITAN_MODELS =
[
	$"models/titans/light/titan_light_raptor.mdl",
	$"models/titans/light/titan_light_locust.mdl",
	$"models/titans/light/titan_light_northstar_prime.mdl",
	$"models/titans/light/titan_light_ronin_prime.mdl",
]
const array<asset> VALID_ATLAS_TITAN_MODELS =
[
	$"models/titans/medium/titan_medium_ajax.mdl",
	$"models/titans/medium/titan_medium_wraith.mdl",
	$"models/titans/medium/titan_medium_vanguard.mdl",
	$"models/titans/medium/titan_medium_ion_prime.mdl",
	$"models/titans/medium/titan_medium_tone_prime.mdl",
]
const array<asset> VALID_OGRE_TITAN_MODELS =
[
	$"models/titans/heavy/titan_heavy_ogre.mdl",
	$"models/titans/heavy/titan_heavy_deadbolt.mdl",
	$"models/titans/heavy/titan_heavy_scorch_prime.mdl",
	$"models/titans/heavy/titan_heavy_legion_prime.mdl",
]
void function TitanConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// debugging
	//ExtraSpawner_SetNPCFlinchProtectionScale( soldier, 1.0 )

	// here goes some hack: if turret isn't owned by player, we scale down their score value
	// needs to delay 1 frame for them to set up ownership
	thread DelayedSetUpNPCTitan( soldier )

	// APRIL FOOLS SPECIAL
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// remove titan skin
		soldier.SetSkin( 0 )
		soldier.SetCamo( 0 )
		// random model as same chassis
		entity soul = soldier.GetTitanSoul()
		if ( IsValid( soul ) )
		{
			array<asset> validModelGroups
			switch ( GetSoulTitanSubClass( soul ) )
			{
				case "stryder":
					validModelGroups = VALID_STRYDER_TITAN_MODELS
					break

				case "atlas":
					validModelGroups = VALID_ATLAS_TITAN_MODELS
					break

				case "ogre":
					validModelGroups = VALID_OGRE_TITAN_MODELS
					break
			}
			if ( validModelGroups.len() > 0 )
				soldier.SetModel( validModelGroups[ RandomInt( validModelGroups.len() ) ] )
		}

		// change projectile model
		foreach ( entity weapon in soldier.GetMainWeapons() )
			GiveNessyProjectileMod( soldier, weapon )
		foreach ( entity weapon in soldier.GetOffhandWeapons() )
			GiveNessyProjectileMod( soldier, weapon )
	}
}

void function DelayedSetUpNPCTitan( entity soldier )
{
	soldier.EndSignal( "OnDestroy" )

	WaitEndFrame()
	entity soul = soldier.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	if ( IsValid( soul.GetBossPlayer() ) )
		return

	// scale down score value earn from npc titan
	ScoreEvent_SetEntityEarnValueOverride( soldier, "KillTitan", 0.10, 0.05, 0.0 )
	ScoreEvent_SetEntityEarnValueOverride( soldier, "KillAutoTitan", 0.0, 0.0 )
	ScoreEvent_SetEntityEarnValueOverride( soldier, "EliminateTitan", 0.10, 0.05, 0.0 )
	ScoreEvent_SetEntityEarnValueOverride( soldier, "EliminateAutoTitan", 0.0, 0.0 )
	ScoreEvent_SetEntityEarnValueOverride( soldier, "TitanKillTitan", 0.0, 0.0 )
	ScoreEvent_SetEntityEarnValueOverride( soul, "TitanAssist", 0.05, 0.05 ) // titan's assist score store in souls
	ScoreEvent_SetEntityEarnValueOverride( soldier, "TitanAssist", 0.05, 0.05 )

	// APRIL FOOLS SPECIAL
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// remove npc titan skin again because they're assigned after DispatchSpawn()
		soldier.SetSkin( 0 )
		soldier.SetCamo( 0 )

		// grants shield for non-player titans
		if ( GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
			SetShieldHealthWithFix( soul, GetShieldHealthMaxWithFix( soul ) )
	}
}

void function DroneConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// APRIL FOOLS SPECIAL: use fake_nessy_weapon
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		if ( soldier.GetMainWeapons().len() > 0 )
			soldier.GetMainWeapons()[0].AddMod( "fake_nessy_weapon" )
	}
}

void function GunshipConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 4800 ) // was 7500, once used 5850. but we've made them less likely to be targeted...
	soldier.SetHealth( 4800 ) // was 7500, once used 5850. but we've made them less likely to be targeted...

	//soldier.SetNoTarget( true ) // don't want other npcs targeting them
	soldier.SetNPCPriorityOverride( 10 ) // they're flying around, don't want other npcs targeting them very often
}

void function DropshipConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function TickConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// following things only set up for npc spawned ticks
	// needs to delay 1 frame for them to set up ownership
	thread DelayedSetUpNPCSpawnedTick( soldier )
}

void function DelayedSetUpNPCSpawnedTick( entity soldier )
{
	soldier.EndSignal( "OnDestroy" )

	WaitEndFrame()
	if ( IsValid( soldier.GetBossPlayer() ) )
		return

	// enemy highlight
	//if ( IsAlive( soldier ) )
	//	AITdmExtend_EnemyThreatenHighlight( soldier )

	// SP ticks already have long animation, respawn still adding them 0.25s more delay before exploding
	// that works fine for SP because it's a case we should enjoy the game, but for multiplayer it makes them way too vulnerable
	// we need to remove that extra delay so they can perform better in combat
	// EDIT: due that we've made only SP ticks to have suicide chase behavior, this buff can be removed
	//SuicideSpectre_SetOverloadDelayAdjustment( soldier, 0.0 )
}

void function OnLaunchedFragDroneSpawned( entity reaper, entity nade, entity fragDrone, string droneSettings )
{
	// apply settings to reaper spawned ticks
	if ( IsValid( fragDrone ) )
	{
		if ( IsAlive( fragDrone ) )
			AITdmExtend_EnemyThreatenHighlight( fragDrone )
		// settings modfied in _ai_suicide_spectres.gnut
		//SuicideSpectre_SetJumpAtTitans( fragDrone, true )
		SuicideSpectre_SetCreateHeavyArmorDangerousArea( fragDrone, true ) // maybe this makes npc titans behave better? idk
		// allow ticks to jump at titans before exploding, and makes them won't overload right after getting shot
		// only for SP ticks I guess? MP ticks explodes really fast and I want to make them behave similar to player's tick
		if ( fragDrone.GetAISettingsName() == "npc_frag_drone" )
		{
			//SuicideSpectre_SetSuicideChaseBehavior( fragDrone, 3.0 ) // same SuicideChaseTime as SP player ticks
			SuicideSpectre_SetSuicideChaseBehavior( fragDrone, 2.1 ) // same SuicideChaseTime as SP npc ticks
			SuicideSpectre_SetCanExplodeInMidAir( fragDrone, true ) // also allow them to trigger overload while still in mid-air
		}
	}
}

void function TurretConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// here goes some hack: if turret isn't owned by player, we scale down their score value
	// needs to delay 1 frame for them to set up ownership
	thread DelayedSetUpNPCSpawnedTurret( soldier )

	// APRIL FOOLS SPECIAL
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
	{
		// use fake_nessy_weapon
		if ( soldier.GetMainWeapons().len() > 0 )
			soldier.GetMainWeapons()[0].AddMod( "fake_nessy_weapon" )

		// grants shield
		SetShieldHealthMaxWithFix( soldier, soldier.GetMaxHealth() * 0.5 )
		SetShieldHealthWithFix( soldier, GetShieldHealthMaxWithFix( soldier ) )
	}
}

void function DelayedSetUpNPCSpawnedTurret( entity soldier )
{
	soldier.EndSignal( "OnDestroy" )

	WaitEndFrame()
	if ( IsValid( soldier.GetBossPlayer() ) )
		return

	// scale down score value earn from npc turrets
	ScoreEvent_SetEntityEarnValueOverride( soldier, "KillLightTurret", 0.02, 0.02 )
}

////////////////////////////////////
///// NPC CONFIG FUNCTIONS END /////
////////////////////////////////////



//////////////////////////////////////////
///// EXTRASPAWNER SETTINGS FUNCTION /////
//////////////////////////////////////////
// acually not everything is from extra spawner

void function InitExtraSpawnerSettings()
{
	// changed r201 to r101. they just looks better
	// if we've enabled extreme weapons, specialist grunt will no longer appear, should give grunts their weapons
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 && GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
		ExtraSpawner_SetNPCWeapons( "npc_soldier", ["mp_weapon_rspn101_og", "mp_weapon_lmg", "mp_weapon_shotgun", "mp_weapon_r97", "mp_weapon_dmr", "mp_weapon_car", "mp_weapon_vinson", "mp_weapon_alternator_smg", "mp_weapon_wingman_n"] )
	else
		ExtraSpawner_SetNPCWeapons( "npc_soldier", ["mp_weapon_rspn101_og", "mp_weapon_lmg", "mp_weapon_shotgun", "mp_weapon_r97", "mp_weapon_dmr", "mp_weapon_car", "mp_weapon_vinson"] )
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_soldier", ["mp_weapon_rocket_launcher", "mp_weapon_mgl"] )
	ExtraSpawner_SetNPCGrenadeWeapons( "npc_soldier", ["mp_weapon_frag_grenade", "mp_weapon_thermite_grenade", "mp_weapon_grenade_electric_smoke", "mp_weapon_grenade_emp"] )
	// nerf dmr, mastiff and wingman elite damage cause we enabled npc headshots, disable archers fire at human players and increase their damage against titans
	// APRIL FOOLS SPECIAL: use fake_nessy_weapon
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_soldier", ["npc_lower_damage", "npc_disable_fire_at_pilot", "multiplayer_npc_launcher", "fake_nessy_weapon"] )
	else
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_soldier", ["npc_lower_damage", "npc_disable_fire_at_pilot", "multiplayer_npc_launcher"] )

	// if we've enabled extreme weapons, specialist grunt will no longer appear, should give grunts their weapons
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 && GetCurrentPlaylistVarInt( "aitdm_april_fools_extreme_npc_weapons", 0 ) == 1 )
		ExtraSpawner_SetNPCWeapons( "npc_spectre", ["mp_weapon_mastiff", "mp_weapon_doubletake", "mp_weapon_hemlok_smg", "mp_weapon_hemlok", "mp_weapon_lstar", "mp_weapon_g2", "mp_weapon_shotgun_pistol", "mp_weapon_sniper", "mp_weapon_smart_pistol"] )
	else
		ExtraSpawner_SetNPCWeapons( "npc_spectre", ["mp_weapon_mastiff", "mp_weapon_doubletake", "mp_weapon_hemlok_smg", "mp_weapon_hemlok", "mp_weapon_lstar", "mp_weapon_g2"] )
	// removed arc launcher cuz they're bit too powerful
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_spectre", ["mp_weapon_mgl", "mp_weapon_defender"] )
	// spectres don't throw grenades, just keep here
	//ExtraSpawner_SetNPCGrenadeWeapons( "npc_spectre", ["mp_weapon_frag_grenade", "mp_weapon_thermite_grenade", "mp_weapon_grenade_emp"] )
	// buff double take damage and fire rate
	// APRIL FOOLS SPECIAL: use fake_nessy_weapon
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_spectre", ["npc_higher_damage_headshot", "npc_shorter_rest", "fake_nessy_weapon"] )
	else
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_spectre", ["npc_higher_damage_headshot", "npc_shorter_rest"] )

	ExtraSpawner_SetNPCWeapons( "npc_pilot_elite", ["mp_weapon_rspn101_og", "mp_weapon_r97", "mp_weapon_lmg", "mp_weapon_dmr", "mp_weapon_shotgun", "mp_weapon_mastiff", "mp_weapon_car", "mp_weapon_hemlok_smg", "mp_weapon_hemlok", "mp_weapon_g2", "mp_weapon_vinson", "mp_weapon_doubletake", "mp_weapon_lstar"] )
	// only re-45 and p2016 don't have "hcog" mod included... using them is good enough
	// removed because we've disable npc pilot capability of switching to pistol
	//ExtraSpawner_SetNPCSecondaryWeapons( "npc_pilot_elite", ["mp_weapon_autopistol", "mp_weapon_semipistol"] )
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_pilot_elite", ["mp_weapon_rocket_launcher", "mp_weapon_mgl", "mp_weapon_arc_launcher", "mp_weapon_defender"] )
	// npcs cannot use gravity star
	// CAI_BaseNPC::NPCInitWeapons - Could not create anymore shared grenade weapons, max 5. Tried to create 'mp_weapon_grenade_gravity'
	ExtraSpawner_SetNPCGrenadeWeapons( "npc_pilot_elite", ["mp_weapon_frag_grenade", "mp_weapon_thermite_grenade", "mp_weapon_grenade_electric_smoke", "mp_weapon_grenade_emp"] )
	// nerf dmr, mastiff and wingman elite damage cause we enabled npc headshots, buff double take damage and fire rate, disable archers fire at human players and increase their damage against titans
	// for pilots, add optics, extended_ammo and pro_screen for their weapons. we've added npc weapon bodygroup update!(proscreen can't show xp count for a npc though)
	// aog goes first because spitfire and lstar both have holosight(lstar one is unfinished), wants to overwrite
	// APRIL FOOLS SPECIAL: no optics, use fake_nessy_weapon
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_pilot_elite", ["npc_lower_damage", "npc_higher_damage_headshot", "npc_shorter_rest", "npc_disable_fire_at_pilot", "multiplayer_npc_launcher", "fake_nessy_weapon"] )
	else
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_pilot_elite", ["npc_lower_damage", "npc_higher_damage_headshot", "npc_shorter_rest", "npc_disable_fire_at_pilot", "multiplayer_npc_launcher", "hcog", "aog", "holosight", "scope_4x", "extended_ammo", "pro_screen"] )

	// npcs can't shoot "mp_weapon_pulse_lmg"
	ExtraSpawner_SetNPCWeapons( "npc_stalker", ["mp_weapon_softball", "mp_weapon_smr", "mp_weapon_epg"] )
	// should I just remove AT weapons for stalkers cuz they're using grenadier?
	//ExtraSpawner_SetNPCAntiTitanWeapons( "npc_stalker", ["mp_weapon_mgl", "mp_weapon_arc_launcher", "mp_weapon_defender"] )
	// balanced epg for multiplayer
	// APRIL FOOLS SPECIAL: use fake_nessy_weapon
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_april_fools", 0 ) == 1 )
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_stalker", ["multiplayer_npc_grenadier", "fake_nessy_weapon"] )
	else
		ExtraSpawner_SetNPCExtraWeaponMods( "npc_stalker", ["multiplayer_npc_grenadier"] )


	// modified functions in _ai_drone.nut
	//AiDrone_SetDroneSpawnedByNPCRandomType( true ) // specialist grunts will spawn random drones
	//AiDrone_SetDroneSpawnedByNPCForceDie( true ) // drones spawned by npcs will be destroyed right after it's owner's death

	// modified functions in class_wallrun.gnut
	//Wallrun_SetProtectionForRodeoPlayerStyle( eRodeoPlayerProtectionStyle.PROTECTION_AGAINST_NPC_MELEE ) // player can be damaged by npcs while rodeoing, but protects them from random melee damage
	//Wallrun_SetProtectionForRodeoPlayerStyle( eRodeoPlayerProtectionStyle.PROTECTION_AGAINST_NON_AGGRO_NPC ) // player can be damaged by npcs aggro at them
	Wallrun_SetProtectionForRodeoPlayerStyle( eRodeoPlayerProtectionStyle.PROTECTION_AGAINST_NON_TITAN_AND_NPC_MELEE )

	// modified functions in _base_gametype.gnut
	GameMode_SetCanUseNPCAsLastAttacker( true ) // allow use npcs as last attacker, so we can get more accurate score from npcs
	GameMode_SetUseLastValidAttacker( true ) // allow finding from entity's damage history for last valid attacker, so we can get more accurate score from npcs

	// damage history settings, for better handling npc score
	GameMode_SetPlayerDamageHistoryLifeTime( 30.0 ) // modified function from _codecallbacks.gnut
	TitanHealth_SetNPCTitanDamageHistoryLifeTime( 30.0 ) // modified function from _titan_health.gnut
	ExtraSpawner_SetNPCDamageHistoryLifeTime( 12.0 )

	// modified function in _ai_suicide_spectres.gnut
	SuicideSpectre_SetUseGlobalChainExplosionTimer( false ) // sets npc owned ticks to have constant explosion timer. chain explosion delay is calculated per player

	// modified function in levels_util.gnut
	Levels_SetNPCAssistScoreEnabled( true ) // award assist score to players on npc killing each other, so players won't complain

	// modified function in sh_damage_history.gnut
	// removed because in normal gamemodes player should be easier to secure kills, and npc titan needs kills for more core meter charge
	//DamageHistory_EnableOffsetDamageTimeForSelfDestruction( true ) // move damage time along with time of self-destruction, that way we can get more accurate damage time on them
	//DamageHistory_SetNPCKillStealPreventionTime( 2.0 ) // transfer score to player if npc killed an target
}

//////////////////////////////////////////////
///// EXTRASPAWNER SETTINGS FUNCTION END /////
//////////////////////////////////////////////

void function SetUpAITdmExtendedScoreEvent()
{
	// pilot kill
	ScoreEvent_SetEarnMeterValues( "KillPilot", 0.10, 0.05 )
	ScoreEvent_SetEarnMeterValues( "EliminatePilot", 0.10, 0.05 )
	ScoreEvent_SetEarnMeterValues( "PilotAssist", 0.03, 0.020001, 0.0 ) // if set to "0.03, 0.02", will display as "4%"
	// titan doom
	ScoreEvent_SetEarnMeterValues( "DoomTitan", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "DoomAutoTitan", 0.0, 0.0 )
	// titan kill
	// don't know why auto titan kills appear to be no value in vanilla
	// even when the titan have an owner player
	ScoreEvent_SetEarnMeterValues( "KillTitan", 0.15, 0.07, 0.0 ) // scale down from 0.20, 0.10
	ScoreEvent_SetEarnMeterValues( "KillAutoTitan", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "EliminateTitan", 0.15, 0.07, 0.0 ) // scale down from 0.20, 0.10
	ScoreEvent_SetEarnMeterValues( "EliminateAutoTitan", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "TitanKillTitan", 0.0, 0.0 )
	// but titan assist do have earn values... 
	// maybe because they're not splitted into AutoTitan or PlayerTitan variant
	ScoreEvent_SetEarnMeterValues( "TitanAssist", 0.10, 0.05 ) // scale down from 0.10, 0.10
	// rodeo
	ScoreEvent_SetEarnMeterValues( "PilotBatteryStolen", 0.0, 0.25, 0.0 ) // was 0.0, 0.35. scale down because it's easy to get batteries from npc titans
	ScoreEvent_SetEarnMeterValues( "PilotBatteryApplied", 0.0, 0.25, 0.0 ) // was 0.0, 0.35
	// special method of killing
	ScoreEvent_SetEarnMeterValues( "Headshot", 0.0, 0.02, 0.0 )
	ScoreEvent_SetEarnMeterValues( "FirstStrike", 0.03, 0.020001, 0.0 ) // if set to "0.03, 0.02", will display as "4%"
	
	// ai
	// so here's a funny twist, respawn don't know "0.03, 0.02" will display as 4%
	// which means actual vanilla infantry value is 5% but it displays as 4%
	// (if you set earnmeter multiplier to 5.0 it displays as 24%, proving my thought)
	ScoreEvent_SetEarnMeterValues( "KillGrunt", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSpectre", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "LeechSpectre", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillHackedSpectre", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillStalker", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSuperSpectre", 0.10, 0.10, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillLightTurret", 0.05, 0.050001 )
	// ai(extended)
	ScoreEvent_SetEarnMeterValues( "KillProwler", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillDrone", 0.01, 0.01 )
	ScoreEvent_SetEarnMeterValues( "FlyerKill", 0.10, 0.10, 0.5 ) // this is actually used for gunship kill

	// display type
	// default case is adding a eEventDisplayType.CENTER, required for client to show earnvalue on screen
	ScoreEvent_SetEventDisplayTypes( "KillPilot", GetScoreEvent( "KillPilot" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "EliminatePilot", GetScoreEvent( "EliminatePilot" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "PilotAssist", GetScoreEvent( "PilotAssist" ).displayType | eEventDisplayType.CENTER )
	// doom a titan shouldn't be displayed at center of screen

	ScoreEvent_SetEventDisplayTypes( "KillTitan", GetScoreEvent( "KillTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillAutoTitan", GetScoreEvent( "KillAutoTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "EliminateTitan", GetScoreEvent( "EliminateTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "EliminateAutoTitan", GetScoreEvent( "EliminateAutoTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "TitanKillTitan", GetScoreEvent( "TitanKillTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "TitanAssist", GetScoreEvent( "TitanAssist" ).displayType | eEventDisplayType.CENTER )
	
	ScoreEvent_SetEventDisplayTypes( "PilotBatteryStolen", GetScoreEvent( "PilotBatteryStolen" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "PilotBatteryApplied", GetScoreEvent( "PilotBatteryApplied" ).displayType | eEventDisplayType.CENTER )
	
	ScoreEvent_SetEventDisplayTypes( "Headshot", GetScoreEvent( "Headshot" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "FirstStrike", GetScoreEvent( "FirstStrike" ).displayType | eEventDisplayType.CENTER )
	
	ScoreEvent_SetEventDisplayTypes( "KillGrunt", GetScoreEvent( "KillGrunt" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillSpectre", GetScoreEvent( "KillSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "LeechSpectre", GetScoreEvent( "LeechSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillHackedSpectre", GetScoreEvent( "KillHackedSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillStalker", GetScoreEvent( "KillStalker" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillSuperSpectre", GetScoreEvent( "KillSuperSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillLightTurret", GetScoreEvent( "KillLightTurret" ).displayType | eEventDisplayType.CENTER )

	ScoreEvent_SetEventDisplayTypes( "KillProwler", GetScoreEvent( "KillProwler" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillDrone", GetScoreEvent( "KillDrone" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "FlyerKill", GetScoreEvent( "FlyerKill" ).displayType | eEventDisplayType.CENTER )
}

//------------------------------------------------------

void function OnPrematchStart()
{
    InitExtraSpawnerSettings() // npc weapon settings or something...

	// don't run spawning code if ains and nms aren't up to date
	if ( GetAINScriptVersion() == AIN_REV && GetNodeCount() != 0 )
	{
		thread SpawnIntroBatch( TEAM_IMC )
		thread SpawnIntroBatch( TEAM_MILITIA )
	}

	// Starts skyshow, this also requiers AINs but doesn't crash if they're missing
	if ( !Flag( "LevelHasRoof" ) )
		thread StratonHornetDogfightsIntense()
}

void function OnPlaying()
{
	// cleaning up
	TryCleanupBoredNPCGameLong()
}

void function OnPlayerConnected( entity player )
{
	Remote_CallFunction_NonReplay( player, "ServerCallback_AITDM_OnPlayerConnected" )
}

//------------------------------------------------------

int function AITdmExtend_GetScoreValue( entity ent, bool isDoomedShot = false )
{
	int scoreToAdd = 0

	// fake coop support
	bool coopEnabled = GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1

	int playerScore = PLAYER_SCORE_AMOUNT
	// coop case: scale player score
	if ( coopEnabled )
		playerScore = int( PLAYER_SCORE_AMOUNT * file.teamPilotScoreMultiplier )

	if ( ent.IsPlayer() )
		scoreToAdd = playerScore
	
	string className = ent.GetClassName()
	// class name override here: embarked npc titan
	if ( ent.IsTitan() && TitanHasNpcPilot( ent ) )
		className = GetTitanEmbarkedNpcClassName( ent )

	if ( className == "npc_pilot_elite" )
		scoreToAdd = PILOT_SCORE_AMOUNT
	
	if ( className == "npc_gunship" )
		scoreToAdd = GUNSHIP_SCORE_AMOUNT
	
	if ( className == "npc_marvin" )
		scoreToAdd = MARVIN_SCORE_AMOUNT

	if ( className == "npc_prowler" )
	{
		// hardcoded here: if it's a small prowler we add less score
		if ( float( ent.kv.modelscale ) < 1.0 )
			scoreToAdd = SMALL_PROWLER_SCORE_AMOUNT
		else
			scoreToAdd = PROWLER_SCORE_AMOUNT
	}

	if ( className == "npc_spectre" )
		scoreToAdd = SPECTRE_SCORE_AMOUNT

	if ( className == "npc_stalker" )
		scoreToAdd = STALKER_SCORE_AMOUNT

	if ( className == "npc_super_spectre" )
		scoreToAdd = REAPER_SCORE_AMOUNT

	if ( className == "npc_soldier" )
	{
		if ( SPECIALIST_GRUNTS.contains( ent.GetAISettingsName() ) )
			scoreToAdd = SPECIALIST_GRUNT_SCORE_AMOUNT
		else
			scoreToAdd = GRUNT_SCORE_AMOUNT
	}
	
	if ( className == "npc_drone" )
		scoreToAdd = DRONE_SCORE_AMOUNT

	if ( ent.IsTitan() )
	{
		int titanScore = TITAN_SCORE_AMOUNT
		// player owned titan
		if ( IsValid( ent.GetTitanSoul() ) && IsValid( GetPetTitanOwner( ent ) ) )
		{
			// coop case: scale player owned titan score
			if ( coopEnabled )
				titanScore = int( TITAN_SCORE_AMOUNT * file.teamTitanScoreMultiplier )
		}

		if ( TitanHasNpcPilot( ent ) && !isDoomedShot ) // pilot was killed without ejecting
			scoreToAdd += titanScore // base score add an extra titan score
		else if ( ent.IsPlayer() ) // fix for player score!
			scoreToAdd = titanScore + playerScore
		else // auto titan
			scoreToAdd = titanScore

		// modified function in _titan_health.gnut, recovering ttf1 behavior: we add score on doom but not on death for health loss titans
		bool removeTitanScore = !TitanHealth_GetSoulInfiniteDoomedState( ent.GetTitanSoul() )
		if ( isDoomedShot ) // doomed shot: reversed check. we don't add score on infinite doom titans
			removeTitanScore = TitanHealth_GetSoulInfiniteDoomedState( ent.GetTitanSoul() )
		if ( removeTitanScore )
			scoreToAdd -= titanScore // remove titan score on kill for doomed health loss titans
	}
	else // humans
	{
		// APRIL FOOLS SPECIAL: titan weapon grunts award extra score
		if ( file.npcsUsingTitanWeapon.contains( ent ) )
			scoreToAdd *= HUMAN_TITAN_WEAPON_SCORE_MULTIPLYER
	}

	return scoreToAdd
}

void function HandleScoreForPlayerOrNPCKill( entity victim, entity attacker, var damageInfo )
{
	// if victim is a non-titan npc that owned by players, don't add score
	if ( !VictimIsValidForAITdmScore( victim ) )
		return
	
	if ( !AttackerIsValidForAITdmScore( victim, attacker, damageInfo ) )
	{
		// attacker maybe invalid, but we still needs to add some score
		// welp... this should never gets hit because PlayerOrNPCKilled() won't do callbacks if attacker invalid
		if ( !IsValid( attacker ) && GamePlayingOrSuddenDeath() )
		{
			int scoreToAdd = AITdmExtend_GetScoreValue( victim )
			if ( scoreToAdd > 0 )
				AddTeamScore( GetOtherTeam( victim.GetTeam() ), scoreToAdd )
		}
		return
	}

	// if it's a npc with bossplayer...
	// mostly never gets hit because it's already handled by PlayerOrNPCKilled() in _base_gametype.gnut
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		attacker = GetAITdmAttackOwner( attacker )
	}

	// start adding score
	int scoreToAdd = AITdmExtend_GetScoreValue( victim )
	if ( scoreToAdd > 0 )
		AddAITdmTeamScore( attacker, scoreToAdd ) // this can handle both players' and npcs' kills
}

bool function AttackerIsValidForAITdmScore( entity victim, entity attacker, var damageInfo )
{
	// shouldn't be able to add score during other state after game logic fix.. just handle here
	if ( !GamePlayingOrSuddenDeath() )
		return false
	
	if( !IsValid( attacker ) )
		return false

	// Team filter -- don't want Friendly Fire able to influence score
	// make it a setting
	if ( victim.GetTeam() == attacker.GetTeam() && !FriendlyFire_ShouldAddScoreOnFriendlyKill() )
		return false
	
	if( !attacker.IsNPC() && !attacker.IsPlayer() ) // not killed by any combat character
		return false

	if ( attacker == victim ) // suicide!
		return false

	// Hacked spectre and pet titan filter
	// though hacked spectres already handled by npc.s.givenAttritionScore, titans handled below
	// owner should be related with visibility stuffs( like synced melee ), not adding to this check
	//if ( victim.GetOwner() == attacker || victim.GetBossPlayer() == attacker )
	if ( victim.GetBossPlayer() == attacker )
		return false

	// npc titan case
	if ( victim.IsTitan() && victim.IsNPC() )
	{
		entity soul = victim.GetTitanSoul()
		// victim is titan but their bossPlayer is attacker... usually happens when ejecting without taking damage
		if ( IsValid( soul ) && GetPetTitanOwner( victim ) == attacker )
			return false
	}

	// all checks passed
	return true
}

bool function VictimIsValidForAITdmScore( entity victim )
{
	// if victim is a non-titan npc that owned by players, don't add score
	// vanilla doesn't seem to have this check, and we've added npc.s.givenAttritionScore for hacked spectres
	/*
	if ( victim.IsNPC() && !victim.IsTitan() )
	{
		entity bossPlayer = victim.GetBossPlayer()
		entity owner = victim.GetOwner()
		if ( IsValid( bossPlayer ) )
		{
			if ( bossPlayer.IsPlayer() )
				return false
		}
		if ( IsValid( owner ) )
		{
			if ( owner.IsPlayer() )
				return false
		}
	}
	*/
	// check whether this npc has given score or not
	if ( "givenAttritionScore" in victim.s )
		return false

	// all checks passed
	return true
}

entity function GetAITdmAttackOwner( entity ent )
{
	entity attacker
	if ( ent.IsPlayer() ) // player always use themselves as attacker
		return ent
	if ( IsValid( ent.GetBossPlayer() ) )
		attacker = ent.GetBossPlayer()
	// owner is for visibility stuffs, never check it
	//if ( IsValid( ent.GetOwner() ) )
	//	attacker = ent.GetOwner()
	// attacker still not valid?
	if ( !IsValid( attacker ) )
		return ent // use npc or something itself
	
	return attacker
}

void function AddAITdmTeamScore( entity ent, int score )
{
	// Add score + update network int to trigger the "Score +n" popup
	AddTeamScore( ent.GetTeam(), score )
	if ( ent.IsPlayer() )
	{
		ent.AddToPlayerGameStat( PGS_ASSAULT_SCORE, score )
		AITdm_SetPlayerBonusPoints( ent, ent.GetPlayerGameStat( PGS_ASSAULT_SCORE ) )
	}
}

// networkvar updates
void function AITdm_AddPlayerBonusPoints( entity player, int amount )
{
	AITdm_SetPlayerBonusPoints( player, AITdm_GetPlayerBonusPoints( player ) + amount )
}

int function AITdm_GetPlayerBonusPoints( entity player )
{
	return player.GetPlayerNetInt( "AT_bonusPoints" ) + ( player.GetPlayerNetInt( "AT_bonusPoints256" ) * 256 )
}

void function AITdm_SetPlayerBonusPoints( entity player, int amount )
{
	// split into stacks of 256 where necessary
	int stacks = amount / 256 // automatically rounds down because int division

	player.SetPlayerNetInt( "AT_bonusPoints256", stacks )
	player.SetPlayerNetInt( "AT_bonusPoints", amount - stacks * 256 )
}

// earn points, seems not used
void function AITdm_AddPlayerEarnedPoints( entity player, int amount )
{
	AITdm_SetPlayerEarnedPoints( player, AITdm_GetPlayerEarnedPoints( player ) + amount )
}

int function AITdm_GetPlayerEarnedPoints( entity player )
{
	return player.GetPlayerNetInt( "AT_earnedPoints" ) + ( player.GetPlayerNetInt( "AT_earnedPoints256" ) * 256 )
}

void function AITdm_SetPlayerEarnedPoints( entity player, int amount )
{
	// split into stacks of 256 where necessary
	int stacks = amount / 256 // automatically rounds down because int division

	player.SetPlayerNetInt( "AT_earnedPoints256", stacks )
	player.SetPlayerNetInt( "AT_earnedPoints", amount - stacks * 256 )
}

// for handling doomed health loss titans
void function HandleTitanDoomedScore( entity victim, var damageInfo, bool firstDoom )
{
	// if victim is a non-titan npc that owned by players, don't add score
	if ( !VictimIsValidForAITdmScore( victim ) )
		return
	
	if ( !firstDoom ) // only add score on first doom
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !AttackerIsValidForAITdmScore( victim, attacker, damageInfo ) )
	{
		// attacker maybe invalid, but we still needs to add some score
		// welp... this should never gets hit because PlayerOrNPCKilled() won't do callbacks if attacker invalid
		if ( !IsValid( attacker ) && GamePlayingOrSuddenDeath() )
		{
			int scoreToAdd = AITdmExtend_GetScoreValue( victim, true )
			if ( scoreToAdd > 0 )
				AddTeamScore( GetOtherTeam( victim.GetTeam() ), scoreToAdd )
		}
		return
	}

	// if it's a npc with bossplayer...
	// mostly never gets hit because it's already handled by PlayerOrNPCKilled() in _base_gametype.gnut
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		attacker = GetAITdmAttackOwner( attacker )
	}

	int scoreToAdd = AITdmExtend_GetScoreValue( victim, true )
	if ( scoreToAdd > 0 )
		AddAITdmTeamScore( attacker, scoreToAdd )
}

//------------------------------------------------------

// CHECK FUNCTIONS

bool function ShouldSpawnSpecialistSquad( string otherSpawnWith = "" )
{
	// never spawn specialist grunt with stalkers
	// stalkers are slow and they've already got pretty high health and damage
	if ( otherSpawnWith == "npc_stalker" )
		return false
	// removed. to make game more chaotic, always spawn specialist squad
	//return RandomInt( 3 ) > 0 // 66% chance of spawning a specialist squad(??
	return true
}

bool function ShouldSpawnDropship( string entToSpawn = "" )
{
	// vanilla flag
	if ( Flag( "DisableDropships" ) )
		return false

	// stalkers can do traverse now, add dropship will be pretty cool( though their animation wasn't very nice and will do spew error on landing )
	//if ( entToSpawn == "npc_stalker" ) // stalkers has been reworked and never spawn from dropship
	//	return false

	array<entity> points = GetZiplineDropshipSpawns()
	if ( points.len() <= 4 ) // must have more than 4 points
		return false

	// reduced chance down to 20% because dropship spawn makes npcs spread out and can sometimes fail to spawn
	// maybe it's good to add higher chance of dropship spawn after navmesh supports traverse nodes
	// navmesh traverse nodes are implemented, and we're always allowing npc to use dropship( quick edit: welp eDropStyle.FORCED won't help us spawn npcs )
	// gets spreaded makes them harder to be mayhemed which is good, increasing chance to 35%
	// welp I can't make npc dropship always success for now...
	//return RandomInt( 3 ) == 0 // 33% chance of choose to spawn a dropship
	return RandomInt( 100 ) < 20
	//return RandomInt( 100 ) < 35
}

string function GetSpecialistGruntLeader()
{
	bool spawnRareSpecialist = RandomInt( 100 ) < int( GetCurrentPlaylistVarFloat( "modaitdm_rare_specialist_chance", RARE_SPECIALIST_GRUNT_PICK_CHANCE ) * 100 )
	string leaderSet = "npc_soldier_drone_summoner"
	if ( spawnRareSpecialist )
		leaderSet = SPECIALIST_GRUNTS_RARE[ RandomInt( SPECIALIST_GRUNTS_RARE.len() ) ]
	else
	{
		array<string> genericSpecialist
		foreach ( aiSet in SPECIALIST_GRUNTS )
		{
			if ( !SPECIALIST_GRUNTS_RARE.contains( aiSet ) )
				genericSpecialist.append( aiSet )
		}
		leaderSet = genericSpecialist[ RandomInt( genericSpecialist.len() ) ]
	}

	//print( "leaderAiSet: " + leaderSet )

	return leaderSet
}

// reworked here: we scale up health depending on current spawn level, not depend on the ones they spawn with
//int function GetSpecialistLeaderHealth( int team, string otherSpawnWith )
int function GetSpecialistLeaderHealth( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1
	// reworked here: we scale up health depending on current spawn level, not depend on the ones they spawn with
	//return 200 + ( 60 * file.podEntities[ index ].find( otherSpawnWith ) )
	return 200 + ( 60 * ( file.podEntities[ index ].len() - 1 ) )
}

bool function ShouldSpawnBossTitan()
{
	// now reduce chance down to 30% because we've given bosses more powerful execution
	// and allow it to be modified by playlistvar
	//return RandomInt( 2 ) == 0 // boss titans has 50% chance to spawn( was 20%, but we've added many new bosses... )
	return RandomInt( 100 ) < int( GetCurrentPlaylistVarFloat( "modaitdm_boss_replace_chance", BOSS_TITAN_REPLACE_CHANCE ) * 100 )
}

string function GetBossTitanSpawnName( int team )
{
	// team specific
	if ( team == TEAM_IMC )
	{
		const array<string> imcBossList =
		[
			"blisk",
			"kane",
			"ash",
			"richter",
			"viper",
			"slone",
		]
		return imcBossList[ RandomInt( imcBossList.len() ) ]
	}
	else if ( team == TEAM_MILITIA )
	{
		// add static chance of picking vanguard because they have various of weapons
		if ( RandomInt( 100 ) < 40 ) // 40% chance of spawning
			return "vanguard"
		
		const array<string> mltBossList =
		[
			"jack",
			"sarah",
			//"sarah_monarch",
			"gates",
			//"bear",
			"lastimosa",
			"anderson",
		]
		return mltBossList[ RandomInt( mltBossList.len() ) ]
	}

	// default case
	return "" // empty string means random
}

int function GetBossTitanSpawnTeam( int friendlyTeam = -1 )
{
	bool coopEnabled = GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1
	bool teamBasedBossTitan = GetCurrentPlaylistVarInt( "aitdm_coop_team_boss_titans", 0 ) == 1

	// only do checks if coop enabled
	if ( friendlyTeam > TEAM_UNASSIGNED && coopEnabled && teamBasedBossTitan )
	{
		if ( GetPlayerArray().len() == 1 ) // single player
		{
			// use faction team
			entity player = GetPlayerArray()[0]
			int factionTeam = ConvertPlayerFactionToIMCOrMilitiaTeam( player )
			bool isFriendlySpawn = player.GetTeam() == friendlyTeam
			return isFriendlySpawn ? factionTeam : GetOtherTeam( factionTeam )
		}
		else if ( GetPlayerArray().len() > 1 ) // multiplayer coop
		{
			// use player leader's team
			int leaderTeam = GetCOOPLeaderPlayer().GetTeam()
			bool isFriendlySpawn = leaderTeam == friendlyTeam
			return isFriendlySpawn ? leaderTeam : GetOtherTeam( leaderTeam )
		}
	}
	else // not coop, pick from two teams
	{
		const array<int> validBossSpawnTeams = [TEAM_IMC, TEAM_MILITIA]
		return validBossSpawnTeams[ RandomInt( validBossSpawnTeams.len() ) ]
	}

	return -1 // -1 means no team-based checks, always pick random boss titans
}

bool function ReachedPlayerCheckAmount()
{
	int maxPlayers = GetCurrentPlaylistVarInt( "max_players", 16 )
	if ( float ( GetPlayerArray().len() ) >= float ( maxPlayers ) * 0.6 )
		return true
	return false
}

//


void function SpawnIntroBatch( int team )
{
	//array<entity> dropPodNodes = GetDroppodStartPoints()
	array<entity> dropPodNodes = SpawnPoints_GetDropPodStart( team )
	array<entity> dropShipNodes = GetValidIntroDropShipSpawn( dropPodNodes )
	// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
	ValidateNPCSpawnpoints( dropPodNodes, "npc_soldier" )
	ValidateNPCSpawnpoints( dropShipNodes, "npc_soldier" )
	
	array<entity> podNodes
	array<entity> shipNodes
	
	// mp_rise has weird droppod_start nodes, this gets around it
	// To be more specific the teams aren't setup and some nodes are scattered in narnia
	if( GetMapName() == "mp_rise" )
	{
		entity spawnPoint
		
		// Get a spawnpoint for team
		foreach ( point in GetEntArrayByClass_Expensive( "info_spawnpoint_dropship_start" ) )
		{
			if ( point.HasKey( "gamemode_tdm" ) )
				if ( point.kv[ "gamemode_tdm" ] == "0" )
					continue
			
			if ( point.GetTeam() == team )
			{
				spawnPoint = point
				break
			}
		}
		
		// Get nodes close enough to team spawnpoint
		foreach ( node in dropPodNodes )
		{
			if ( node.HasKey("teamnum") && Distance2D( node.GetOrigin(), spawnPoint.GetOrigin()) < 2000 )
				podNodes.append( node )
		}
	}
	else
	{
		// Sort per team
		foreach ( node in dropPodNodes )
		{
			if ( node.GetTeam() == team )
				podNodes.append( node )
		}
	}

	shipNodes = GetValidIntroDropShipSpawn( podNodes )

	// calculate intro spawn delay
	float introLength = ClassicMP_GetIntroLength()
	float introSpawnRequiredTime = expect float( GetDropPodAnimDuration() )

	float introSpawnWait = introLength - introSpawnRequiredTime
	if ( introSpawnWait > 0 )
		wait introSpawnWait

	// Spawn logic
	int startIndex = 0
	entity node
	string introSpawnClass = "npc_soldier"
	
	int pods = RandomInt( podNodes.len() + 1 )
	
	int ships = shipNodes.len()
	bool spawnSucceeded = false

	array<int> usedPodNodeIndex
	array<int> usedShipNodeIndex

	int squadsToSpawn = GetTeamNPCSpawnCountModifier( file.squadCount, team )
	for ( int i = 0; i < squadsToSpawn; i++ )
	{
		if ( ( pods != 0 || ships == 0 ) && podNodes.len() > 0 ) // defensive fix for podNodes can sometimes be 0
		{
			spawnSucceeded = true // mark as we've done intro spawn, we'll wait before game-loop-spawn
			if ( usedPodNodeIndex.len() > podNodes.len() - 1 ) // max nodes used!
				usedPodNodeIndex.clear() // reuse nodes

			// get a random unused node
			int index
			while ( usedPodNodeIndex.contains( index ) )
				index = RandomInt( podNodes.len() )

			node = podNodes[ index ]
			usedPodNodeIndex.append( index ) // mark as node used
			UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
			if ( ShouldSpawnSpecialistSquad( introSpawnClass ) )
			{
				string leaderSet = GetSpecialistGruntLeader()
				//int leaderHealth = GetSpecialistLeaderHealth( team, introSpawnClass )
				int leaderHealth = GetSpecialistLeaderHealth( team )
				thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, leaderSet, leaderHealth )
			}
			else
				thread ExtraSpawner_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, introSpawnClass )

			pods--
		}
		else if ( shipNodes.len() > 0 ) // defensive fix for shipNodes can sometimes be 0
		{
			spawnSucceeded = true // mark as we've done intro spawn, we'll wait before game-loop-spawn
			if ( startIndex == 0 ) 
				startIndex = i // save where we started
			
			node = shipNodes[ i - startIndex ]
			UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
			if ( ShouldSpawnSpecialistSquad( introSpawnClass ) )
			{
				string leaderSet = GetSpecialistGruntLeader()
				//int leaderHealth = GetSpecialistLeaderHealth( team, introSpawnClass )
				int leaderHealth = GetSpecialistLeaderHealth( team )
				thread ExtraSpawner_SpawnSpecialistGruntDropShip( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, 4, leaderSet, leaderHealth )
			}
			else
				thread ExtraSpawner_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, SQUAD_SIZE )
			
			ships--
		}
		
		// add a delay after half spawn
		if ( i == ( squadsToSpawn / 2 ) - 1 )
			wait 4 // ~droppod landing delay
	}

	// do wait before looping spawn starts if we did intro spawn
	if ( spawnSucceeded )
		wait 8.0
	
	// intro spawn finished
	thread SpawnEscalator( team ) // handles team Escalate()
	thread SpawnerSquads( team )
	thread SpawnerHeavyArmor( team )
	thread SpawnerNPCs( team )
}

// Populates the match
void function SpawnEscalator( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		Escalate( team )
	}
}

void function SpawnerSquads( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
		int infantryCount = 0
		foreach ( entity npc in GetNPCArrayOfTeam( team ) )
		{
			if ( IsHumanSized( npc ) && !IsValid( npc.GetBossPlayer() ) )
				infantryCount += 1
		}
		int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()

		// NORMAL SPAWNS
		int maxSquads = GetTeamNPCSpawnCountModifier( file.squadCount, team )
		//if ( ReachedPlayerCheckAmount() && file.reapers[ index ] ) // if we have pretty much players and reached reaper level
		//	maxSquads = SQUADS_PER_TEAM_MORE_PLAYERS // do reduced minions count
		if ( file.reapers[ index ] )
			maxSquads = GetTeamNPCSpawnCountModifier( file.squadCountHighLevel, team )
		
		int squadsToSpawn = ( maxSquads * SQUAD_SIZE - 2 - infantryCount ) / SQUAD_SIZE
		if ( squadsToSpawn > 0 )
		{
			for ( int i = 0; i < squadsToSpawn; i++ )
			{
				if ( i > 0 )
					wait 2.0 // delay before next spawn
				
				array<entity> dropshipPoints = GetZiplineDropshipSpawns()
				array<entity> droppodPoints = SpawnPoints_GetDropPod()
				// add startpoints for fun!
				dropshipPoints.extend( GetValidIntroDropShipSpawn( GetDroppodStartPoints() ) )
				droppodPoints.extend( GetDroppodStartPoints() )
				string ent = file.podEntities[ index ][ RandomInt( file.podEntities[ index ].len() ) ]
				// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
				ValidateNPCSpawnpoints( dropshipPoints, ent )
				ValidateNPCSpawnpoints( droppodPoints, ent )

				if ( ShouldSpawnSpecialistSquad( ent ) )
				{
					string leaderSet = GetSpecialistGruntLeader()
					// add health depending on what npc it spawning with
					//int leaderHealth = GetSpecialistLeaderHealth( team, ent )
					// add health depending on current team's spawn level
					int leaderHealth = GetSpecialistLeaderHealth( team )
					//print( "RUNNING ExtraSpawner_SpawnSpecialistGruntDropPod()" )
					//print( "leaderHealth is: " + string( leaderHealth ) )
					if ( ShouldSpawnDropship( ent ) )
					{
						entity node = FindBestSpawnForNPCDrop( dropshipPoints, team, 15 )
						UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
						thread ExtraSpawner_SpawnSpecialistGruntDropShip( node.GetOrigin(), node.GetAngles(), team, "npc_soldier", 4, leaderSet, leaderHealth )
						continue
					}
					
					entity node = FindBestSpawnForNPCDrop( droppodPoints, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, ent, leaderSet, leaderHealth )
				}
				else
				{
					if ( ShouldSpawnDropship( ent ) )
					{
						entity node = FindBestSpawnForNPCDrop( dropshipPoints, team, 15 )
						UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
						if ( ent == "npc_stalker" ) // more powerful stalker spawn
							thread ExtraSpawner_SpawnOverloadedStalkerDropShip( node.GetOrigin(), node.GetAngles(), team, SQUAD_SIZE )
						else
							thread ExtraSpawner_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, ent, SQUAD_SIZE )
						continue
					}

					entity node = FindBestSpawnForNPCDrop( droppodPoints, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					if ( ent == "npc_stalker" ) // more powerful stalker spawn
						thread ExtraSpawner_SpawnOverloadedStalkerDropPod( node.GetOrigin(), node.GetAngles(), team )
					else
						thread ExtraSpawner_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
				}
			}

			wait 8.0 // wait after each spawn wave
		}

		// PROWLER SQUADS
		if ( file.prowlers[ index ] )
		{
			//print( "prowlerCount: " + string( prowlerCount ) )
			int squadsToSpawn = ( GetTeamNPCSpawnCountModifier( PROWLER_SQUADS_PER_TEAM, team ) * 4 - 2 - prowlerCount ) / 4
			if ( squadsToSpawn > 0 )
			{
				for ( int i = 0; i < squadsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetDropPod()
					points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_prowler" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//print( "RUNNING ExtraSpawner_SpawnProwlerSquadDropPod()" )
					thread ExtraSpawner_SpawnProwlerSquadDropPod( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerHeavyArmor( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()
		int gunshipCount = GetNPCArrayEx( "npc_gunship", team, -1, <0,0,0>, -1 ).len()
		int titanCount = 0
		foreach ( entity npc in GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ) )
		{
			if ( !IsValid( npc.GetBossPlayer() ) )
				titanCount += 1
		}

		// REAPERS
		if ( file.reapers[ index ] )
		{
			int reapersToSpawn = GetTeamNPCSpawnCountModifier( file.reaperCount, team ) - reaperCount
			if ( reapersToSpawn > 0 )
			{
				for ( int i = 0; i < reapersToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn

					array<entity> points = SpawnPoints_GetTitan()
					points.extend( GetTitanStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_super_spectre" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//thread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
					// crazy reaper
					string reaperSettings = "npc_super_spectre_aitdm"
					string tickSettings = "npc_frag_drone"
					if ( CoinFlip() ) // 50% change of spawning sp ticks, 50% chance spawning mp ticks
						tickSettings = "npc_frag_drone_throwable"
					
					thread ExtraSpawner_SpawnReaperCanLaunchTicks( node.GetOrigin(), node.GetAngles(), team, reaperSettings, tickSettings )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// GUNSHIPS
		if ( file.gunships[ index ] )
		{
			int gunshipsToSpawn = GetTeamNPCSpawnCountModifier( file.gunshipCount, team ) - gunshipCount
			if ( gunshipsToSpawn > 0 )
			{
				for ( int i = 0; i < gunshipsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetTitan()
					points.extend( GetTitanStartPoints() ) // add startpoints for fun!
					entity node = FindBestSpawnForNPCDrop( points, team, 12 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					thread ExtraSpawner_SpawnGunShip( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// TITANS
		if ( file.titans[ index ] )
		{
			int titansToSpawn = GetTeamNPCSpawnCountModifier( TITANS_PER_TEAM, team ) - titanCount
			if ( titansToSpawn > 0 )
			{
				for ( int i = 0; i < titansToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetTitan()
					points.extend( GetTitanStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_titan" )
					entity node = FindBestSpawnForNPCDrop( points, team, 10 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					thread ExtraSpawner_SpawnTitan( node.GetOrigin(), node.GetAngles(), team, true )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// PILOTS
		if ( file.pilots[ index ] )
		{
			int pilotsToSpawn = GetTeamNPCSpawnCountModifier( file.pilotCount, team ) - titanCount // count titans
			if ( pilotsToSpawn > 0 )
			{
				for ( int i = 0; i < pilotsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points
					points.extend( GetTitanStartPoints() )
					points.extend( SpawnPoints_GetTitan() ) // new added because we've made a spawnpoint search function
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_titan" )
					ValidateNPCSpawnpoints( points, "npc_pilot_elite" ) // validate points twice so we won't have any issue
					entity node = FindBestSpawnForNPCDrop( points, team, 15 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team )
					if ( ShouldSpawnBossTitan() ) 
					{
						string spawnName = GetBossTitanSpawnName( GetBossTitanSpawnTeam( team ) )
						thread ExtraSpawner_SpawnBossTitan( node.GetOrigin(), node.GetAngles(), team, spawnName )
					}
					else
						thread ExtraSpawner_SpawnPilotCanEmbark( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerNPCs( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		int marvinCount = GetNPCArrayEx( "npc_marvin", team, -1, <0,0,0>, -1 ).len()
		int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()

		// MARVINS
		if ( file.marvins[ index ] )
		{
			const int spawnAmount = 2 // spawn 2 marvins per droppod
			const string spawnEnt = "npc_marvin"
			int marvinsToSpawn = ( GetTeamNPCSpawnCountModifier( MARVINS_PER_TEAM, team ) * spawnAmount - 1 - marvinCount ) / spawnAmount
			if ( marvinsToSpawn > 0 )
			{
				for ( int i = 0; i < marvinsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetDropPod()
					points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_marvin" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt, spawnAmount )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// PROWLERS
		if ( file.prowlers[ index ] )
		{
			const int spawnAmount = 1 // spawn 1 prowler per droppod
			const string spawnEnt = "npc_prowler"
			int prowlersToSpawn = ( GetTeamNPCSpawnCountModifier( file.prowlerCount, team ) * spawnAmount - 1 - prowlerCount ) / spawnAmount
			if ( prowlersToSpawn > 0 )
			{
				for ( int i = 0; i < prowlersToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn

					array< entity > points = SpawnPoints_GetDropPod()
					points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_prowler" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt, spawnAmount )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

// Based on points tries to balance match
void function Escalate( int team )
{
	int score = GameRules_GetTeamScore( team )
	
	foreach ( AITdmEscalatorstruct escalator in file.levelEscalators )
	{
		if ( escalator.usedByTeams.contains( team ) ) // never run the same escalator for one team
			continue
		if ( score >= escalator.scoreRequired )
		{
			if ( escalator.spawnSettingsFunc != null )
				escalator.spawnSettingsFunc( team )
			escalator.usedByTeams.append( team )
		}
	}
}

//------------------------------------------------------

entity function FindBestSpawnForNPCDrop( array<entity> spawnPoints, int team, float timeSinceLastUsedCheck = 10 )
{
	array<entity> validSpawnPoints

	// modified: make a new function so ai gamemodes don't have to re-decide for each spawn
	// due to spawn points refactor, let's change back to older version
	entity zone = DecideSpawnZone_Generic( spawnPoints, team )
	//entity zone = GetCurrentSpawnZoneForTeam( team )

	if ( IsValid( zone ) )
	{
		foreach ( entity spawn in spawnPoints )
		{
			// spawn from too far shouldn't count!
			if ( Distance2D( spawn.GetOrigin(), zone.GetOrigin() ) > 4000 )
				continue
			
			// init like spawn.nut, so player can also get that
			if ( InitNPCSpawnpoint( spawn ) )
			{
				// not inited spawn must be valid. add it to array
				validSpawnPoints.append( spawn )
				continue // we continue to next point if we mark current one as valid
			}

			// only search for those are not used recently
			if ( Time() - spawn.s.lastUsedTime > timeSinceLastUsedCheck )
			{
				validSpawnPoints.append( spawn )
				continue
			}
		}
	}
	
	// no spawn zone valid or we can't find any valid point in zone...
	// let's just find from all given points!!
	if ( validSpawnPoints.len() == 0 )
	{
		foreach ( entity spawn in spawnPoints )
		{
			// init like spawn.nut, so player can also get that
			if ( InitNPCSpawnpoint( spawn ) )
			{
				// not inited spawn must be valid. add it to array
				validSpawnPoints.append( spawn )
				continue // we continue to next point if we mark current one as valid
			}

			if ( Time() - spawn.s.lastUsedTime > timeSinceLastUsedCheck )
			{
				validSpawnPoints.append( spawn )
				continue
			}
		}
	}

	// wait what... we can't find any valid point, maybe too many entities spawning together
	// let's use all points instead...
	if ( validSpawnPoints.len() == 0 )
	{
		validSpawnPoints = spawnPoints
	}

	return validSpawnPoints[ RandomInt( validSpawnPoints.len() ) ]
}

// return true if "lastUsedTime" not in point.s
bool function InitNPCSpawnpoint( entity point )
{
	if ( !( "lastUsedTime" in point.s ) )
	{
		point.s.lastUsedTime <- -999
		return true
	}

	return false
}

void function UpdateNPCSpawnLastUsedTime( entity point )
{
	InitNPCSpawnpoint( point )

	point.s.lastUsedTime = Time()
}

// this function now gets all valid start points for droppod
// for regular cases we use SpawnPoints_GetDropPodStart( team )
array<entity> function GetDroppodStartPoints()
{
	//return GetEntArrayByClass_Expensive( "info_spawnpoint_droppod_start" )
	array<entity> allDroppodStarts
	allDroppodStarts.extend( SpawnPoints_GetDropPodStart( TEAM_IMC ) )
	allDroppodStarts.extend( SpawnPoints_GetDropPodStart( TEAM_MILITIA ) )
	return allDroppodStarts
}

array<entity> function GetTitanStartPoints()
{
	array<entity> allTitanStarts
	allTitanStarts.extend( SpawnPoints_GetTitanStart( TEAM_IMC ) )
	allTitanStarts.extend( SpawnPoints_GetTitanStart( TEAM_MILITIA ) )
	return allTitanStarts
}

//------------------------------------------------------

// Award for hacking
// can't name it "OnNPCLeeched()" because there's a deprecated function with same name... and it's globalized. yay.
void function AITdmExtend_OnNPCLeeched( entity npc, entity player )
{
	// Set Owner so we can filter in HandleScore
	// not a good idea. score could be handled by GetBossPlayer()
	// setting an owner will make entity have no collision with their owner
	//npc.SetOwner( player )
	// wait what???? in vanilla you CAN kill your leeched npcs
	// that's quiet more funnier than you can hack them multiple times
	//npc.ai.preventOwnerDamage = true // this is required so we don't kill our spectres

	// adding score, same as killing the target does
	// they can be re-hacked and we need to prevent gain score multiple times
	if ( !( "givenAttritionScore" in npc.s ) )
	{
		// start adding score
		int scoreToAdd = AITdmExtend_GetScoreValue( npc )
		if ( scoreToAdd > 0 )
			AddAITdmTeamScore( player, scoreToAdd )

		npc.s.givenAttritionScore <- true // mark the npc as already given score to player
	}

	// disable leech on this spectre, don't let them to be multiple-leeched by diffrent team...
	// reverted. it is vanilla behavior! and it's pretty funny
	//DisableLeeching( npc )
	//npc.UnsetUsable()
}

// ticks clean up
void function CleanUpOverloadedTicks()
{
	thread CleanUpOverloadedTicks_Threaded()
}

void function CleanUpOverloadedTicks_Threaded()
{
	int maxTicks = file.reaperCount * 2 * 4 + 2 // clean up ticks spawned by reapers
	//maxTicks += int( file.squadCountHighLevel * 1.5 ) // add some space for specialist grunt spawned ticks

	while ( true )
	{
		array<entity> tickArray
		foreach ( entity tick in GetNPCArrayByClass( "npc_frag_drone" ) )
		{
			if ( !IsAlive( tick ) )
				continue
			
			// player owned tick?
			if ( IsValid( tick.GetBossPlayer() ) )
				continue

			// still arming up?
			if ( !tick.ai.fragDroneArmed )
				continue

			// pending explode?
			if ( tick.Anim_IsActive() )
				continue

			tickArray.append( tick )
		}

		if( tickArray.len() > maxTicks )
		{
			// clean up first spawned tick in array
			// validation checks already done
			//tickArray[0].Signal( "SuicideSpectreExploding" ) // this will make them explode
			tickArray[0].Signal( "SuicideSpectreForceExplode" ) // signal "SuicideSpectreExploding" will cause ticks already ignited to explode instantly, which makes player unable to react...
		}

		WaitFrame()
	}
}

// npc clean up
void function TryCleanupBoredNPCGameLong()
{
	thread TryCleanupBoredNPCGameLong_Threaded()
}

// npc cleanup
const float NPC_CLEANUP_INITIAL_WAIT_TIME = 15.0 // some npcs will stand still for proximity 10s... due to my bad squadhandler logic, I think
const float NPC_CLEANUP_REQUIRED_IDLE_TIME = 15.0 // bit shorter than grunt mode because in normal gamemodes players can move faster... maybe?

void function TryCleanupBoredNPCGameLong_Threaded()
{
	// keep searching new npcs and run CleanupBoredNPCThread() for them
	while ( true )
	{
		foreach ( entity npc in GetNPCArray() )
		{
			if ( npc.GetClassName() == "npc_marvin" ) // never clean up marvins
				continue

			if ( !IsAlive( npc ) )
				continue

			// first time init
			if ( !( npc in file.npcCleanUpStartTime ) )
				file.npcCleanUpStartTime[ npc ] <- Time()
			if ( !( npc in file.npcIdleStartTime ) )
				file.npcIdleStartTime[ npc ] <- -1
			if ( !( npc in file.npcLastTickOrigin ) )
				file.npcLastTickOrigin[ npc ] <- npc.GetOrigin()

			if ( !( npc in file.npcWaitingToBeCleanUp ) )
			{
				file.npcWaitingToBeCleanUp[ npc ] <- false
				continue // first time init -- always skip because npc needs to be set into dropship/pod
			}

			if ( file.npcWaitingToBeCleanUp[ npc ] ) // this means our think for this npc is already done
				continue

			// cover spawning time from dropship/pod + before we start cleaning up
			if ( IsValid( npc.GetParent() ) || npc.e.isHotDropping )
				continue

			// init time
			float timeSinceCleanUpStart = Time() - file.npcCleanUpStartTime[ npc ]
			if ( timeSinceCleanUpStart < NPC_CLEANUP_INITIAL_WAIT_TIME )
				continue
			
			// npc already damaged, never clean up them( I guess? )
			// they can still get stuck after taking damage, I think...
			/*
			if ( npc.GetHealth() != npc.GetMaxHealth() )
			{
				file.npcWaitingToBeCleanUp[ npc ] = true // this npc will skip all checks
				continue
			}
			*/

			// start thinking
			if ( npc.Anim_IsActive() ) // anim active, such as marvin doing a job or npc being executed
				continue
			
			if ( npc.IsFrozen() ) // frozen guy, no need to clean them up
				continue

			// if the npc is owned by anyone, or has a bossplayer, we skip checks
			entity owner = npc.GetOwner()
			entity bossPlayer = npc.GetBossPlayer()
			if ( IsValid( owner ) )
				continue
			if ( IsValid( bossPlayer ) )
				continue

			// if npc is a titan with bubbleshield, we skip checks
			// also skip if titan already doomed
			if ( npc.IsTitan() )
			{
				entity soul = npc.GetTitanSoul()
				if( IsValid( soul ) )
				{
					// they can still get stuck after doomed, I think...
					/*
					if ( GetDoomedState( npc ) )
					{
						file.npcWaitingToBeCleanUp[ npc ] = true // this npc will skip all checks
						continue
					}
					*/

					entity bubbleShield = soul.soul.bubbleShield
					if ( IsValid( bubbleShield ) )
						continue
				}
			}

			array<entity> otherGuys = GetPlayerArray()
			otherGuys.extend( GetNPCArrayOfEnemies( npc.GetTeam() ) )

			bool failedChecks = false
			foreach ( entity otherGuy in otherGuys )
			{
				// skip dead people
				if ( !IsAlive( otherGuy ) )
					continue

				// don't kill if too close to anything
				if ( Distance( otherGuy.GetOrigin(), npc.GetOrigin() ) < 2000.0 )
					break

				// don't kill if ai or players can see them
				if ( otherGuy.IsPlayer() )
				{
					if ( PlayerCanSee( otherGuy, npc, true, 135 ) )
						break
				}
				else
				{
					if ( otherGuy.CanSee( npc ) )
						break
				}

				// don't kill if they can see any ai
				if ( npc.CanSee( otherGuy ) )
					break

				failedChecks = true
			}

			if ( !IsAlive( npc.GetEnemy() ) 
				&& Distance( npc.GetOrigin(), file.npcLastTickOrigin[ npc ] ) <= 64 
				) // assume they're not moving nor combating
				failedChecks = true // mark as checks failed

			// record last tick origin
			file.npcLastTickOrigin[ npc ] = npc.GetOrigin()

			if ( failedChecks )
			{
				if ( file.npcIdleStartTime[ npc ] == -1 )
				{
					file.npcIdleStartTime[ npc ] = Time()
					continue
				}
			}
			else // idle invalid!
			{
				file.npcIdleStartTime[ npc ] = -1
				continue
			}

			// idle time not enough!
			float timeSinceIdleStart = Time() - file.npcIdleStartTime[ npc ]
			if ( timeSinceIdleStart < NPC_CLEANUP_REQUIRED_IDLE_TIME )
				continue

			// all checks done!
			file.npcWaitingToBeCleanUp[ npc ] = true // no longer run thinks on this npc
			//print( "cleaning up bored npc: " + npc + " from team " + npc.GetTeam() )

			HideName( npc ) // prevent their title or health bar from showing
			TakeAllWeapons( npc ) // so they won't have a weapon floating
			
			npc.EnableNPCFlag( NPC_IGNORE_ALL ) // disable any sensing
			if ( IsValid( npc.GetEnemy() ) ) // clear out current enemy( basically for prowlers because they aren't affected by NPC_IGNORE_ALL )
				npc.ClearEnemy()
			
			// add invulnerability
			npc.SetNoTarget( true ) // disable npc targeting
			npc.SetNoTargetSmartAmmo( true ) // disable smart ammo targeting
			npc.NotSolid() // disable collision
			npc.SetInvulnerable()

			// clean up highlights
			npc.e.hasDefaultEnemyHighlight = false // no longer runs default highlight function!
			Highlight_ClearEnemyHighlight( npc )
			Highlight_ClearFriendlyHighlight( npc )

			// titan being dissolved
			if ( npc.IsTitan() )
			{
				TitanBoredToCleanUp( npc )
			}
			// reaper being dissolved
			if ( npc.GetClassName() == "npc_super_spectre" )
			{
				ReaperBoredToCleanUp( npc )
			}

			// remove any attack behavior
			npc.SetCapabilityFlag( bits_CAP_MOVE_SHOOT, false )
			npc.SetCapabilityFlag( bits_CAP_AIM_GUN, false )
			npc.SetCapabilityFlag( bits_CAP_WEAPON_RANGE_ATTACK1, false )
			npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1, false )
			npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK2, false )
			npc.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false )
			npc.SetCapabilityFlag( bits_CAP_MOVE_TRAVERSE, false )

			npc.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 ) // dissolve them to have better visual

			// prowler being dissolved
			// prowler being fully dissolved can crash the game?????
			// like changing hullType for them... too bad!
			// we try to destroy them while they not getting fully dissolved
			// tested something, without this check things still go right...
			// don't know why it was crashing so often
			if ( npc.GetClassName() == "npc_prowler" )
			{
				thread DelayedDestroyProwler( npc )
			}
		}
		WaitFrame()
	}
}

void function TitanBoredToCleanUp( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if( IsValid( soul ) )
	{
		// end any rodeo on it
		ForceTitanRodeoToEnd( titan )
		DisableTitanRodeo( titan )
		// try to hide a cleaning up titan's batteryContainer
		entity batteryContainer = soul.soul.batteryContainer
		if ( IsValid( batteryContainer ) )
			batteryContainer.Hide()
	}
}

void function ReaperBoredToCleanUp( entity reaper )
{
	// detonate all frag drones they owned
	if ( reaper.ai.activeMinionEntArrayID > 0 )
	{
		foreach ( entity ent in GetScriptManagedEntArray( reaper.ai.activeMinionEntArrayID ) )
		{
			if ( IsValid( ent ) ) 
			{
				if ( ent.IsNPC() && ent.ai.fragDroneArmed )
					ent.Signal( "SuicideSpectreForceExplode" ) // signal "SuicideSpectreExploding" will cause ticks already ignited to explode instantly, which makes player unable to react...
				else // minion still a grenade, or not armed ready yet... just destroy
				{
					if ( ent.IsProjectile() )
						ent.Destroy()
					else if ( ent.IsNPC() && !ent.ai.fragDroneArmed )
					{
						ent.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
						ent.SetNoTarget( true )
						ent.EnableNPCFlag( NPC_IGNORE_ALL )
						ent.NotSolid()
						ent.SetInvulnerable() // can still take radius damage after nonsolid!
					}
				}
			}
		}
	}
}

void function DelayedDestroyProwler( entity prowler )
{
	// needs to be thread off
	// try to destroy them while they not getting fully dissolved
	prowler.EndSignal( "OnDestroy" )

	wait 1.0
	prowler.DissolveStop() // prevent it crashes server
	prowler.Destroy()
}