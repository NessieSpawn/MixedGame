// basically a copy of gruntmode. with only npcs spawns, players are still pilots

untyped
global function Modded_Gamemode_AITdm_Extended_Init

// npc counts default value
// can be modified by playlistvar
const int SQUADS_PER_TEAM = 5
//const int SQUADS_PER_TEAM_MORE_PLAYERS = 3 // maybe do reduced squad if we have more players and reached higher level
const int SQUADS_PER_TEAM_HIGH_LEVEL = 3 // maybe do reduced squad if we have reached higher level

const int MARVINS_PER_TEAM = 0
const int PROWLERS_PER_TEAM = 4
const int PROWLER_SQUADS_PER_TEAM = 0 // prowler squad: 2 cqb prowler with 3 small prowlers

const int REAPERS_PER_TEAM = 2 // was 3, reduced reaper spawn since we're using tick spawner reapers
const int GUNSHIPS_PER_TEAM = 2

const int PILOTS_PER_TEAM = 3
const int TITANS_PER_TEAM = 0

// escalator default value
// can be modified by playlistvar
const int LEVEL_SPECTRES = 80
const int LEVEL_STALKERS = 150
const int LEVEL_REAPERS = 230
//const int LEVEL_GUNSHIPS = 280 // has been merged to reaper spawns
const int LEVEL_TITANS = 330

// scores
const int PLAYER_SCORE_AMOUNT = 5
const int PILOT_SCORE_AMOUNT = 5
const int GUNSHIP_SCORE_AMOUNT = 5
const int MARVIN_SCORE_AMOUNT = 1
const int GRUNT_SCORE_AMOUNT = 1
const int SPECIALIST_GRUNT_SCORE_AMOUNT = 2
const int SPECTRE_SCORE_AMOUNT = 1 // was 2. spectres shouldn't have too many score
const int STALKER_SCORE_AMOUNT = 2
const int PROWLER_SCORE_AMOUNT = 2
const int SMALL_PROWLER_SCORE_AMOUNT = 1
const int REAPER_SCORE_AMOUNT = 5
const int DRONE_SCORE_AMOUNT = 0
const int TITAN_SCORE_AMOUNT = 10

// fake coop
// npc spawn
const float FAKE_COOP_PLAYER_TEAM_NPC_PERCENT = 0.7 // 3-2 squads, 2 prowlers, 1 reaper and gunship, 2 titans
const float FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MIN = 1.0
const float FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_INCREMENT = 0.5 // 4 players = max spawn
const float FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MAX = 2.5 // 12-7 squads, 10 prowlers, 5 reapers and gunships, 7 titans
// scoring
const float FAKE_COOP_PLAYER_PILOT_SCORE_MULTIPLIER = 2.0 // gets applied on npc killing player team pilot
const float FAKE_COOP_PLAYER_TITAN_SCORE_MULTIPLIER = 3.0 // gets applied on npc killing player team titan

// struct used by function Escalate()
struct AITdmEscalatorstruct
{
	int scoreRequired
	void functionref( int team ) spawnSettingsFunc
	array<int> usedByTeams
}

struct
{
	// Due to team based escalation everything is an array

	// reworked to use structs
	//array< int > levels = [] //[ LEVEL_SPECTRES, LEVEL_SPECTRES ] // modified, since we added playlistvar should leave this init inside functions
	array<AITdmEscalatorstruct> levelEscalators

	// spawn contents
	array< array< string > > podEntities = [ [ "npc_soldier" ], [ "npc_soldier" ] ] // also handling spectres and stalkers
	
	array< bool > marvins = [ false, false ] // bind with spectres

	array< bool > prowlers = [ false, false ] // bind with stalkers

	array< bool > reapers = [ false, false ]
	array< bool > gunships = [ false, false ] // bind with reapers

	array< bool > titans = [ false, false ]
	array< bool > pilots = [ false, false ] // bind with titans


	// spawn settings
	int squadCount
	int squadCountHighLevel
	int prowlerCount
	int reaperCount
	int gunshipCount
	int pilotCount
	// escalator settings
	int levelSpectres
	int levelStalkers
	int levelReapers
	int levelTitans

	// fake coop
	// npc spawn
	float friendlyNPCPercent
	float enemyNPCMinPercent
	float enemyNPCIncrementPerPlayer
	float enemyNPCMaxPercent
	// scoring
	float teamPilotScoreMultiplier
	float teamTitanScoreMultiplier
} file


void function Modded_Gamemode_AITdm_Extended_Init()
{
	SetSpawnpointGamemodeOverride( ATTRITION ) // use bounty hunt spawns as vanilla game has no spawns explicitly defined for aitdm

	AddCallback_GameStateEnter( eGameState.Prematch, OnPrematchStart )
	AddCallback_GameStateEnter( eGameState.Playing, OnPlaying )

	// scoring
	SetUpAITdmExtendedScoreEvent() // score setup
	AddCallback_OnPlayerKilled( HandleScoreForPlayerOrNPCKill )
	AddCallback_OnNPCKilled( HandleScoreForPlayerOrNPCKill )
	// modified callback in _score.nut: for handling doomed health loss titans
	AddCallback_TitanDoomedScoreEvent( HandleTitanDoomedScore )

	AddCallback_OnClientConnected( OnPlayerConnected )

	AddCallback_NPCLeeched( AITdmExtend_OnNPCLeeched )

    // game settings
	Highlight_SetCustomHighlightFunction( AITdmExtend_Highlight ) // highlight handle for phase shift and such
    // npc executions
	MeleeSyncedNPC_EnableAll_Init() // npc executions for fun

    // ai configs
	AddSpawnCallback( "npc_soldier", GruntConfig )
	AddSpawnCallback( "npc_pilot_elite", PilotConfig )
	AddSpawnCallback( "npc_marvin", MarvinConfig )
	AddSpawnCallback( "npc_prowler", ProwlerConfig )
	AddSpawnCallback( "npc_spectre", SpectreConfig )
	AddSpawnCallback( "npc_stalker", StalkerConfig )
	AddSpawnCallback( "npc_super_spectre", ReaperConfig )
	AddSpawnCallback( "npc_titan", TitanConfig )
	AddSpawnCallback( "npc_drone", DroneConfig )
	AddSpawnCallback( "npc_gunship", GunshipConfig )
	AddSpawnCallback( "npc_dropship", DropshipConfig )
	AddSpawnCallback( "npc_frag_drone", TickConfig )
	AddSpawnCallback( "npc_turret_sentry", TurretConfig )

	// ai damages
	DamageUtility_EnableNPCLocationBasedDamage( true ) // modified function in sh_damage_utility.gnut. allow npcs to deal headshot damages

	// tempfix specifics
	SetShouldPlayDefaultMusic( true ) // play music when score or time reaches some point
	EarnMeterMP_SetPassiveGainProgessEnable( true ) // enable earnmeter gain progressing like vanilla


	// init npc spawn settings
	InitModdedSpawnSettings()
}

void function InitModdedSpawnSettings()
{
	// update settings from playlistvar, with default values implemented
	file.squadCount = GetCurrentPlaylistVarInt( "modaitdm_squad_count", SQUADS_PER_TEAM )
	file.squadCountHighLevel = GetCurrentPlaylistVarInt( "modaitdm_squad_count", SQUADS_PER_TEAM_HIGH_LEVEL )
	file.prowlerCount = GetCurrentPlaylistVarInt( "modaitdm_prowler_count", PROWLERS_PER_TEAM )
	file.reaperCount = GetCurrentPlaylistVarInt( "modaitdm_reaper_count", REAPERS_PER_TEAM )
	file.gunshipCount = GetCurrentPlaylistVarInt( "modaitdm_gunship_count", GUNSHIPS_PER_TEAM )
	file.pilotCount = GetCurrentPlaylistVarInt( "modaitdm_pilot_count", PILOTS_PER_TEAM )

	file.levelSpectres = GetCurrentPlaylistVarInt( "modaitdm_spectre_spawn_score", LEVEL_SPECTRES )
	file.levelStalkers = GetCurrentPlaylistVarInt( "modaitdm_stalker_spawn_score", LEVEL_STALKERS )
	file.levelReapers = GetCurrentPlaylistVarInt( "modaitdm_reaper_spawn_score", LEVEL_REAPERS )
	file.levelTitans = GetCurrentPlaylistVarInt( "modaitdm_titan_spawn_score", LEVEL_TITANS )
	// reworked to use Escalator_Init()
	//file.levels = [ file.levelSpectres, file.levelSpectres ] // init levels

	// fake coop
	// everything is based on GetPlayerArray()[0]( listen server host, or the first joined player )
	if ( GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1 )
	{
		// npc spawn
		file.friendlyNPCPercent = GetCurrentPlaylistVarFloat( "aitdm_coop_friendly_npc_percent", FAKE_COOP_PLAYER_TEAM_NPC_PERCENT )
		file.enemyNPCMinPercent = GetCurrentPlaylistVarFloat( "aitdm_coop_enemy_npc_min_percent", FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MIN )
		file.enemyNPCIncrementPerPlayer = GetCurrentPlaylistVarFloat( "aitdm_coop_enemy_npc_increment_per_player", FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_INCREMENT )
		file.enemyNPCMaxPercent = GetCurrentPlaylistVarFloat( "aitdm_coop_enemy_npc_max_percent", FAKE_COOP_ENEMY_TEAM_NPC_PERCENT_MAX )

		// scoring
		file.teamPilotScoreMultiplier = GetCurrentPlaylistVarFloat( "aitdm_coop_pilot_score_multiplier", FAKE_COOP_PLAYER_PILOT_SCORE_MULTIPLIER )
		file.teamTitanScoreMultiplier = GetCurrentPlaylistVarFloat( "aitdm_coop_titan_score_multiplier", FAKE_COOP_PLAYER_TITAN_SCORE_MULTIPLIER )

		// start updating all player's team
		UpdateCOOPPlayerTeam()
	}

	// all values init done, start init escatator
	Escalator_Init()
}

// init the structs used in function Escalate()
void function Escalator_Init()
{
	// spectres and marvins
	AITdmEscalatorstruct spectreSpawn
	spectreSpawn.scoreRequired = file.levelSpectres
	spectreSpawn.spawnSettingsFunc = SpawnLevel_Spectre
	file.levelEscalators.append( spectreSpawn )

	// stalkers and prowlers
	AITdmEscalatorstruct stalkerSpawn
	stalkerSpawn.scoreRequired = file.levelStalkers
	stalkerSpawn.spawnSettingsFunc = SpawnLevel_Stalker
	file.levelEscalators.append( stalkerSpawn )

	// reapers and gunships
	AITdmEscalatorstruct reaperSpawn
	reaperSpawn.scoreRequired = file.levelReapers
	reaperSpawn.spawnSettingsFunc = SpawnLevel_Reaper
	file.levelEscalators.append( reaperSpawn )

	// titans and pilots
	AITdmEscalatorstruct titanSpawn
	titanSpawn.scoreRequired = file.levelTitans
	titanSpawn.spawnSettingsFunc = SpawnLevel_Titan
	file.levelEscalators.append( titanSpawn )
}

void function SpawnLevel_Spectre( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	file.podEntities[ index ].append( "npc_spectre" ) // add spectres into droppod and dropship
	file.marvins[ index ] = true // enable marvin spawn
	SetGlobalNetInt( defcon, 2 ) // Enemy Spectres Incoming
}

void function SpawnLevel_Stalker( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	//file.marvins[ index ] = false // never remove marvin spawns ;)
	file.podEntities[ index ].append( "npc_stalker" ) // add stalkers into droppod and dropship
	file.prowlers[ index ] = true // enable prowler spawn
	SetGlobalNetInt( defcon, 3 ) // Enemy Stalkers Incoming
}

void function SpawnLevel_Reaper( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	file.reapers[ index ] = true // enable reaper spawn
	file.gunships[ index ] = true // enable gunship spawn
	SetGlobalNetInt( defcon, 4 ) // Enemy Reapers Incoming

	// start cleanup ticks spawned by reapers( might also clean up specialist grunt ticks )
	CleanUpOverloadedTicks()
}

void function SpawnLevel_Titan( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	// level spawn content
	file.titans[ index ] = true // enable titan spawn
	file.pilots[ index ] = true // enable npc pilot spawn
	SetGlobalNetInt( defcon, 6 ) // this will show nothing
}
//

void function AITdmExtend_Highlight( entity ent )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( ent )

	// highlights think
	string className = ent.GetClassName()
	switch ( className )
	{
		case "npc_pilot_elite":
			ent.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
			Highlight_SetEnemyHighlight( ent, "enemy_player" )
			break
		case "npc_super_spectre":
		case "npc_gunship":
			ent.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
			Highlight_SetEnemyHighlight( ent, "enemy_titan" )
			break

		default:
			// default highlight setting
			if ( ent.IsTitan() )
				Highlight_SetEnemyHighlight( ent, "enemy_player" )
			else
				Highlight_SetEnemyHighlight( ent, "enemy_player" )
			break
	}
}

void function AITdmExtend_FriendlyHighlight( entity ent )
{
	// sp_enemy_pilot kinda bad, visible through viewmodel
	//Highlight_SetFriendlyHighlight( ent, "sp_enemy_pilot" )
	Highlight_SetFriendlyHighlight( ent, "sp_friendly_pilot" )
	ent.Highlight_SetParam( 1, 0, < 2, 2, 2 > )
}

// used for high threat npcs such as tick
void function AITdmExtend_EnemyThreatenHighlight( entity ent )
{
	Highlight_SetEnemyHighlight( ent, "sp_enemy_pilot" )
	ent.Highlight_SetParam( 2, 0, < 2, 0, 0 > )
}


// fake coop utility
// leader player: GetPlayerArray()[0]( listen server host, or the first joined player )
entity function GetCOOPLeaderPlayer()
{
	if ( GetPlayerArray().len() >= 1 )
		return GetPlayerArray()[0]

	return null
}

// npc spawn count modifier
int function GetTeamNPCSpawnCountModifier( int expectedSpawn, int team = -1 )
{
	bool coopEnabled = GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1
	entity coopLeader = GetCOOPLeaderPlayer()
	if ( team > TEAM_UNASSIGNED && coopEnabled && IsValid( coopLeader ) )
	{
		// friendly team
		if ( team == coopLeader.GetTeam() )
			return int( float( expectedSpawn ) * file.friendlyNPCPercent )
		else // enemy team
		{
			int playersOtherThanLeader = GetPlayerArray().len() - 1
			float npcSpawnModifier = file.enemyNPCMinPercent + ( file.enemyNPCIncrementPerPlayer * playersOtherThanLeader )
			npcSpawnModifier = min( file.enemyNPCMaxPercent, npcSpawnModifier )
			// debug
			//print( "spawnModifier: " + string( int( float( expectedSpawn ) * npcSpawnModifier ) ) )
			return int( float( expectedSpawn ) * npcSpawnModifier )
		}
	}

	return expectedSpawn // no modifier, just return default value
}

// player team updating
void function UpdateCOOPPlayerTeam()
{
	thread UpdateCOOPPlayerTeam_Threaded()
}

void function UpdateCOOPPlayerTeam_Threaded()
{
	while ( true )
	{
		WaitFrame()

		entity leaderPlayer = GetCOOPLeaderPlayer()
		if ( !IsValid( leaderPlayer ) )
			continue

		int leaderTeam = leaderPlayer.GetTeam()
		foreach ( entity player in GetPlayerArray() )
		{
			if ( player.GetTeam() != leaderTeam )
				SetTeam( player, leaderTeam )
		}
	}	
}

////////////////////////////////
///// NPC CONFIG FUNCTIONS /////
////////////////////////////////

// hardcoded here
const array<string> SPECIALIST_GRUNTS =
[
	"npc_soldier_shield_captain",
	"npc_soldier_drone_summoner",
	"npc_soldier_sidearm",
	"npc_soldier_pve_eliteguard",
]

const array<string> SPECIALIST_GRUNTS_RARE = // specialist class in this array will have less picking rate
[
	"npc_soldier_shield_captain",
]

void function GruntConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// hardcoded here
	string aiSetName = soldier.GetAISettingsName()
	bool isSpecialistGrunt = SPECIALIST_GRUNTS.contains( aiSetName )
	if ( !isSpecialistGrunt ) // normal grunts
	{
		soldier.SetMaxHealth( 80 )
		soldier.SetHealth( 80 )
	}
	
	thread GruntTitleThink( soldier ) // specialist grunts may spawn from dropship, do a think here

	// grunt executions: 
	Melee_SetExecutionRefsOverride( 
		soldier, 
		// execution_face_stab_combat is a modified execution ref
		["execution_neck_snap", "execution_face_stab_combat", "execution_backshot"]
	)
}

void function GruntTitleThink( entity soldier )
{
	soldier.EndSignal( "OnDestroy" )
	soldier.EndSignal( "OnDeath" )

	float endTime = Time() + 5
	while ( Time() <= endTime )
	{
		WaitFrame()
		string aiSetName = soldier.GetAISettingsName()
		bool isSpecialistGrunt = SPECIALIST_GRUNTS.contains( aiSetName )
		if ( !isSpecialistGrunt )
			continue
		WaitFrame() // they may get a title from spawn function, we wait a frame before changing again
		soldier.SetTitle( GetMilitiaTitle() ) // funny in _ai_soldiers.gnut
		return
	}
}

void function PilotConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// pilot executions: 
	Melee_SetExecutionRefsOverride( 
		soldier, 
		["execution_telefrag", "execution_stim", "execution_grapple", "execution_pulseblade", "execution_cloak", "execution_holopilot", "execution_ampedwall"]
	)
}

void function MarvinConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 300 )
	soldier.SetHealth( 300 )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function ProwlerConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// so they won't block teammates( won't work )
	// actually it's pretty fun seeing them collide with player titans
	//soldier.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER
	// this can fix their collision
	// no this can't!!! it crashes server immediately
	//soldier.SetHullType( "HULL_HUMAN" )

	soldier.SetMaxHealth( 350 )
	soldier.SetHealth( 350 )
}

void function SpectreConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 190 )
	soldier.SetHealth( 190 )

	// spectre executions: 
	Melee_SetExecutionRefsOverride( 
		soldier, 
		["execution_combo", "execution_knockout"]
	)
}

void function StalkerConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 350 ) // they gets disarmed by shooting weakpoint though
	soldier.SetHealth( 350 )
}

void function ReaperConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// even stronger
	soldier.SetMaxHealth( 5500 ) // was 5000
	soldier.SetHealth( 5500 )
}

void function TitanConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )
}

void function DroneConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )
}

void function GunshipConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetMaxHealth( 5850 ) // was 7500, but we've made them less likely to be targeted...
	soldier.SetHealth( 5850 ) // was 7500, but we've made them less likely to be targeted...

	//soldier.SetNoTarget( true ) // don't want other npcs targeting them
	soldier.SetNPCPriorityOverride( 10 ) // they're flying around, don't want other npcs targeting them very often
}

void function DropshipConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	soldier.SetNoTarget( true ) // don't want other npcs targeting them
}

void function TickConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )

	// enemy highlight
	AITdmExtend_EnemyThreatenHighlight( soldier )
}

void function TurretConfig( entity soldier )
{
	// friendly highlight
	AITdmExtend_FriendlyHighlight( soldier )
}

////////////////////////////////////
///// NPC CONFIG FUNCTIONS END /////
////////////////////////////////////



//////////////////////////////////////////
///// EXTRASPAWNER SETTINGS FUNCTION /////
//////////////////////////////////////////

void function InitExtraSpawnerSettings()
{
	// changed r201 to r101. they just looks better
	ExtraSpawner_SetNPCWeapons( "npc_soldier", ["mp_weapon_rspn101_og", "mp_weapon_lmg", "mp_weapon_shotgun", "mp_weapon_r97", "mp_weapon_dmr", "mp_weapon_car", "mp_weapon_vinson"] )
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_soldier", ["mp_weapon_rocket_launcher", "mp_weapon_mgl"] )
	ExtraSpawner_SetNPCGrenadeWeapons( "npc_soldier", ["mp_weapon_frag_grenade", "mp_weapon_thermite_grenade", "mp_weapon_grenade_electric_smoke", "mp_weapon_grenade_emp"] )
	// nerf dmr damage cause we enabled npc headshots, increase archer damage against titans
	ExtraSpawner_SetNPCExtraWeaponMods( "npc_soldier", ["npc_lower_damage", "multiplayer_npc_launcher"] )

	ExtraSpawner_SetNPCWeapons( "npc_spectre", ["mp_weapon_mastiff", "mp_weapon_doubletake", "mp_weapon_hemlok_smg", "mp_weapon_hemlok", "mp_weapon_lstar", "mp_weapon_g2"] )
	// removed arc launcher cuz they're bit too powerful
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_spectre", ["mp_weapon_mgl", "mp_weapon_defender"] )
	// spectres don't throw grenades, just keep here
	//ExtraSpawner_SetNPCGrenadeWeapons( "npc_spectre", ["mp_weapon_frag_grenade", "mp_weapon_thermite_grenade", "mp_weapon_grenade_emp"] )

	ExtraSpawner_SetNPCWeapons( "npc_pilot_elite", ["mp_weapon_rspn101_og", "mp_weapon_r97", "mp_weapon_lmg", "mp_weapon_car", "mp_weapon_hemlok_smg", "mp_weapon_hemlok", "mp_weapon_g2", "mp_weapon_vinson", "mp_weapon_doubletake", "mp_weapon_lstar"] )
	// only re-45 and p2016 don't have "hcog" mod included... using them is good enough
	ExtraSpawner_SetNPCSecondaryWeapons( "npc_pilot_elite", ["mp_weapon_autopistol", "mp_weapon_semipistol"] )
	ExtraSpawner_SetNPCAntiTitanWeapons( "npc_pilot_elite", ["mp_weapon_rocket_launcher", "mp_weapon_mgl", "mp_weapon_arc_launcher", "mp_weapon_defender"] )
	// npcs cannot use gravity star
	// CAI_BaseNPC::NPCInitWeapons - Could not create anymore shared grenade weapons, max 5. Tried to create 'mp_weapon_grenade_gravity'
	ExtraSpawner_SetNPCGrenadeWeapons( "npc_pilot_elite", ["mp_weapon_frag_grenade", "mp_weapon_thermite_grenade", "mp_weapon_grenade_electric_smoke", "mp_weapon_grenade_emp"] )
	// increase archer damage against titans
	// for pilots, add optics, extended_ammo and pro_screen for their weapons. we've added npc weapon bodygroup update!(proscreen can't show xp count for a npc though)
	// aog goes first because spitfire and lstar both have holosight(lstar one is unfinished), wants to overwrite
	ExtraSpawner_SetNPCExtraWeaponMods( "npc_pilot_elite", ["multiplayer_npc_launcher", "hcog", "aog", "holosight", "scope_4x", "extended_ammo", "pro_screen"] )

	// npcs can't shoot "mp_weapon_pulse_lmg"
	ExtraSpawner_SetNPCWeapons( "npc_stalker", ["mp_weapon_softball", "mp_weapon_smr", "mp_weapon_epg"] )
	// should I just remove AT weapons for stalkers cuz they're using grenadier?
	//ExtraSpawner_SetNPCAntiTitanWeapons( "npc_stalker", ["mp_weapon_mgl", "mp_weapon_arc_launcher", "mp_weapon_defender"] )
	// balanced epg for multiplayer
	ExtraSpawner_SetNPCExtraWeaponMods( "npc_stalker", ["multiplayer_npc_grenadier"] )

	//AiDrone_SetDroneSpawnedByNPCRandomType( true ) // modified function in _ai_drone.nut, specialist grunts will spawn random drones
	//AiDrone_SetDroneSpawnedByNPCForceDie( true ) // modified function in _ai_drone.nut, drones spawned by npcs will be destroyed right after it's owner's death

	Wallrun_EnableProtectionForRodeoPlayerAgainstNPCs( false ) // modified function in class_wallrun.gnut. disable damage immune against npcs while rodeoing
}

//////////////////////////////////////////////
///// EXTRASPAWNER SETTINGS FUNCTION END /////
//////////////////////////////////////////////

void function SetUpAITdmExtendedScoreEvent()
{
	// pilot kill
	ScoreEvent_SetEarnMeterValues( "KillPilot", 0.10, 0.05 )
	ScoreEvent_SetEarnMeterValues( "EliminatePilot", 0.10, 0.05 )
	ScoreEvent_SetEarnMeterValues( "PilotAssist", 0.03, 0.020001, 0.0 ) // if set to "0.03, 0.02", will display as "4%"
	// titan doom
	ScoreEvent_SetEarnMeterValues( "DoomTitan", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "DoomAutoTitan", 0.0, 0.0 )
	// titan kill
	// don't know why auto titan kills appear to be no value in vanilla
	// even when the titan have an owner player
	ScoreEvent_SetEarnMeterValues( "KillTitan", 0.20, 0.10, 0.0 )
	ScoreEvent_SetEarnMeterValues( "KillAutoTitan", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "EliminateTitan", 0.20, 0.10, 0.0 )
	ScoreEvent_SetEarnMeterValues( "EliminateAutoTitan", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "TitanKillTitan", 0.0, 0.0 )
	// but titan assist do have earn values... 
	// maybe because they're not splitted into AutoTitan or PlayerTitan variant
	ScoreEvent_SetEarnMeterValues( "TitanAssist", 0.10, 0.10 )
	// rodeo
	ScoreEvent_SetEarnMeterValues( "PilotBatteryStolen", 0.0, 0.35, 0.0 )
	ScoreEvent_SetEarnMeterValues( "PilotBatteryApplied", 0.0, 0.35, 0.0 )
	// special method of killing
	ScoreEvent_SetEarnMeterValues( "Headshot", 0.0, 0.02, 0.0 )
	ScoreEvent_SetEarnMeterValues( "FirstStrike", 0.03, 0.020001, 0.0 ) // if set to "0.03, 0.02", will display as "4%"
	
	// ai
	// so here's a funny twist, respawn don't know "0.03, 0.02" will display as 4%
	// which means actual vanilla infantry value is 5% but it displays as 4%
	// (if you set earnmeter multiplier to 5.0 it displays as 24%, proving my thought)
	ScoreEvent_SetEarnMeterValues( "KillGrunt", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSpectre", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "LeechSpectre", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillHackedSpectre", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillStalker", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSuperSpectre", 0.10, 0.10, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillLightTurret", 0.05, 0.05 )
	// ai(extended)
	ScoreEvent_SetEarnMeterValues( "KillProwler", 0.03, 0.020001, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillDrone", 0.01, 0.01 )
	ScoreEvent_SetEarnMeterValues( "FlyerKill", 0.10, 0.10, 0.5 ) // this is actually used for gunship kill

	// display type
	// default case is adding a eEventDisplayType.CENTER, required for client to show earnvalue on screen
	ScoreEvent_SetEventDisplayTypes( "KillPilot", GetScoreEvent( "KillPilot" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "EliminatePilot", GetScoreEvent( "EliminatePilot" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "PilotAssist", GetScoreEvent( "PilotAssist" ).displayType | eEventDisplayType.CENTER )
	// doom a titan shouldn't be displayed at center of screen

	ScoreEvent_SetEventDisplayTypes( "KillTitan", GetScoreEvent( "KillTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillAutoTitan", GetScoreEvent( "KillAutoTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "EliminateTitan", GetScoreEvent( "EliminateTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "EliminateAutoTitan", GetScoreEvent( "EliminateAutoTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "TitanKillTitan", GetScoreEvent( "TitanKillTitan" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "TitanAssist", GetScoreEvent( "TitanAssist" ).displayType | eEventDisplayType.CENTER )
	
	ScoreEvent_SetEventDisplayTypes( "PilotBatteryStolen", GetScoreEvent( "PilotBatteryStolen" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "PilotBatteryApplied", GetScoreEvent( "PilotBatteryApplied" ).displayType | eEventDisplayType.CENTER )
	
	ScoreEvent_SetEventDisplayTypes( "Headshot", GetScoreEvent( "Headshot" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "FirstStrike", GetScoreEvent( "FirstStrike" ).displayType | eEventDisplayType.CENTER )
	
	ScoreEvent_SetEventDisplayTypes( "KillGrunt", GetScoreEvent( "KillGrunt" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillSpectre", GetScoreEvent( "KillSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "LeechSpectre", GetScoreEvent( "LeechSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillHackedSpectre", GetScoreEvent( "KillHackedSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillStalker", GetScoreEvent( "KillStalker" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillSuperSpectre", GetScoreEvent( "KillSuperSpectre" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillLightTurret", GetScoreEvent( "KillLightTurret" ).displayType | eEventDisplayType.CENTER )

	ScoreEvent_SetEventDisplayTypes( "KillProwler", GetScoreEvent( "KillProwler" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "KillDrone", GetScoreEvent( "KillDrone" ).displayType | eEventDisplayType.CENTER )
	ScoreEvent_SetEventDisplayTypes( "FlyerKill", GetScoreEvent( "FlyerKill" ).displayType | eEventDisplayType.CENTER )
}

//------------------------------------------------------

void function OnPrematchStart()
{
    InitExtraSpawnerSettings() // npc weapon settings or something...

	// don't run spawning code if ains and nms aren't up to date
	if ( GetAINScriptVersion() == AIN_REV && GetNodeCount() != 0 )
	{
		thread SpawnIntroBatch( TEAM_IMC )
		thread SpawnIntroBatch( TEAM_MILITIA )
	}

	// Starts skyshow, this also requiers AINs but doesn't crash if they're missing
	if ( !Flag( "LevelHasRoof" ) )
		thread StratonHornetDogfightsIntense()
}

void function OnPlaying()
{
	// cleaning up
	TryCleanupBoredNPCGameLong()
}

void function OnPlayerConnected( entity player )
{
	Remote_CallFunction_NonReplay( player, "ServerCallback_AITDM_OnPlayerConnected" )
}

//------------------------------------------------------

int function AITdmExtend_GetScoreValue( entity ent )
{
	int scoreToAdd = 0

	// fake coop support
	bool coopEnabled = GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1

	int playerScore = PLAYER_SCORE_AMOUNT
	// coop case: scale player score
	if ( coopEnabled )
		playerScore = int( PLAYER_SCORE_AMOUNT * file.teamPilotScoreMultiplier )

	if ( ent.IsPlayer() )
		scoreToAdd = playerScore
	
	string className = ent.GetClassName()

	if ( className == "npc_pilot_elite" )
		scoreToAdd = PILOT_SCORE_AMOUNT
	
	if ( className == "npc_gunship" )
		scoreToAdd = GUNSHIP_SCORE_AMOUNT
	
	if ( className == "npc_marvin" )
		scoreToAdd = MARVIN_SCORE_AMOUNT

	if ( className == "npc_prowler" )
	{
		// hardcoded here: if it's a small prowler we add less score
		if ( float( ent.kv.modelscale ) < 1.0 )
			scoreToAdd = SMALL_PROWLER_SCORE_AMOUNT
		else
			scoreToAdd = PROWLER_SCORE_AMOUNT
	}

	if ( className == "npc_spectre" )
		scoreToAdd = SPECTRE_SCORE_AMOUNT

	if ( className == "npc_stalker" )
		scoreToAdd = STALKER_SCORE_AMOUNT

	if ( className == "npc_super_spectre" )
		scoreToAdd = REAPER_SCORE_AMOUNT

	if ( className == "npc_soldier" )
	{
		if ( SPECIALIST_GRUNTS.contains( ent.GetAISettingsName() ) )
			scoreToAdd = SPECIALIST_GRUNT_SCORE_AMOUNT
		else
			scoreToAdd = GRUNT_SCORE_AMOUNT
	}
	
	if ( className == "npc_drone" )
		scoreToAdd = DRONE_SCORE_AMOUNT

	if ( ent.IsTitan() )
	{
		int titanScore = TITAN_SCORE_AMOUNT
		// player owned titan
		if ( IsValid( ent.GetTitanSoul() ) && IsValid( GetPetTitanOwner( ent ) ) )
		{
			// coop case: scale player owned titan score
			if ( coopEnabled )
				titanScore = int( TITAN_SCORE_AMOUNT * file.teamTitanScoreMultiplier )
		}

		if ( TitanHasNpcPilot( ent ) ) // pilot was killed without ejecting
			scoreToAdd = titanScore + PILOT_SCORE_AMOUNT
		else if ( ent.IsPlayer() ) // fix for player score!
			scoreToAdd = titanScore + playerScore
		else // auto titan
			scoreToAdd = titanScore

		// modified function in _titan_health.gnut, recovering ttf1 behavior: we add score on doom but not on death for health loss titans
		if ( !TitanHealth_GetSoulInfiniteDoomedState( ent.GetTitanSoul() ) )
			scoreToAdd -= titanScore // remove titan score on kill for doomed health loss titans
	}

	return scoreToAdd
}

void function HandleScoreForPlayerOrNPCKill( entity victim, entity attacker, var damageInfo )
{
	// if victim is a non-titan npc that owned by players, don't add score
	if ( !VictimIsValidForAITdmScore( victim ) )
		return
	
	if ( !AttackerIsValidForAITdmScore( victim, attacker, damageInfo ) )
		return

	// if it's a npc with bossplayer/owner...
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		attacker = GetAITdmAttackOwner( attacker )
	}

	// start adding score
	int scoreToAdd = AITdmExtend_GetScoreValue( victim )
	if ( scoreToAdd > 0 )
		AddAITdmTeamScore( attacker, scoreToAdd ) // this can handle both players' and npcs' kills
}

bool function AttackerIsValidForAITdmScore( entity victim, entity attacker, var damageInfo )
{
	if( !IsValid( attacker ) )
		return false
	
	if( !attacker.IsNPC() && !attacker.IsPlayer() ) // not killed by any combat character
		return false

	if ( attacker == victim ) // suicide!
		return false

	// npc titan case
	if ( victim.IsTitan() && victim.IsNPC() )
	{
		entity soul = victim.GetTitanSoul()
		// victim is titan but their bossPlayer is attacker... usually happens when ejecting without taking damage
		if ( IsValid( soul ) && GetPetTitanOwner( victim ) == attacker )
			return false
	}

	// all checks passed
	return true
}

bool function VictimIsValidForAITdmScore( entity victim )
{
	// if victim is a non-titan npc that owned by players, don't add score
	if ( victim.IsNPC() && !victim.IsTitan() )
	{
		entity bossPlayer = victim.GetBossPlayer()
		entity owner = victim.GetOwner()
		if ( IsValid( bossPlayer ) )
		{
			if ( bossPlayer.IsPlayer() )
				return false
		}
		if ( IsValid( owner ) )
		{
			if ( owner.IsPlayer() )
				return false
		}
	}

	// all checks passed
	return true
}

entity function GetAITdmAttackOwner( entity ent )
{
	entity attacker
	if ( ent.IsPlayer() ) // player always use themselves as attacker
		return ent
	if ( IsValid( ent.GetBossPlayer() ) )
		attacker = ent.GetBossPlayer()
	if ( IsValid( ent.GetOwner() ) )
		attacker = ent.GetOwner()
	// attacker still not valid?
	if ( !IsValid( attacker ) )
		return ent // use npc or something itself
	
	return attacker
}

void function AddAITdmTeamScore( entity ent, int score )
{
	// Add score + update network int to trigger the "Score +n" popup
	AddTeamScore( ent.GetTeam(), score )
	if ( ent.IsPlayer() )
	{
		ent.AddToPlayerGameStat( PGS_ASSAULT_SCORE, score )
		ent.SetPlayerNetInt( "AT_bonusPoints", ent.GetPlayerGameStat( PGS_ASSAULT_SCORE ) )
	}
}

// for handling doomed health loss titans
void function HandleTitanDoomedScore( entity victim, var damageInfo, bool firstDoom )
{
	// if victim is a non-titan npc that owned by players, don't add score
	if ( !VictimIsValidForAITdmScore( victim ) )
		return
	
	if ( !firstDoom ) // only add score on first doom
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !AttackerIsValidForAITdmScore( victim, attacker, damageInfo ) )
		return

	// if it's a npc with bossplayer/owner...
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		attacker = GetAITdmAttackOwner( attacker )
	}

	if ( !TitanHealth_GetSoulInfiniteDoomedState( victim.GetTitanSoul() ) )
		AddAITdmTeamScore( attacker, TITAN_SCORE_AMOUNT )
}

//------------------------------------------------------

// CHECK FUNCTIONS

bool function ShouldSpawnSpecialistSquad( string otherSpawnWith = "" )
{
	// never spawn specialist grunt with stalkers
	// stalkers are slow and they've already got pretty high health and damage
	if ( otherSpawnWith == "npc_stalker" )
		return false
	// removed. to make game more chaotic, always spawn specialist squad
	//return RandomInt( 3 ) > 0 // 66% chance of spawning a specialist squad(??
	return true
}

bool function ShouldSpawnDropship()
{
	array<entity> points = GetZiplineDropshipSpawns()
	if ( points.len() <= 4 ) // must have more than 4 points
		return false

	return RandomInt( 3 ) == 0 // 33% chance of choose to spawn a dropship
}

string function GetSpecialistGruntLeader()
{
	// 15% chance of spawning a rare specialist grunt
	bool spawnRareSpecialist = RandomIntRange( 1, 100 ) <= 15
	string leaderSet = "npc_soldier_drone_summoner"
	if ( spawnRareSpecialist )
		leaderSet = SPECIALIST_GRUNTS_RARE[ RandomInt( SPECIALIST_GRUNTS_RARE.len() ) ]
	else
	{
		array<string> genericSpecialist
		foreach ( aiSet in SPECIALIST_GRUNTS )
		{
			if ( !SPECIALIST_GRUNTS_RARE.contains( aiSet ) )
				genericSpecialist.append( aiSet )
		}
		leaderSet = genericSpecialist[ RandomInt( genericSpecialist.len() ) ]
	}

	//print( "leaderAiSet: " + leaderSet )

	return leaderSet
}

int function GetSpecialistLeaderHealth( int team, string otherSpawnWith )
{
	int index = team == TEAM_MILITIA ? 0 : 1
	return 200 + ( 60 * file.podEntities[ index ].find( otherSpawnWith ) )
}

bool function ShouldSpawnBossTitan()
{
	return RandomInt( 2 ) == 0 // boss titans has 50% chance to spawn( was 20%, but we've added many new bosses... )
}

string function GetBossTitanSpawnName( int team )
{
	// team specific
	if ( team == TEAM_IMC )
	{
		const array<string> imcBossList =
		[
			"blisk",
			"kane",
			"ash",
			"richter",
			"viper",
			"slone",
		]
		return imcBossList[ RandomInt( imcBossList.len() ) ]
	}
	else if ( team == TEAM_MILITIA )
	{
		const array<string> mltBossList =
		[
			"jack",
			"sarah",
			//"sarah_monarch",
			"vanguard",
			"gates"
		]
		return mltBossList[ RandomInt( mltBossList.len() ) ]
	}

	// default case
	return "" // empty string means random
}

int function GetBossTitanSpawnTeam( int friendlyTeam = -1 )
{
	if ( friendlyTeam == -1 ) // unchanged!
		return -1

	bool coopEnabled = GetCurrentPlaylistVarInt( "aitdm_extended_coop", 0 ) == 1
	bool teamBasedBossTitan = GetCurrentPlaylistVarInt( "aitdm_coop_team_boss_titans", 0 ) == 1

	// only do checks if coop enabled
	if ( friendlyTeam > TEAM_UNASSIGNED && coopEnabled && teamBasedBossTitan )
	{
		if ( GetPlayerArray().len() == 1 ) // single player
		{
			// use faction team
			entity player = GetPlayerArray()[0]
			int factionTeam = ConvertPlayerFactionToIMCOrMilitiaTeam( player )
			bool isFriendlySpawn = player.GetTeam() == friendlyTeam
			return isFriendlySpawn ? factionTeam : GetOtherTeam( factionTeam )
		}
		else if ( GetPlayerArray().len() > 1 ) // multiplayer coop
		{
			// use player leader's team
			int leaderTeam = GetCOOPLeaderPlayer().GetTeam()
			bool isFriendlySpawn = leaderTeam == friendlyTeam
			return isFriendlySpawn ? leaderTeam : GetOtherTeam( leaderTeam )
		}
	}

	return -1 // -1 means no team-based checks, always pick random boss titans
}

bool function ReachedPlayerCheckAmount()
{
	int maxPlayers = GetCurrentPlaylistVarInt( "max_players", 16 )
	if ( float ( GetPlayerArray().len() ) >= float ( maxPlayers ) * 0.6 )
		return true
	return false
}

//


void function SpawnIntroBatch( int team )
{
	array<entity> dropPodNodes = GetEntArrayByClass_Expensive( "info_spawnpoint_droppod_start" )
	array<entity> dropShipNodes = GetValidIntroDropShipSpawn( dropPodNodes )  
	
	array<entity> podNodes
	
	array<entity> shipNodes
	
	
	// mp_rise has weird droppod_start nodes, this gets around it
	// To be more specific the teams aren't setup and some nodes are scattered in narnia
	if( GetMapName() == "mp_rise" )
	{
		entity spawnPoint
		
		// Get a spawnpoint for team
		foreach ( point in GetEntArrayByClass_Expensive( "info_spawnpoint_dropship_start" ) )
		{
			if ( point.HasKey( "gamemode_tdm" ) )
				if ( point.kv[ "gamemode_tdm" ] == "0" )
					continue
			
			if ( point.GetTeam() == team )
			{
				spawnPoint = point
				break
			}
		}
		
		// Get nodes close enough to team spawnpoint
		foreach ( node in dropPodNodes )
		{
			if ( node.HasKey("teamnum") && Distance2D( node.GetOrigin(), spawnPoint.GetOrigin()) < 2000 )
				podNodes.append( node )
		}
	}
	else
	{
		// Sort per team
		foreach ( node in dropPodNodes )
		{
			if ( node.GetTeam() == team )
				podNodes.append( node )
		}
	}

	shipNodes = GetValidIntroDropShipSpawn( podNodes )

	// calculate intro spawn delay
	float introLength = ClassicMP_GetIntroLength()
	float introSpawnRequiredTime = expect float( GetDropPodAnimDuration() )

	float introSpawnWait = introLength - introSpawnRequiredTime
	if ( introSpawnWait > 0 )
		wait introSpawnWait

	// Spawn logic
	int startIndex = 0
	bool first = true
	entity node
	string introSpawnClass = "npc_soldier"
	
	int pods = RandomInt( podNodes.len() + 1 )
	
	int ships = shipNodes.len()
	bool spawnSucceeded = false

	for ( int i = 0; i < GetTeamNPCSpawnCountModifier( file.squadCount, team ); i++ )
	{
		if ( ( pods != 0 || ships == 0 ) && podNodes.len() > 0 ) // defensive fix for podNodes can sometimes be 0
		{
			spawnSucceeded = true // mark as we've done intro spawn, we'll wait before game-loop-spawn
			int index = i
			
			if ( index > podNodes.len() - 1 )
				index = RandomInt( podNodes.len() )
			
			node = podNodes[ index ]
			if ( ShouldSpawnSpecialistSquad( introSpawnClass ) )
			{
				array< entity > points = GetZiplineDropshipSpawns()
				string leaderSet = GetSpecialistGruntLeader()
				int leaderHealth = GetSpecialistLeaderHealth( team, introSpawnClass )
				thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, leaderSet, leaderHealth )
			}
			else
				thread ExtraSpawner_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, introSpawnClass )

			pods--
		}
		else if ( shipNodes.len() > 0 ) // defensive fix for shipNodes can sometimes be 0
		{
			spawnSucceeded = true // mark as we've done intro spawn, we'll wait before game-loop-spawn
			if ( startIndex == 0 ) 
				startIndex = i // save where we started
			
			node = shipNodes[ i - startIndex ]
			if ( ShouldSpawnSpecialistSquad( introSpawnClass ) )
			{
				array< entity > points = GetZiplineDropshipSpawns()
				string leaderSet = GetSpecialistGruntLeader()
				int leaderHealth = GetSpecialistLeaderHealth( team, introSpawnClass )
				thread ExtraSpawner_SpawnSpecialistGruntDropShip( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, 4, leaderSet, leaderHealth )
			}
			else
				thread ExtraSpawner_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, SQUAD_SIZE )
			
			ships--
		}
		
		// Vanilla has a delay after first spawn
		if ( first )
			wait 2
		
		first = false
	}

	// do wait before looping spawn starts if we did intro spawn
	if ( spawnSucceeded )
		wait 8.0
	
	// intro spawn finished
	thread SpawnEscalator( team ) // handles team Escalate()
	thread SpawnerSquads( team )
	thread SpawnerHeavyArmor( team )
	thread SpawnerNPCs( team )
}

// Populates the match
void function SpawnEscalator( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		Escalate( team )
	}
}

void function SpawnerSquads( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
		int infantryCount = 0
		foreach ( entity npc in GetNPCArrayOfTeam( team ) )
		{
			if ( IsHumanSized( npc ) && !IsValid( npc.GetBossPlayer() ) )
				infantryCount += 1
		}
		int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()

		// NORMAL SPAWNS
		int maxSquads = GetTeamNPCSpawnCountModifier( file.squadCount, team )
		//if ( ReachedPlayerCheckAmount() && file.reapers[ index ] ) // if we have pretty much players and reached reaper level
		//	maxSquads = SQUADS_PER_TEAM_MORE_PLAYERS // do reduced minions count
		if ( file.reapers[ index ] )
			maxSquads = GetTeamNPCSpawnCountModifier( file.squadCountHighLevel, team )
		
		int squadsToSpawn = ( maxSquads * SQUAD_SIZE - 2 - infantryCount ) / SQUAD_SIZE
		if ( squadsToSpawn > 0 )
		{
			for ( int i = 0; i < squadsToSpawn; i++ )
			{
				if ( i > 0 )
					wait 2.0 // delay before next spawn
				
				array<entity> dropshipPoints = GetZiplineDropshipSpawns()
				array<entity> droppodPoints = SpawnPoints_GetDropPod()
				string ent = file.podEntities[ index ][ RandomInt( file.podEntities[ index ].len() ) ]

				if ( ShouldSpawnSpecialistSquad( ent ) )
				{
					string leaderSet = GetSpecialistGruntLeader()
					// add health depending on what npc it spawning with
					int leaderHealth = GetSpecialistLeaderHealth( team, ent )
					//print( "RUNNING ExtraSpawner_SpawnSpecialistGruntDropPod()" )
					//print( "leaderHealth is: " + string( leaderHealth ) )
					if ( ShouldSpawnDropship() )
					{
						entity node = dropshipPoints[ GetSpawnPointIndex( dropshipPoints, team ) ]
						thread ExtraSpawner_SpawnSpecialistGruntDropShip( node.GetOrigin(), node.GetAngles(), team, "npc_soldier", 4, leaderSet, leaderHealth )
						continue
					}
					
					entity node = droppodPoints[ GetSpawnPointIndex( droppodPoints, team ) ]
					thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, ent, leaderSet, leaderHealth )
				}
				else
				{
					if ( ShouldSpawnDropship() )
					{
						entity node = dropshipPoints[ GetSpawnPointIndex( dropshipPoints, team ) ]
						thread ExtraSpawner_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, ent, SQUAD_SIZE )
						continue
					}

					entity node = droppodPoints[ GetSpawnPointIndex( droppodPoints, team ) ]
					thread ExtraSpawner_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
				}
			}

			wait 8.0 // wait after each spawn wave
		}

		// PROWLER SQUADS
		if ( file.prowlers[ index ] )
		{
			//print( "prowlerCount: " + string( prowlerCount ) )
			int squadsToSpawn = ( GetTeamNPCSpawnCountModifier( PROWLER_SQUADS_PER_TEAM, team ) * 4 - 2 - prowlerCount ) / 4
			if ( squadsToSpawn > 0 )
			{
				for ( int i = 0; i < squadsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetDropPod()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//print( "RUNNING ExtraSpawner_SpawnProwlerSquadDropPod()" )
					thread ExtraSpawner_SpawnProwlerSquadDropPod( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerHeavyArmor( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()
		int gunshipCount = GetNPCArrayEx( "npc_gunship", team, -1, <0,0,0>, -1 ).len()
		int titanCount = 0
		foreach ( entity npc in GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ) )
		{
			if ( !IsValid( npc.GetBossPlayer() ) )
				titanCount += 1
		}

		// REAPERS
		if ( file.reapers[ index ] )
		{
			int reapersToSpawn = GetTeamNPCSpawnCountModifier( file.reaperCount, team ) - reaperCount
			if ( reapersToSpawn > 0 )
			{
				for ( int i = 0; i < reapersToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn

					array<entity> points = SpawnPoints_GetTitan()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//thread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
					// crazy reaper
					string reaperSettings = "npc_super_spectre_aitdm"
					string tickSettings = "npc_frag_drone"
					if ( CoinFlip() ) // 50% change of spawning sp ticks, 50% chance spawning mp ticks
						tickSettings = "npc_frag_drone_throwable"
					
					thread ExtraSpawner_SpawnReaperCanLaunchTicks( node.GetOrigin(), node.GetAngles(), team, reaperSettings, tickSettings )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// GUNSHIPS
		if ( file.gunships[ index ] )
		{
			int gunshipsToSpawn = GetTeamNPCSpawnCountModifier( file.gunshipCount, team ) - gunshipCount
			if ( gunshipsToSpawn > 0 )
			{
				for ( int i = 0; i < gunshipsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetTitan()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					thread ExtraSpawner_SpawnGunShip( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// TITANS
		if ( file.titans[ index ] )
		{
			int titansToSpawn = GetTeamNPCSpawnCountModifier( TITANS_PER_TEAM, team ) - titanCount
			if ( titansToSpawn > 0 )
			{
				for ( int i = 0; i < titansToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetTitan()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					thread ExtraSpawner_SpawnTitan( node.GetOrigin(), node.GetAngles(), team, true )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// PILOTS
		if ( file.pilots[ index ] )
		{
			int pilotsToSpawn = GetTeamNPCSpawnCountModifier( file.pilotCount, team ) - titanCount // count titans
			if ( pilotsToSpawn > 0 )
			{
				for ( int i = 0; i < pilotsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points
					points.extend( SpawnPoints_GetTitanStart( TEAM_IMC ) )
					points.extend( SpawnPoints_GetTitanStart( TEAM_MILITIA ) )
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team )
					if ( ShouldSpawnBossTitan() ) 
					{
						string spawnName = GetBossTitanSpawnName( GetBossTitanSpawnTeam( team ) )
						thread ExtraSpawner_SpawnBossTitan( node.GetOrigin(), node.GetAngles(), team, spawnName )
					}
					else
						thread ExtraSpawner_SpawnPilotCanEmbark( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerNPCs( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		int marvinCount = GetNPCArrayEx( "npc_marvin", team, -1, <0,0,0>, -1 ).len()
		int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()

		// MARVINS
		if ( file.marvins[ index ] )
		{
			const int spawnAmount = 2 // spawn 2 marvins per droppod
			const string spawnEnt = "npc_marvin"
			int marvinsToSpawn = ( GetTeamNPCSpawnCountModifier( MARVINS_PER_TEAM, team ) * spawnAmount - 1 - marvinCount ) / spawnAmount
			if ( marvinsToSpawn > 0 )
			{
				for ( int i = 0; i < marvinsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetDropPod()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt, spawnAmount )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// PROWLERS
		if ( file.prowlers[ index ] )
		{
			const int spawnAmount = 1 // spawn 1 prowler per droppod
			const string spawnEnt = "npc_prowler"
			int prowlersToSpawn = ( GetTeamNPCSpawnCountModifier( file.prowlerCount, team ) * spawnAmount - 1 - prowlerCount ) / spawnAmount
			if ( prowlersToSpawn > 0 )
			{
				for ( int i = 0; i < prowlersToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn

					array< entity > points = SpawnPoints_GetDropPod()
					entity node = points[ GetSpawnPointIndex( points, team ) ]
					//thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt, spawnAmount )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

// Based on points tries to balance match
void function Escalate( int team )
{
	int score = GameRules_GetTeamScore( team )
	
	foreach ( AITdmEscalatorstruct escalator in file.levelEscalators )
	{
		if ( escalator.usedByTeams.contains( team ) ) // never run the same escalator for one team
			continue
		if ( score >= escalator.scoreRequired )
		{
			if ( escalator.spawnSettingsFunc != null )
				escalator.spawnSettingsFunc( team )
			escalator.usedByTeams.append( team )
		}
	}
}

//------------------------------------------------------

int function GetSpawnPointIndex( array< entity > points, int team )
{
	// modified: make a new function so ai gamemodes don't have to re-decide for each spawn
	//entity zone = DecideSpawnZone_Generic( points, team )
	entity zone = GetCurrentSpawnZoneForTeam( team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( points.len() )

			if ( Distance2D( points[ index ].GetOrigin(), zone.GetOrigin() ) < 6000 )
				return index
		}
	}

	return RandomInt( points.len() )
}

//------------------------------------------------------

// Award for hacking
// can't name it "OnNPCLeeched()" because there's a deprecated function with same name... and it's globalized. yay.
void function AITdmExtend_OnNPCLeeched( entity npc, entity player )
{
	// Set Owner so we can filter in HandleScore
	// not a good idea. score could be handled by GetBossPlayer()
	// setting an owner will make entity have no collision with their owner
	//npc.SetOwner( player )
	npc.ai.preventOwnerDamage = true // this is required so we don't kill our spectres

	// adding score, same as killing the target does
	// they can be re-hacked and we need to prevent gain score multiple times
	if ( !( "givenAttritionScore" in npc.s ) )
	{
		// start adding score
		int scoreToAdd = AITdmExtend_GetScoreValue( npc )
		if ( scoreToAdd > 0 )
			AddAITdmTeamScore( player, scoreToAdd )

		npc.s.givenAttritionScore <- true // mark the npc as already given score to player
	}

	// disable leech on this spectre, don't let them to be multiple-leeched by diffrent team...
	// reverted. it is vanilla behavior! and it's pretty funny
	//DisableLeeching( npc )
	//npc.UnsetUsable()
}

// ticks clean up
void function CleanUpOverloadedTicks()
{
	thread CleanUpOverloadedTicks_Threaded()
}

void function CleanUpOverloadedTicks_Threaded()
{
	int maxTicks = file.reaperCount * 2 * 4 + 2 // clean up ticks spawned by reapers
	//maxTicks += int( file.squadCountHighLevel * 1.5 ) // add some space for specialist grunt spawned ticks

	while ( true )
	{
		array<entity> tickArray
		foreach ( entity tick in GetNPCArrayByClass( "npc_frag_drone" ) )
		{
			if ( !IsAlive( tick ) )
				continue
			
			// player owned tick?
			if ( IsValid( tick.GetBossPlayer() ) )
				continue

			// still arming up?
			if ( !tick.ai.fragDroneArmed )
				continue

			// pending explode?
			if ( tick.Anim_IsActive() )
				continue

			tickArray.append( tick )
		}

		if( tickArray.len() > maxTicks )
		{
			// clean up first spawned tick in array
			// validation checks already done
			tickArray[0].Signal( "SuicideSpectreExploding" ) // this will make them explode
		}

		WaitFrame()
	}
}

// npc clean up
void function TryCleanupBoredNPCGameLong()
{
	thread TryCleanupBoredNPCGameLong_Threaded()
}

void function TryCleanupBoredNPCGameLong_Threaded()
{
	// keep searching new npcs and run CleanupBoredNPCThread() for them
	while ( true )
	{
		foreach ( entity npc in GetNPCArray() )
		{
			if ( !( "waitingToBeCleanUp" in npc.s ) )
				npc.s.waitingToBeCleanUp <- false
			if ( !npc.s.waitingToBeCleanUp )
			{
				thread CleanupBoredNPCThread( npc )
				npc.s.waitingToBeCleanUp = true
			}
		}
		WaitFrame()
	}
}

// npc cleanup
const float NPC_CLEANUP_INITIAL_WAIT_TIME = 10.0
const float NPC_CLEANUP_REQUIRED_IDLE_TIME = 20.0

void function CleanupBoredNPCThread( entity guy )
{
	// track all ai that we spawn, ensure that they're never "bored" (i.e. stuck by themselves doing fuckall with nobody to see them) for too long
	// if they are, kill them so we can free up slots for more ai to spawn
	// we shouldn't ever kill ai if players would notice them die

	// NOTE: this partially covers up for the fact that we script ai alot less than vanilla probably does
	// vanilla probably messes more with making ai assaultpoint to fights when inactive and stuff like that, we don't do this so much

	if ( guy.GetClassName() == "npc_marvin" ) // never clean up marvins
		return
	guy.EndSignal( "OnDestroy" )
	// cover spawning time from dropship/pod + before we start cleaning up
	WaitFrame()
	while ( IsValid( guy.GetParent() ) )
		WaitFrame()

	wait NPC_CLEANUP_INITIAL_WAIT_TIME // initial wait
	int team = guy.GetTeam()
	vector lastCheckOrigin = guy.GetOrigin() // if they get stucked we also clean up
	float idleDuration = 0.0
	while ( idleDuration < NPC_CLEANUP_REQUIRED_IDLE_TIME )
	{
		WaitFrame()

		if ( guy.Anim_IsActive() ) // anim active, such as marvin doing a job or npc being executed
			continue

		// if the npc is owner by player, we skip checks
		entity owner = guy.GetOwner()
		entity bossPlayer = guy.GetBossPlayer()
		if ( IsValid( owner ) )
		{
			if ( owner.IsPlayer() )
				continue
		}
		if ( IsValid( bossPlayer ) )
		{
			if ( bossPlayer.IsPlayer() )
				continue
		}

		// if npc is a titan with bubbleshield, we skip checks
		if ( guy.IsTitan() )
		{
			entity soul = guy.GetTitanSoul()
			if( IsValid( soul ) )
			{
				entity bubbleShield = soul.soul.bubbleShield
				if ( IsValid( bubbleShield ) )
					continue
			}
		}

		array<entity> otherGuys = GetPlayerArray()
		otherGuys.extend( GetNPCArrayOfEnemies( team ) )

		bool failedChecks = false

		foreach ( entity otherGuy in otherGuys )
		{
			// skip dead people
			if ( !IsAlive( otherGuy ) )
				continue

			failedChecks = false

			// don't kill if too close to anything
			if ( Distance( otherGuy.GetOrigin(), guy.GetOrigin() ) < 2000.0 )
				break

			// don't kill if ai or players can see them
			if ( otherGuy.IsPlayer() )
			{
				if ( PlayerCanSee( otherGuy, guy, true, 135 ) )
					break
			}
			else
			{
				if ( otherGuy.CanSee( guy ) )
					break
			}

			// don't kill if they can see any ai
			if ( guy.CanSee( otherGuy ) )
				break

			failedChecks = true
		}

		if ( !IsAlive( guy.GetEnemy() ) 
			 && Distance( guy.GetOrigin(), lastCheckOrigin ) <= 64 
			 ) // assume they're not moving nor combating
			failedChecks = true // mark as checks failed

		if ( failedChecks )
			idleDuration += 0.1
		else
			idleDuration = 0.0

		lastCheckOrigin = guy.GetOrigin()
	}

	print( "cleaning up bored npc: " + guy + " from team " + guy.GetTeam() )
	HideName( guy ) // prevent their title or health bar from showing
	TakeAllWeapons( guy ) // so they won't have a weapon floating
	guy.SetNoTarget( true ) // disable npc targeting
	guy.SetNoTargetSmartAmmo( true ) // disable smart ammo targeting
	guy.EnableNPCFlag( NPC_IGNORE_ALL ) // disable any sensing
	guy.NotSolid() // disable collision
	// titan being dissolved
	if ( guy.IsTitan() )
	{
		entity soul = guy.GetTitanSoul()
		if( IsValid( soul ) )
		{
			// end any rodeo on it
			ForceTitanRodeoToEnd( guy )
			DisableTitanRodeo( guy )
			// try to hide a cleaning up titan's batteryContainer
			entity batteryContainer = soul.soul.batteryContainer
			if ( IsValid( batteryContainer ) )
				batteryContainer.Hide()
		}
	}
	// reaper being dissolved
	if ( guy.GetClassName() == "npc_super_spectre" )
	{
		if ( guy.ai.activeMinionEntArrayID > 0 )
		{
			// detonate all frag drones they owned
			foreach ( entity ent in GetScriptManagedEntArray( guy.ai.activeMinionEntArrayID ) )
			{
				if ( IsValid( ent ) ) 
				{
					if ( ent.IsNPC() && ent.ai.fragDroneArmed ) // minion may doing a deploy animation, which handled by WaitForFragDroneDeployThenDetonate()
						ent.Signal( "SuicideSpectreExploding" )
					else if ( ent.GetClassName() == "grenade" ) // minion still a grenade
						ent.Destroy()
				}
			}
		}
	}
	guy.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 ) // dissolve them to have better visual
}