untyped // for GiveExtraWeaponMod()

/* Required PlaylistVars
    scorelimit 9999+
    earn_meter_pilot_multiplier 0.0
*/

// maybe ban maps like relic, crashsite and complex?
// I'm pretty not sure carring banners by a single player is a good idea, maybe banners are carried by the whole team could be better( just like apex )?

/* // Sounds to be used:
    diag_mcor_cmdr_fd_onlyPlayerIsAlive
    diag_mcor_cmdr_fd_pilotRespawn
    diag_mcor_cmdr_fd_singlePilotDown
*/

global function Modded_Gamemode_Survival_Init


const int SURVIVAL_TOTAL_ENEMY_AMOUNT			= 1080

const int SURVIVAL_PLAYER_TEAM                  = TEAM_IMC // TEAM_MILITIA
const int SURVIVAL_NPC_TEAM						= TEAM_MILITIA


const string SURVIVAL_BURNMETER_REWARD          = "burnmeter_ap_turret_weapon" // whatever you do, never give another "mp_ability_burncardweapon"
const int SURVIVAL_STARTER_BOOST_COUNT 			= 1


struct SurvivalPlayerStruct
{
    //float titanEarnMeter // this mode's earnMeter is controlled manually
	float lastDeathProtectionTime
	int activeBoostCount
}

struct
{
	array<entity> beaconTempModels
	float lastBeaconActivateTime

    table< entity, SurvivalPlayerStruct > playerSurvivalTable // it's better to use player's uid instead of the entity
	table< entity, bool > turretsWaitingForRepair

	bool waveStarted = false
	array<string> respawnedPlayerUIDs // saved for respawning players
} file

void function Modded_Gamemode_Survival_Init()
{
	// Initialize
	RegisterSignal( "SurvivalWaveStart" )

	// ping system Init
	RegisterSignal( "OnPinged" )
    RegisterSignal( "StopPing" )

    // Vanilla Mode Settings
    //Riff_ForceBoostAvailability( eBoostAvailability.Disabled ) // player will only have certain amount of boosts, this will make disembarking clear the boosts!
    //Riff_ForceTitanAvailability( eTitanAvailability.Never ) // titan meter is controlled by server

	AiGameModes_SetNPCWeapons( "npc_soldier", [ "mp_weapon_rocket_launcher" ] )
	AiGameModes_SetNPCWeapons( "npc_spectre", [ "mp_weapon_defender" ] )

	ScoreEvent_SetupEarnMeterValuesForMixedModes()
	SurvivalScoreEventsSetUp()

    // modded settings
	// rodeo
	//ClassicRodeo_SetEnabled( true )

    // intro
	ClassicMP_SetCustomIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )
    SetGamemodeAnnouncementEnabled( false ) // so we can do custom announcement!
	//ClassicMP_SetCustomIntro( ClassicMP_DefaultNoIntro_Setup, ClassicMP_DefaultNoIntro_GetLength() )
    SetWaitingForPlayersMaxDuration( 30.0 ) // wait a bit longer
    ClassicMP_ForceDisableEpilogue( true )

    // gameplay
	SetLateJoinRespawnEnabled( false ) // manually do the respawning
    SetShouldPlayFactionDialogue( false ) // disable default faction dialogue, this mode needs manually controlling the dialogues
    SetBattleChatterEnableToSelf( true ) // play chatter to player themselves
    Burnmeter_SetForcedReward( SURVIVAL_BURNMETER_REWARD ) // better one: give players 3 turrets at start
    //SetLateJoinRespawnEnabled( false ) // this mode use a standalone respawn method

	// this also needs to disable the cloak and a-wall weapons in loadout functions
	SetShouldFUCKOFFCLOAK( true )
	SetShouldFUCKOFFAWALL( true )

    // custom highlight settings
	Highlight_SetCustomHighlight( "enemy_player", "enemy_titan", "sp_friendly_hero", "sp_friendly_hero" )

    // Callbacks
	AddPostDamageCallback( "player", OnSurvivalPlayerPostDamage )
	//SetUsedCoreCallback( OnSurvivalPlayerCoreUsed ) // to nerf monarch
	AddCallback_OnTitanCoreUsed( OnSurvivalPlayerCoreUsed ) // new utility in sh_titancore_utility.gnut

    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
    AddCallback_OnClientConnected( OnClientConnected )
	AddCallback_OnPlayerRespawned( OnPlayerRespawned )
	AddCallback_OnPlayerKilled( OnPlayerKilled )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPilotGetLoadout )
    AddCallback_GameStateEnter( eGameState.Prematch, OnGamePrematch )
    AddCallback_GameStateEnter( eGameState.Playing, OnGamePlaying )
	AddCallback_GameStateEnter( eGameState.Epilogue, OnGameEpilogue )
	//AddCallback_OnPilotBecomesTitan( OnPilotBecomesTitan )
	//AddCallback_OnTitanBecomesPilot( OnTitanBecomesPilot )

	// modded callbacks
	AddCallback_OnPlayerRespawnBannerDropped( OnBannerDropped )
	AddCallback_OnPlayerRespawnBannerCollected( OnBannerCollected )
	AddCallback_OnPlayerActivateRespawnBeacon( OnBeaconActivated )

    // TEMP SCOREBOARD
	AddCallback_OnTouchHealthKit( "item_flag", OnFlagCollected )
	// TEMP PLAYLIST
    AddCallback_GameStateEnter( eGameState.Postmatch, ForceChangeMapAfterGame )
}



//////////////////////////////
///// CALLBACK FUNCTIONS /////
//////////////////////////////

void function OnPlayerClassChanged( entity player )
{
    UpdateSurvivalPlayerClass( player )
}

void function OnClientConnected( entity player )
{
    InitSurvivalPlayer( player )
}

void function OnPlayerRespawned( entity player )
{
	SurvivalPlayerMarkAsRespawned( player )
	SurvivalPlayerMessageThink( player )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
	SendChatMessageForPlayerKilled( victim, damageInfo )
}

void function OnPilotGetLoadout( entity player, PilotLoadoutDef p )
{
    GivePlayerSurvivalLoadout( player )
}

void function OnGamePrematch()
{
	SurvivalNPCSettings()
	SurvivalTurretSettings()
}

void function OnGamePlaying()
{
	SpawnBeaconTempModels()
    StartNPCSpawner()
	StartingGivePlayersSurvivalBoost()
	SurvivalTimerThink()
	InitSurvivalRespawnShipPoints()
	// ai
	ExtraSpawner_SetNPCWeapons( "npc_pilot_elite", ["mp_weapon_epg", "mp_weapon_smr", "mp_weapon_pulse_lmg", "mp_weapon_rocket_launcher"] )
	InitSurvivalEnemyScore()

	// TEMP, this is required for showing the scoreboard!
	SpawnFakeFlagCarrier()
}

void function OnGameEpilogue()
{

}

// modified callbacks
void function OnBannerDropped( entity player, entity banner )
{
	PingPlayerBanner( banner )
}

void function OnBannerCollected( entity collector, entity bannerOwner )
{
	SendChatMessageForBannerCollection( collector, bannerOwner )
	PingSurvivalRespawnBeacons()
}

void function OnBeaconActivated( entity activator, array<entity> playersToRespawn )
{
	file.lastBeaconActivateTime = Time() // for player's notifications
	AddScoreForBeaconActivation( activator, playersToRespawn )
	SendChatMessageForBeaconActivation( activator )
	//DeactivateBeaconPings()
}

//////////////////////////////////
///// CALLBACK FUNCTIONS END /////
//////////////////////////////////



/////////////////////////////
///// LOADOUT FUNCTIONS /////
/////////////////////////////

const int SURVIVAL_PLAYER_HEALTH			= 150 // give players more space

void function UpdateSurvivalPlayerClass( entity player )
{
    if ( IsAlive( player ) )
    {
		if ( !player.IsTitan() ) // good to check this...
		{
			player.SetMaxHealth( SURVIVAL_PLAYER_HEALTH )
			player.SetHealth( SURVIVAL_PLAYER_HEALTH )
		}
    }
}

const array<string> SURVIVAL_DISABLED_TACTICALS =
[
	"mp_ability_cloak",
	"mp_weapon_deployable_cover"
]

const string SURVIVAL_REPLACEMENT_TACTICAL = "mp_ability_grapple"

void function GivePlayerSurvivalLoadout( entity player )
{
	entity tactical = player.GetOffhandWeapon( OFFHAND_SPECIAL )
	if ( IsValid( tactical ) )
	{
		string weaponName = tactical.GetWeaponClassName()
		if ( SURVIVAL_DISABLED_TACTICALS.contains( weaponName ) )
		{
			player.TakeWeaponNow( weaponName )
			player.GiveOffhandWeapon( SURVIVAL_REPLACEMENT_TACTICAL, OFFHAND_SPECIAL )
		}
	}


	//player.GiveExtraWeaponMod( "titandamage_weapon" )
    //player.GiveExtraWeaponMod( "at_unlimited_ammo" )
}

// prematch will clean up the boosts, should be in playing state
void function StartingGivePlayersSurvivalBoost()
{
	foreach ( entity player in GetPlayerArray() )
	{
		GivePlayerSurvivalBoost( player )
	}
}

void function GivePlayerSurvivalBoost( entity player )
{
	thread GivePlayerSurvivalBoost_Threaded( player )
}

void function GivePlayerSurvivalBoost_Threaded( entity player )
{
	//has to be delayed because PlayerConnect callbacks get called in wrong order
	WaitFrame()
	for ( int i = 0; i < SURVIVAL_STARTER_BOOST_COUNT; i++ ) // give a certain amount of burncard
		PlayerInventory_PushInventoryItemByBurnRef( player, SURVIVAL_BURNMETER_REWARD )

	// turret settings
	DeployableTurret_SetAISettingsForPlayer_AP( player, "npc_turret_sentry_burn_card_ap_fd" )
	DeployableTurret_SetAISettingsForPlayer_AT( player, "npc_turret_sentry_burn_card_at_fd" )
}

// nerf monarch: they won't receive shields if not at max level
void function OnSurvivalPlayerCoreUsed( entity titan, entity coreWeapon )
{
	string className = coreWeapon.GetWeaponClassName()
	if ( className == "mp_titancore_upgrade" )
	{
		entity titanSoul = titan.GetTitanSoul()
		int currentUpgradeCount = titanSoul.GetTitanSoulNetInt( "upgradeCount" )
		if ( currentUpgradeCount < 4 ) // not max level
			titanSoul.SetShieldHealth( 0 ) // remove all shields
	}
}

/////////////////////////////////
///// LOADOUT FUNCTIONS END /////
/////////////////////////////////



///////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS /////
///////////////////////////////////////

void function InitSurvivalPlayer( entity player )
{
    SetTeam( player, SURVIVAL_PLAYER_TEAM ) // always set player to the right team

    SurvivalPlayerStruct emptyStruct
    file.playerSurvivalTable[ player ] <- emptyStruct

	// starting loadouts
	if ( GetGameState() >= eGameState.Playing ) // this is required for not crashing the server
		GivePlayerSurvivalBoost( player )

	// respawning
	thread TryRespawnNewConnectingPlayer( player )

	// notifications
	SurvivalGamemodeAnnouncement( player )
}

///////////////////////////////////////////
///// PLAYER INITIALIZE FUNCTIONS END /////
///////////////////////////////////////////



///////////////////////////////////
///// PLAYER DAMAGE FUNCTIONS /////
///////////////////////////////////

const int SURVIVAL_LESS_PLAYER_COUNT				= 2 // less than this will be consider as "less players"
const int SURVIVAL_NORMAL_PLAYER_COUNT				= 4 // normal player count
const int SURVIVAL_MORE_PLAYER_COUNT				= 6 // more player count

const float NPC_DAMAGE_MULTIPLIER_LESS_PLAYERS		= 0.8
const float NPC_DAMAGE_MULTIPLIER_NORMAL_PLAYERS	= 1.0
const float NPC_DAMAGE_MULTIPLIER_MORE_PLAYERS		= 1.25

const float PLAYER_DEATH_PROTECTION_COOLDOWN		= 30 // every 30s give player a chance to protect themselves
const float PLAYER_DEATH_PROTECTION_DURATION		= 1.0 // player won't die within this time

float function GetSurvivalPlayerDamageReceivedMultiplier()
{
	int playerCount = GetPlayerArrayOfTeam( SURVIVAL_PLAYER_TEAM ).len()
	
	float damageScale = 1.0
	if ( playerCount <= SURVIVAL_LESS_PLAYER_COUNT )
	{
		//float damagePerPlayer = fabs ( ( NPC_DAMAGE_MULTIPLIER_NORMAL_PLAYERS - NPC_DAMAGE_MULTIPLIER_LESS_PLAYERS ) / float ( SURVIVAL_NORMAL_PLAYER_COUNT - SURVIVAL_LESS_PLAYER_COUNT ) )
		//float countDiffer = SURVIVAL_LESS_PLAYER_COUNT - playerCount
		//damageScale -= ( countDiffer * damagePerPlayer )
		damageScale = NPC_DAMAGE_MULTIPLIER_LESS_PLAYERS
	}
	else if ( playerCount > SURVIVAL_LESS_PLAYER_COUNT && playerCount <= SURVIVAL_NORMAL_PLAYER_COUNT )
	{
		//float damagePerPlayer = fabs ( ( NPC_DAMAGE_MULTIPLIER_MORE_PLAYERS - NPC_DAMAGE_MULTIPLIER_NORMAL_PLAYERS ) / float ( SURVIVAL_MORE_PLAYER_COUNT - SURVIVAL_NORMAL_PLAYER_COUNT ) )
		//float countDiffer = SURVIVAL_MORE_PLAYER_COUNT - playerCount
		//damageScale += ( countDiffer * damagePerPlayer )
		damageScale = NPC_DAMAGE_MULTIPLIER_NORMAL_PLAYERS
	}
	else if ( playerCount >= SURVIVAL_MORE_PLAYER_COUNT )
		damageScale = NPC_DAMAGE_MULTIPLIER_MORE_PLAYERS

	return damageScale
}

bool function ShouldGivePlayerDeathProtection( entity player )
{
	if ( !file.waveStarted ) // save player's death protection to wave start
		return false
	if ( player.IsTitan() )
		return false
	if ( file.playerSurvivalTable[ player ].lastDeathProtectionTime + PLAYER_DEATH_PROTECTION_COOLDOWN >= Time() )
		return false

	return true
}

void function PlayerDeathProtectionThink( entity player )
{
	//print( "enabling death protection" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	EnableDemigod( player )
	file.playerSurvivalTable[ player ].lastDeathProtectionTime = Time()

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				if ( IsDemigod( player ) )
					DisableDemigod( player )
			}
		}
	)

	wait PLAYER_DEATH_PROTECTION_DURATION
}

void function OnSurvivalPlayerPostDamage( entity player, var damageInfo )
{
	if ( player.IsTitan() ) // titans take multiplied damage
	{
		DamageInfo_ScaleDamage( damageInfo, GetSurvivalPlayerDamageReceivedMultiplier() )
		//print( GetSurvivalPlayerDamageReceivedMultiplier() )
		return
	}

	float damage = DamageInfo_GetDamage( damageInfo )
	int playerHealth = player.GetShieldHealth() + player.GetHealth()
	bool isKillshot = playerHealth <= damage
	if ( isKillshot )
	{
		if ( ShouldGivePlayerDeathProtection( player ) )
		{
			//DamageInfo_SetDamage( damageInfo, playerHealth - 1 ) // don't kill the player
			thread PlayerDeathProtectionThink( player )
		}
	}
}

///////////////////////////////////////
///// PLAYER DAMAGE FUNCTIONS END /////
///////////////////////////////////////



/////////////////////////////
///// RESPAWN FUNCTIONS /////
/////////////////////////////

// prevent players from stuck inside a beacon, 
void function SpawnBeaconTempModels()
{
	foreach ( entity spawnpoint in GetEntArrayByClass_Expensive( "info_hardpoint" ) )
    {
        // use hardpoints from amped hardpoint
        if ( !spawnpoint.HasKey( "gamemode_cp" ) )
			continue
        if ( spawnpoint.kv.gamemode_cp == "0" )
            continue

		entity prop = CreatePropDynamic( spawnpoint.GetModelName(), spawnpoint.GetOrigin(), spawnpoint.GetAngles(), 6 )
		thread PlayAnim( prop, "mh_inactive_idle" )
		file.beaconTempModels.append( prop )
	}
}

void function DestroyBeaconTempModels()
{
	foreach ( entity prop in file.beaconTempModels )
	{
		if ( IsValid( prop ) )
			prop.Destroy()
	}
	file.beaconTempModels.clear()
}

void function InitSurvivalRespawnShipPoints()
{
	array<entity> spawnPoints
	foreach ( entity spawnpoint in GetEntArrayByClass_Expensive( "info_hardpoint" ) )
    {
        // use hardpoints from amped hardpoint
        if ( !spawnpoint.HasKey( "gamemode_cp" ) )
			continue
        if ( spawnpoint.kv.gamemode_cp == "0" )
            continue

		spawnPoints.append( spawnpoint )
    }

	SetDropshipRespawnPointsOverride( spawnPoints )
}

void function SurvivalPlayerMarkAsRespawned( entity player )
{
	if ( file.waveStarted )
		file.respawnedPlayerUIDs.append( player.GetUID() )
}

void function TryRespawnNewConnectingPlayer( entity player )
{
	player.EndSignal( "OnDestroy" )

	// wave started...
	//if ( file.waveStarted ) // for debugging
	if ( file.waveStarted && !file.respawnedPlayerUIDs.contains( player.GetUID() ) ) 
	{
		WaitFrame()
		RespawnAsPilot( player )
		// respawn into dropship to prevent unhappy situations from now
		RespawnInDropShip( player )
		TryGiveTitanToPlayer( player ) // enable titan usage
	}
}

void function TryGiveTitanToPlayer( entity player )
{
	if ( !player.IsTitan() && !IsValid( player.GetPetTitan() ) )
		PlayerEarnMeter_AddOwnedFrac( player, 1.0 )
}

/////////////////////////////////
///// RESPAWN FUNCTIONS END /////
/////////////////////////////////



///////////////////////////////
///// GAMESTATE FUNCTIONS /////
///////////////////////////////

const float SURVIVAL_WAVE_START_DELAY 			= 35 // for players ready up?
const float SURVIVAL_WAVE_TIME_LIMIT			= 720 // 12 min, if player can't finish the wave they will lose

void function SurvivalTimerThink()
{
	thread SurvivalTimerThink_Threaded()
}

void function SurvivalTimerThink_Threaded()
{
	PlayerEarnMeter_SetEnabled( false ) // disable earnmeter
	SetServerVar( "gameStartTime", Time() )
	SetServerVar( "gameEndTime", Time() + SURVIVAL_WAVE_START_DELAY + 0.2 ) // don't end the game!

	wait SURVIVAL_WAVE_START_DELAY

	SetServerVar( "gameEndTime", Time() + SURVIVAL_WAVE_TIME_LIMIT ) // update timer
	file.waveStarted = true // mark as wave started
	svGlobal.levelEnt.Signal( "SurvivalWaveStart" )

	SpawnRespawnBeacons() // in _respawn_beacon.gnut
	DestroyBeaconTempModels() // destroy the fake models
	SetRespawnsEnabled( false ) // disable the respawn
	Riff_ForceSetEliminationMode( eEliminationMode.Pilots ) // start elimination
	
	// start with titan
	PlayerEarnMeter_SetEnabled( true )
	foreach ( entity player in GetPlayerArray() )
	{
		if ( !IsAlive( player ) ) // defensive fix
			RespawnAsPilot( player )
			
		TryGiveTitanToPlayer( player )
		// mark existing players as respawned
		file.respawnedPlayerUIDs.append( player.GetUID() )
		// do announcement
		SurvivalWaveStartAnnouncement( player )
	}
}

///////////////////////////////////
///// GAMESTATE FUNCTIONS END /////
///////////////////////////////////



//////////////////////////////////
///// ANNOUNCEMENT FUNCTIONS /////
//////////////////////////////////

const string SURVIVAL_BANNER_MESSAGE_ID 			= "21"
const string SURVIVAL_BEACON_MESSAGE_ID				= "22"
const float SURVIVAL_BEACON_MESSAGE_DELAY			= 15 // if the beacon was activated recently we don't show the banner message

void function SurvivalPlayerMessageThink( entity player )
{
	thread SurvivalPlayerMessageThink_Threaded( player )
}

void function ClearPlayerSurvivalMessage( entity player )
{
	NSDeleteStatusMessageOnPlayer( player, SURVIVAL_BANNER_MESSAGE_ID ) // try to delete existing one
	NSDeleteStatusMessageOnPlayer( player, SURVIVAL_BEACON_MESSAGE_ID ) // try to delete existing one
}

void function SurvivalPlayerMessageThink_Threaded( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
				ClearPlayerSurvivalMessage( player )
		}
	)

	int team = SURVIVAL_PLAYER_TEAM
	ClearPlayerSurvivalMessage( player ) // defensive fix

	bool bannerMsgCreated = false
	bool beaconMsgCreated = false
	while ( true )
	{
		WaitFrame()
		
		if ( !file.waveStarted ) // wait until wave start
			continue

		int bannerCount = GetTeamActiveRespawnBanners( team ).len()
		int deadPlayerCount = GetPlayerArrayOfTeam( team ).len() - GetPlayerArrayOfTeam_Alive( team ).len()
		
		if ( deadPlayerCount > 0 && file.lastBeaconActivateTime + SURVIVAL_BEACON_MESSAGE_DELAY < Time() )
		{
			if ( bannerMsgCreated )
			{
				NSEditStatusMessageOnPlayer( player, "", "旗幟已收集 " + string( bannerCount ) + " / " + string( deadPlayerCount ), SURVIVAL_BANNER_MESSAGE_ID ) // init health message
			}
			else
			{
				NSDeleteStatusMessageOnPlayer( player, SURVIVAL_BANNER_MESSAGE_ID ) // defensive fix
				NSCreateStatusMessageOnPlayer( player, "", "", SURVIVAL_BANNER_MESSAGE_ID )
				bannerMsgCreated = true
			}
		}
		else // no dead players
		{
			if ( beaconMsgCreated )
			{
				NSDeleteStatusMessageOnPlayer( player, SURVIVAL_BANNER_MESSAGE_ID )
				bannerMsgCreated = false
			}
		}


		if ( bannerCount > 0 )
		{
			if ( !beaconMsgCreated )
			{
				NSDeleteStatusMessageOnPlayer( player, SURVIVAL_BEACON_MESSAGE_ID ) // defensive fix
				NSCreateStatusMessageOnPlayer( player, "", "激活重生信標以重生友方玩家", SURVIVAL_BEACON_MESSAGE_ID )
				beaconMsgCreated = true
			}
		}
		else // no banners
		{
			if ( beaconMsgCreated )
			{
				NSDeleteStatusMessageOnPlayer( player, SURVIVAL_BEACON_MESSAGE_ID )
				beaconMsgCreated = false
			}
		}
	}
}

void function SurvivalGamemodeAnnouncement( entity player )
{
	thread DelayedSendGamemodeMessage( player )

	// TEMP NORIFICATION
    Chat_ServerPrivateMessage( player, "本服务器对话与出怪机制未完工，目前在测试数据", false )
    Chat_ServerPrivateMessage( player, "无复活，尽可能在NPC的攻击下存活。死亡的玩家会掉落旗帜卡，拾取后对重生信标使用以进行重生", false )
}

void function DelayedSendGamemodeMessage( entity player )
{
	player.EndSignal( "OnDestroy" )

	wait 1 // better wait
	while ( IsPlayerUnableToReceiveAnnouncement( player ) )
		WaitFrame()

	NSSendAnnouncementMessageToPlayer( 
		player, 
		"生存模式", 
		"在時間結束前擊殺所有敵方NPC。通過重生信標復活友方。", 
		< 255, 255, 255 >, 
		1, 
		1 														// 1 means ANNOUNCEMENT_STYLE_QUICK
	)
}

bool function IsPlayerUnableToReceiveAnnouncement( entity player )
{
	if ( !IsAlive( player ) )
		return true
	if ( player.GetParent() != null && ( HasCinematicFlag( player, CE_FLAG_INTRO ) || HasCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING ) || HasCinematicFlag( player, CE_FLAG_WAVE_SPAWNING ) ) )
		return true

	return false
}

void function SendChatMessageForPlayerKilled( entity player, var damageInfo )
{
	if ( file.waveStarted )
		Chat_ServerBroadcast( "\x1b[38;5;160m" + "玩家 " + player.GetPlayerName() + " 已死亡，回收其旗幟卡以進行重生" + "\x1b[0m" )
}

void function SendChatMessageForBannerCollection( entity collector, entity bannerOwner )
{
	Chat_ServerBroadcast( "\x1b[38;5;76m" + collector.GetPlayerName() + " 回收了 " + bannerOwner.GetPlayerName() + " 的旗幟卡" + "\x1b[0m" )
}

void function SendChatMessageForBeaconActivation( entity activator )
{
	Chat_ServerBroadcast( "\x1b[38;5;33m" + activator.GetPlayerName() + " 激活了重生信標" + "\x1b[0m" )
}

void function SurvivalWaveStartAnnouncement( entity player )
{
	NSSendAnnouncementMessageToPlayer( 
		player, 
		"回合開始！", 
		"在時間結束前擊殺所有敵方NPC。通過重生信標復活友方。", 
		< 255, 255, 255 >, 
		1, 
		1 														// 1 means ANNOUNCEMENT_STYLE_QUICK
	)
}

//////////////////////////////////////
///// ANNOUNCEMENT FUNCTIONS END /////
//////////////////////////////////////



//////////////////////////////////
///// NPC SETTINGS FUNCTIONS /////
//////////////////////////////////

void function SurvivalNPCSettings()
{
	//AddSpawnCallback( "npc_soldier", SetUpSurvivalRPGMinion )
	//AddSpawnCallback( "npc_spectre", SetUpSurvivalRPGMinion )
	AddSpawnCallback( "npc_stalker", SetUpSurvivalStalker )
}

void function SetUpSurvivalRPGMinion( entity npc )
{
	npc.GiveWeapon( "mp_weapon_rocket_launcher" ) // give minions at weapon
}

void function SetUpSurvivalStalker( entity npc )
{
	TakeAllWeapons( npc )

	npc.GiveWeapon( "mp_weapon_epg" )
	npc.SetActiveWeaponByName( "mp_weapon_epg" )
}

//////////////////////////////////////
///// NPC SETTINGS FUNCTIONS END /////
//////////////////////////////////////



////////////////////////////
///// TURRET FUNCTIONS /////
////////////////////////////

void function SurvivalTurretSettings()
{
	AddSpawnCallback( "npc_turret_sentry", SetUpSurvivalTurret )
	AddDamageFinalCallback( "npc_turret_sentry", OnPlayerTurretFinalDamaged )
}

void function SetUpSurvivalTurret( entity turret )
{
	entity bossPlayer = turret.GetBossPlayer()
	if ( !IsValid( bossPlayer ) || bossPlayer.IsNPC() ) // for we may add turret grunts?
		return
	
	// init some settings
	file.turretsWaitingForRepair[ turret ] <- false // for not multiplying the repair function!

	Highlight_SetOwnedHighlight( turret, "sp_friendly_hero" )
	AddEntityCallback_OnDamaged( turret, OnPlayerTurretDamaged )
	TurretWaitForBeingPickedUp( turret )
	thread TrackTurretBossPlayerLifeTime( turret, bossPlayer )
}

void function TrackTurretBossPlayerLifeTime( entity turret, entity bossPlayer )
{
	turret.EndSignal( "OnDestroy" )

	bossPlayer.WaitSignal( "OnDestroy" )
	turret.Destroy()
}

void function TurretWaitForBeingPickedUp( entity turret )
{
	turret.SetUsableByGroup( "owner pilot" )
	turret.SetUsePrompts( "#REFUND_HOLD_USE", "#REFUND_PRESS_USE" )

	AddCallback_OnUseEntity( turret, PlayerPickUpTurret )
}

function PlayerPickUpTurret( turret, player )
{
	expect entity ( turret )
	expect entity ( player )

	turret.UnsetUsable()
	DisablePlayerTurret( turret )
	turret.NotSolid()
	turret.SetOwner( null ) // disable ownership
	Highlight_ClearOwnedHighlight( turret )
	turret.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )

	string rewardRefund = GetTurretBurnmeterName( turret )
	PlayerInventory_PushInventoryItemByBurnRef( player, rewardRefund )
}

const array<string> BURNCARD_TURRET_AP_SETFILES = 
[
	"npc_turret_sentry_burn_card_ap",
	"npc_turret_sentry_burn_card_ap_fd",
	"npc_turret_sentry"
]

const array<string> BURNCARD_TURRET_AT_SETFILES = 
[
	"npc_turret_sentry_burn_card_at",
	"npc_turret_sentry_burn_card_at_fd",
	"npc_turret_sentry_plasma"
]

string function GetTurretBurnmeterName( entity turret )
{
	string aiSettings = turret.GetAISettingsName()

	if ( BURNCARD_TURRET_AP_SETFILES.contains( aiSettings ) )
		return "burnmeter_ap_turret_weapon"
	if ( BURNCARD_TURRET_AT_SETFILES.contains( aiSettings ) )
		return "burnmeter_at_turret_weapon"
	
	return SURVIVAL_BURNMETER_REWARD // default
}

// post damage can't handle most things even the "damage" will not be setting to 0
void function OnPlayerTurretDamaged( entity turret, var damageInfo )
{
	float damage = DamageInfo_GetDamage( damageInfo )
	//print( damage ) // the damage won't be setting to 0 even if the turret is disabled, so we really should use the turret.s.waitingForRepair
	if ( turret.GetHealth() <= damage ) // killshot
	{
		DamageInfo_SetDamage( damageInfo, turret.GetHealth() - 1 )
		turret.DisableTurret() // disable the turret and protects it
		//turret.SetHealth( 1 ) // not killing it!

		TurretWaitForBeingRepaired( turret )
	}
}

void function OnPlayerTurretFinalDamaged( entity turret, var damageInfo )
{
	entity bossPlayer = turret.GetBossPlayer()
	if ( !IsValid( bossPlayer ) || bossPlayer.IsNPC() ) // for we may add turret grunts?
		return

	OnPlayerTurretDamaged( turret, damageInfo )
}

void function TurretWaitForBeingRepaired( entity turret )
{
	RemoveCallback_OnUseEntity( turret, PlayerPickUpTurret ) // disable the pickupable
	//RemoveCallback_OnUseEntity( turret, PlayerRepairTurret ) // defensive fix
	if ( file.turretsWaitingForRepair[ turret ] ) // defensive fix!!
		return
	file.turretsWaitingForRepair[ turret ] = true

	DisablePlayerTurret( turret )
	turret.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_ENEMY ) // notify the player this turret is down
	turret.UnsetUsable() // clear the "pickupable"
	turret.SetUsableByGroup( "owner pilot" )
	turret.SetUsePrompts( "#TURRET_WAKEUP_HOLD_USE", "#TURRET_WAKEUP_PRESS_USE" )

	AddCallback_OnUseEntity( turret, PlayerRepairTurret )
}

function PlayerRepairTurret( turret, player )
{
	expect entity ( turret )
	expect entity ( player )

	RemoveCallback_OnUseEntity( turret, PlayerRepairTurret )

	file.turretsWaitingForRepair[ turret ] = false
	EnablePlayerTurret( turret )
	AddPlayerScore( player, "FDRepairTurret" ) // score event

	turret.SetHealth( turret.GetMaxHealth() )
	turret.UnsetUsable()
	turret.Highlight_SetParam( 3, 0, HIGHLIGHT_COLOR_FRIENDLY ) // healthy turret highlight

	thread DelayedEnablePickUpTurret( turret )
}

const float TURRET_PICKUP_GRACE_PERIOD = 0.5 // prevent players double tapping to pick up the turret accidently
void function DelayedEnablePickUpTurret( entity turret )
{
	turret.EndSignal( "OnDestroy" )

	wait TURRET_PICKUP_GRACE_PERIOD
	TurretWaitForBeingPickedUp( turret )
}

void function DisablePlayerTurret( entity turret )
{
	turret.DisableTurret()
	HideName( turret )
	StopSoundOnEntity( turret, "Boost_Card_SentryTurret_Scanning_Loop_3P" ) // stop scanning sound
	turret.Signal( "StopTurretLaser" ) // stop turret laser, modified in _ai_turret_sentry
}

void function EnablePlayerTurret( entity turret )
{
	turret.EnableTurret()
	ShowName( turret )
	EmitSoundOnEntity( turret, "Boost_Card_SentryTurret_Scanning_Loop_3P" ) // start scanning sound
	thread SentryTurretAimLaser( turret )
}

void function RemoveCallback_OnUseEntity( entity ent, callbackFunc )
{
	local funcPos = ent.s.onUseEntityCallbacks.find( callbackFunc )
	if ( funcPos < 0 ) // can't find the func
		return
	ent.s.onUseEntityCallbacks.remove( expect int( funcPos ) )
}

////////////////////////////////
///// TURRET FUNCTIONS END /////
////////////////////////////////



///////////////////////////
///// SCORE FUNCTIONS /////
///////////////////////////

void function AddScoreForBeaconActivation( entity player, array<entity> savedPlayers )
{
	int score = savedPlayers.len()
	player.AddToPlayerGameStat( PGS_ASSAULT_SCORE, score )
}


void function SurvivalScoreEventsSetUp()
{
	// pilot/titan related
	ScoreEvent_SetEarnMeterValues( "KillPilot", 0.0, 0.0 )
	ScoreEvent_SetEarnMeterValues( "EliminatePilot", 0.0, 0.05 )
	ScoreEvent_SetEarnMeterValues( "KillTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "KillAutoTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "EliminateTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "EliminateAutoTitan", 0.0, 0.15 )
	ScoreEvent_SetEarnMeterValues( "TitanKillTitan", 0.0, 0.15 ) // unsure
	ScoreEvent_SetEarnMeterValues( "PilotBatteryStolen", 0.0, 0.35 ) // this actually just doesn't have overdrive in vanilla even
	ScoreEvent_SetEarnMeterValues( "Headshot", 0.0, 0.05 )
	ScoreEvent_SetEarnMeterValues( "FirstStrike", 0.0, 0.05 )
	ScoreEvent_SetEarnMeterValues( "PilotBatteryApplied", 0.0, 0.35 )

	// ai
	ScoreEvent_SetEarnMeterValues( "KillGrunt", 0.02, 0.02, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSpectre", 0.02, 0.02, 0.5 )
	ScoreEvent_SetEarnMeterValues( "LeechSpectre", 0.02, 0.02 )
	ScoreEvent_SetEarnMeterValues( "KillStalker", 0.02, 0.02, 0.5 )
	ScoreEvent_SetEarnMeterValues( "KillSuperSpectre", 0.0, 0.1 )

	AddDeathCallback( "npc_soldier", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_spectre", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_stalker", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_super_spectre", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_titan", SurvivalEnemyNPCKilled )
	AddDeathCallback( "npc_pilot_elite", SurvivalEnemyNPCKilled )
}

void function InitSurvivalEnemyScore()
{
	AddTeamScore( SURVIVAL_NPC_TEAM, SURVIVAL_TOTAL_ENEMY_AMOUNT ) // starting amount!
}


const int GRUNT_SCORE_AMOUNT 			= 1
const int SPECTRE_SCORE_AMOUNT 			= 1
const int STALKER_SCORE_AMOUNT 			= 1
const int REAPER_SCORE_AMOUNT 			= 3
const int TITAN_SCORE_AMOUNT			= 10
const int PILOT_SCORE_AMOUNT			= 5

void function SurvivalEnemyNPCKilled( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( !IsValid( attacker ) )
		return
	if( !attacker.IsPlayer() && !attacker.IsNPC() )
		return
	if( attacker.GetTeam() != SURVIVAL_PLAYER_TEAM )
		return

	if ( attacker == victim ) // suicide!
		return

	entity player
	if ( attacker.IsPlayer() )
		player = attacker
	// if it's a npc with bossplayer/owner...
	else if ( attacker.IsNPC() )
	{
		// reassign attacker
		if ( IsValid( attacker.GetBossPlayer() ) )
			player = attacker.GetBossPlayer()
		if ( IsValid( attacker.GetOwner() ) )
			player = attacker.GetOwner()
	}

	if ( !IsValid( player ) )
		return

	string className = victim.GetClassName()
	int scoreToRemove = 0
	string scoreEvent = "" // for npcs can't handle by OnNPCKilled(), do a extra score event

	if ( className == "npc_pilot_elite" )
	{
		scoreToRemove = PILOT_SCORE_AMOUNT
		scoreEvent = "EliminatePilot"
	}

	if ( className == "npc_soldier" )
		scoreToRemove = GRUNT_SCORE_AMOUNT

	if ( className == "npc_spectre" )
		scoreToRemove = SPECTRE_SCORE_AMOUNT

	if ( className == "npc_stalker" )
		scoreToRemove = STALKER_SCORE_AMOUNT

	if ( className == "npc_super_spectre" )
		scoreToRemove = REAPER_SCORE_AMOUNT

	// Player ejecting triggers this without the extra check
	if ( victim.IsTitan() && victim.GetBossPlayer() != player )
	{
		if ( TitanHasNpcPilot( victim ) ) // pilot was killed without ejecting
		{
			scoreToRemove = TITAN_SCORE_AMOUNT + PILOT_SCORE_AMOUNT
			scoreEvent = "EliminatePilot"
		}
		else // ejected or auto titan
			scoreToRemove = TITAN_SCORE_AMOUNT
	}

	if ( scoreEvent != "" )
		AddPlayerScore( player, scoreEvent, victim )

	if ( scoreToRemove > 0 )
	{
		if ( GetGameState() != eGameState.Playing ) // game already end?
			return

		player.AddToPlayerGameStat( PGS_KILLS, scoreToRemove )
		
		int scoreLeft = GameRules_GetTeamScore( SURVIVAL_NPC_TEAM )
		bool winningKill = ( scoreLeft - scoreToRemove <= 0 )

		if ( winningKill )
		{
			SurvivalTeamWinsTheGame()
			return
		}

		AddTeamScore( SURVIVAL_NPC_TEAM, -scoreToRemove ) // discard the npc team's score
	}
}

void function SurvivalTeamWinsTheGame()
{
	Riff_ForceSetEliminationMode( eEliminationMode.Default ) // disable elimination
	SetRespawnsEnabled( true ) 

	ClassicMP_ForceDisableEpilogue( false ) // re-enable epilogue for players to have fun
	ClassicMP_SetEpilogue( SurvivalEvacEpilogue ) // custom epilogue!

	GameRules_SetTeamScore( SURVIVAL_NPC_TEAM, 0 )
	AddTeamScore( SURVIVAL_PLAYER_TEAM, 1 ) // at least make player have the winning hint?

	// Respawn dead players
	foreach ( entity player in GetPlayerArray() )
	{
		if ( !IsAlive( player ) )
		{
			RespawnAsPilot( player )
			// respawn into dropship to prevent unhappy situations from now
			RespawnInDropShip( player )
		}
	}

	SetWinner( SURVIVAL_PLAYER_TEAM )
}

///////////////////////////////
///// SCORE FUNCTIONS END /////
///////////////////////////////



//////////////////////////
///// EVAC FUNCTIONS /////
//////////////////////////

const float EVAC_INITIAL_WAIT = 5.0
const float EVAC_ARRIVAL_TIME = 40.0
const float EVAC_WAIT_TIME = 18.0

// celebrating the winning!
void function SurvivalEvacEpilogue()
{
	thread Evac( SURVIVAL_PLAYER_TEAM, EVAC_INITIAL_WAIT, EVAC_ARRIVAL_TIME, EVAC_WAIT_TIME, EvacEpiloguePlayerCanBoard, EvacEpilogueShouldLeaveEarly, EvacEpilogueCompleted )
}

bool function EvacEpiloguePlayerCanBoard( entity dropship, entity player )
{
	// can't board a dropship on a different team
	if ( dropship.GetTeam() != player.GetTeam() )
		return false
	
	// check if there are any free slots on the dropship, if there are then they can board
	foreach ( entity player in dropship.s.evacSlots )
		if ( !IsValid( player ) )
			return true
	
	// no empty slots
	return false
}

bool function EvacEpilogueShouldLeaveEarly( entity dropship )
{
	int numEvacing
	foreach ( entity player in dropship.s.evacSlots )
		if ( IsValid( player ) )
			numEvacing++

	return GetPlayerArrayOfTeam( dropship.GetTeam() ).len() == numEvacing || numEvacing == dropship.s.evacSlots.len()
}

void function EvacEpilogueCompleted( entity dropship )
{
	wait 5.0
	
	foreach ( entity player in GetPlayerArray() )
		ScreenFadeToBlackForever( player, 2.0 )
	
	wait 2.0
	if( GetGameState() != eGameState.Postmatch )
		SetGameState( eGameState.Postmatch )
}

//////////////////////////////
///// EVAC FUNCTIONS END /////
//////////////////////////////



/////////////////////////////////
///// NPC SPAWNER FUNCTIONS /////
/////////////////////////////////

void function StartNPCSpawner()
{
    thread Spawner( SURVIVAL_NPC_TEAM )
    thread SpawnerExtend( SURVIVAL_NPC_TEAM )
}

const int SQUADS_MAX_COUNT = 12
const int REAPERS_MAX_COUNT = 4
const int TITANS_MAX_COUNT = 8

// Populates the match
void function Spawner( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )
	svGlobal.levelEnt.WaitSignal( "SurvivalWaveStart" ) // wait for real start

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			//Escalate( team )

			// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
			array<entity> npcs = GetNPCArrayOfTeam( team )
			int count = npcs.len()
			int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()

			// REAPERS
            array< entity > points = SpawnPoints_GetDropPod()
            if ( reaperCount < REAPERS_MAX_COUNT )
            {
                entity node = points[ GetSpawnPointIndex( points, team ) ]
                waitthread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
            }

			// NORMAL SPAWNS
			if ( count < SQUADS_MAX_COUNT * 4 - 2 )
			{
                array<string> podEntities = ["npc_soldier", "npc_stalker", "npc_spectre"] // hardcoded
				string ent = podEntities[ RandomInt( podEntities.len() ) ]

				array< entity > points = GetZiplineDropshipSpawns()

				// Prefer dropship when spawning grunts
				if ( ent == "npc_soldier" && points.len() / 4 > 0 ) // must have more than 4 points
				{
					if ( RandomInt( points.len() / 4 ) )
					{
						entity node = points[ GetSpawnPointIndex( points, team ) ]
						waitthread AiGameModes_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, 4, SquadHandler )
						continue
					}
				}

				points = SpawnPoints_GetDropPod()
				entity node = points[ GetSpawnPointIndex( points, team ) ]
				thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent, SquadHandler )
			}
		}
		else
			break
		WaitFrame()
	}
}

// tells infantry where to go
// In vanilla there seem to be preset paths ai follow to get to the other teams vone and capture it
// AI can also flee deeper into their zone suggesting someone spent way too much time on this
void function SquadHandler( array<entity> guys )
{
	// Not all maps have assaultpoints / have weird assault points ( looking at you ac )
	// So we use enemies with a large radius
	array< entity > points = GetNPCArrayOfEnemies( guys[0].GetTeam() )
	
	if ( points.len()  == 0 )
		return
	
	vector point
	point = points[ RandomInt( points.len() ) ].GetOrigin()
	
	array<entity> players = GetPlayerArrayOfEnemies( guys[0].GetTeam() )
	
	// Setup AI
	foreach ( guy in guys )
	{
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guy.AssaultPoint( point )
		guy.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
		
		// show on enemy radar
		foreach ( player in players )
			guy.Minimap_AlwaysShow( 0, player )
		
		
		thread CleanupBoredNPCThread( guy )
	}
	
	// Every 5 - 15 secs change AssaultPoint
	while ( true )
	{	
		foreach ( guy in guys )
		{
			// Check if alive
			if ( !IsAlive( guy ) )
			{
				guys.removebyvalue( guy )
				continue
			}
			// Stop func if our squad has been killed off
			if ( guys.len() == 0 )
				return
			
			// Get point and send guy to it
			points = GetNPCArrayOfEnemies( guy.GetTeam() )
			if ( points.len() == 0 )
				continue
				
			point = points[ RandomInt( points.len() ) ].GetOrigin()
			
			guy.AssaultPoint( point )
		}
		wait RandomFloatRange(5.0,15.0)
	}
}

void function ReaperHandler( entity reaper )
{
	array<entity> players = GetPlayerArrayOfEnemies( reaper.GetTeam() )
	foreach ( player in players )
		reaper.Minimap_AlwaysShow( 0, player )

	thread CleanupBoredNPCThread( reaper )
}

void function CleanupBoredNPCThread( entity guy )
{
	// track all ai that we spawn, ensure that they're never "bored" (i.e. stuck by themselves doing fuckall with nobody to see them) for too long
	// if they are, kill them so we can free up slots for more ai to spawn
	// we shouldn't ever kill ai if players would notice them die

	// NOTE: this partially covers up for the fact that we script ai alot less than vanilla probably does
	// vanilla probably messes more with making ai assaultpoint to fights when inactive and stuff like that, we don't do this so much

	guy.EndSignal( "OnDestroy" )
	wait 15.0 // cover spawning time from dropship/pod + before we start cleaning up

	int cleanupFailures = 0 // when this hits 2, cleanup the npc
	while ( cleanupFailures < 2 )
	{
		wait 10.0

		if ( guy.GetParent() != null )
			continue // never cleanup while spawning

		array<entity> otherGuys = GetPlayerArray()
		otherGuys.extend( GetNPCArrayOfTeam( GetOtherTeam( guy.GetTeam() ) ) )

		bool failedChecks = false

		foreach ( entity otherGuy in otherGuys )
		{
			// skip dead people
			if ( !IsAlive( otherGuy ) )
				continue

			failedChecks = false

			// don't kill if too close to anything
			if ( Distance( otherGuy.GetOrigin(), guy.GetOrigin() ) < 2000.0 )
				break

			// don't kill if ai or players can see them
			if ( otherGuy.IsPlayer() )
			{
				if ( PlayerCanSee( otherGuy, guy, true, 135 ) )
					break
			}
			else
			{
				if ( otherGuy.CanSee( guy ) )
					break
			}

			// don't kill if they can see any ai
			if ( guy.CanSee( otherGuy ) )
				break

			failedChecks = true
		}

		if ( failedChecks )
			cleanupFailures++
		else
			cleanupFailures--
	}

	print( "cleaning up bored npc: " + guy + " from team " + guy.GetTeam() )
	guy.Destroy()
}

void function SpawnerExtend( int team )
{
	svGlobal.levelEnt.EndSignal( "GameStateChanged" )
	svGlobal.levelEnt.WaitSignal( "SurvivalWaveStart" ) // wait for real start

	int index = team == TEAM_MILITIA ? 0 : 1

	while( true )
	{
		if( GetGameState() == eGameState.Playing )
		{
			//Escalate( team )

	        //int pilotCount = GetNPCArrayEx( "npc_pilot_elite", team, -1, <0,0,0>, -1 ).len() + GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()
			int titanCount = GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ).len()

			// TITANS
			// not sure will these points collide with player's points
            if ( titanCount < TITANS_MAX_COUNT )
            {
                entity node = GetNPCTitanSpawnPoint( team )
                //entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team, TitanHandler )
                // use a different function to prevent pilots behaves silly
                waitthread ExtraSpawner_SpawnTitanWithPilot( node.GetOrigin(), node.GetAngles(), team )
            }
		}
		else
			break
		WaitFrame()
	}
}

int function GetSpawnPointIndex( array< entity > points, int team )
{
	// modified: make a new function so ai gamemodes don't have to re-decide for each spawn
	//entity zone = DecideSpawnZone_Generic( points, team )
	entity zone = GetCurrentSpawnZoneForTeam( team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( points.len() )

			if ( Distance2D( points[ index ].GetOrigin(), zone.GetOrigin() ) < 6000 )
				return index
		}
	}

	return RandomInt( points.len() )
}

const float NPC_TITAN_POINT_SAFE_TIME = 10.0 // if the spawnpoint's lastUsedTime is less than this, we don't use it

entity function GetNPCTitanSpawnPoint( int team )
{
	array<entity> spawnPoints
	spawnPoints.extend( SpawnPoints_GetTitan() )
	spawnPoints.extend( SpawnPoints_GetTitanStart( TEAM_IMC ) )
	spawnPoints.extend( SpawnPoints_GetTitanStart( TEAM_MILITIA ) )

	// modified: make a new function so ai gamemodes don't have to re-decide for each spawn
	//entity zone = DecideSpawnZone_Generic( points, team )
	entity zone = GetCurrentSpawnZoneForTeam( team )

	if ( IsValid( zone ) )
	{
		// 20 Tries to get a random point close to the zone
		for ( int i = 0; i < 20; i++ )
		{
			int index = RandomInt( spawnPoints.len() )
			entity point = spawnPoints[ index ]

			if ( Distance2D( point.GetOrigin(), zone.GetOrigin() ) < 6000 )
			{
				var usedTime = point.s.lastUsedTime
				if ( usedTime + NPC_TITAN_POINT_SAFE_TIME < Time() )
				{
					point.s.lastUsedTime = Time() // mark as used
					return point
				}
			}
		}
	}

	return spawnPoints[ RandomInt( spawnPoints.len() ) ]
}

/////////////////////////////////////
///// NPC SPAWNER FUNCTIONS END /////
/////////////////////////////////////



/////////////////////////////////
///// PING SYSTEM FUNCTIONS /////
/////////////////////////////////

void function PingSurvivalRespawnBeacons()
{
    foreach ( entity beacon in GetAllRespawnBeaconEntities() )
    {
        if ( IsValid( beacon ) )
            PingRespawnBeacon( beacon )
    }

	thread TrackSurvivalTeamBannerCount() // to disable the ping in proper time
}

void function TrackSurvivalTeamBannerCount()
{
	int team = SURVIVAL_PLAYER_TEAM

	while ( true )
	{
		WaitFrame()
		int bannerCount = GetTeamActiveRespawnBanners( team ).len()
		if ( bannerCount == 0 ) // banner used or banner owner quit
			break
	}

	DeactivateBeaconPings() // deactive the pings
}

const asset SURVIVAL_BEACON_INDICATOR			= FX_EVAC_MARKER

void function PingRespawnBeacon( entity beacon )
{
	thread PingRespawnBeacon_Threaded( beacon )
}

void function PingRespawnBeacon_Threaded( entity beacon )
{
	vector origin = beacon.GetOrigin()
    vector angles = beacon.GetAngles()

	// indicator pings
	int indicFxId = GetParticleSystemIndex( SURVIVAL_BEACON_INDICATOR )
    entity indicatorFX = StartParticleEffectInWorld_ReturnEntity( indicFxId, origin, < 0,0,0 > )
	SetTeam( indicatorFX, SURVIVAL_PLAYER_TEAM )
	EffectSetControlPointVector( indicatorFX, 1, < 0, 110, 0 > ) // green
	indicatorFX.DisableHibernation() // prevent it from fading out

    WaitSignal( beacon, "OnDestroy", "OnPinged", "StopPing", "PlayerActivatingRespawnBeacon" )

	if ( IsValid( indicatorFX ) )
		EffectStop( indicatorFX )
}

void function DeactivateBeaconPings()
{
	// signal all beacons to disable ping
    foreach ( entity beacon in GetAllRespawnBeaconEntities() )
    {
        if ( IsValid( beacon ) )
            beacon.Signal( "StopPing" )
    }
}

const asset SURVIVAL_BANNER_INICATOR 			= $"P_ar_titan_droppoint"

void function PingPlayerBanner( entity banner )
{
	thread PingPlayerBanner_Threaded( banner )
}

void function PingPlayerBanner_Threaded( entity banner )
{
	vector origin = banner.GetOrigin()
    vector angles = banner.GetAngles()
    vector surfaceNormal = < 0, 0, 1 >

	// indicator pings
	int indicFxId = GetParticleSystemIndex( SURVIVAL_BANNER_INICATOR )
    entity indicatorFX = StartParticleEffectInWorld_ReturnEntity( indicFxId, origin, surfaceNormal )
    EffectSetControlPointVector( indicatorFX, 1, < 0, 110, 0 > ) // green
	indicatorFX.DisableHibernation() // prevent it from fading out

    WaitSignal( banner, "OnDestroy", "OnPinged", "StopPing", "PlayerCollectingRespawnBanner" )

	if ( IsValid( indicatorFX ) )
		EffectStop( indicatorFX )
}

/////////////////////////////////////
///// PING SYSTEM FUNCIONTS END /////
/////////////////////////////////////



//////////////////////////
///// TEMP FUNCTIONS /////
//////////////////////////

void function SpawnFakeFlagCarrier()
{
	entity flag = CreateEntity( "item_flag" )
	flag.SetValueForModelKey( CTF_FLAG_MODEL )
	flag.MarkAsNonMovingAttachment()
	DispatchSpawn( flag )
	flag.SetModel( CTF_FLAG_MODEL )
	flag.SetOrigin( < 0, 0, 10000 > ) // never let the player pick it up
	flag.SetVelocity( < 0, 0, 0 > )
	SetTeam( flag, SURVIVAL_PLAYER_TEAM )

	SetGlobalNetEnt( "flagCarrier", flag ) // this is required for showing the scoreboard!
}

bool function OnFlagCollected( entity player, entity flag )
{
	return false // so flag ent doesn't despawn
}

const array<string> FORCED_SURVIVAL_PLAYLIST =
[
    "mp_colony02",
    "mp_black_water_canal",
    "mp_thaw",
    "mp_homestead",
    "mp_forwardbase_kodai",
    "mp_angel_city"
] // excluded mp_glitch, mp_relic02, mp_grave, mp_eden, mp_wargames, mp_drydock, mp_rise, mp_complex3 and mp_crashsite3, for they have very high parts or canyons?

void function ForceChangeMapAfterGame()
{
    string nextMap = GetNextSurvivalMap()

    ServerCommand( "map " + nextMap )
}

string function GetNextSurvivalMap()
{
	string curMapName = GetMapName()

    int mapIndex = FORCED_SURVIVAL_PLAYLIST.find( GetMapName() )
    mapIndex += 1 // next map index
	if( mapIndex == FORCED_SURVIVAL_PLAYLIST.len() ) // reached last map?
		mapIndex = 0
	string map = FORCED_SURVIVAL_PLAYLIST[mapIndex]

    return map
}

//////////////////////////////
///// TEMP FUNCTIONS END /////
//////////////////////////////