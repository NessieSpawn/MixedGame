untyped // for player.GiveExtraWeaponMod()
// WIP: Health limited incap shield( done by using a constant shield ), Downed Fake Player
/*
WARNING BY NESSIE( fixed by Bleedout_PlayerMovementLimiter() ): 
Bleedout_DiableWallrunAndDoubleJump() and Bleedout_EnableWallrunAndDoubleJump()
existing, which will do a "OnClassChange" after being downed or revived, please notice!
maybe when bleeding player is wallrunning we FreezeControl could be better? like SlidePrevention()
*/

const string ANSI_COLOR_END = "\x1b[0m"
const string ANSI_COLOR_BLUE = "\x1b[38;5;81m"
const string ANSI_COLOR_RED = "\x1b[38;5;196m"
const string ANSI_COLOR_ORANGE = "\x1b[38;5;208m"
const string ANSI_COLOR_YELLOW = "\x1b[38;5;11m"

const array<string> CONNECTING_NOTIFICATIONS = 
[
    ANSI_COLOR_YELLOW + "流血倒地PVP" + ANSI_COLOR_END,
	ANSI_COLOR_BLUE + "玩家拥有125生命和100护盾" + ANSI_COLOR_END,
	ANSI_COLOR_BLUE + "装备依照高TTK进行平衡，反泰坦武器增加了反铁驭能力。辅助瞄准禁用" + ANSI_COLOR_END,
	ANSI_COLOR_ORANGE + "血量归零后不会立即死亡而是会倒地等待救助。期间按住开火使用击倒护盾，在倒地玩家的背后按下E键进行处决" + ANSI_COLOR_END,
    ANSI_COLOR_ORANGE + "击杀敌人或助攻以获取护盾电池，可回满护盾。处决击杀和救助队友也可恢复最大80护盾" + ANSI_COLOR_END,

    ANSI_COLOR_RED + "请尊重其他玩家，勿卖弱、嘲讽等" + ANSI_COLOR_END,
]

global function Modded_Gamemode_Bleedout_Init

global function Bleedout_HealthRegenThink
global function Bleedout_SetHealthRegenRate

const asset BLEEDOUT_EXECUTION_HITBOX_MODEL = $"models/weapons/bullets/mgl_grenade.mdl"

// downed effects
const asset FLESH_PINKMIST_FX = $"death_pinkmist_LG_nochunk" // was death_pinkmist_LG_nochunk
const asset MECHNAICAL_PINKMIST_FX = $"xo_damage_exp_1" // was xo_damage_exp_2, current one has chunks

// modifiable settings!
global function Bleedout_EnableExecutingBleedingPlayer
global function Bleedout_SetProtectionDuration
global function Bleedout_SetIncapShieldHealth
global function Bleedout_SetIncapShieldInvulnerable

const float BLEEDOUT_PROTECTION_DURATION = 1.05 // default value
const int BLEEDOUT_INCAP_SHIELD_MAX_HEALTH = 350 // default value

/* // unused
struct IncapShieldStruct
{
	entity vortexSphere
	entity shieldWallFX1P
}
*/

// fake apex loadouts
const bool BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT = false // default value
// passives, unfinished
const bool BLEEDOUT_MODE_ENABLE_PASSIVES = false

const float BLEEDOUT_MODE_SHIELD_BATTERY_USETIME = 2.5 // remember try to avoid sound issue( using sound lasts about 3.0s )
const float BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_USETIME = 7.0
const int BLEEDOUT_MODE_SHIELD_BATTERY_REGEN_AMOUNT = 100
const int BLEEDOUT_MODE_REVIVING_FRIENDLY_SHIELD_REWARD = 80
const int BLEEDOUT_MODE_EXECUTION_SHIELD_REWARD = 80
const int BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_REGEN_AMOUNT = 300

// health settings
const int BLEEDOUT_MODE_HEALTH = 125
const int BLEEDOUT_MODE_DOWNED_HEALTH = 100
const int BLEEDOUT_MODE_SHIELD_HEALTH = 100

const float BLEEDOUT_MODE_ELIMINATE_PILOT_EARNED_VALUE = 0.0 // was 0.1
const float BLEEDOUT_MODE_ELIMINATE_PILOT_OWNED_VALUE = 0.3 // was 0.3
const float BLEEDOUT_MODE_PILOT_ASSIST_EARNED_VALUE = 0.2 // was 0.3
const float BLEEDOUT_MODE_PILOT_ASSIST_OWNED_VALUE = 0.0 // was 0.0
// knock down and death events, no score event handler, just add directly to earnmeter
const float BLEEDOUT_MODE_KNOCKDOWN_EARNED_VALUE = 0.2 // only add once for knocking down a player
const float BLEEDOUT_MODE_KNOCKDOWN_OWNED_VALUE = 0.0
const float BLEEDOUT_MODE_DEATH_EARNED_VALUE = 0.0 // death will clean up earned value
const float BLEEDOUT_MODE_DEATH_OWNED_VALUE = 0.3 // killed by a player will give you some earnmeter

// balance, hardcoded for now
const array<int> BLEEDOUT_DOT_DAMAGE_TYPES =
[
	eDamageSourceId.mp_weapon_thermite_grenade,
	eDamageSourceId.mp_weapon_grenade_electric_smoke,
	eDamageSourceId.burn, // triggered by "thermite_grenade_dot"
]
const float BLEEDOUT_DOWNED_DOT_DAMAGE_SCALE = 0.3 // scale dot damage for downed players, so they can try to escape

const array<int> BLEEDOUT_TRAP_DAMAGE_TYPES =
[
	eDamageSourceId.mp_weapon_satchel,
	eDamageSourceId.mp_weapon_proximity_mine, // modded weapon
]
const float BLEEDOUT_DOWNED_TRAP_DAMAGE_SCALE = 0.7 // scale trap damage for downed players, as they mostly can't escape from traps
// things below should be in playlistvar
/*
riff_player_bleedout 1
player_bleedout_forceHolster 1
player_bleedout_forceDeathOnTeamBleedout 0
player_bleedout_bleedoutTime 20
player_bleedout_firstAidTime 2
player_bleedout_firstAidTimeSelf 6
player_bleedout_firstAidHealPercent 0.4
player_bleedout_aiBleedingPlayerMissChance 0.25
*/

// abandoned, these will cause desync without modifying playlisrvars
/*
const float GAMEMODE_BLEEDOUT_TIME = 15
const float GAMEMODE_FIRSTAID_TIME = 2
const float GAMEMODE_FIRSTAID_TIME_SELF = 6
const float GAMEMODE_FIRSTAID_HEAL_PERCENT = 0.4
const float GAMEMODE_AI_BLEEDING_PLAYER_MISS_CHANCE = 0.5
const bool GAMEMODE_FORCE_WEAPON_HOLSTER = true
const bool GAMEMODE_DEATH_ON_TEAM_BLEEDOUT = false
*/

struct
{
    // modifiable variables
	// executions
	bool executingBleedingEnabled = false

	// health regen
	float bleedoutHealthRegenRate = 4.0
	float bleedoutHealthRegenDelay = 4.0

	// damage protection
	float protectionDuration = BLEEDOUT_PROTECTION_DURATION

	// incap shield
	int incapShieldMaxHealth = BLEEDOUT_INCAP_SHIELD_MAX_HEALTH
	bool invulnerableIncapShield

	// in-file variables
	// damage protection
	table<entity, float> playerBleedoutStartTime

	// apex loadout
	table< string, bool > useFakeApexLoadout // player's uid so they can retain loadout after re-join

	// title
	//table<entity, string> playerSavedTitle

	// incap shield
	//table<entity, int> incapShieldHealthTable // abandoned
	//table<entity, IncapShieldStruct> playerIncapShieldTable // no need to use 1p things
	table<entity, entity> playerIncapShieldTable
	
	// fake player models
	table<entity, entity> bleedoutFakePlayers // no support for now

	// score event
	table< entity, array<entity> > playerBeingKnockDownBy // handle knockdown score event
} file

void function Modded_Gamemode_Bleedout_Init()
{
	//SetServerVar( "ammoLimit", true )
	//SetServerVar( "playerBleedout", true )

    PrecacheParticleSystem( FLESH_PINKMIST_FX )
	PrecacheParticleSystem( MECHNAICAL_PINKMIST_FX )

	// modified function in _utility_shared.nut, disable bleedout killcam
	AddReplayDisabledDamageSourceId( eDamageSourceId.bleedout )

    Rodeo_SetBatterySkinRandom( false ) // from _rodeo_titan.gnut
	Nessie_SetDecoyOutfit( true ) // from mp_ability_holopilot.nut
	//Nessie_DecoyOutfitInit() // init decoy
	
    Bleedout_EnableExecutingBleedingPlayer( true ) // funny
	//Bleedout_SetIncapShieldInvulnerable( true ) // op
	//Bleedout_AllowInterruptSelfRes( false ) // meaning you can choose weather allow teammate revive you, complicated
	SetShouldPlayerStartBleedoutFunc( GamemodeBleedout_PlayerDownedCheck ) // using this will also check shield health
	Bleedout_SetBleedoutDofEnabled( false ) // disables annoying dof
	Bleedout_SetDownedGracePeriodEnabled( false ) // disable annoying sound

    //Melee_SetSyncedMeleeNoLimit( true ) // so you can execute anywhere
	Melee_AlwaysDoRandomSyncedMelee( true ) // funny modifier
    //Rodeo_SetBatteryThrowEnabled( true ) // messed up
	
    Burnmeter_SetForcedReward( "burnmeter_emergency_battery" ) // from _burnmeter.gnut

    SetAltPilotChance( 0.5 ) // higher chance to change model, 50%
    //SetShouldAlsoFuckOffPOV( false ) // for something
    SetShouldFUCKOFFCLOAK( true ) // fuck them
	
    //SetPlayerDeathsHidden( true ) // no sounds for deaths, and won't count deaths by default
    SetWeaponDropsEnabled( false ) // bleedout uses USE so much, don't let players drop weapons
	// modified function in _score.nut, override "KillPilot" with "EliminatePilot"
	ScoreEvent_SetScoreEventNameOverride( "KillPilot", "EliminatePilot" )
    
    // from pilot_shield_battery.gnut, shield battery main mechanic
    SetPilotBatteryUsageAllowed( true )
    SetShieldBatteryInputOverwritesBoost( true )
    SetShieldBatteryUseTime( BLEEDOUT_MODE_SHIELD_BATTERY_USETIME, BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_USETIME )
    SetShieldBatteryRegenAmount( BLEEDOUT_MODE_SHIELD_BATTERY_REGEN_AMOUNT, BLEEDOUT_MODE_AMPED_SHIELD_BATTERY_REGEN_AMOUNT )

    // don't make the intro annoying
	SetShouldPlayFactionDialogue( false )
    SetWaitingForPlayersMaxDuration( 10.0 )
    ClassicMP_SetCustomIntro( ClassicMP_ShorterDropshipIntro_Setup, DROPSHIP_INTRO_LENGTH_SHORTER )

    Bleedout_AddCallback_OnPlayerStartBleedout( BleedoutMode_OnPlayerDowned )
    Bleedout_AddCallback_OnPlayerBeenRevived( BleedoutMode_OnPlayerRevived )

    //AddCallback_GameStateEnter( eGameState.Playing, SetBleedoutState )
    AddCallback_OnClientConnected( OnClientConnected )
    AddCallback_OnClientDisconnected( OnClientDisconnected )
    AddCallback_PlayerClassChanged( OnPlayerClassChanged )
    AddCallback_OnPlayerRespawned( OnPlayerRespawned )
    AddCallback_OnPlayerGetsNewPilotLoadout( OnPlayerGetsPilotLoadout )
    AddCallback_OnPlayerKilled( OnPlayerKilled )
    AddCallback_OnTouchHealthKit( "item_titan_battery", OnTouchBatteryPack )

	// damage protection
	AddDamageCallback( "player", OnPlayerFinalDamaged )

	// balance handler
	AddDamageCallback( "player", OnPlayerDamaged )

    // more score added
    AddCallback_GameStateEnter( eGameState.Playing, SetBleedoutModeScoreEvent )

	// grapple!!!
	AddCallback_OnPlayerGrappled( BleedoutOnPlayerGrappled )

	// UNUSED
    RegisterSignal( "GiveMeleeAfterGracePeriod" )

    // do these in playlistvar?, pretty annoying
	// abandoned, these will cause desync without modifying playlisrvars
	/*
    Riff_ForcePlayerBleedout( ePlayerBleedout.Enabled )
    BleedoutShared_Init( 
        GAMEMODE_BLEEDOUT_TIME, 
        GAMEMODE_FIRSTAID_TIME,
	    GAMEMODE_FIRSTAID_TIME_SELF, 
        GAMEMODE_FIRSTAID_HEAL_PERCENT,
	    GAMEMODE_AI_BLEEDING_PLAYER_MISS_CHANCE, 
        GAMEMODE_FORCE_WEAPON_HOLSTER,
	    GAMEMODE_DEATH_ON_TEAM_BLEEDOUT 
        )
    Bleedout_Init()
	*/

    Riff_ForceTitanAvailability( eTitanAvailability.Never )
}

void function SetBleedoutState()
{
    

    //BleedoutShared_Init( 30, 4,8, 0.4,0.5, true,true )
}

// modified function
void function OnClientConnected( entity player )
{
	foreach ( string notification in CONNECTING_NOTIFICATIONS )
	    Chat_ServerPrivateMessage( player, notification, false, false )

	// damage protection
	file.playerBleedoutStartTime[ player ] <- -1

	// apex loadout
    file.useFakeApexLoadout[ player.GetUID() ] <- false
    if( BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT )
        AddButtonPressedPlayerInputCallback( player, IN_MELEE, SwitchLoadoutType )

	// shield notifications
    //AddButtonPressedPlayerInputCallback( player, IN_USE, GetShieldLeft )
    //AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, GetShieldLeft )

    // title
	//file.playerSavedTitle[ player ] <- "" // no idea now

	// incap shield
	//file.incapShieldHealthTable[ player ] <- file.incapShieldMaxHealth
	file.playerIncapShieldTable[ player ] <- null
	/*
	IncapShieldStruct emptyStruct
	emptyStruct.vortexSphere = null
	emptyStruct.shieldWallFX1P = null
	file.playerIncapShieldTable[ player ] <- emptyStruct
	*/

	// fake player model
	file.bleedoutFakePlayers[ player ] <- null

	// score event
	file.playerBeingKnockDownBy[ player ] <- []

	// disable aimassist life long
	thread DisablePlayerBeingAimAssisted( player )
}

void function DisablePlayerBeingAimAssisted( entity player )
{
	player.EndSignal( "OnDestroy" )

	while ( true )
	{
		if ( IsAlive( player ) )
			player.SetAimAssistAllowed( false )
		WaitFrame()
	}
}

void function OnClientDisconnected( entity player )
{
    /* // onClientDisconnected can't handle this
    delete file.playerSavedTitle[ player ]
	delete file.incapShieldHealthTable[ player ]
	delete file.playerIncapShieldTable[ player ]
    */
}

void function OnPlayerClassChanged( entity player )
{
	// health&shield update
	if ( IsAlive( player ) ) // can't set health for a no-alive entity
	{
		if ( !player.IsTitan() && player.GetPlayerSettings() != "spectator" )
		{
			player.SetMaxHealth( BLEEDOUT_MODE_HEALTH )
			player.SetHealth( BLEEDOUT_MODE_HEALTH )
			player.SetShieldHealthMax( BLEEDOUT_MODE_SHIELD_HEALTH )
			player.SetShieldHealth( BLEEDOUT_MODE_SHIELD_HEALTH )
		}
	}

    //print( "Running OnPlayerClassChanged()" )
    thread Bleedout_HealthRegenThink( player )
}

void function OnPlayerRespawned( entity player )
{
	DeleteAllPlayerMessages( player ) // defensive fix
	thread PlayerStatusDisplayer( player )

    if( !BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT )
        return
    if( !file.useFakeApexLoadout[player.GetUID()] )
        SendHudMessage( player, "當前裝備: 原版技能組\n按下 近戰 切換至僞apex技能組", -1, -0.3, 0, 255, 255, 255, 0, 10, 0 )
    else if( file.useFakeApexLoadout[player.GetUID()] )
        SendHudMessage( player, "当前装备: 僞apex技能組\n按下 近戰 切換至原版技能組", -1, -0.3, 0, 255, 255, 255, 0, 10, 0 )
}

void function OnPlayerGetsPilotLoadout( entity player, PilotLoadoutDef p )
{
    // FUCKOFFCLOAK( player )
    // don't enable Nessy_EnableAllFunny_Init(), will conflict, use it's function instead
    ClearNessy( player ) 
	SpawnNessyOutfit( player ) // become better!

	// offhand limit
    for ( int i = 0; i <= OFFHAND_MELEE; i++ ) // for better sloting
    {
        entity nowWeapon = player.GetOffhandWeapon( i )
        if( IsValid( nowWeapon ))
        {
            string className = nowWeapon.GetWeaponClassName()
            if( className == "mp_ability_cloak" )
            {
                player.TakeWeaponNow( className )
                player.GiveOffhandWeapon( "mp_ability_grapple", i )
            }
            else if( className == "mp_weapon_deployable_cover" )
            {
                player.TakeWeaponNow( className )
                player.GiveOffhandWeapon( "mp_weapon_hard_cover", i, ["hard_cover_always"] )
            }
        }
    }

	// anti-titan replace
	foreach ( entity weapon in player.GetMainWeapons() )
	{
		string className = weapon.GetWeaponClassName()
		if ( className == "mp_weapon_rocket_launcher" )
		{
			weapon.AddMod( "no_lock_required" )
			//weapon.AddMod( "at_low_stockpile" )
			/* // now using max ammo
			if ( weapon.HasMod( "extended_ammo" ) )
			{
				// maybe because extended_ammo has been modified by my self to "ammo_default_total" * 1.29, this will only have 5 rockets!
				weapon.SetWeaponPrimaryAmmoCount( 6 )
			}
			else
				weapon.SetWeaponPrimaryAmmoCount( 4 ) // limited to 5 shots
			*/
		}
		if ( className == "mp_weapon_arc_launcher" )
		{
			weapon.AddMod( "antipilot_arc_launcher" )
		}
		if ( className == "mp_weapon_mgl" )
		{
			weapon.AddMod( "flesh_magnetic" )
		}
		if ( className == "mp_weapon_defender" )
		{
			weapon.RemoveMod( "quick_charge" ) // quick charge has built in bleedout_balance
		}
	}

    SyncedMelee_Disable( player )

	player.GiveExtraWeaponMod( "bleedout_balance" )
	//player.GiveExtraWeaponMod( "pushback_melee" ) // removed for now, using normal emptyhanded melee

    if( file.useFakeApexLoadout[player.GetUID()] ) // apex loadout players
    {
        AltPilot_ReplacePilotModel( player )
        GiveFakeApexLoadout( player )
    }
    if( BLEEDOUT_MODE_ENABLE_SECOND_LOADOUT )
        thread GiveMeleeAfterGracePeriod( player )
    else
	{
		// balance ordnances
		entity ordnance = player.GetOffhandWeapon( OFFHAND_ORDNANCE )
		if ( IsValid( ordnance ) )
		{
			string ordnanceName = ordnance.GetWeaponClassName()
			switch ( ordnanceName )
			{
				case "mp_weapon_frag_grenade":
					ordnance.AddMod( "frag_no_charge" )
					break
				case "mp_weapon_satchel":
					ordnance.AddMod( "satchel_long_delay" )
					break
				case "mp_weapon_thermite_grenade":
					ordnance.AddMod( "thermite_grenade_dot" )
					break
			}
			
		}
		// better melee weapon
		//thread DelayedCheckMelee( player ) // removed for now, using normal emptyhanded melee
		entity meleeWeapon = player.GetOffhandWeapon( OFFHAND_MELEE )
		if ( IsValid( meleeWeapon ) )
		{
		    meleeWeapon.AddMod( "pushback_melee" )
			meleeWeapon.AddMod( "fake_human_melee" )
			meleeWeapon.AddMod( "jetpack_fx_melee" ) // cool stuffs
		}
	}
}

void function GiveMeleeAfterGracePeriod( entity player )
{
    player.EndSignal( "OnDeath" )
    player.EndSignal( "OnDestroy" )
    player.Signal( "GiveMeleeAfterGracePeriod" )
    player.EndSignal( "GiveMeleeAfterGracePeriod" )
    player.TakeOffhandWeapon( OFFHAND_MELEE )

    while( true )
    {
        if( !( expect bool( player.s.inGracePeriod ) ) )
            break
        WaitFrame()
    }
	
    GivePlayerSpecialMelee( player )
}

void function DelayedCheckMelee( entity player )
{
	player.TakeOffhandWeapon( OFFHAND_MELEE )
    WaitFrame()
    if( IsAlive( player ) )
    {
        GivePlayerSpecialMelee( player )
    }
}

void function GivePlayerSpecialMelee( entity player )
{
	string meleeToGive = CoinFlip() ? "melee_pilot_kunai" : "melee_pilot_sword"
	if( !IsValid( player.GetOffhandWeapon( OFFHAND_MELEE ) ) )
        player.GiveOffhandWeapon( meleeToGive, OFFHAND_MELEE )
}

void function OnPlayerKilled( entity victim, entity attacker, var damageInfo )
{
    ClearNessy( victim )
    // abandoned, only using emergency batteries
    /*
    entity battery = Rodeo_CreateBatteryPack()
    if( IsValid( battery ) )
    {
        battery.SetOrigin( victim.EyePosition() )
        battery.SetVelocity( < 0,0,1 > )
    }
    */

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
    entity attacker = DamageInfo_GetAttacker( damageInfo )
    // reward for executions
    if( IsValid( attacker ) && damageSourceID == eDamageSourceId.human_execution )
	{
		if( attacker.IsPlayer() && victim.IsPlayer() && victim != attacker )
		{
			if( attacker.GetShieldHealth() < attacker.GetShieldHealthMax() )
			{
				int shieldRestored = PlayerShieldReward( attacker, BLEEDOUT_MODE_EXECUTION_SHIELD_REWARD )
				SendHudMessage( attacker, "處決一名敵人, 已回復" + string(shieldRestored) + "點護盾! ", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
			}
		}
	}

	if ( attacker != victim ) // suicide check!
	{
		// score events, add meter for dead player
		PlayerEarnMeter_AddEarnedAndOwned( victim, BLEEDOUT_MODE_DEATH_EARNED_VALUE, BLEEDOUT_MODE_DEATH_OWNED_VALUE )
	}
	file.playerBeingKnockDownBy[ victim ].clear() // clear knocked down saver

	// we never count player's deaths
	thread DelayedReducePlayerDeathCount( victim )
	
}

void function DelayedReducePlayerDeathCount( entity player )
{
	player.EndSignal( "OnDestroy" )
	WaitEndFrame() // wait for other death callbacks setup and death count being added

	if ( player.GetPlayerGameStat( PGS_DEATHS ) > 0 )
		player.AddToPlayerGameStat( PGS_DEATHS, -1 )
}

void function OnPlayerFinalDamaged( entity victim, var damageInfo )
{
	if ( Bleedout_IsPlayerBleeding( victim ) ) // victim is bleeding!
	{
		// damage protection
		// don't block bleedout knockdown shot( we need to leave knockbacks for player )
		// well, no need to add complicated checks, knockdown shots won't be blocked here
		float protectionEndTime = file.playerBleedoutStartTime[ victim ] + file.protectionDuration
		if ( Time() < protectionEndTime )
		{
			// debug
			//print( "Damage blocked by bleedout protection" )
			
			DamageInfo_SetDamage( damageInfo, 0 )
		}
	}
}

void function OnPlayerDamaged( entity victim, var damageInfo )
{
	if ( Bleedout_IsPlayerBleeding( victim ) ) // victim is bleeding!
	{
		// dot damage banlance
		int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
		if ( BLEEDOUT_DOT_DAMAGE_TYPES.contains( damageSourceID ) )
			DamageInfo_ScaleDamage( damageInfo, BLEEDOUT_DOWNED_DOT_DAMAGE_SCALE )
		else if ( BLEEDOUT_TRAP_DAMAGE_TYPES.contains( damageSourceID ) )
			DamageInfo_ScaleDamage( damageInfo, BLEEDOUT_DOWNED_TRAP_DAMAGE_SCALE )
	}
}

int function PlayerShieldReward( entity player, int reward )
{
	entity shieldFXHandle = StartParticleEffectOnEntity_ReturnEntity( player, GetParticleSystemIndex( $"P_xo_armor_body_CP" ), FX_PATTACH_POINT_FOLLOW, player.LookupAttachment( "CHESTFOCUS" ) )
	SetTeam( shieldFXHandle, player.GetTeam() )
	shieldFXHandle.SetOwner( player )
	EffectSetControlPointVector( shieldFXHandle, 1, <115, 247, 255> )

	int currentShieldHealth = player.GetShieldHealth()
	int shieldToRestore = int( min( player.GetShieldHealthMax() - currentShieldHealth, reward ) )
	if( shieldToRestore <= reward ) // consider shield is full, not showing a extra fx
		shieldFXHandle.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	player.SetShieldHealth( min( player.GetShieldHealthMax(), player.GetShieldHealth() + shieldToRestore ) )
	MessageToPlayer( player, eEventNotifications.VANGUARD_ShieldGain, player )

	return shieldToRestore
}

bool function OnTouchBatteryPack( entity player, entity batteryPack )
{
    if( !IsAlive( player ) )
        return false
    //if( IsValid( GetBatteryOnBack( player ) ) ) // player carring a battery
    //    return false
    // HACKED FIX!
    if( GetPlayerLastShieldBatteryUsedTime( player ) >= Time() - 1.0 ) // modified function in pilot_shield_battery.gnut
    {
        //print( GetPlayerLastShieldBatteryUsedTime( player ) >= Time() - 1.0 )    
        return false
    }
    SendHudMessage( player, "按下 強化 按鍵\n使用護盾電池", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )

    //Basically always return false since we don't want the battery pack to go away when being touched. ApplyBatteryToTitan() etc will deal with lifetime of battery
	return false
}

void function SetBleedoutModeScoreEvent()
{
	if ( IsLobby() )
		return

    ScoreEvent_SetEarnMeterValues( "EliminatePilot", BLEEDOUT_MODE_ELIMINATE_PILOT_EARNED_VALUE, BLEEDOUT_MODE_ELIMINATE_PILOT_OWNED_VALUE )
    ScoreEvent_SetEarnMeterValues( "PilotAssist", BLEEDOUT_MODE_PILOT_ASSIST_EARNED_VALUE, BLEEDOUT_MODE_PILOT_ASSIST_OWNED_VALUE )
}

void function BleedoutMode_OnPlayerDowned( entity player, entity attacker, var damageInfo )
{
    //print( "Running OnPlayerDowned()" )
	//player.Signal( "StopHealthRegenThink" )
	// Delete any shield health remaining, but not for DF_BYPASS_SHIELDS
	if( !( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BYPASS_SHIELD ) )
		player.SetShieldHealth( 0 )

	// error handle... don't know how this happens
	if ( !IsAlive( player ) )
	{
		print( "Bleedout error: player died when not getting downed!" )
		printt( "BleedoutMode_OnPlayerDowned() ent:", player )
		printt( "    Attacker:", DamageInfo_GetAttacker( damageInfo ) )
		printt( "    Inflictor:", DamageInfo_GetInflictor( damageInfo ) )
		printt( "    Distance:", DamageInfo_GetDistFromAttackOrigin( damageInfo ) )
		printt( "    Original damage:", DamageInfo_GetDamage( damageInfo ) )
		printt( "    Hitbox:", DamageInfo_GetHitBox( damageInfo ) )
		int sourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
		printt( "    SourceID:", sourceID )
		if ( sourceID == -1 )
			printt( "    SourceID: From Code (npc melee, etc)" )
		else
			printt( "    SourceID:", GetObitFromDamageSourceID( sourceID ) )

		PrintDamageFlags( DamageInfo_GetCustomDamageType( damageInfo ) )

		return
	}

	file.playerBleedoutStartTime[ player ] = Time()
    thread UpdateBleedoutPlayerHealth( player )

    Bleedout_PlayerDownedSound( player, attacker )
	Bleedout_PlayerDownedEffect( player, damageInfo )
	Bleedout_PlayerDownedObit( player, attacker, damageInfo ) // now only shows to attacker!

    EmitSoundOnEntityToTeamExceptPlayer( player, "UI_Spawn_FriendlyPilot", player.GetTeam(), player )

    //thread Bleedout_DeathProtection( player )
	thread Bleedout_PlayerMovementLimiter( player ) // using this now, also prevents player from slide hopping
	/*
	string playerTitle = player.GetTitle()
	if( playerTitle != "#DEATH_BLEEDOUT" && playerTitle !=  )
		file.playerSavedTitle[player] = playerTitle
	*/
	//thread Bleedout_PlayerSlidePrevention( player )
    //thread Bleedout_FakePlayerThink( player ) // don't know how to do this
	// this should done before callbacks since it triggers a "OnClassChange"
	// done using Bleedout_PlayerMovementLimiter()
	//Bleedout_DiableWallrunAndDoubleJump( player ) 

	thread Bleedout_VisualEffectThink( player )
	thread Bleedout_EnemySpottingHighlight( player )
	if( Bleedout_GetForceWeaponHolster() ) // if player is able to use a weapon, we don't enable incap shields
	{
		thread Bleedout_IncapShieldThink( player )
		thread Bleedout_PlayerHolsterWeapon( player ) // better fix
	}
    if( file.executingBleedingEnabled )
		thread Bleedout_BecomeExecutionTarget( player )

	// score event
	if ( IsValid( attacker ) && attacker.IsPlayer() )
	{
		if ( PlayerCanEarnFromKnockdown( attacker, player ) )
			PlayerEarnMeter_AddEarnedAndOwned( attacker, BLEEDOUT_MODE_KNOCKDOWN_EARNED_VALUE, BLEEDOUT_MODE_KNOCKDOWN_OWNED_VALUE )
	}
}

void function UpdateBleedoutPlayerHealth( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	
	WaitEndFrame() // wait for the damage going through

	if ( Bleedout_IsPlayerBleeding( player ) )
	{
		player.SetMaxHealth( BLEEDOUT_MODE_DOWNED_HEALTH * 5 )
		player.SetHealth( BLEEDOUT_MODE_DOWNED_HEALTH )
	}
}

bool function PlayerCanEarnFromKnockdown( entity attacker, entity victim )
{
	if ( attacker == victim ) // self damage
		return false
	
	if ( file.playerBeingKnockDownBy[ victim ].contains( attacker ) ) // only gain once for each knockdowner!
		return false

	file.playerBeingKnockDownBy[ victim ].append( attacker )
	return true
}

void function BleedoutMode_OnPlayerRevived( entity playerToRes, entity playerHealer )
{
    //print( "Running OnPlayerRevived()" )
    // this should done before callbacks since it triggers a "OnClassChange"
	// done using Bleedout_PlayerMovementLimiter()
	//Bleedout_EnableWallrunAndDoubleJump( playerToRes )
	//player.Signal( "StopHealthRegenThink" )

	file.playerBleedoutStartTime[ playerToRes ] = -1
    playerToRes.SetMaxHealth( BLEEDOUT_MODE_HEALTH )
    playerToRes.p.lastDamageTime = Time()

    thread Bleedout_PlayerForceStand( playerToRes ) // so players won't have to manually cancel their crouch, but might be annoying for reviving behind low covers

    // do a reward for playerHealer
	if( playerHealer != playerToRes ) // selfRes
	{
    	if( playerHealer.GetShieldHealth() < playerHealer.GetShieldHealthMax() )
		{
			int shieldRestored = PlayerShieldReward( playerHealer, BLEEDOUT_MODE_REVIVING_FRIENDLY_SHIELD_REWARD )
			SendHudMessage( playerHealer, "復活一名隊友, 已回復" + string(shieldRestored) + "點護盾! ", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
		}
	}
}

void function SwitchLoadoutType( entity player )
{
    if( !Loadouts_CanGivePilotLoadout( player ) )
        return

    string uid = player.GetUID()

    if( !file.useFakeApexLoadout[uid] )
    {
        file.useFakeApexLoadout[uid] = true
        SendHudMessage( player, "当前装备: 伪apex技能\n按 近战 切换至原版", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
        Loadouts_TryGivePilotLoadout( player )
    }
    else if( file.useFakeApexLoadout[uid] )
    {
        file.useFakeApexLoadout[uid] = false
        SendHudMessage( player, "当前装备: 原版\n按 近战 切换至伪apex技能", -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
        Loadouts_TryGivePilotLoadout( player )
    }
}

void function GiveFakeApexLoadout( entity player )
{
    string tacticalName = player.GetOffhandWeapon( OFFHAND_SPECIAL ).GetWeaponClassName()
    string ordnanceName = player.GetOffhandWeapon( OFFHAND_ORDNANCE ).GetWeaponClassName()

    if( ordnanceName == "mp_weapon_grenade_gravity" )
        GiveReplacementOrdnance( player )

    player.TakeWeaponNow( tacticalName )
    player.TakeWeaponNow( ordnanceName )

    switch( tacticalName )
    {
        case "mp_weapon_hard_cover":
            player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_SPECIAL, ["deployable_dome_shield"] )
            break
        case "mp_ability_heal":
			player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_SPECIAL, ["jump_pad"] )
            break
		case "mp_ability_grapple":
			player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, ["zipline_gun"] )
            break
		case "mp_ability_holopilot":
			player.GiveOffhandWeapon( "mp_ability_holopilot", OFFHAND_SPECIAL, ["holoshift"] )
            break
		case "mp_ability_shifter":
            player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["wraith_portal", "amped_tacticals"] )
            break
        case "mp_weapon_grenade_sonar":
            player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_SPECIAL, ["gravity_lift"] )
            break
    }

    switch( ordnanceName )
    {
        case "mp_weapon_frag_grenade":
            player.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ORDNANCE, ["pilot_tether"] )
            break
        case "mp_weapon_grenade_emp":
			player.GiveOffhandWeapon( "mp_weapon_arc_trap", OFFHAND_ORDNANCE, ["limited_arc_trap", "multiplayer_arc_trap"] )
            break
        case "mp_weapon_thermite_grenade":
			player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE, ["flamewall_grenade"] )
            break
        case "mp_weapon_grenade_electric_smoke":
			player.GiveOffhandWeapon( "mp_titanability_slow_trap", OFFHAND_ORDNANCE, ["gas_trap"] )
            break
        case "mp_weapon_satchel":
            player.GiveOffhandWeapon( "mp_weapon_satchel", OFFHAND_ORDNANCE, ["proximity_mine"] )
            break
        default:
            player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE )
    }
}

void function GiveReplacementOrdnance( entity player )
{
    string tacticalName = player.GetOffhandWeapon( OFFHAND_SPECIAL ).GetWeaponClassName()
    string ordnanceName = player.GetOffhandWeapon( OFFHAND_ORDNANCE ).GetWeaponClassName()
        
    player.TakeWeaponNow( ordnanceName )
    switch( tacticalName )
    {
        case "mp_ability_grapple":
            player.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ORDNANCE, ["pilot_tether"] )
            break
        case "mp_ability_heal":
			player.GiveOffhandWeapon( "mp_weapon_arc_trap", OFFHAND_ORDNANCE, ["limited_arc_trap", "multiplayer_arc_trap"] )
            break
        case "mp_weapon_hard_cover":
			player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE, ["flamewall_grenade"] )
            break
        case "mp_ability_shifter":
			player.GiveOffhandWeapon( "mp_titanability_slow_trap", OFFHAND_ORDNANCE, ["gas_trap"] )
            break
        case "mp_ability_holopilot":
            player.GiveOffhandWeapon( "mp_weapon_satchel", OFFHAND_ORDNANCE, ["proximity_mine"] )
            break
        default:
            player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE )
    }
}

const string BLEEDOUT_MODE_SHIELD_MESSAGE_ID = "11"
const string BLEEDOUT_MODE_HEALTH_MESSAGE_ID = "12"
const string BLEEDOUT_MODE_BATTERY_HINT_ID = "15"

void function DeleteAllPlayerMessages( entity player ) // for defensive fix
{
	NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_SHIELD_MESSAGE_ID )
	NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_HEALTH_MESSAGE_ID )
	NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_BATTERY_HINT_ID )

	// don't forget to remove this
	NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID )
}

void function PlayerStatusDisplayer( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( player )
		{
			// clean up
			if ( IsValid( player ) )
			{
				DeleteAllPlayerMessages( player )
			}
		}
	)

	WaitFrame()
	// wait for leaving dropship or end intro
	while ( HasCinematicFlag( player, CE_FLAG_INTRO ) || 
			HasCinematicFlag( player, CE_FLAG_CLASSIC_MP_SPAWNING ) || 
			HasCinematicFlag( player, CE_FLAG_WAVE_SPAWNING ) ||
			HasCinematicFlag( player, CE_FLAG_HIDE_MAIN_HUD ) )
		WaitFrame()

	wait 3 // maybe fixes players unable to move?
	if ( GetGameState() > eGameState.Playing )
		return

	if ( !player.IsWatchingSpecReplay() && !player.IsWatchingKillReplay() ) // maybe need this fix?
	{
		NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_SHIELD_MESSAGE_ID ) // try to delete existing one
		NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_HEALTH_MESSAGE_ID ) // try to delete existing one
		NSCreateStatusMessageOnPlayer( player, "護盾", string( player.GetShieldHealth() ), BLEEDOUT_MODE_SHIELD_MESSAGE_ID ) // init shield message
		NSCreateStatusMessageOnPlayer( player, "血量", string( player.GetHealth() ), BLEEDOUT_MODE_HEALTH_MESSAGE_ID ) // init health message
	}

	bool hasBatteryHint = false
	bool hasIncapShieldHint = false
	while ( true )
	{
		if ( GetGameState() > eGameState.Playing )
			return
		WaitFrame()
		//player.WaitSignal( "OnDamaged" ) // this can't handle the health regen!
		string shieldString = string( player.GetShieldHealth() )
		string healthString = string( player.GetHealth() )
		if ( Bleedout_IsPlayerBleeding( player ) ) // for noticing players health that they've been downed
			healthString += " (倒地)"

		NSEditStatusMessageOnPlayer( player, "護盾", shieldString, BLEEDOUT_MODE_SHIELD_MESSAGE_ID ) // update shield message
		NSEditStatusMessageOnPlayer( player, "血量", healthString, BLEEDOUT_MODE_HEALTH_MESSAGE_ID ) // update health message

		if ( ShouldAddPlayerBatteryHint( player ) && player.GetShieldHealth() != player.GetShieldHealthMax() && !Bleedout_IsPlayerBleeding( player ) )
		{
			if ( hasBatteryHint )
				continue
			else
			{
				hasBatteryHint = true
				if ( !player.IsWatchingSpecReplay() && !player.IsWatchingKillReplay() ) // maybe need this fix?
				{
					NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_BATTERY_HINT_ID ) // try to delete existing one
					NSCreateStatusMessageOnPlayer( player, "", "護盾電池可用，按下 強化 回復護盾", BLEEDOUT_MODE_BATTERY_HINT_ID )
				}
			}
		}
		else
		{
			if ( hasBatteryHint )
			{
				hasBatteryHint = false
				NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_BATTERY_HINT_ID )
			}
		}
	}
}

bool function ShouldAddPlayerBatteryHint( entity player )
{
	entity batteryWeapon = player.GetOffhandWeapon( OFFHAND_INVENTORY ) // get current
	entity battery = GetBatteryOnBack( player )
	if ( IsValid( battery ) )
		return true
	
	if ( IsValid( batteryWeapon ) )
	{
		if( batteryWeapon.HasMod( "burnmeter_emergency_battery" ) )
        {
			return true
		}
	}

	return false
}

void function GetShieldLeft( entity player )
{
    SendHudMessage( player, "剩餘護盾值: " + string( player.GetShieldHealth() ) + " / " + string( player.GetShieldHealthMax() ), -1, -0.3, 0, 255, 255, 255, 0, 2, 0 )
}


// Gamemode Functions!!!
bool function GamemodeBleedout_PlayerDownedCheck( entity victim, var damageInfo )
{
	bool isBypassShield = ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BYPASS_SHIELD ) > 0
	// doing a better check including shield health
	if ( victim.GetHealth() + victim.GetShieldHealth() - DamageInfo_GetDamage( damageInfo ) <= 0 )
		return true
	// bypass shield condition
	else if ( isBypassShield && victim.GetHealth() - DamageInfo_GetDamage( damageInfo ) <= 0 )
		return true

	return false
}

void function Bleedout_PlayerHolsterWeapon( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function():( player )
		{
			//if( IsValid( player ) )
			//	player.Server_TurnOffhandWeaponsDisabledOff()
		}
	)

	//wait file.protectionDuration * 0.5 // wait for player switching to mp_weapon_gunship_missile
	while( true )
	{
		player.HolsterWeapon()
		//player.Server_TurnOffhandWeaponsDisabledOn()
		WaitFrame() // wait in the first loop
	}
}

void function Bleedout_PlayerDownedSound( entity victim, entity attacker )
{
	if( attacker.IsPlayer() )
	{
		if( victim.IsMechanical() )
		{
			if( attacker != victim )
			{
				// this has been handled by DF_KILLSHOT
				//EmitSoundOnEntityOnlyToPlayer( victim, attacker, "flesh_bulletimpact_killshot_1p_vs_3p" )
				EmitSoundOnEntityExceptToPlayer( victim, attacker, "android_bulletimpact_killshot_3p_vs_3p" )
			}
		}
		else
		{
			if( attacker != victim )
			{
				// this has been handled by DF_KILLSHOT
				//EmitSoundOnEntityOnlyToPlayer( victim, attacker, "flesh_bulletimpact_killshot_1p_vs_3p" )
				EmitSoundOnEntityExceptToPlayer( victim, attacker, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
			}
		}
	}
	else
	{
		if( victim.IsMechanical() )
			EmitSoundOnEntityExceptToPlayer( victim, victim, "android_bulletimpact_killshot_3p_vs_3p" )
		else
			EmitSoundOnEntityExceptToPlayer( victim, victim, "flesh_heavy_bulletimpact_killshot_3p_vs_3p" )
	}

	// what ever we do, emit sound on victim themselves, fx handling in Bleedout_PlayerDownedEffect()
	EmitSoundOnEntityOnlyToPlayer( victim, victim, "flesh_bulletimpact_killshot_1p_vs_3p" )
}

void function Bleedout_PlayerDownedEffect( entity player, var damageInfo )
{
	if( !( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BULLET ) ) // not a bullet damage type
		return
	int attachmentIndex = player.LookupAttachment( "CHESTFOCUS" )
	if ( attachmentIndex <= 0 )
		return
	if( player.IsMechanical() )
	{
		// don't show mechanic downed effect to owner themselves, it's annoying!
		int particleIndex = GetParticleSystemIndex( MECHNAICAL_PINKMIST_FX )
		entity fx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		SetTeam( fx, player.GetTeam() )
		fx.SetOwner( player )
		fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
		EffectSetControlPointVector( fx, 1, < 0, 0, 0 > ) // prevent blood fx fly everywhere
		thread FastStopParticle( fx, 1.0 )
		//entity ownerFx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		//fx.SetOwner( player )
		//fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
		//thread FastStopParticle( fx, 1.0 )
	}
	else
	{
		int particleIndex = GetParticleSystemIndex( FLESH_PINKMIST_FX )
		entity fx = StartParticleEffectOnEntity_ReturnEntity( player, particleIndex, FX_PATTACH_POINT_FOLLOW, attachmentIndex )
		fx.SetOwner( player )
		fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
		EffectSetControlPointVector( fx, 1, < 0, 0, 0 > ) // prevent blood fx fly everywhere
	}
}

void function FastStopParticle( entity fx, float delay )
{
	fx.EndSignal( "OnDestroy" )
	wait delay
	EffectStop( fx )
}

void function Bleedout_PlayerDownedObit( entity ent, entity attacker, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	// trigger_hurt is no longer networked, so the "attacker" fails to display obituaries
	if ( attacker )
	{
		if( !attacker.IsPlayer() || ent == attacker ) // now only shows to attacker!
			return

		string attackerClassname = attacker.GetClassName()

		if ( attackerClassname == "trigger_hurt" || attackerClassname == "trigger_multiple" )
			attacker = GetEntByIndex( 0 ) // worldspawn
	}

	int attackerEHandle = attacker ? attacker.GetEncodedEHandle() : -1

	int victimEHandle = ent.GetEncodedEHandle()
	int scriptDamageType = DamageInfo_GetCustomDamageType( damageInfo )
	int damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo )

	if ( scriptDamageType & DF_VORTEX_REFIRE )
		damageSourceId = eDamageSourceId.mp_titanweapon_vortex_shield

	if ( IsValidHeadShot( damageInfo, ent ) )
		scriptDamageType = scriptDamageType | DF_HEADSHOT
	else
		scriptDamageType = scriptDamageType & (~DF_HEADSHOT)
	
	// now only shows to attacker!
	//Remote_CallFunction_NonReplay( attacker, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	foreach ( entity player in GetPlayerArray() )
	{
		if( player != ent ) // not player themselves only, or the client will consider them as died then hide their hud
			Remote_CallFunction_NonReplay( player, "ServerCallback_OnEntityKilled", attackerEHandle, victimEHandle, scriptDamageType, damageSourceId )
	}

	// moving from OnPlayerBleedoutBegin(), show a popup to attacker
	if( attacker != ent )
	{
		if( attacker.IsPlayer() && ent.IsPlayer() )
		{
			// serverside-RUI is really fucked up with updating per tick...
			//NSSendPopUpMessageToPlayer( attacker, "擊倒 " + ent.GetPlayerName() )
			//NSSendPopUpMessageToPlayer( ent, "被 " + attacker.GetPlayerName() + " 擊倒" )
			// temp remove these
			//SendHudMessage( attacker, "擊倒" + ent.GetPlayerName(), -1, -0.3, 0, 255, 255, 255, 0.2, 1.0, 0.5 )
			//SendHudMessage( ent, "被 " + attacker.GetPlayerName() + " 擊倒", -1, -0.3, 255, 255, 0, 255, 0.2, 1.5, 0.5 )
		}
	}
}

/* // reworked. now handled by OnPlayerFinalDamaged()
void function Bleedout_DeathProtection( entity player )
{
	// really should use a better check!
	//player.SetInvulnerable()
	//wait file.protectionDuration
	//if( IsValid( player ) )
	//	player.ClearInvulnerable()
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	// since assert() won't work, we need to check if the callback has been removed
	table results = {}
	results.postDamageCallbackRemoved <- false

	OnThreadEnd(
		function(): ( player, results )
		{
			if ( IsValid( player ) )
			{
				// clean up
				if ( !results.postDamageCallbackRemoved ) // hasn't be removed( killed by forceKill things? )
					RemoveEntityCallback_OnPostDamaged( player, OnRecentDownedPlayerPostDamage )
				else
					RemoveEntityCallback_OnDamaged( player, OnRecentDownedPlayerDamaged )
			}
		}
	)

	// update health
	player.SetHealth( BLEEDOUT_MODE_DOWNED_HEALTH )

	// this one is only for handling killshots!
	AddEntityCallback_OnPostDamaged( player, OnRecentDownedPlayerPostDamage )
	float endTime = Time() + file.protectionDuration
	WaitFrame()
	// since in postdamage the hitmarker has been displayed, we don't need it anymore
	RemoveEntityCallback_OnPostDamaged( player, OnRecentDownedPlayerPostDamage )
	results.postDamageCallbackRemoved = true // mark as removed

	AddEntityCallback_OnDamaged( player, OnRecentDownedPlayerDamaged )

	while ( Time() < endTime )
	{
		player.SetHealth( BLEEDOUT_MODE_DOWNED_HEALTH ) // keep setting the player to downed max health
		WaitFrame()
	}
}
*/

// reworked. now handled by OnPlayerFinalDamaged()
/*
void function OnRecentDownedPlayerDamaged( entity player, var damageInfo )
{
	if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) )
		return
	DamageInfo_SetDamage( damageInfo, 0 ) // protect the player
}

void function OnRecentDownedPlayerPostDamage( entity player, var damageInfo )
{
	if ( IsInstantDeath( damageInfo ) || DamageInfo_GetForceKill( damageInfo ) )
		return
	if( DamageInfo_GetCustomDamageType( damageInfo ) & DF_KILLSHOT ) // the killshot
		DamageInfo_SetDamage( damageInfo, player.GetHealth() - 1 ) // protect the player, leave knockbacks
	else // not a kill shot
		DamageInfo_SetDamage( damageInfo, 0 ) // protect the player
}
*/

void function Bleedout_PlayerMovementLimiter( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			if( IsValid( player ) )
			{
				player.UnforceCrouch()
				// using custom utility!
				//player.SetGroundFrictionScale( 1.0 )
				RestorePlayerPermanentGroundFriction( player )
			}
		}
	)


	// delay it so player can still slide off when in protection? better use after able to knockback players on killshot
	float slideDisableTime = Time() + file.protectionDuration
	while( true )
	{
		if ( Time() >= slideDisableTime )
		{
			// using custom utility!
			//player.SetGroundFrictionScale( 9999.0 )
			player.SetGroundFrictionScale( 9999.0 ) // really high to prevent sliding
		}
		else
		{
			// using custom utility!
			//player.SetGroundFrictionScale( 10.0 )
			player.SetGroundFrictionScale( 10.0 ) // at least let players slide a bit
		}
		player.ForceCrouch() // keep force crouch
		player.ConsumeDoubleJump() // keep using their double jumps
		if ( player.IsTraversing() ) // is traversing or mantling
			player.ClearTraverse() // force clear it
		WaitFrame()
	}
}

/* // not using following things
void function Bleedout_PlayerSlidePrevention( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	//bool lastFrameSlide // for checks
	while( true )
	{
		WaitFrame()
		if( player.IsSliding() && player.IsOnGround() ) // sometimes sliding off a roof will remain slide state, do a check
		{
			player.SetVelocity( < 0,0,0 > )
		//	lastFrameSlide = true
		//	continue
		}
		//if( lastFrameSlide && !player.IsOnGround() ) // prevent player being stopped midair
		//	player.SetVelocity( < 0,0,100 > )
		//lastFrameSlide = false
	}
}

void function Bleedout_DiableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	if( !settingMods.contains( "disable_wallrun" ) )
		settingMods.append( "disable_wallrun" )
	if( !settingMods.contains( "disable_doublejump" ) )
		settingMods.append( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}

void function Bleedout_EnableWallrunAndDoubleJump( entity player )
{
	// WARN!!! This triggers a "OnClassChange"
	int skin = player.GetSkin()
	int camo = player.GetCamo()
	asset modelName = player.GetModelName()

	string setFile = player.GetPlayerSettings()
	array<string> settingMods = player.GetPlayerSettingsMods()
	settingMods.removebyvalue( "disable_wallrun" )
	settingMods.removebyvalue( "disable_doublejump" )

	player.SetPlayerSettingsWithMods( setFile, settingMods )
	player.SetSkin( skin )
	player.SetCamo( camo )
	player.SetModel( modelName )
}
*/

void function Bleedout_PlayerForceStand( entity player )
{
	player.UnforceCrouch()
    // if player holding crouch we don't make them forced stand up!
    if( player.IsInputCommandHeld( IN_DUCK ) || player.IsInputCommandHeld( IN_DUCKTOGGLE ) )
        return
	player.ForceStand()
	wait 0.2
	if( IsValid( player ) )
		player.UnforceStand()
}

void function Bleedout_EnemySpottingHighlight( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	OnThreadEnd(
		function(): ( player )
		{
			Highlight_ClearEnemyHighlight( player )
		}
	)

	while( true )
	{
		// outline that can show through viewmodel
		Highlight_SetEnemyHighlight( player, "sp_enemy_pilot" ) // default is orange
		//player.Highlight_SetParam( 2, 0, < 2,0,0 > ) // red
		WaitFrame()
	}
}

void function Bleedout_BecomeExecutionTarget( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	wait file.protectionDuration // do need this to prevent execution invulnerable players

	entity hitbox = CreateHitboxEntityForPlayer( player )
	hitbox.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( hitbox )
		{
			//print( "hitbox Think End" )
			if( IsValid( hitbox ) )
				hitbox.Destroy()
		}
	)

	while( true )
	{
		// temp unsetUsable() when player getting firstaid by friendlies
		if( Bleedout_IsPlayerGettingFirstAid( player ) && !Bleedout_IsPlayerSelfHealing( player ) )
		{
			hitbox.UnsetUsable()
			//print( "hitbox being UnsetUsable()" )
		}
		else if( !player.ContextAction_IsActive() ) // assuming this is player being executing, wait for it
		{	
			hitbox.SetUsableByGroup( "enemies pilot" )
			//print( "hitbox being SetUsable()" )
		}

		// defensive fixs( actually messed things up
		/*
		if( !player.ContextAction_IsActive() ) 
		{
			hitbox.SetUsableByGroup( "enemies pilot" )
			//print( "hitbox being SetUsable()" )
		}
		else
		{
			hitbox.UnsetUsable()
			//print( "hitbox being UnsetUsable()" )
		}
		*/
		WaitFrame()
	}
}

entity function CreateHitboxEntityForPlayer( entity player )
{
	entity hitbox = CreatePropScript( BLEEDOUT_EXECUTION_HITBOX_MODEL )
	hitbox.SetParent( player, "CHESTFOCUS" )
	//hitbox.SetOrigin( < 30, 0, 0 > )
	//hitbox.SetLocalAngles( < 90, -90, 0 > )
	hitbox.SetTakeDamageType( DAMAGE_NO )
	SetTeam( hitbox, player.GetTeam() )
	SetObjectCanBeMeleed( hitbox, false )
	//hitbox.kv.modelscale = 0.1
	hitbox.kv.solid = SOLID_VPHYSICS
	hitbox.Hide()
	
	hitbox.SetOwner( player )
	
    hitbox.SetUsableByGroup( "enemies pilot" )
    hitbox.SetUsePrompts( "在目標身後按住 %use% 進行處決", "在目標身後按下 %use% 進行處決" )

    AddCallback_OnUseEntity( hitbox, ExecuteHitboxOwner )
	return hitbox
}

var function ExecuteHitboxOwner( var hitbox, var player )
{
	expect entity( player )
	expect entity( hitbox )
	thread ExecuteHitboxOwner_Threaded( hitbox, player )
}

void function ExecuteHitboxOwner_Threaded( entity hitbox, entity player )
{
	entity owner = hitbox.GetOwner()
	
	hitbox.UnsetUsable()
	// avoid this kind of crash... redo a SetUsable
	if( player.ContextAction_IsActive() ) // doing a execution?
		return
	if( Bleedout_IsPlayerBleeding( player ) ) // dont let downed players execute each other :(
		return
	if( !IsAlive( owner ) ) // owner may died before executions starts
		return
	if( owner.ContextAction_IsActive() ) // already being executed?
		return
	if( owner.GetTeam() == player.GetTeam() ) // well this can't fix wrong notifications caused by swiching team
	{
		WaitFrame()
		if( IsValid( hitbox ) )
		{
			hitbox.SetUsableByGroup( "enemies pilot" )
		}
		return
	}

	// checks from AttemptHumanMeleeExecution()
	if ( !IsAlive( player ) )
		return

	if ( player.IsPhaseShifted() )
		return

	// action validations check( PlayerTriesSyncedMelee() can freeze player if no action can be found )
	SyncedMeleeChooser ornull actions = GetSyncedMeleeChooserForPlayerVsTarget( player, owner )
	if ( actions == null )
		return
	expect SyncedMeleeChooser( actions )
	SyncedMelee ornull action = FindBestSyncedMelee( player, owner, actions )
	if ( action == null )
		return

	// all checks passed!

	// start execution
	// add signals that cancels executions
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	player.EndSignal( "BleedOut_OnStartDying" )
	owner.EndSignal( "OnDestroy" )
	//owner.EndSignal( "OnDeath" ) // no need to add owner's "OnDeath" EndSignal, otherwise PlayerTriesSyncedMelee() will be ended unexpectly

	OnThreadEnd(
		function(): ( owner, hitbox )
		{
			if( IsValid( hitbox ) )
			{
				if( !IsAlive( owner ) ) // owner died
					hitbox.Destroy()
				else // execution being interrupted
					hitbox.SetUsableByGroup( "enemies pilot" )
			}
		}
	)

	player.Anim_StopGesture( 0 )
	PlayerTriesSyncedMelee( player, owner )
}

void function Bleedout_IncapShieldThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	// before OnThreadEnd()
	array<int> statusEffectHandles = []

	OnThreadEnd(
		function(): ( player, statusEffectHandles )
		{
			if( IsValid( player ) )
			{
				/* // abandoned
				entity vortexSphere = file.playerIncapShieldTable[ player ].vortexSphere
				entity shieldWallFX1P = file.playerIncapShieldTable[ player ].shieldWallFX1P
				if( IsValid( vortexSphere ) )
					vortexSphere.Destroy()
				if( IsValid( shieldWallFX1P ) )
					shieldWallFX1P.Destroy()
				*/
				entity vortexSphere = file.playerIncapShieldTable[ player ]
				if( IsValid( vortexSphere ) )
					vortexSphere.Destroy()
				
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
		}
	)

	//entity vortexSphere = CreateIncapShieldForBleedingPlayer( player )
	//HideIncapShieldVortexSphere( vortexSphere ) // later we enable it
	//vortexSphere.EndSignal( "OnDestroy" )
	
	wait file.protectionDuration * 0.5

	entity vortexSphere = CreateIncapShieldForBleedingPlayer( player )
	vortexSphere.EndSignal( "OnDestroy" )

	float lastDryFireTime = 0
	bool vortexShown = true // default is shown
	bool hasStatusEffect = true
	bool firstLoop = true
	while( true )
	{
		if ( !firstLoop ) // first loop should never wait, so player can hide their incap shield immediately
			WaitFrame()
		firstLoop = false

		// not holding attack or be in special state
		if( IsInValidIncapShieldState( player ) && player.IsInputCommandHeld( IN_ATTACK ) ) 
		{
			if( !hasStatusEffect )
			{
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.5 ) )
				//statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
				hasStatusEffect = true
			}

			if( !vortexShown )
			{
				EmitSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
				StopSoundOnEntity( player, "Hardcover_Shield_End_3P" )
				EmitSoundOnEntity( vortexSphere, "Hardcover_Shield_Start_3P" )
				HACK_ShowIncapShieldVortexSphere( vortexSphere, player ) // hacking function
				//ShowIncapShieldVortexSphere( vortexSphere )
				//CreateIncapShieldWallFX( vortexSphere ) // no need for now!
				vortexShown = true
			}
			if( IsValid( vortexSphere.e.shieldWallFX ) )
				EffectSetControlPointVector( vortexSphere.e.shieldWallFX, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
			
		}
		else if( vortexShown )
		{
			//print( "Stopping Incap Shield" )
			StopSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
			StopSoundOnEntity( vortexSphere, "Hardcover_Shield_Start_3P" )
			EmitSoundOnEntity( player, "Hardcover_Shield_End_3P" ) // do sound on player since vortex has been hide
			//StopIncapShieldWallFX( vortexSphere ) // no need for now!
			HACK_TempHideIncapShieldVortexSphere( vortexSphere ) // stupid function
			//HideIncapShieldVortexSphere( vortexSphere )
			vortexShown = false
			if( hasStatusEffect )
			{
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
			hasStatusEffect = false
		}
	}

	/* // really should rework this
	while( true )
	{
		WaitFrame()
		//print( file.IsGettingFirstAidFrom[ player ] == player )

		// this continued everything, fuck me
		//if( !IsInValidIncapShieldState( player ) )
		//	continue

		if( file.incapShieldHealthTable[ player ] == 0 )
		{
			if( lastDryFireTime + 1.0 <= Time() && player.IsInputCommandHeld( IN_ATTACK ) )
			{
				EmitSoundOnEntityOnlyToPlayer( player, player, "pistol_dryfire" )
				lastDryFireTime = Time()
			}
			continue
		}

		//entity vortexSphere = file.playerIncapShieldTable[ player ].vortexSphere
		entity vortexSphere = file.playerIncapShieldTable[ player ]
		//print( IsValid( vortexSphere ) )
		//print( "Bleedout_IsPlayerGettingFirstAid( player ) = " + string( Bleedout_IsPlayerGettingFirstAid( player ) ) )
		//print( "Bleedout_IsPlayerSelfHealing( player ) = " + string( Bleedout_IsPlayerSelfHealing( player ) ) )
		//print( "player.ContextAction_IsActive() = " + string( player.ContextAction_IsActive() ) )
		//print( IsInValidIncapShieldState( player ) )

		// not holding attack or be in special state
		if( IsInValidIncapShieldState( player ) && player.IsInputCommandHeld( IN_ATTACK ) ) 
		{
			//print( "Looping Here but doing nothing" )
			//print( "Looping Here!!" )
			if( !IsValid( vortexSphere ) ) // new vortex
			{
				//print( "ReCreating Incap Shield" )
				CreateIncapShieldForBleedingPlayer( player )
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.move_slow, 0.5 ) )
				statusEffectHandles.append( StatusEffect_AddEndless( player, eStatusEffect.turn_slow, 0.3 ) )
			}
			else // last vortexSphere exists
			{
				EffectSetControlPointVector( vortexSphere.e.shieldWallFX, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
				if( !loopSoundPlaying )
				{
					EmitSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
					loopSoundPlaying = true
				}
			}
			
		}
		else// if( player.IsInputCommandHeld( IN_ATTACK ) )
		{
			if( IsValid( vortexSphere ) )
			{
				//print( "Stopping Incap Shield" )
				StopSoundOnEntity( vortexSphere, "ShieldWall_Loop" )
				loopSoundPlaying = false
				vortexSphere.Destroy()
				foreach( int effect in statusEffectHandles )
					StatusEffect_Stop( player, effect )
			}
		}
	}
	*/
}

bool function IsInValidIncapShieldState( entity player )
{
	if( Bleedout_IsPlayerGettingFirstAid( player ) ||
		Bleedout_IsPlayerSelfHealing( player ) ||
		player.ContextAction_IsActive() )
		return false

	return true
}

// should set a different one since it's fx has been reset angle!
const int INCAP_SHIELD_RADIUS = 35
const int INCAP_SHIELD_HEIGHT = 60
const int INCAP_SHIELD_FOV = 75

const asset INCAP_SHIELD_EFFECT_NAME = $"P_anti_titan_shield_3P"

entity function CreateIncapShieldForBleedingPlayer( entity player )
{
	vector angles = VectorToAngles( player.EyeAngles() )
	int maxHealth = file.incapShieldMaxHealth
	int health = file.incapShieldMaxHealth//file.incapShieldHealthTable[ player ]

	// doing hardcode here, guess no need to change( and I cant easily change it
	// vortexSphere
	entity vortexSphere = CreateShieldWithSettings( player.GetOrigin(), angles, INCAP_SHIELD_RADIUS, INCAP_SHIELD_HEIGHT, INCAP_SHIELD_FOV, 9999, maxHealth, INCAP_SHIELD_EFFECT_NAME )
	//file.playerIncapShieldTable[ player ].vortexSphere = vortexSphere // no need to use 1p things
	file.playerIncapShieldTable[ player ] = vortexSphere
	
	vortexSphere.SetHealth( health )
	vortexSphere.SetOwner( player )
	vortexSphere.SetBlocksRadiusDamage( true )
	SetTeam( vortexSphere, player.GetTeam() )
	vortexSphere.SetParent( player, "ORIGIN" )
	vortexSphere.e.shieldWallFX.DisableHibernation() // prevent fx from fading out
	vortexSphere.e.shieldWallFX.SetAngles( < 20,0,94 > )
	vortexSphere.e.shieldWallFX.SetOrigin( < 31,0,32 > )

	thread IncapShieldHealthDisplayer( player, vortexSphere ) // maybe no need to have this too dumb?
	//thread IncapShieldMoverThink( player, vortexSphere ) // let player move the incap shield
	
	vortexSphere.SetDamageNotifications( false ) // no hitmarkers?
	if( file.invulnerableIncapShield )
	{
		vortexSphere.SetInvulnerable()
		vortexSphere.SetTakeDamageType( DAMAGE_NO )
	}
	else
	{	
		// this thing don't work for a vortexSphere?
		//AddEntityCallback_OnDamaged( vortexSphere, IncapShieldTableUpdate )
		//thread TrackPlayerIncapShieldHealth( vortexSphere, player )
		thread TrackIncapShieldDeath( vortexSphere, player ) // for emitting a sound

		// damage handler
		SetVortexSphereBulletHitRules( vortexSphere, OnIncapSheildBulletHit )
		SetVortexSphereProjectileHitRules( vortexSphere, OnIncapSheildProjectileHit )
	}

	return vortexSphere
	

	// temp
	//vortexSphere.e.shieldWallFX.kv.VisibilityFlags = (ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY)

	/*
	// Shield wall fx control point
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	// Shield wall fx
	entity shieldWallFX1P = StartParticleEffectInWorld_ReturnEntity( GetParticleSystemIndex( $"P_anti_titan_shield_3P" ), < 20,0,48 >, < 20,0,95 > )
	file.playerIncapShieldTable[ player ].shieldWallFX1P = shieldWallFX1P

	shieldWallFX1P.SetOwner( player )
	shieldWallFX1P.kv.VisibilityFlags = ENTITY_VISIBLE_TO_OWNER
	EffectSetControlPointVector( shieldWallFX1P, 1, GetIncapShieldCurrentColor( 1.0 - GetHealthFrac( vortexSphere ) ) )
	shieldWallFX1P.SetParent( vortexSphere )

	thread Stop1PFXOnDestroy( vortexSphere, shieldWallFX1P )
	*/
}

var function OnIncapSheildBulletHit( entity vortexSphere, var damageInfo )
{
	entity owner = vortexSphere.GetOwner()
	if ( !IsAlive( owner ) )
		return damageInfo

	// modified function from _vortex.gnut
	int damage = int( Vortex_CalculateBulletHitDamage( vortexSphere, damageInfo ) )
	bool isKillShot = damage >= vortexSphere.GetHealth()
	if ( isKillShot ) // killshot!
	{
		int overdoseDamage = damage - vortexSphere.GetHealth()
		// deal overdose damage to player
		if ( overdoseDamage >= 1 )
		{
			owner.TakeDamage( overdoseDamage,
							  DamageInfo_GetAttacker( damageInfo ), 
							  DamageInfo_GetInflictor( damageInfo ), 
							  { // damage table
							    weapon = DamageInfo_GetWeapon( damageInfo ), 
							    origin = DamageInfo_GetDamagePosition( damageInfo ), 
							    force = DamageInfo_GetDamageForce( damageInfo ), 
							    scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
							    damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo ) 
							  }
							)
		}
	}

	// take a viewpunch from damage
	owner.ViewPunch( DamageInfo_GetDamagePosition( damageInfo ), 2.0, 1.0, 1.0 )

	return damageInfo
}

// the function SetVortexSphereProjectileHitRules() has been modified, it takes 1 more parameter
bool function OnIncapSheildProjectileHit( entity vortexSphere, entity attacker, entity projectile, bool takesDamage )
{
	if ( !IsValid( projectile ) )
		return takesDamage

	entity owner = vortexSphere.GetOwner()
	if ( !IsAlive( owner ) )
		return takesDamage

	// modified function from _vortex.gnut
	int damage = int( Vortex_CalculateProjectileHitDamage( vortexSphere, attacker, projectile ) )
	bool isKillShot = damage >= vortexSphere.GetHealth()
	if ( isKillShot ) // killshot!
	{
		int overdoseDamage = damage - vortexSphere.GetHealth()
		// deal overdose damage to player
		if ( overdoseDamage >= 1 )
		{
			owner.TakeDamage( overdoseDamage,
							  attacker, 
							  projectile, 
							  { // damage table
							    scriptType = TEMP_GetDamageFlagsFromProjectile( projectile ), 
							    damageSourceId = projectile.ProjectileGetDamageSourceID() 
							  }
							)
		}
	}

	// take a viewpunch from damage
	owner.ViewPunch( projectile.GetOrigin(), 2.0, 1.0, 1.0 )

	return takesDamage
}

const string BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID = "16"

// maybe no need to have this?
void function IncapShieldHealthDisplayer( entity player, entity vortexSphere )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )
	
	if ( !player.IsWatchingSpecReplay() && !player.IsWatchingKillReplay() ) // maybe need this fix?
	{
		NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID ) // try to delete existing one
		//NSCreateStatusMessageOnPlayer( player, "", "擊倒護盾 " + string( vortexSphere.GetHealth() ), BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID ) // init incap shield message
		NSCreateStatusMessageOnPlayer( player, "", "", BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID )
	}

	OnThreadEnd(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				NSDeleteStatusMessageOnPlayer( player, BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID )
			}
		}
	)
	
	while ( true )
	{
		if ( !IsValid( vortexSphere ) )
		{
			NSEditStatusMessageOnPlayer( player, "", "擊倒護盾不可用", BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID )
			WaitForever() // shield down
		}
		else
		{
			//vortexSphere.WaitSignal( "OnDamaged", "OnDestroy" )  // this can't handle the vortexSphere!
			//if ( IsValid( vortexSphere ) ) // after waiting the shield may be destroyed
			//	NSEditStatusMessageOnPlayer( player, "", "擊倒護盾 " + string( vortexSphere.GetHealth() ), BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID )
			NSEditStatusMessageOnPlayer( player, "", "擊倒護盾 " + string( vortexSphere.GetHealth() ), BLEEDOUT_MODE_INCAP_SHIELD_HINT_ID )
		}
		WaitFrame()
	}
	/*
	table playerInfo = {}
	playerInfo.activeWeaponName <- ""

	entity activeWeapon = player.GetActiveWeapon()
	if ( IsValid( activeWeapon ) )
		playerInfo.activeWeaponName = activeWeapon.GetWeaponClassName()

	entity ammoWeapon = player.GiveWeapon( "mp_weapon_gunship_missile", ["incap_shield_modifier"] )
	player.DeployWeapon() // deploy once to make activeWeapon change
	player.SetActiveWeaponByName( "mp_weapon_gunship_missile" )
	//player.HolsterWeapon()
	player.EndSignal( "OnDestroy" )
	vortexSphere.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( player, ammoWeapon, playerInfo )
		{
			if ( IsValid( ammoWeapon ) )
				ammoWeapon.Destroy()
			if ( IsValid( player ) )
			{
				string formerWeapon = string( playerInfo.activeWeaponName )
				if ( PlayerHasWeapon( player, formerWeapon ) )
					player.SetActiveWeaponByName( formerWeapon )
				else
				{
					array<entity> mainWeapons = player.GetMainWeapons()
					if ( mainWeapons.len() > 0 )
						player.SetActiveWeaponBySlot( 0 )
				}
			}
		}
	)

	if ( file.invulnerableIncapShield )
	{
		ammoWeapon.SetWeaponPrimaryAmmoCount( 1 )
		WaitForever()
	}
	while ( true )
	{
		ammoWeapon.SetWeaponPrimaryAmmoCount( vortexSphere.GetHealth() )
		WaitFrame()
	}
	*/
}

void function HACK_ShowIncapShieldVortexSphere( entity vortexSphere, entity player )
{
	// this is not very nice!
	vortexSphere.SetParent( player, "ORIGIN" )
	// re-enable shieldWallFx
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Start", "", 0, null, null )
}

// this is basically not letting any player shoot the vortex, really dumb
void function HACK_TempHideIncapShieldVortexSphere( entity vortexSphere )
{
	// stop shieldWallFx for a while
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Stop", "", 0, null, null )
	vortexSphere.ClearParent()
	vortexSphere.SetOrigin( < -9999, -9999, -9999 > ) // so player can never hit it
}


// WARNING: this is unfinished! can't handle it's angles, don't know why
/*
void function IncapShieldMoverThink( entity owner, entity vortexSphere )
{
	// signals goes here
	owner.EndSignal( "OnDestroy" )
	vortexSphere.EndSignal( "OnDestroy" )

	entity mover = CreateScriptMover()
	mover.SetOrigin( owner.GetOrigin() )
	//vector moverAngles = owner.GetAngles()
	//mover.SetAngles( AnglesCompose( moverAngles, <0,0,180> ) )
	//vector ownerAngles = owner.EyeAngles()
	//mover.SetAngles( < 0, ownerAngles.y, 0 > )

	//mover.SetParent( owner )
	vortexSphere.SetParent( mover )
	// offset for each things
	vortexSphere.e.shieldWallFX.SetAngles( < 20, 0, 94 > )
	vortexSphere.e.shieldWallFX.SetOrigin( < 31, 0, 32 > )

	OnThreadEnd(
		function(): ( mover )
		{
			if ( IsValid( mover ) )
			{
				mover.Destroy()
			}
		}
	)

	while ( true )
	{
		UpdateShieldPosition( mover, owner )
	}
}

const float INCAP_SHIELD_PITCH_LIMIT = 30 // for better visual and limit player's protection
void function UpdateShieldPosition( entity mover, entity owner )
{
	vector angles = owner.EyeAngles()
	//print( owner.EyeAngles() )
	//print( VectorToAngles( owner.GetViewVector() ) )
	int dist = 10 // needs this to protect moving forward players
	vector offset = AnglesToForward( < 0, angles.y, 0 > ) * dist
	mover.NonPhysicsMoveTo( owner.GetOrigin() + offset, 0.1, 0.0, 0.0 )

	//float yaw = angles.y
	//yaw %= 360
	//mover.NonPhysicsRotateTo( <0,yaw,180>, 1.35, 0, 0 )
	vector angleOffset = < angles.x, angles.y, 0 >
	angleOffset = ClampPitch( angleOffset )
	mover.NonPhysicsRotateTo( angleOffset, 0.15, 0, 0 )

	WaitFrame()
}

vector function ClampPitch( vector angles )
{
	if ( angles.x >= 30 )
		angles.x = 30
	if ( angles.x <= -30 )
		angles.x = -30
	return angles
}
*/

// not solid can't handle vortexSphere for some reason
/*
void function ShowIncapShieldVortexSphere( entity vortexSphere )
{
	// re-enable shieldWallFx
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Start", "", 0, null, null )
	vortexSphere.Solid() // start protecting the owner
}

void function HideIncapShieldVortexSphere( entity vortexSphere )
{
	// stop shieldWallFx for a while
	EntFireByHandle( vortexSphere.e.shieldWallFX, "Stop", "", 0, null, null )
	vortexSphere.NotSolid() // so it won't block any bullets
}

void function StopIncapShieldWallFX( entity vortexSphere )
{
	entity shieldWallFX = vortexSphere.e.shieldWallFX
	if( !IsValid( shieldWallFX ) )
		return

	entity cpoint = shieldWallFX.e.cpoint
	shieldWallFX.e.cpoint = null
	if( IsValid( cpoint ) )
		cpoint.Destroy()

	StopShieldWallFX( vortexSphere )
}

entity function CreateIncapShieldWallFX( entity vortexSphere )
{
	// Shield wall fx control point
	entity cpoint = CreateEntity( "info_placement_helper" )
	SetTargetName( cpoint, UniqueString( "shield_wall_controlpoint" ) )
	DispatchSpawn( cpoint )

	// Shield wall fx
	entity shieldWallFX = PlayFXWithControlPoint( INCAP_SHIELD_EFFECT_NAME, < 0,0,0 >, cpoint, -1, null, < 0,0,0 >, C_PLAYFX_LOOP )
	vortexSphere.e.shieldWallFX = shieldWallFX
	shieldWallFX.e.cpoint = cpoint
	shieldWallFX.SetParent( vortexSphere )
	shieldWallFX.SetAngles( < 20,0,94 > )
	shieldWallFX.SetOrigin( < 31,0,32 > )

	return shieldWallFX
}

void function Stop1PFXOnDestroy( entity vortexSphere, entity shieldWallFX1P )
{
	vortexSphere.EndSignal( "OnDestroy" )
	shieldWallFX1P.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( vortexSphere, shieldWallFX1P )
		{
			if( IsValid( shieldWallFX1P ) )
				shieldWallFX1P.Destroy()
		}
	)

	WaitForever()
}
*/

const vector BLEEDOUT_INCAP_SHIELD_COLOR_FULL		 = <115, 247, 255>	// blue
const vector BLEEDOUT_INCAP_SHIELD_COLOR_MED		 = <200, 128, 80>	// orange
const vector BLEEDOUT_INCAP_SHIELD_COLOR_EMPTY		 = <200, 80, 80>	// red

vector function GetIncapShieldCurrentColor( float chargeFrac, vector fullHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_FULL, vector medHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_MED, vector emptyHealthColor = BLEEDOUT_INCAP_SHIELD_COLOR_EMPTY )
{
	return GetTriLerpColor( chargeFrac, fullHealthColor, medHealthColor, emptyHealthColor )
}

// Copied from vortex, since it's not a global func
vector function GetTriLerpColor( float fraction, vector color1, vector color2, vector color3 )
{
	float crossover1 = 0.55  // from zero to this fraction, fade between color1 and color2
	float crossover2 = 0.75 // from crossover1 to this fraction, fade between color2 and color3

	float r, g, b

	// 0 = full charge, 1 = no charge remaining
	if ( fraction < crossover1 )
	{
		r = Graph( fraction, 0, crossover1, color1.x, color2.x )
		g = Graph( fraction, 0, crossover1, color1.y, color2.y )
		b = Graph( fraction, 0, crossover1, color1.z, color2.z )
		return <r, g, b>
	}
	else if ( fraction < crossover2 )
	{
		r = Graph( fraction, crossover1, crossover2, color2.x, color3.x )
		g = Graph( fraction, crossover1, crossover2, color2.y, color3.y )
		b = Graph( fraction, crossover1, crossover2, color2.z, color3.z )
		return <r, g, b>
	}
	else
	{
		// for the last bit of overload timer, keep it max danger color
		r = color3.x
		g = color3.y
		b = color3.z
		return <r, g, b>
	}

	unreachable
}

void function TrackIncapShieldDeath( entity vortexSphere, entity player )
{
	vortexSphere.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function(): ( player )
		{
			if( IsValid( player ) )
			{
				if( Bleedout_IsPlayerBleeding( player ) && IsAlive( player ) ) // otherwise means player has been revived or died
					EmitSoundOnEntity( player, "ShieldWall_Destroyed" )
			}
		}
	)

	WaitForever()
}

// why vortex_sphere don't have a damaged callback?
/*
void function IncapShieldTableUpdate( entity vortexSphere, var damageInfo )
{
	//print( "try to update incap shield health!" )
	entity owner = vortexSphere.GetOwner()
	if( !IsValid( owner ) )
		return
	float baseDamage = DamageInfo_GetDamage( damageInfo )
	float damageDifference = vortexSphere.GetHealth() - baseDamage
	if( baseDamage >= 300 ) // basically for krabers
		baseDamage = 300
	if( damageDifference < 0 ) // shield broke damage
	{
		owner.TakeDamage( fabs( damageDifference ), 
						  DamageInfo_GetAttacker( damageInfo ), 
						  DamageInfo_GetInflictor( damageInfo ), 
						  { // damage table
							weapon = DamageInfo_GetWeapon( damageInfo ), 
						    origin = DamageInfo_GetDamagePosition( damageInfo ), 
							force = DamageInfo_GetDamageForce( damageInfo ), 
							scriptType = DamageInfo_GetCustomDamageType( damageInfo ), 
							damageSourceId = DamageInfo_GetDamageSourceIdentifier( damageInfo ) 
						  } )
		file.incapShieldHealthTable[ owner ] = 0
		return
	}
	int calcDamage = file.incapShieldHealthTable[ owner ] - int( DamageInfo_GetDamage( damageInfo ) )
	file.incapShieldHealthTable[ owner ] = int( max( calcDamage, 0 ) )
	//print( "incap Shield health left: "+ string( file.incapShieldHealthTable[ owner ] ) )
}

void function TrackPlayerIncapShieldHealth( entity vortexSphere, entity player )
{
	vortexSphere.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function():( vortexSphere, player )
		{
			if( !IsValid( vortexSphere ) )
			{
				file.incapShieldHealthTable[ player ] = 0
				//print( "incap Shield down" )
			}
			if( IsValid( player ) )
			{
				file.incapShieldHealthTable[ player ] = file.incapShieldMaxHealth // restore shield
				if( Bleedout_IsPlayerBleeding( player ) && IsAlive( player ) ) // otherwise means player has been revived or died
					EmitSoundOnEntity( player, "ShieldWall_Destroyed" )
			}
		}
	)

	int lastTickHealth = vortexSphere.GetHealth()
	while( true )
	{
		int calcDamage = lastTickHealth - vortexSphere.GetHealth()
		file.incapShieldHealthTable[ player ] = int( max( file.incapShieldHealthTable[ player ] - calcDamage, 0 ) )

		lastTickHealth = vortexSphere.GetHealth()
		//print( "incap Shield health left: "+ string( file.incapShieldHealthTable[ player ] ) )
		WaitFrame()
	}
}
*/

void function Bleedout_VisualEffectThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "BleedOut_StopBleeding" )
	player.EndSignal( "BleedOut_OnRevive" )

	array<int> statusEffects = []

	OnThreadEnd(
		function(): ( player, statusEffects )
		{
			if( IsValid( player ) )
			{
				ScreenFade( player, 0, 0, 0, 125, 0.1, 0.1, FFADE_IN | FFADE_PURGE )
				foreach ( int effect in statusEffects )
					StatusEffect_Stop( player, effect )
				// doesn't seem work
				//player.nv.reviveBleedingOut = -1.0 //-1 means off
				//SetEntityVar( player, "reviveBleedingOut", -1 )
			}
		}
	)

	float bleedingTime = Bleedout_GetBleedoutTime()
	float screenFadeStartDelay = bleedingTime * 0.5
	// bleedout DOF takes 80% of actual bleeding time to fully apply
	float dofApplyDuration = bleedingTime * 0.8
	float dofStartDelay = bleedingTime - dofApplyDuration

	// text "Bleeding out"
	float endTime = Time() + bleedingTime
	// doesn't seem work
	//player.nv.reviveBleedingOut = endTime
	//SetEntityVar( player, "reviveBleedingOut", endTime )
	
	wait dofStartDelay
	statusEffects.append( StatusEffect_AddEndless( player, eStatusEffect.bleedoutDOF, 1.0 ) )

	wait ( dofStartDelay > 0 ? screenFadeStartDelay - dofStartDelay : screenFadeStartDelay )
	ScreenFade( player, 0, 0, 0, 225, bleedingTime * 0.5, 999, FFADE_OUT | FFADE_PURGE )

	WaitForever()
}

// WIP
void function Bleedout_FakePlayerThink( entity player ) // don't know how to do this
{
	float fadeDist 	= 10000.0
	int solidType = 0// 0 = no collision, 2 = bounding box, 6 = use vPhysics, 8 = hitboxes only

	player.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
	entity fakePlayer = CreatePropDynamic( player.GetModelName(), < 0,0,0 >, < 0,0,0 >, solidType, fadeDist )
	fakePlayer.SetOwner( player )
	SetTeam( fakePlayer, player.GetTeam() )
	fakePlayer.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY | ENTITY_VISIBLE_TO_FRIENDLY
	entity mover = CreateScriptMover()
	mover.kv.VisibilityFlags = ENTITY_VISIBLE_TO_EVERYONE
	mover.SetModel( $"models/dev/empty_model.mdl" )
	mover.SetParent( player, "ORIGIN" )
	mover.SetOrigin( < -35, 50, 0 > ) // redirect fake player
	SetForceDrawWhileParented( mover, true )
	fakePlayer.SetParent( mover, "REF" )
	file.bleedoutFakePlayers[ player ] = fakePlayer
	fakePlayer.Anim_Play( "pt_wounded_drag_zinger_A_idle" )
}

// grapple
void function BleedoutOnPlayerGrappled( entity player, entity victim )
{
	// hacked death: track attacker cancelling the grapple, players are able to grapple a spectator player if they're not actually dead
	thread TrackPlayerGrappleDetach( player, victim )
}

void function TrackPlayerGrappleDetach( entity player, entity target )
{
	player.EndSignal( "BleedOut_OnStartDying" ) // go to OnThreadEnd() if player start bleedout...
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	table results = {}
	results.cancelled <- false

	OnThreadEnd
	(
		function(): ( player, target, results )
		{
			if ( IsValid( player ) )
			{
				if ( IsAlive( target ) ) // target still alive, meaning there's only player entered bleedout
				{
					if ( !results.cancelled ) // not manually cancelled
					{
						player.Grapple( < 0, 0, 0 > ) // fire another grapple while grappling will cancel current one
						//print( "Player being forced cancelling grapple!" )
					}
				}

				// clean up
				RemoveButtonPressedPlayerInputCallback( player, IN_DUCK, PlayerPressedGrappleDetachButton )
				RemoveButtonPressedPlayerInputCallback( player, IN_DUCKTOGGLE, PlayerPressedGrappleDetachButton )
			}
		}
	)

	// check cancelling through crouching
	AddButtonPressedPlayerInputCallback( player, IN_DUCK, PlayerPressedGrappleDetachButton )
	AddButtonPressedPlayerInputCallback( player, IN_DUCKTOGGLE, PlayerPressedGrappleDetachButton )

	// signals all handled in mp_ability_grapple.nut
	WaitSignal( player, "GrappleCancelled", "OnGrappled" )
	results.cancelled = true // if triggered these signals we consider it as grapple cancelled
	//print( "Player cancelled grapple!" )
}

void function PlayerPressedGrappleDetachButton( entity player )
{
	player.Signal( "GrappleCancelled" )
}

// health regen: pas_fast_regen won't take effect, all players have less regen rate
void function Bleedout_HealthRegenThink( entity player )
{
    player.EndSignal( "OnDestroy" )
	player.Signal( "BleedoutHealthRegenThink" ) // why this not getting registered most of time..
	player.Signal( "StopHealthRegenThink" ) // end normal health regen in _health_regen.gnut
	player.EndSignal( "BleedoutHealthRegenThink" )
	player.EndSignal( "StopHealthRegenThink" )

	float healthRegenStartDelay = file.bleedoutHealthRegenDelay

	while ( IsValid( player ) )
	{
		//print( "Bleedout Health Regen Think" )
		wait( HEALTH_REGEN_TICK_TIME )

		if ( !IsAlive( player ) )
			continue

		if ( !IsPilot( player ) )
			continue

		if ( shGlobal.proto_pilotHealthRegenDisabled )
			continue

		float healthRegenRate = file.bleedoutHealthRegenRate	// health regen per tick

		if ( player.GetHealth() == player.GetMaxHealth() )
			continue

		// No regen during phase shift
		if ( player.IsPhaseShifted() )
			continue

		// no regen during bleeding out
		if( Bleedout_IsPlayerBleeding( player ) )
			continue

		if ( Time() - player.p.lastDamageTime < healthRegenStartDelay )
		{
			continue
		}

		player.SetHealth( min( player.GetMaxHealth(), player.GetHealth() + healthRegenRate ) )
		if ( player.GetHealth() == player.GetMaxHealth() )
		{
			ClearRecentDamageHistory( player )
			ClearLastAttacker( player )
		}
	}
}

// settings goes here
void function Bleedout_EnableExecutingBleedingPlayer( bool enable )
{
	file.executingBleedingEnabled = enable
}

void function Bleedout_SetProtectionDuration( float duration )
{
	file.protectionDuration = duration
}

void function Bleedout_SetIncapShieldInvulnerable( bool invulnerable )
{
	file.invulnerableIncapShield = invulnerable
}

void function Bleedout_SetIncapShieldHealth( int health )
{
	file.incapShieldMaxHealth = health
}

void function Bleedout_SetHealthRegenRate( float rate )
{
	file.bleedoutHealthRegenRate = rate
}

void function Bleedout_SetHealthRegenDelay( float delay )
{
	file.bleedoutHealthRegenDelay = delay
}