untyped // for playersettings work

global function Default_GruntMode_Classes_Init

void function Default_GruntMode_Classes_Init()
{
	PrecacheModel( $"models/humans/grunts/imc_grunt_lmg_helmet.mdl" )
    RegisterAllDefaultClass()
}



//////////////////////////////////////
///// GRUNT CLASS INIT FUNCTIONS /////
//////////////////////////////////////

// grunt classes, GM refers to GruntMode
// maybe we should do a "tolower()" ?
const string GM_ASSAULT_GRUNT_CLASSNAME			= "Assault_Grunt"		// r97, archer and frag
const string GM_HEAVY_GRUNT_CLASSNAME			= "Heavy_Grunt"			// nerfed spitfire and archer
const string GM_RIFLEMAN_GRUNT_CLASSNAME		= "Rifleman_Grunt"		// flatline, archer and frag
const string GM_SHOTGUN_GRUNT_CLASSNAME			= "Shotgun_Grunt"		// eva-8, archer and frag
const string GM_SNIPER_GRUNT_CLASSNAME			= "Sniper_Grunt"		// nerfed dmr, archer and electric smoke
const string GM_ENGINEER_CLASSNAME				= "Engineer"			// l-star and thunderbolt, one turret in inventory( replenish with care package )
const string GM_SPECIALIST_GRUNT_CLASSNAME		= "Specialist_Grunt"	// l-star and mgl, two drones release
const string GM_SHIELD_CAPTAIN_CLASSNAME		= "Shield_Captain"		// r201 and mgl, carrying a particle wall
const string GM_SHOCK_GRUNT_CLASSNAME			= "Shock_Grunt"			// volt and thunderbolt, one arc trap usage
const string GM_SPECTRE_CLASSNAME				= "Spectre"				// mastiff and chargerifle, double jumping, weaker wallclimb
const string GM_SONAR_PULSER_CLASSNAME			= "Sonar_Pulser"		// alternator, chargerifle and double timed pulse blade
const string GM_NINJA_CLASSNAME					= "Ninja"				// no mainweapon, mgl and smoke launcher, regenerating kunai and gravity star
const string GM_BEAST_KING_CLASSNAME			= "Beast_King"			// no mainweapon, sword, high titan damage magnitic arc grenade and prowlers( 10s respawn )
const string GM_JUMPER_CLASSNAME				= "Jumper"				// devotion and mgl, one jumppad usage
const string GM_SHIFTER_CLASSNAME				= "Shifter"				// double-take, thunderbolt, one longer shifter usage
const string GM_RAVENANT_CLASSNAME				= "Ravenant"			// hemlok, chargerifle and satchel, super wallclimb, faster crouchwalk
const string GM_PHASEWALKER_CLASSNAME			= "Phase_Walker"		// r101 and thunderbolt, one portal usage
const string GM_HEAVY_SNIPER_CLASSNAME			= "Heavy_Sniper"		// kraber(anti-titan) and electric smoke
const string GM_RUNNER_CLASSNAME				= "Runner"				// run_and_gun, extended_ammo re45 with less damage falloff and mgl, octane stim( longer stim that costs health )
const string GM_PATH_BUILDER_CLASSNAME			= "Path_Builder"		// r97, one zipline gun usage(zipline destroys on death)
const string GM_SCOUT_CLASSNAME					= "Scout"				// nerfed g2 and archer, two grapple usage
const string GM_FLYER_CLASSNAME					= "Flyer"				// mozambique and chargerifle, weaker jetpack
const string GM_ASSASSIN_CLASSNAME				= "Assassin"			// silenced wingman elite, chargerifle and arc grenade
const string GM_STALKER_CLASSNAME				= "Stalker"				// double-barrel shotgun and chargerifle, two holopilot decoy usage
const string GM_GRAVITYMASTER_CLASSNAME			= "Gravity_Master"		// peacekraber and thunderbolt, one gravity lift usage
const string GM_FORTRESS_CLASSNAME				= "Fortress"			// SMR(less human damage, more titan damage and cannot headshot), one hard cover usage

void function RegisterAllDefaultClass()
{
	// assault grunt
	GruntMode_RegisterPlayerClass(
		GM_ASSAULT_GRUNT_CLASSNAME,		// classname
		BecomeAssaultGrunt,				// loadout function
		false							// specialist, should this class give more score
	)
	
	// heavy grunt
	GruntMode_RegisterPlayerClass(
		GM_HEAVY_GRUNT_CLASSNAME,		// classname
		BecomeHeavyGrunt,				// loadout function
		false							// specialist, should this class give more score
	)

	// rifleman grunt
	GruntMode_RegisterPlayerClass(
		GM_RIFLEMAN_GRUNT_CLASSNAME,	// classname
		BecomeRiflemanGrunt,			// loadout function
		false							// specialist, should this class give more score
	)

	// shotgun grunt
	GruntMode_RegisterPlayerClass(
		GM_SHOTGUN_GRUNT_CLASSNAME,		// classname
		BecomeShotgunGrunt,				// loadout function
		false							// specialist, should this class give more score
	)

	// sniper grunt
	GruntMode_RegisterPlayerClass(
		GM_SNIPER_GRUNT_CLASSNAME,		// classname
		BecomeSniperGrunt,				// loadout function
		false							// specialist, should this class give more score
	)

	// engineer
	GruntMode_RegisterPlayerClass(
		GM_ENGINEER_CLASSNAME,			// classname
		BecomeEngineer,					// loadout function
		true							// specialist, should this class give more score
	)

	// specialist grunt
	GruntMode_RegisterPlayerClass(
		GM_SPECIALIST_GRUNT_CLASSNAME,	// classname
		BecomeSpecialistGrunt,			// loadout function
		true							// specialist, should this class give more score
	)

	// shield captain
	PrecacheModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" ) // this is only precached in fd by default
	GruntMode_RegisterPlayerClass(
		GM_SHIELD_CAPTAIN_CLASSNAME,	// classname
		BecomeShieldCaptain,			// loadout function
		true							// specialist, should this class give more score
	)

	// shock grunt
	GruntMode_RegisterPlayerClass(
		GM_SHOCK_GRUNT_CLASSNAME,		// classname
		BecomeShockGrunt,				// loadout function
		true							// specialist, should this class give more score
	)

	// spectre
	GruntMode_RegisterPlayerClass(
		GM_SPECTRE_CLASSNAME,			// classname
		BecomeSpectre,					// loadout function
		true							// specialist, should this class give more score
	)

	// sonar pulser
	GruntMode_RegisterPlayerClass(
		GM_SONAR_PULSER_CLASSNAME,		// classname
		BecomeSonarPulser,				// loadout function
		false							// specialist, should this class give more score
	)

	// temp remove melee classes since we've got enough classes?
	// for my own entertainment I'd enable them for fun
	// ninja
	GruntMode_RegisterPlayerClass(
		GM_NINJA_CLASSNAME,				// classname
		BecomeNinja,					// loadout function
		true							// specialist, should this class give more score
	)
	
    // beast king
	GruntMode_RegisterPlayerClass(
		GM_BEAST_KING_CLASSNAME,		// classname
		BecomeBeastKing,				// loadout function
		true							// specialist, should this class give more score. beast king also has prowlers which gives enemy 2 points in gruntmode
	)
	AddDamageCallbackSourceID( eDamageSourceId.mp_weapon_grenade_electric_smoke, BeastKingSmokeDamageTarget )
	AddDamageCallbackSourceID( eDamageSourceId.prowler_melee, BeastKingProwlerDamageTarget )
	//

    // jumper
	GruntMode_RegisterPlayerClass(
		GM_JUMPER_CLASSNAME,			// classname
		BecomeJumper,					// loadout function
		false							// specialist, should this class give more score
	)

    // shifter
	GruntMode_RegisterPlayerClass(
		GM_SHIFTER_CLASSNAME,			// classname
		BecomeShifter,					// loadout function
		false							// specialist, should this class give more score
	)

	// ravenant
	GruntMode_RegisterPlayerClass(
		GM_RAVENANT_CLASSNAME,			// classname
		BecomeRavenant,					// loadout function
		true							// specialist, should this class give more score
	)

	// phase walker
	GruntMode_RegisterPlayerClass(
		GM_PHASEWALKER_CLASSNAME,		// classname
		BecomePhaseWalker,				// loadout function
		true							// specialist, should this class give more score
	)

	// heavy sniper
	GruntMode_RegisterPlayerClass(
		GM_HEAVY_SNIPER_CLASSNAME,		// classname
		BecomeHeavySniper,				// loadout function
		true							// specialist, should this class give more score( value has been changed )
	)

	// runner
	GruntMode_RegisterPlayerClass(
		GM_RUNNER_CLASSNAME,			// classname
		BecomeRunner,					// loadout function
		false							// specialist, should this class give more score
	)

	// path builder
	GruntMode_RegisterPlayerClass(
		GM_PATH_BUILDER_CLASSNAME,		// classname
		BecomePathBuilder,				// loadout function
		false							// specialist, should this class give more score
	)

	// scout
	GruntMode_RegisterPlayerClass(
		GM_SCOUT_CLASSNAME,				// classname
		BecomeScout,					// loadout function
		false							// specialist, should this class give more score
	)

	// flyer
	GruntMode_RegisterPlayerClass(
		GM_FLYER_CLASSNAME,				// classname
		BecomeFlyer,					// loadout function
		true							// specialist, should this class give more score
	)

	// assassin
	GruntMode_RegisterPlayerClass(
		GM_ASSASSIN_CLASSNAME,			// classname
		BecomeAssassin,					// loadout function
		false							// specialist, should this class give more score
	)

	// stalker
	GruntMode_RegisterPlayerClass(
		GM_STALKER_CLASSNAME,			// classname
		BecomeStalker,					// loadout function
		false							// specialist, should this class give more score
	)
	// holopilot settings
	AddCallback_OnDecoyCreated( OnStalkerDecoyCreated )
	AddCallback_PlayerDecoyDie( OnStalkerDecoyDieOrDissolve )
	AddCallback_PlayerDecoyDissolve( OnStalkerDecoyDieOrDissolve )

	// gravity master
	GruntMode_RegisterPlayerClass(
		GM_GRAVITYMASTER_CLASSNAME,		// classname
		BecomeGravityMaster,			// loadout function
		false							// specialist, should this class give more score
	)

	// fortress
	GruntMode_RegisterPlayerClass(
		GM_FORTRESS_CLASSNAME,			// classname
		BecomeFortress,					// loadout function
		true							// specialist, should this class give more score
	)
}

//////////////////////////////////////////
///// GRUNT CLASS INIT FUNCTIONS END /////
//////////////////////////////////////////



///////////////////////////////////////////
///// DEFAULT CLASS LOADOUT FUNCTIONS /////
///////////////////////////////////////////

void function BecomeAssaultGrunt( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout( 
		player,
		"mp_weapon_r97",													// primary weapon
		"mp_weapon_rocket_launcher",										// secondary weapon
		"mp_weapon_frag_grenade",											// grenade
		// all normal grunts now uses random model
		$"",																// imc player model
		$"",																// mlt player model
		//$"models/humans/grunts/imc_grunt_smg.mdl",							// imc player model
		//$"models/humans/grunts/mlt_grunt_smg.mdl",							// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Assault Grunt",													// title
		"Respawn as Assault Grunt"											// respawn notification
	)

	// gives random grunt model based on team
	RandomGruntModel( player )

	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	// mlt specific pov camo
	ApplyMLTGruntCamo( player )
}

void function BecomeHeavyGrunt( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_lmg",													// primary weapon
		"mp_weapon_rocket_launcher",										// secondary weapon
		"",																	// grenade
		// all normal grunts now uses random model
		$"",																// imc player model
		$"",																// mlt player model
		//$"models/humans/grunts/imc_grunt_lmg.mdl",							// imc player model
		//$"models/humans/grunts/mlt_grunt_lmg.mdl",							// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Heavy Grunt",														// title
		"Respawn as Heavy Weapons Grunt"								    // respawn notification
	)

	// gives random grunt model based on team
	RandomGruntModel( player )

	player.GetMainWeapons()[0].AddMod( "gm_heavy" ) // damage nerfed spitfire
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	// mlt specific pov camo
	ApplyMLTGruntCamo( player )
}

void function BecomeRiflemanGrunt( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_vinson",													// primary weapon
		"mp_weapon_rocket_launcher",										// secondary weapon
		"mp_weapon_frag_grenade",											// grenade
		// all normal grunts now uses random model
		$"",																// imc player model
		$"",																// mlt player model
		//$"models/humans/grunts/imc_grunt_rifle.mdl",						// imc player model
		//$"models/humans/grunts/mlt_grunt_rifle.mdl",						// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Rifleman Grunt",													// title
		"Respawn as Rifleman Grunt"											// respawn notification
	)

	// gives random grunt model based on team
	RandomGruntModel( player )

	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	// mlt specific pov camo
	ApplyMLTGruntCamo( player )
}

void function BecomeShotgunGrunt( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_shotgun",												// primary weapon
		"mp_weapon_rocket_launcher",										// secondary weapon
		"mp_weapon_frag_grenade",											// grenade
		// all normal grunts now uses random model
		$"",																// imc player model
		$"",																// mlt player model
		//$"models/humans/grunts/imc_grunt_shotgun.mdl",						// imc player model
		//$"models/humans/grunts/mlt_grunt_shotgun.mdl",						// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Shotgunner Grunt",													// title
		"Respawn as Shotgunner Grunt"										// respawn notification
	)

	// gives random grunt model based on team
	RandomGruntModel( player )

	player.GetMainWeapons()[0].AddMod( "gm_shotgun" ) // fire-rate nerfed eva-8
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	// mlt specific pov camo
	ApplyMLTGruntCamo( player )
}

void function BecomeSniperGrunt( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_dmr",													// primary weapon
		"mp_weapon_rocket_launcher",										// secondary weapon
		"mp_weapon_grenade_electric_smoke",									// grenade
		// all normal grunts now uses random model
		$"",																// imc player model
		$"",																// mlt player model
		//$"models/humans/grunts/imc_grunt_lmg.mdl",							// imc player model
		//$"models/humans/grunts/mlt_grunt_lmg.mdl",							// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Sniper Grunt",														// title
		"Respawn as Sniper Grunt"										    // respawn notification
	)

	// gives random grunt model based on team
	RandomGruntModel( player )

	player.GetMainWeapons()[0].AddMod( "gm_sniper" ) // nerfed dmr
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it
	
	// mlt specific pov camo
	ApplyMLTGruntCamo( player )
}

// gives random grunt model based on team
void function RandomGruntModel( entity player )
{
	asset modelName = $"models/humans/grunts/imc_grunt_rifle.mdl"
	if ( player.GetTeam() == TEAM_MILITIA )
	{
		const array<asset> randomModels = 
		[
			$"models/humans/grunts/mlt_grunt_rifle.mdl",
			$"models/humans/grunts/mlt_grunt_lmg.mdl",
			$"models/humans/grunts/mlt_grunt_smg.mdl",
			$"models/humans/grunts/mlt_grunt_shotgun.mdl",
		]
		modelName = randomModels[ RandomInt( randomModels.len() ) ]
	}
	else
	{
		const array<asset> randomModels = 
		[
			$"models/humans/grunts/imc_grunt_rifle.mdl",
			$"models/humans/grunts/imc_grunt_lmg.mdl",
			$"models/humans/grunts/imc_grunt_smg.mdl",
			$"models/humans/grunts/imc_grunt_shotgun.mdl",
		]
		modelName = randomModels[ RandomInt( randomModels.len() ) ]
	}
	player.SetModel( modelName )
}

void function BecomeEngineer( entity player )
{
	player.SetPlayerSettings( "pilot_heavy_female" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_lstar",													// primary weapon
		"mp_weapon_arc_launcher",											// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_heavy_roog_f.mdl",						// imc player model
		$"models/humans/pilots/pilot_heavy_roog_f.mdl",						// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Engineer",															// title
		"Respawn as Engineer: One turret usage"								// respawn notifications
	)

	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	thread EngineerThink( player ) // death will clear player's turret item

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

// turret settings
const string ENGINEER_TURRET_BURNMETER = "burnmeter_ap_turret_weapon"
const int ENGINEER_TURRET_MAX_COUNT = 1
const int ENGINEER_TURRET_HEALTH = 850 // higher than 700 health could be good: turrets take heavy armor damage and gets destroyed easily by most anti-titan weapons

void function EngineerThink( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	//PlayerInventory_PushInventoryItemByBurnRef( player, ENGINEER_TURRET_BURNMETER ) // give one usage of turret
	// refill turrets first
	RefillEngineerTurrets( player )
	// carepackage refilling turret think
	AddEntityCallback_OnUseCarePackage( player, OnEngineerUseCarePackage )

	OnThreadEnd
	(
		function(): ( player )
		{
			if ( IsValid( player ) )
			{
				RemoveEntityCallback_OnUseCarePackage( player, OnEngineerUseCarePackage )
				PlayerInventory_TakeAllInventoryItems( player ) // clear inventory
			}
		}
	)

	thread EngineerTurretsHandler( player )

	player.WaitSignal( "OnDeath" ) // wait for player's death
}

void function OnEngineerUseCarePackage( entity player, entity pod )
{
	RefillEngineerTurrets( player )
}

void function RefillEngineerTurrets( entity player )
{
	// refill turret if we have less turrets than max count
	if ( PlayerInventory_CountBurnRef( player, ENGINEER_TURRET_BURNMETER ) < ENGINEER_TURRET_MAX_COUNT )
		PlayerInventory_PushInventoryItemByBurnRef( player, ENGINEER_TURRET_BURNMETER ) // give one usage of turret
}

array<entity> function GetGruntPlayerOwnedTurrets( entity player )
{
	array<entity> turrets
	foreach( entity turret in GetNPCArrayByClass( "npc_turret_sentry" ) )
	{
		if ( turret.GetBossPlayer() == player )
			turrets.append( turret )
	}

	return turrets
}

void function EngineerTurretsHandler( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	array<entity> handledTurrets
	OnThreadEnd(
		function(): ( player, handledTurrets )
		{
			// player still valid!
			if ( IsValid( player ) )
			{
				// find from all turrets
				array<entity> turrets = GetGruntPlayerOwnedTurrets( player )
				foreach ( entity turret in turrets )
				{
					if ( IsAlive( turret ) )
						turret.Die()
				}
			}
			else // player became invalid
			{
				// use our stored turrets
				foreach( entity turret in handledTurrets )
				{
					if ( IsAlive( turret ) )
						turret.Die()
				}
			}
        }
	)

	while ( true )
	{
		ArrayRemoveDead( handledTurrets )

		foreach ( entity turret in GetGruntPlayerOwnedTurrets( player ) )
		{
			if ( handledTurrets.contains( turret ) )
				continue
			
			// debug
			//print( "turret handled by engineer: " + string( turret ) )

			handledTurrets.append( turret )
			// update turret weapon mods
			turret.GetMainWeapons()[0].AddMod( "gm_engineer_turret" )
			turret.SetMaxHealth( ENGINEER_TURRET_HEALTH )
			turret.SetHealth( turret.GetMaxHealth() )
		}

		// hit max turrets?
		int overloadedTurreCount = handledTurrets.len() - ENGINEER_TURRET_MAX_COUNT
		if ( overloadedTurreCount > 0 )
		{
			for ( int i = 0; i < overloadedTurreCount; i++ )
			{
				if ( IsAlive( handledTurrets[i] ) )
					handledTurrets[i].Die()
			}
		}

		WaitFrame()
	}
}

void function BecomeSpecialistGrunt( entity player )
{
	thread WaitForSpecialistGruntLeaveDropship( player )
}

void function WaitForSpecialistGruntLeaveDropship( entity player )
{
	// thinks for spectre model, no longer used!
	/*
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	
	player.SetPlayerSettings( "pilot_light_male" ) // have a better pov model, also temp use this model
	
	WaitFrame() // wait for player being set into dropship
	while( IsValid( player.GetParent() ) && player.GetParent().GetClassName() == "npc_dropship" )
		WaitFrame() // wait for player leave dropship
	*/

	player.SetPlayerSettings( "pilot_grapple_male" )

	SimpleClassLoadout(  
		player,
		//"mp_weapon_lstar",													// primary weapon
		"mp_weapon_car",													// primary weapon
		"mp_weapon_mgl",													// secondary weapon
		"",																	// grenade
		// model updated -- no longer uses fake spectre model
		//$"",																// imc player model
		//$"",																// mlt player model
		$"models/humans/grunts/imc_grunt_smg.mdl",							// imc player model
		$"models/humans/grunts/mlt_grunt_smg.mdl",							// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Specialist Grunt",													// title
		"Respawn as Specialist Grunt: Able to use Drones and Ticks"			// respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "gm_specialist" ) // nerf car's reload time a little bit
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it
	
	// drone spawning ability( two times usage )
	// maybe spawn one drone and one tick could be better...
	//player.GiveOffhandWeapon( "mp_weapon_frag_drone", OFFHAND_SPECIAL, ["drone_spawner_anim"] )

	// model updated -- no longer uses fake spectre model
	/*
	player.SetModel( $"models/robots/spectre/imc_spectre.mdl" ) // safe to reset model
	// attach a fake head to it
	CreateMechanicalHeadForPlayer( player )
	// modified in _ai_spawn_content.gnut, attach fake backpack for drone grunt
	HACK_DroneGruntModel( player )
	*/

	// specialist grunts uses pilot headshot effect
	DeathPackage_RemoveEntityHeadshotFXOverride( player )

	// mlt specific pov camo
	ApplyMLTGruntCamo( player )

	// doing a better check now!
	thread SpecialistGruntThink( player )
}

struct SpecialistGruntStruct
{
	float lastRecallTime
	float lastNotifyTime
}

struct
{
	table< entity, SpecialistGruntStruct > classTable
} specialistGrunt

// drone recall
const bool SPECIALIST_GRUNT_DRONE_RECALL_ENABLED = false // temporary disable drone recall because drones won't block owner bullets
const float SPECIALIST_GRUNT_RECALL_RANGE = 600
const float SPECIALIST_GRUNT_RECALL_COOLDOWN = 3.0
const float SPECIALIST_GRUNT_NOTIFICATION_COOLDOWN = 2.0
// drone settings
const int SPECIALIST_GRUNT_DRONE_HEALTH = 130 // 70 when having 2 drones
const int SPECIALIST_GRUNT_DRONE_MAX_COUNT = 1 // don't forget to adjust this value when updating offhand weapons
// ticks
const int SPECIALIST_GRUNT_TICK_MAX_COUNT = 1 // EDIT: thrown ticks will try to detonate themselves! -- this only limits ticks in inventory, thrown ticks won't be destroyed even reached max count

void function SpecialistGruntThink( entity player )
{
	player.EndSignal( "OnDestroy" )

	// init this class
	if ( !( player in specialistGrunt.classTable ) )
	{
		SpecialistGruntStruct emptyStruct
		specialistGrunt.classTable[player] <- emptyStruct
	}

	// make recall available
	specialistGrunt.classTable[player].lastRecallTime = Time() - SPECIALIST_GRUNT_RECALL_COOLDOWN
	specialistGrunt.classTable[player].lastNotifyTime = Time() - SPECIALIST_GRUNT_NOTIFICATION_COOLDOWN

	if ( SPECIALIST_GRUNT_DRONE_RECALL_ENABLED )
	{
		AddButtonPressedPlayerInputCallback( player, IN_USE, SpecialistGruntRecallDrones )
		AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, SpecialistGruntRecallDrones )
	}

	// refill ticks first
	RefillSpecialistGruntTicks( player )
	// give drones
	player.GiveOffhandWeapon( "mp_ability_arc_blast", OFFHAND_SPECIAL, ["drone_summoner", "gm_specialist"] )
	// carepackage refilling ticks think
	AddEntityCallback_OnUseCarePackage( player, OnSpecialistGruntUseCarePackage )

    OnThreadEnd(
        function(): ( player )
        {
            if ( IsValid( player ) )
            {
				if ( SPECIALIST_GRUNT_DRONE_RECALL_ENABLED )
				{
					RemoveButtonPressedPlayerInputCallback( player, IN_USE, SpecialistGruntRecallDrones )
					RemoveButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, SpecialistGruntRecallDrones )
				}

				RemoveEntityCallback_OnUseCarePackage( player, OnSpecialistGruntUseCarePackage )
				PlayerInventory_TakeAllInventoryItems( player ) // clear inventory
            }
        }
    )

	thread SpecialistGruntDronesHandler( player )

	player.WaitSignal( "OnDeath" ) // wait for player's death
}

void function OnSpecialistGruntUseCarePackage( entity player, entity pod )
{
	RefillSpecialistGruntTicks( player )
}

void function RefillSpecialistGruntTicks( entity player )
{
	// refill ticks if we have less ticks than max count
	if ( PlayerInventory_CountBurnRef( player, "burnmeter_ticks" ) < SPECIALIST_GRUNT_TICK_MAX_COUNT )
		PlayerInventory_PushInventoryItemByBurnRef( player, "burnmeter_ticks" ) // give one usage of turret
	// remove current drone weapon because we may have entered infinite fire_duration
	player.TakeOffhandWeapon( OFFHAND_SPECIAL )
	player.GiveOffhandWeapon( "mp_ability_arc_blast", OFFHAND_SPECIAL, ["drone_summoner", "gm_specialist"] )
}

array<entity> function GetGruntPlayerOwnedDrones( entity player )
{
	array<entity> drones
	foreach ( entity drone in GetNPCArrayByClass( "npc_drone" ) )
	{
		if ( IsAlive( drone ) && drone.GetBossPlayer() == player )
			drones.append( drone )
	}
	return drones
}

array<entity> function GetGruntPlayerOwnedTicks( entity player )
{
	array<entity> ticks
	foreach ( entity tick in GetNPCArrayByClass( "npc_frag_drone" ) )
	{
		// seems no need to add armed check?
		//if ( IsAlive( tick ) && tick.ai.fragDroneArmed && tick.GetBossPlayer() == player )
		if ( IsAlive( tick ) && tick.GetBossPlayer() == player )
			ticks.append( tick )
	}
	// should we also append tick projectile?

	return ticks
}

void function SpecialistGruntDronesHandler( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	array<entity> handledDrones
	array<entity> handledTicks
	array<entity> explodingTicks

	OnThreadEnd(
		function(): ( player, handledDrones, handledTicks )
		{
			// player still valid!
			if ( IsValid( player ) )
			{
				// find from all drones
				array<entity> drones = GetGruntPlayerOwnedDrones( player )
				foreach ( entity drone in drones )
				{
					if ( IsAlive( drone ) )
						drone.Die()
				}
				// destroy ticks, including those haven't landed yet
				foreach ( entity tick in GetNPCArrayByClass( "npc_frag_drone" ) )
				{
					if ( IsAlive( tick ) && tick.GetBossPlayer() == player )
					{
						if ( tick.ai.fragDroneArmed )
							handledTicks.append( tick ) // gets cleared later
						else // isn't armed yet, dissolving it
						{
							tick.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
							tick.SetNoTarget( true )
							tick.EnableNPCFlag( NPC_IGNORE_ALL )
							tick.NotSolid()
							tick.SetInvulnerable() // can still take radius damage after nonsolid!
						}
					}
				}
				// tick won't be spawned if owner isn't valid anymore, only needs to clear projectile in this case
				foreach ( entity projectile in GetProjectileArrayEx( "any", player.GetTeam(), TEAM_ANY, Vector( 0, 0, 0 ), -1 ) )
				{
					if ( projectile.GetClassName() == "grenade" && projectile.GetThrower() == player )
					{
						if ( projectile.ProjectileGetWeaponClassName() == "mp_weapon_frag_drone" )
							projectile.Destroy()
					}
				}
			}
			else // player became invalid
			{
				// use our stored drones
				foreach( entity drone in handledDrones )
				{
					if ( IsAlive( drone ) )
						drone.Die()
				}
			}

			// clear all ticks, should've handle player invalid cases!
			foreach ( entity tick in handledTicks )
			{
				if ( IsValid( tick ) )
					tick.Signal( "SuicideSpectreForceExplode" )
			}
		}
	)

	while ( true )
	{
		ArrayRemoveDead( handledDrones )
		ArrayRemoveDead( handledTicks )
		ArrayRemoveDead( explodingTicks )

		foreach ( entity drone in GetGruntPlayerOwnedDrones( player ) )
		{
			if ( handledDrones.contains( drone ) )
				continue
			
			// debug
			//print( "drone handled by specialist grunt: " + string( drone ) )
			
			handledDrones.append( drone )
			// update drone status
			thread DisableDroneSound( drone ) // try to stop annoying sound
			drone.SetMaxHealth( SPECIALIST_GRUNT_DRONE_HEALTH )
			drone.SetHealth( drone.GetMaxHealth() )
			// send notification
			if ( SPECIALIST_GRUNT_DRONE_RECALL_ENABLED )
				SendHudMessage( player, "Press USE to move your drone to Crosshair",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )
		}

		foreach ( entity tick in GetGruntPlayerOwnedTicks( player ) )
		{
			if ( handledTicks.contains( tick ) )
				continue
			// don't check ticks detonated by this file!
			if ( explodingTicks.contains( tick ) )
				continue

			handledTicks.append( tick )
		}

		// hit max drones?
		int overloadedDroneCount = handledDrones.len() - SPECIALIST_GRUNT_DRONE_MAX_COUNT
		if ( overloadedDroneCount > 0 )
		{
			for ( int i = 0; i < overloadedDroneCount; i++ )
			{
				if ( IsAlive( handledDrones[i] ) )
					handledDrones[i].Die()
			}
		}
		// hit max ticks?
		int overloadedTickCount = handledTicks.len() - SPECIALIST_GRUNT_TICK_MAX_COUNT
		if ( overloadedTickCount > 0 )
		{
			for ( int i = 0; i < overloadedTickCount; i++ )
			{
				entity tick = handledTicks[i]
				if ( IsAlive( tick ) && tick.ai.fragDroneArmed )
				{
					// tick explosion is delayed, remove it from aray
					tick.Signal( "SuicideSpectreForceExplode" )
					handledTicks.remove( i )
					// no longer check it
					explodingTicks.append( tick )
				}
			}
		}

		WaitFrame()
	}
}

void function SpecialistGruntRecallDrones( entity player )
{
	if ( player.Anim_IsActive() ) // doing some animations like drone spawning
		return
	
	array<entity> drones = GetGruntPlayerOwnedDrones( player )
    float lastRecallTime = specialistGrunt.classTable[player].lastRecallTime
	float lastNotifyTime = specialistGrunt.classTable[player].lastNotifyTime
    
	bool dronesLeft = false
	foreach( entity drone in drones )
	{
		if ( IsAlive( drone ) ) // at least one drone alive
			dronesLeft = true
	}

	if ( !dronesLeft )
	{
		if ( Time() - lastNotifyTime >= SPECIALIST_GRUNT_NOTIFICATION_COOLDOWN ) // notification cooldown
		{
			SendHudMessage( player, "No Drone in Field",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )
			specialistGrunt.classTable[player].lastNotifyTime = Time() // update
		}
		return
	}

	if ( Time() - lastRecallTime < SPECIALIST_GRUNT_RECALL_COOLDOWN ) // recently recalled!
	{
		if ( Time() - lastNotifyTime >= SPECIALIST_GRUNT_NOTIFICATION_COOLDOWN ) // notification cooldown
		{
			//SendHudMessage( player, "Can't move frequently",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )
			specialistGrunt.classTable[player].lastNotifyTime = Time() // update
		}
		return
	}

	vector targetPos
	vector targetAngs = < 0, player.EyeAngles().y, 0 > // get player's looking yaw
	TraceResults traceResult = TraceLine( player.EyePosition(), player.EyePosition() + player.GetViewVector() * SPECIALIST_GRUNT_RECALL_RANGE, player, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
	targetPos = traceResult.endPos

	foreach( entity drone in drones )
	{
		if ( !IsValid( drone ) ) // not a valid drone!!
			continue

		// leave a fx on original place, don't play disappear sound
		PlayDroneDisappearFX( drone.GetOrigin() )
		// we're having only 1 drone now, sound would be cool
		EmitSoundAtPosition( TEAM_UNASSIGNED, drone.GetOrigin(), SHIFTER_START_SOUND_3P )

		// play another fx on drone, only play one sound
		PlayDroneAppearFX( drone )
		drone.SetOrigin( targetPos )
		drone.SetAngles( targetAngs )
	}

	// only play one sound
	EmitSoundAtPosition( TEAM_UNASSIGNED, targetPos, SHIFTER_END_SOUND_3P )
	specialistGrunt.classTable[player].lastRecallTime = Time() // set in cooldown!
}

entity function PlayDroneDisappearFX( vector origin )
{
	asset effect = $"P_phase_shift_main"

	return PlayFX( effect, origin, < 0,0,0 > )
}

entity function PlayDroneAppearFX( entity ent )
{
	asset effect = $"P_phase_shift_main"

	return PlayFXOnEntity( effect, ent )
}

void function DisableDroneSound( entity drone )
{
	drone.EndSignal( "OnDestroy" )
	
	WaitFrame() // initial wait
	// wait for drone deploy animation end
	while ( drone.Anim_IsActive() )
		WaitFrame()
	StopSoundOnEntity( drone, "Drone_Mvmt_Hover_Hero" )
	StopSoundOnEntity( drone, "Drone_Mvmt_Hover" )
}

const int SHIELD_CAPTAIN_SHIELD_HEALTH = 100 // was 150
void function BecomeShieldCaptain( entity player )
{
	player.SetPlayerSettings( "pilot_geist_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_rspn101",												// primary weapon
		"mp_weapon_mgl",													// secondary weapon
		"",																	// grenade
		$"models/humans/grunts/imc_grunt_shield_captain.mdl",				// imc player model
		$"models/humans/grunts/imc_grunt_shield_captain.mdl",				// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Shield Captain",													// title
		"Respawn as Shield Captain: Slow mobile shield"						// respawn notification
	)

	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it
	
	// specialist grunts uses pilot headshot effect
	DeathPackage_RemoveEntityHeadshotFXOverride( player )

	thread WaitForShieldCaptainPlayerDrop( player )
}

void function WaitForShieldCaptainPlayerDrop( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	WaitFrame() // wait for player being set into dropship
	while( IsValid( player.GetParent() ) )
		WaitFrame() // wait for player leave dropship or droppod

	thread ActivatePersonalShield( player, SHIELD_CAPTAIN_SHIELD_HEALTH ) // activate mobile shield
}

void function BecomeShockGrunt( entity player )
{
	player.SetPlayerSettings( "pilot_stalker_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_hemlok_smg",												// primary weapon
		"mp_weapon_arc_launcher",											// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_medium_stalker_m.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_stalker_m.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Shock Grunt",														// title
		"Respawn as Shock Grunt: One arc trap usage"						// respawn notification
	)

	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	player.GiveOffhandWeapon( "mp_weapon_arc_trap", OFFHAND_INVENTORY, ["limited_arc_trap", "gm_shock_grunt"] ) // 2 activation arc trap, destroys itself on owner death

	// differ them from stalker
	player.SetSkin( 1 )
	player.SetCamo( 18 ) // sea

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

void function BecomeSpectre( entity player )
{
	thread WaitForSpectrePlayerLeaveDropship( player ) // HACK: wait for player leaving dropship because they don't have dropship animation
}

void function WaitForSpectrePlayerLeaveDropship( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )
	
	player.SetPlayerSettings( "pilot_nomad_male" ) // have a better pov model, also temp use this model
	
	WaitFrame() // wait for player being set into dropship
	while( IsValid( player.GetParent() ) && player.GetParent().GetClassName() == "npc_dropship" )
		WaitFrame() // wait for player leave dropship

	SimpleClassLoadout(  
		player,
		"mp_weapon_mastiff",												// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"",																// imc player model
		$"",																// mlt player model
		//["normal_wallclimb", "spectre_model"],								// class mods
		["normal_wallclimb"],												// class mods
		"Spectre",															// title
		"Respawn as Spectre: Able to Double jump"							// respawn notification
	)

	//player.GiveWeapon( "mp_weapon_defender", ["at_low_stockpile"] ) // 15 stockpile charge rifle
	player.GiveWeapon( "mp_weapon_defender", ["quick_charge"] ) // quick-charge charge rifle
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	//WaitFrame() // wait a frame. was waiting for altpilot_recoverFromSpectre(), but the function has been removed!
	player.SetModel( $"models/robots/spectre/imc_spectre.mdl" ) // safe to set model
	//player.SetTargetInfoIcon( $"ui/targetinfo_spectre_bounty" ) // will appear an error

	// better POV
	// SPECTRES CAN'T CHANGE SKIN! WILL MAKE THEM INVISIBLE!
	//player.SetSkin( 1 )
	//player.SetCamo( 135 ) // haze white
}

void function BecomeSonarPulser( entity player )
{
	player.SetPlayerSettings( "pilot_medium_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_alternator_smg",											// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_medium_reaper_m.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_reaper_m.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Sonar Grunt",														// title
		"Respawn as Sonar Grunt"											// respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "fake_tf1_sprint_anim" ) // update sprint animation
	//player.GiveWeapon( "mp_weapon_defender", ["at_low_stockpile"] ) // 15 stockpile charge rifle
	player.GiveWeapon( "mp_weapon_defender", ["quick_charge"] ) // quick-charge charge rifle
	player.GiveOffhandWeapon( "mp_weapon_grenade_sonar", OFFHAND_SPECIAL, ["grunt_mode", "gm_sonarpulser"] ) // double timed pulse blade
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

void function BecomeNinja( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_female" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"",																	// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_medium_geist_f.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_geist_f.mdl",					// mlt player model
		["disable_doublejump", "pas_wallhang"],								// class mods
		//["disable_doublejump", "pas_wallhang", "courch_walk_boost"],		// class mods(deprecated)
		"Ninja",															// title
		"Respawn as Ninja: Smoke launcher only, uses Throwing knife, Regenerate grenades. Able to Wallrun/Wallhang"	// respawn notification
	)

	//player.SetPlayerSettingPosMods( PLAYERPOSE_CROUCHING, ["coliseum"] ) // 160 crouchwalk speed

	player.SetMaxHealth( 125 ) // higher health
	player.SetHealth( 125 ) // higher health

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
	
	// player will be re-give weapon upon landing... which means they'll have weapon entity changed, needs to handle that
	//array<entity> ninjaWeapons
	//ninjaWeapons.append( player.GiveWeapon( "mp_weapon_arc_launcher", ["smoke_launcher", "at_low_stockpile"] ) ) //4 stockple smoke launcher
	//ninjaWeapons.append( player.GiveWeapon( "mp_weapon_mgl", ["extended_ammo"] ) )
	array<int> ninjaWeaponSlots
	player.GiveWeapon( "mp_weapon_arc_launcher", ["smoke_launcher", "at_low_stockpile"] )
	ninjaWeaponSlots.append( 0 )
	player.GiveWeapon( "mp_weapon_mgl", ["extended_ammo"] )
	ninjaWeaponSlots.append( 1 )
	
	// offhand weapons won't return themselves and is exclusive, saving classname is enough
	array<string> ninjaOffhands
	player.GiveOffhandWeapon( "mp_weapon_grenade_sonar", OFFHAND_SPECIAL, ["ninja_projectile", "dissolve_instant", "impact_bounce"] ) // 2s cooldown instant kill projectile
	ninjaOffhands.append( "mp_weapon_grenade_sonar" )
	player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_ORDNANCE ) // gravity star, was ["ninja_projectile"]: 2s cooldown instant kill projectile, bit slower than kunai. now also removed "pas_ordnance_pack"
	ninjaOffhands.append( "mp_weapon_grenade_gravity" )
	// melee weapon
	entity meleeWeapon = player.GetMeleeWeapon()
	if ( IsValid( meleeWeapon ) )
		player.TakeWeaponNow( meleeWeapon.GetWeaponClassName() )
	player.GiveOffhandWeapon( "melee_pilot_kunai", OFFHAND_MELEE, ["grunt_mode", "fake_human_melee"] )
	ninjaOffhands.append( "melee_pilot_kunai" )
	//thread NinjaForcedWeapon( player, ninjaWeapons, ninjaOffhands ) // force ninja use given weapons
	thread NinjaForcedWeapon( player, ninjaWeaponSlots, ninjaOffhands )
}

// player will be re-give weapon upon landing... which means they'll have weapon entity changed, needs to handle that
//void function NinjaForcedWeapon( entity player, array<entity> allowedWeapons, array<string> allowedOffhands )
void function NinjaForcedWeapon( entity player, array<int> allowedWeaponSlots, array<string> allowedOffhands )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	while( true )
	{
		WaitFrame()

		entity activeWeapon = player.GetActiveWeapon()
		if ( !IsValid( activeWeapon ) ) // not holding a weapon, must be bugged
		{
			if ( player.GetMainWeapons().len() > 0 ) // has another weapon
				player.SetActiveWeaponBySlot( 0 ) // swap to it
			continue
		}
		
		string className = activeWeapon.GetWeaponClassName()
		// debug...
		/*
		print( "activeWeapon: " + string( activeWeapon ) )
		print( "className: " + className )
		foreach ( int index, entity weapon in allowedWeapons )
			print( "allowed weapon " + string( index ) + ": " + string( weapon ) )
		foreach ( int index, string weaponName in allowedOffhands )
			print( "allowed offhand waepon " + string( index ) + ": " + weaponName )
		*/
		
		// player will be re-give weapon upon landing... which means they'll have weapon entity changed, needs to handle that
		//if ( !allowedWeapons.contains( activeWeapon ) && !allowedOffhands.contains( className ) ) // player gets a weapon from other source?
		int activeWeaponSlot
		foreach ( int slot, entity weapon in player.GetMainWeapons() )
		{
			if ( weapon == activeWeapon )
			{
				activeWeaponSlot = slot
				break
			}
		}
		
		if ( !allowedWeaponSlots.contains( activeWeaponSlot ) && !allowedOffhands.contains( className ) )
		{
			player.TakeWeaponNow( activeWeapon.GetWeaponClassName() ) // take it!
			if ( player.GetMainWeapons().len() > 0 ) // has another weapon
				player.SetActiveWeaponBySlot( 0 ) // swap to it
			//SendHudMessage( player, "忍者不可以使用其他武器",  -1, -0.3, 255, 255, 255, 255, 0.15, 6, 1 )
		}
	}
}

void function BecomeBeastKing( entity player )
{
	player.SetPlayerSettings( "pilot_geist_male" ) // have a better pov model

	// still one issue left: beastking can't climb walls...
	SimpleClassLoadout(
		player,
		"",																	// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_heavy_drex_m.mdl",					    // imc player model
		$"models/humans/pilots/pilot_heavy_drex_m.mdl",					    // mlt player model
		["normal_wallclimb"],												// class mods
		"Beast King",														// title
		//"Respawn as Beast King: Melee only, press USE to move your prowler. Regenerate grenades, Electric Smoke won't do self damage. Able to Double jump"	// respawn notification
		"Respawn as Beast King: Melee only, press USE to move your prowler. Regenerate grenades. Able to Double jump"		// respawn notification
	)
	
    player.SetMaxHealth( 125 ) // higher health
	player.SetHealth( 125 ) // higher health

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet

	array<string> beastKingOffhands
	// alt version: smoke as tactical, arc nade as ordnance
	//player.GiveOffhandWeapon( "mp_weapon_grenade_electric_smoke", OFFHAND_SPECIAL, ["gm_beastking"] ) // regenerating electric smoke grenade, very short cooldown and won't do self damage
	//beastKingOffhands.append( "mp_weapon_grenade_electric_smoke" )
	//player.GiveOffhandWeapon( "mp_weapon_grenade_emp", OFFHAND_ORDNANCE, ["gm_beastking_burn", "burn_mod_emp_grenade"] ) // regenerating emp grenade, high heavyarmor damage with burnmod, is good
	// current version: firestar as tactical
	player.GiveOffhandWeapon( "mp_weapon_thermite_grenade", OFFHAND_ORDNANCE, ["gm_beastking"] ) // very short cooldown firestar
	beastKingOffhands.append( "mp_weapon_thermite_grenade" )
	player.GiveOffhandWeapon( "mp_weapon_grenade_emp", OFFHAND_SPECIAL, ["gm_beastking"] ) // regenerating emp grenade, high heavyarmor damage
	beastKingOffhands.append( "mp_weapon_grenade_emp" )
	// melee weapon
	entity meleeWeapon = player.GetMeleeWeapon()
	if ( IsValid( meleeWeapon ) )
		player.TakeWeaponNow( meleeWeapon.GetWeaponClassName() )
	player.GiveOffhandWeapon( "melee_pilot_sword", OFFHAND_MELEE, ["allow_as_primary", "pilot_emptyhanded", "gm_beastking"] ) // was having "grunt_mode", it's now oneshot kill sword
	// use beastKingThink for weapon swap
	//player.SetActiveWeaponByName( "melee_pilot_sword" ) // swap to it
	beastKingOffhands.append( "melee_pilot_sword" )

	thread BeastKingThink( player, beastKingOffhands ) // for beast king respawning prowlers and limit weapon
}

void function BeastKingSmokeDamageTarget( entity ent, var damageInfo )
{
	if ( !IsValid( ent ) )
		return

	entity inflictor = DamageInfo_GetInflictor( damageInfo )

	if( !IsValid( inflictor ) )
		return
	if( !inflictor.IsProjectile() )
		return

	array<string> mods = Vortex_GetRefiredProjectileMods( inflictor ) // modded weapon refire behavior

	// remove self damage if we have beast king weapon mod
	// still bug if projectile is absorbed by vortex sphere... so I hardcoded it inside mp_weapon_grenade_electric_smoke.nut
	if ( mods.contains( "gm_beastking" ) )
	{
		entity attacker = DamageInfo_GetAttacker( damageInfo )
		if( IsValid( attacker ) && attacker == ent )
			DamageInfo_SetDamage( damageInfo, 0 )
	}
}

const float BEAST_KING_PROWLER_DAMAGE_AGAINST_PLAYER_SCALE = 0.5 // 40 for claw and 50 for pounce, at least no more instant kills
const float BEAST_KING_PROWLER_DAMAGE_AGAINST_HEAVY_ARMOR_SCALE = 5.0 // 300-400 for claw and 500 for pounce, bit lower than normal prowlers

void function BeastKingProwlerDamageTarget( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return

	// class table for checking prowler ownership
	entity bossPlayer = attacker.GetBossPlayer()
	if ( !IsValid( bossPlayer ) )
		return
	
	if ( !( bossPlayer in beastKing.classTable ) )
		return
	if ( !IsAlive( beastKing.classTable[bossPlayer].ownedProwler ) )
		return
	
	float damageScale = 1.0

	bool nerfDamage = false
	bool heavyArmorTarget = false
	// prowler's craw damage is 80, pounce damage is 100
	if ( victim.IsPlayer() ) // nerf it's damage agains players
		nerfDamage = true
	if ( victim.IsNPC() )
	{
		// a npc owned by player, do reduce damage
		if ( IsValid( victim.GetBossPlayer() ) )
			nerfDamage = true
	}
	if ( victim.GetArmorType() == ARMOR_TYPE_HEAVY )
		heavyArmorTarget = true

	if ( heavyArmorTarget )
		damageScale *= BEAST_KING_PROWLER_DAMAGE_AGAINST_HEAVY_ARMOR_SCALE
	else if ( nerfDamage )
		damageScale *= BEAST_KING_PROWLER_DAMAGE_AGAINST_PLAYER_SCALE

	DamageInfo_ScaleDamage( damageInfo, damageScale )
}

struct BeastKingStruct
{
	entity ownedProwler
	float lastRecallTime
	float lastNotifyTime
	bool prolwerFirstSpawn
}

struct
{
	table< entity, BeastKingStruct > classTable
} beastKing

const bool BEAST_KING_PROWLER_RECALL_ENABLED = true
const float BEAST_KING_PROWLER_COOLDOWN = 10.0
const bool BEAST_KING_PROWLER_RESPAWN = true
const float BEAST_KING_RECALL_RANGE = 750
const float BEAST_KING_RECALL_COOLDOWN = 2.0
const float BEAST_KING_NOTIFICATION_COOLDOWN = 2.0
const int BEAST_KING_PROWLER_HEALTH = 280 // was 380, 100 more than normal prowlers

void function BeastKingThink( entity player, array<string> allowedOffhands )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	// init this class
	if ( !( player in beastKing.classTable ) )
	{
		BeastKingStruct emptyStruct
		beastKing.classTable[player] <- emptyStruct
	}

	// make recall available
	beastKing.classTable[player].lastRecallTime = Time() - BEAST_KING_RECALL_COOLDOWN
	beastKing.classTable[player].lastNotifyTime = Time() - BEAST_KING_NOTIFICATION_COOLDOWN

	if ( BEAST_KING_PROWLER_RECALL_ENABLED )
	{
		AddButtonPressedPlayerInputCallback( player, IN_USE, BeastKingRecallProwler )
		AddButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, BeastKingRecallProwler )
	}
    
    OnThreadEnd(
        function(): ( player )
        {
            if ( IsValid( player ) )
            {
				if ( BEAST_KING_PROWLER_RECALL_ENABLED )
				{
					RemoveButtonPressedPlayerInputCallback( player, IN_USE, BeastKingRecallProwler )
					RemoveButtonPressedPlayerInputCallback( player, IN_USE_AND_RELOAD, BeastKingRecallProwler )
				}
			}
        }
    )

	thread BeastKingProwlerSpawner( player )
	thread BeastKingForcedWeapon( player, allowedOffhands )

	WaitForever() // wait for endsignals to trigger
}

void function BeastKingRecallProwler( entity player )
{
	// player invulnerable, can't move prowler
	if ( player.IsInvulnerable() || player.IsPhaseShifted() )
		return

	// maybe not first spawn yet
	if ( !beastKing.classTable[player].prolwerFirstSpawn )
		return

    entity prowler = beastKing.classTable[player].ownedProwler
    float lastRecallTime = beastKing.classTable[player].lastRecallTime
	float lastNotifyTime = beastKing.classTable[player].lastNotifyTime
    
	if ( !IsAlive( prowler ) ) // not alive
    {
		if ( Time() - lastNotifyTime >= BEAST_KING_NOTIFICATION_COOLDOWN ) // notification cooldown
		{
        	SendHudMessage( player, "Prowler already dead",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )
			beastKing.classTable[player].lastNotifyTime = Time() // update
		}
        return
    }
    if ( Time() - lastRecallTime < BEAST_KING_RECALL_COOLDOWN ) // recently recalled!
    {
		if ( Time() - lastNotifyTime >= BEAST_KING_NOTIFICATION_COOLDOWN ) // notification cooldown
		{
        	//SendHudMessage( player, "Can't move frequently",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )
			beastKing.classTable[player].lastNotifyTime = Time() // update
		}
        return
    }
    
    vector targetPos
    vector targetAngs = < 0, player.EyeAngles().y, 0 > // get player's looking yaw
    TraceResults traceResult = TraceLine( player.EyePosition(), player.EyePosition() + player.GetViewVector() * BEAST_KING_RECALL_RANGE, player, (TRACE_MASK_SHOT | CONTENTS_BLOCKLOS), TRACE_COLLISION_GROUP_NONE )
    targetPos = traceResult.endPos

    // leave a fx on original place
    PlayProwlerDisappearFX( prowler.GetOrigin() )

    // play another fx on prowler
    PlayProwlerAppearFX( prowler )
    prowler.SetOrigin( targetPos )
    prowler.SetAngles( targetAngs )
    beastKing.classTable[player].lastRecallTime = Time() // set in cooldown!
}

entity function PlayProwlerDisappearFX( vector origin )
{
	asset effect = $"P_phase_shift_main"
	EmitSoundAtPosition( TEAM_UNASSIGNED, origin, SHIFTER_START_SOUND_3P )

	return PlayFX( effect, origin, < 0,0,0 > )
}

entity function PlayProwlerAppearFX( entity ent )
{
	asset effect = $"P_phase_shift_main"
	EmitSoundOnEntity( ent, SHIFTER_END_SOUND_3P )

	return PlayFXOnEntity( effect, ent )
}

void function BeastKingProwlerSpawner( entity player, float delay = 0.0 ) // the delay is for respawning prowlers
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	if ( delay > 0 )
		wait delay

    // wait for player landing and exit droppod
    waitthread WaitForPlayerAbleToSummonProwler( player )

	entity prowler = CreateProwlerForBeastKing( player )
	beastKing.classTable[player].prolwerFirstSpawn = true
    prowler.EndSignal( "OnDestroy" )
    prowler.EndSignal( "OnDeath" )

	// OnThreadEnd() only triggers after delay, since this function won't do anything if player dies before prowler respawn
	OnThreadEnd(
		function(): ( player, prowler )
		{
			if ( !IsAlive( player ) )
			{
				if ( IsAlive( prowler ) )
					prowler.Die()
			}
			else if ( !IsAlive( prowler ) ) // player still alive but prowler dead
            {
                SendHudMessage( player, "Prowler died",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )
				if ( BEAST_KING_PROWLER_RESPAWN )
					thread BeastKingProwlerSpawner( player, BEAST_KING_PROWLER_COOLDOWN ) // 10s for spawning another prowler
            }
        }
	)

	prowler.WaitSignal( "OnDeath" ) // wait for prowler death
}

void function WaitForPlayerAbleToSummonProwler( entity player )
{
	WaitForPlayerLanding( player )

	// wait for player leaving droppod( they have invulnerability while inside )
	while ( player.IsInvulnerable() )
		WaitFrame()
}

void function WaitForPlayerLanding( entity player )
{
	// wait for the moment when player able to act
	WaitForPlayerDrop( player )

	// wait for player landing
	while ( !player.IsOnGround() )
		WaitFrame()
}

entity function CreateProwlerForBeastKing( entity player )
{
	entity prowler = CreateNPC( "npc_prowler", player.GetTeam(), player.GetOrigin(), player.GetAngles() )
	SetSpawnOption_AISettings( prowler, "npc_prowler" )
	prowler.SetMaxHealth( BEAST_KING_PROWLER_HEALTH )
	prowler.SetHealth( BEAST_KING_PROWLER_HEALTH )
	DispatchSpawn( prowler )

	prowler.SetOwner( player )
	prowler.ai.preventOwnerDamage = true
	prowler.SetBossPlayer( player )
	// don't follow!! the prowler will lost target
	//NPCFollowsPlayer( prowler, player )
	Highlight_SetOwnedHighlight( prowler, "friendly_ai" )
	// so they won't block teammates...?
	prowler.kv.CollisionGroup = TRACE_COLLISION_GROUP_PLAYER

    beastKing.classTable[player].ownedProwler = prowler
    beastKing.classTable[player].lastRecallTime = Time() - BEAST_KING_RECALL_COOLDOWN // make recall valid
    if ( BEAST_KING_PROWLER_RECALL_ENABLED )
		SendHudMessage( player, "Prowler Respawned. Press USE to move it to Crosshair",  -1, -0.3, 255, 255, 0, 255, 0.15, 6, 1 )

	PlayProwlerAppearFX( prowler ) // phase out effect

	// sync invulnerability, notarget and solid states
	// ( this means prowler will lose target on owner phase shift... I think? also idk how to check solid state, is player.kv.solid useful? )
	thread PlayerAndProwlerSenseTogether( player, prowler )

	return prowler
}

void function PlayerAndProwlerSenseTogether( entity player, entity prowler )
{
	player.EndSignal( "OnDestroy" )
    player.EndSignal( "OnDeath" )
	prowler.EndSignal( "OnDestroy" )
    prowler.EndSignal( "OnDeath" )

	while ( true )
	{
		if ( player.GetNoTarget() && !prowler.GetNoTarget() )
		{
			prowler.SetNoTarget( true )
			prowler.EnableNPCFlag( NPC_IGNORE_ALL ) // also stop searching for enemies
			//print( "trying to stop prowler enemy sensing..." )
		}
		else if ( !player.GetNoTarget() && prowler.GetNoTarget() )
		{
			prowler.SetNoTarget( false )
			prowler.DisableNPCFlag( NPC_IGNORE_ALL )
			//print( "trying to restore prowler enemy sensing..." )
		}

		if ( player.GetNoTarget() && IsValid( prowler.GetEnemy() ) )
		{
			prowler.ClearEnemy()
			//print( "due that player cannot be targeted, prowler's enemy has been cleared" )
		}

		if ( player.IsInvulnerable() && !prowler.IsInvulnerable() )
		{
			prowler.SetInvulnerable()
			//print( "prowler is now invulnerable" )
		}
		else if ( !player.IsInvulnerable() && prowler.IsInvulnerable() )
		{
			prowler.ClearInvulnerable()
			//print( "prowler is now vulnerable" )
		}

		WaitFrame()
	}
}

void function BeastKingForcedWeapon( entity player, array<string> allowedOffhands )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	// wait for player landing ground
	waitthread WaitForPlayerLanding( player )

	while( true )
	{
		CheckBeastKingWeapon( player, allowedOffhands )
		WaitFrame()
	}
}

void function CheckBeastKingWeapon( entity player, array<string> allowedOffhands )
{
	// player will be re-give weapon upon landing... needs to handle that
	if ( IsValid( player.GetParent() ) )
		return

	entity activeWeapon = player.GetActiveWeapon()
	if ( !IsValid( activeWeapon ) ) // not holding a weapon, must be bugged
	{
		// update weapon to do deploy animation( VERY HACKY )
		player.TakeOffhandWeapon( OFFHAND_MELEE )
		player.GiveOffhandWeapon( "melee_pilot_sword", OFFHAND_MELEE, ["allow_as_primary", "pilot_emptyhanded", "gm_beastking"] )
		
		// same think as sword core
		player.HolsterWeapon()
		player.SetActiveWeaponByName( "melee_pilot_sword" ) // swap to melee
		player.DeployWeapon()
		return
	}
	
	string className = activeWeapon.GetWeaponClassName()
	if ( !allowedOffhands.contains( className ) ) // player gets a weapon from other source?
	{
		player.TakeWeaponNow( activeWeapon.GetWeaponClassName() ) // take it!
		player.SetActiveWeaponByName( "melee_pilot_sword" ) // swap to melee
		//SendHudMessage( player, "驯兽师不可以使用其他武器",  -1, -0.3, 255, 255, 255, 255, 0.15, 6, 1 )
	}
}

void function BecomeJumper( entity player )
{
	player.SetPlayerSettings( "pilot_nomad_male" ) // have a better pov model
    //player.SetPlayerSettings( "pilot_nomad_female" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_esaw",												    // primary weapon
		"mp_weapon_mgl",													// secondary weapon
		"",											                        // grenade
		// runner no longer uses stim pilot model, change this back to male
		//$"models/humans/pilots/pilot_light_jester_f.mdl",					// imc player model
		//$"models/humans/pilots/pilot_light_jester_f.mdl",				    // mlt player model
		$"models/humans/pilots/pilot_light_jester_m.mdl",					// imc player model
		$"models/humans/pilots/pilot_light_jester_m.mdl",				    // mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Jumper",															// title
		"Respawn as Jumper: One jump pad usage"						        // respawn notification
	)

	// no longer allow infinite jump pad because we've added npc jump pad usage...
    //player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_SPECIAL, ["grunt_mode", "jump_pad", "infinite_jump_pad", "gm_jumper"] )
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_SPECIAL, ["grunt_mode", "jump_pad", "gm_jumper"] )
	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	// attach a fake head to it
	CreateMechanicalHeadForPlayer( player )

	player.SetSkin( 1 )
	player.SetCamo( 14 ) // green
}

void function BecomeShifter( entity player )
{
    //player.SetPlayerSettings( "pilot_light_female" ) // have a better pov model
	player.SetPlayerSettings( "pilot_light_male" )

	// not using the model $"models/Humans/heroes/imc_hero_ash.mdl" since we've assigned it to boss titans
	SimpleClassLoadout(  
		player,
		"mp_weapon_doubletake",												// primary weapon
		"mp_weapon_arc_launcher",											// secondary weapon
		"",											                        // grenade
		//$"models/humans/pilots/pilot_light_ged_f.mdl",					    // imc player model
		//$"models/humans/pilots/pilot_light_ged_f.mdl",					    // mlt player model
		$"models/humans/pilots/pilot_light_ged_m.mdl",					    // imc player model
		$"models/humans/pilots/pilot_light_ged_m.mdl",					    // mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Shifter",															// title
        "Respawn as Shifter: One long-time phase shift usage"			    // respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "tripletake" ) // visualize middle bullet(client prediction required)
    player.GetMainWeapons()[0].AddMod( "gm_shifter" ) // nerfed doubletake
    player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["grunt_mode", "gm_shifter"] )
	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	// attach a fake head to it
	// actually no need for phase shift pilot, just for the head break effect
	CreateMechanicalHeadForPlayer( player )

	player.SetSkin( 1 )
	player.SetCamo( 30 ) // dark
}

void function BecomeRavenant( entity player )
{
	player.SetPlayerSettings( "pilot_nomad_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		//"mp_weapon_hemlok",													// primary weapon(deprecated)
		"mp_weapon_rspn101_og",												// primary weapon, switch from phase walker
		"mp_weapon_rocket_launcher",										// secondary weapon
		"mp_weapon_satchel",											    // grenade
		$"models/humans/pilots/pilot_light_jester_m.mdl",					// imc player model
		$"models/humans/pilots/pilot_light_jester_m.mdl",					// mlt player model
		["disable_doublejump", "amped_wallclimb", "courch_walk_boost", "pas_wall_runner"],		// class mods
		"Ravenant",															// title
        "Respawn as Ravenant: Much faster and higher climb, crouch walk won't reduce speed"		// respawn notification
	)

	// 160 crouchwalk speed. there's a "courch_walk_boost" classmod for us handling crouch speed, adding this is just for better stand-to-crouch transition
	player.SetPlayerSettingPosMods( PLAYERPOSE_CROUCHING, ["coliseum"] )

	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	// attach a fake head to it
	CreateMechanicalHeadForPlayer( player )

	player.SetSkin( 1 )
	player.SetCamo( 154 ) // red line
}

void function BecomePhaseWalker( entity player )
{
	player.SetPlayerSettings( "pilot_light_female" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		//"mp_weapon_rspn101_og",												// primary weapon
		"mp_weapon_hemlok",													// new weapon, same as wraith's trailer
		"mp_weapon_arc_launcher",											// secondary weapon
		"",											    					// grenade
		$"models/humans/pilots/pilot_light_ged_f.mdl",					    // imc player model
		$"models/humans/pilots/pilot_light_ged_f.mdl",					    // mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Phase Walker",														// title
        "Respawn as Phase Walker: One portal usage, can teleport between them"		// respawn notification
	)
	
	player.GiveOffhandWeapon( "mp_ability_shifter", OFFHAND_SPECIAL, ["grunt_mode", "gm_phasewalker", "wraith_portal", "amped_tacticals"] )
	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	// attach a fake head to it
	// actually no need for phase shift pilot, just for the head break effect
	CreateMechanicalHeadForPlayer( player )

	player.SetSkin( 1 )
	player.SetCamo( 31 ) // light
}

void function BecomeHeavySniper( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_sniper",													// primary weapon
		"",																	// secondary weapon
		"mp_weapon_grenade_electric_smoke",									// grenade
		// model updated: other normal grunts now uses random model, heavy snipers should use lmg grunt model like specialists!
		//$"models/humans/grunts/imc_grunt_rifle.mdl",						// imc player model
		//$"models/humans/grunts/mlt_grunt_rifle.mdl",						// mlt player model
		$"models/humans/grunts/imc_grunt_lmg.mdl",							// imc player model
		$"models/humans/grunts/mlt_grunt_lmg.mdl",							// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Heavy Sniper",														// title
		"Respawn as Heavy Sniper. Weapon is able to damage heavy armor units"	// respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "gm_heavysniper" ) // high heavy armor damage, bypass titan armor.
	//player.GetMainWeapons()[0].AddMod( "titandamage_weapon" ) // no need to aim weakpoint to deal damage. the mod has been removed and build into gm_heavysniper now
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	// specialist grunts uses pilot headshot effect
	DeathPackage_RemoveEntityHeadshotFXOverride( player )

	// mlt specific pov camo
	ApplyMLTGruntCamo( player )
}

void function BecomeRunner( entity player )
{
	//player.SetPlayerSettings( "pilot_nomad_male" ) // have a better pov model
	player.SetPlayerSettings( "pilot_light_male" )

	SimpleClassLoadout(  
		player,
		"",												    				// primary weapon
		"",																	// secondary weapon
		"",											                        // grenade
		//$"models/humans/pilots/pilot_light_jester_m.mdl",					// imc player model
		//$"models/humans/pilots/pilot_light_jester_m.mdl",				    // mlt player model
		$"models/humans/pilots/pilot_light_ged_m.mdl",					    // imc player model
		$"models/humans/pilots/pilot_light_ged_m.mdl",					    // mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Runner",															// title
		"Respawn as Runner: Longer stim, costs heath"						// respawn notification
	)

	player.GiveWeapon( "mp_weapon_autopistol", ["silencer", "gm_runner", "pas_run_and_gun", "extended_ammo", "fake_tf1_sprint_anim"] ) // less falloff re45
    player.GiveWeapon( "mp_weapon_mgl", ["extended_ammo"] ) // extended ammo mgl
	player.GiveOffhandWeapon( "mp_ability_heal", OFFHAND_SPECIAL, ["octane_stim", "gm_runner"] ) // long duration stim, costs health on activation and disables health regen while activating(not compatible with "grunt_mode")
	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	// attach a fake head to it
	// actually no need for phase shift pilot, just for the head break effect
	CreateMechanicalHeadForPlayer( player )

	// looks like octane legendary skin? just to differ it's pov model from spectres
	// now we could use phase shift pilot model, I think
	//player.SetSkin( 1 )
	//player.SetCamo( 135 ) // haze white
}

void function BecomePathBuilder( entity player )
{
	player.SetPlayerSettings( "pilot_heavy_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_r97",													// primary weapon
		"mp_weapon_mgl",													// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_heavy_roog_m.mdl",						// imc player model
		$"models/humans/pilots/pilot_heavy_roog_m.mdl",						// mlt player model
		["disable_doublejump", "only_wallclimb", "no_grapple_power_regen"],	// class mods
		"Path Builder",														// title
		"Respawn as Path Builder: One zipline gun usage"					// respawn notification
	)

	player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, ["zipline_gun", "gm_pathbuilder"] ) // normal speed zipline, 
	//player.GetMeleeWeapon().AddMod( "fake_human_melee" ) // model doesn't have grunt melee activity, only change their damageSourceId for airkicks

	player.SetSkin( 1 )
	player.SetCamo( 18 ) // sea

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

void function BecomeScout( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_g2",														// primary weapon
		"mp_weapon_rocket_launcher",										// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_medium_geist_m.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_geist_m.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb", "no_grapple_power_regen"],	// class mods
		"Scout",															// title
		"Respawn as Scout: Two grapple usage"								// respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "gm_scout" ) // nerfed g2
	player.GiveOffhandWeapon( "mp_ability_grapple", OFFHAND_SPECIAL, ["gm_scout"] )
	// use this if you want only 1 grapple usage
	//thread TrackScoutGrappleUsage( player )
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	player.SetSkin( 1 )
	player.SetCamo( 18 ) // sea

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

void function TrackScoutGrappleUsage( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	while ( true )
	{
		if ( player.GetSuitGrapplePower() > 50.0 ) // more than one recharge?
			player.SetSuitGrapplePower( 50.0 ) // set to 50
		WaitFrame()
	}
}

void function BecomeFlyer( entity player )
{
	player.SetPlayerSettings( "pilot_medium_female" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"",																	// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_medium_reaper_f.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_reaper_f.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Flyer",															// title
		"Respawn as Flyer: Jet pack as passive ability"						// respawn notification
	)

	player.GiveWeapon( "mp_weapon_shotgun_pistol", ["silencer", "gm_flyer"] ) // less damage mozambique
	//player.GiveWeapon( "mp_weapon_defender", ["at_low_stockpile"] ) // 15 stockpile charge rifle
	player.GiveWeapon( "mp_weapon_defender", ["quick_charge"] ) // quick-charge charge rifle
	player.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_SPECIAL, ["jet_pack", "gm_flyer"] )
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	player.SetSkin( 1 )
	player.SetCamo( 19 ) // overcast

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

void function BecomeAssassin( entity player )
{
	player.SetPlayerSettings( "pilot_stalker_female" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"",																	// primary weapon
		"",																	// secondary weapon
		"mp_weapon_grenade_emp",											// grenade
		$"models/humans/pilots/pilot_medium_stalker_f.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_stalker_f.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Assassin",															// title
		"Respawn as Assassin"												// respawn notification
	)

	// can't use AddMod() or the weapon won't update it's bodygroup
	player.GiveWeapon( "mp_weapon_wingman_n", ["silencer", "ricochet"] ) // silenced wingman elite
	//player.GiveWeapon( "mp_weapon_defender", ["at_low_stockpile"] ) // 15 stockpile charge rifle
	player.GiveWeapon( "mp_weapon_defender", ["quick_charge"] ) // quick-charge charge rifle
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	player.SetSkin( 1 )
	player.SetCamo( 19 ) // overcast

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet
}

void function BecomeStalker( entity player )
{
	player.SetPlayerSettings( "pilot_stalker_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_shotgun_doublebarrel",									// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"models/humans/pilots/pilot_medium_stalker_m.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_stalker_m.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Stalker",															// title
		"Respawn as Stalker"												// respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "fake_tf1_sprint_anim" ) // update sprint animation
	player.GiveWeapon( "mp_weapon_defender", ["quick_charge"] ) // quick-charge charge rifle
	player.GiveOffhandWeapon( "mp_ability_holopilot", OFFHAND_SPECIAL, ["grunt_mode", "gm_stalker"] )

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet. also one way to tell them from decoys is through the helmet
}

const float STALKER_DECOY_DURATION = 30 // doubled DECOY_DURATION
const float STALKER_DECOY_HEALTH = 80 // can tank most npc attack. note that they still gets oneshot by players and npc pilots
const float STALKER_DECOY_REFUND_GRACE_PERIOD = 10 // if decoy isn't shot at and gets destroyed within this time, consider it has collide with something. we'd refund player's decoy charge
const float STALKER_DECOY_MAX_COUNT = 2 // limited to 2 charges per player

struct
{
	table< entity, float > decoyCreationTime
	table< entity, array<entity> > activatedDecoys
} stalker

void function OnStalkerDecoyCreated( entity player, entity decoy )
{
	if ( !IsValid( GetStalkerHolopilotDecoyWeapon( player ) ) )
		return

	stalker.decoyCreationTime[ decoy ] <- Time()
	CheckStalkerPlayerDecoyMaxCount( player, decoy )

	// update timeout and health
	decoy.SetTimeout( STALKER_DECOY_DURATION )
	decoy.SetMaxHealth( STALKER_DECOY_HEALTH )
	decoy.SetHealth( STALKER_DECOY_HEALTH )

	// setup damage callbacks
	// note that this requires decoy.SetDamageNotifications( true ) to take effect
	// that one is handled by modified mp_ability_holopilot.nut file!
	AddEntityCallback_OnDamaged( decoy, OnStalkerDecoyDamaged )

	// track owner life time
	thread StalkerDecoyDissolveOwnerDeath( player, decoy )
}

entity function GetStalkerHolopilotDecoyWeapon( entity player )
{
	entity holopilotWeapon
	foreach ( weapon in player.GetOffhandWeapons() )
	{
		if ( weapon.GetWeaponClassName() == "mp_ability_holopilot" )
		{
			holopilotWeapon = weapon
			break
		}
	}
	if ( !IsValid( holopilotWeapon ) || !holopilotWeapon.HasMod( "gm_stalker" ) )
		return null
	
	return holopilotWeapon
}

void function CheckStalkerPlayerDecoyMaxCount( entity player, entity newDecoy )
{
	if ( !( player in stalker.activatedDecoys ) )
		stalker.activatedDecoys[ player ] <- []
	
	ArrayRemoveInvalid( stalker.activatedDecoys[ player ] )
	stalker.activatedDecoys[ player ].append( newDecoy )

	if ( stalker.activatedDecoys[ player ].len() > STALKER_DECOY_MAX_COUNT )
	{
		entity latestDecoy = stalker.activatedDecoys[ player ][0]
		if ( IsValid( latestDecoy ) )
		{
			// never refund charge on this case
			if ( latestDecoy in stalker.decoyCreationTime )
				delete stalker.decoyCreationTime[ latestDecoy ]
			latestDecoy.Decoy_Dissolve()
			stalker.activatedDecoys[ player ].removebyvalue( latestDecoy )
		}
	}
}

void function StalkerDecoyDissolveOwnerDeath( entity player, entity decoy )
{
	player.EndSignal( "OnDestroy" )
	decoy.EndSignal( "OnDestroy" )
	
	player.WaitSignal( "OnDeath" )
	// decoy still valid!
	if ( stalker.activatedDecoys[ player ].contains( decoy ) )
		decoy.Decoy_Dissolve()
}

void function OnStalkerDecoyDamaged( entity decoy, var damageInfo )
{
	// as long as decoy takes damage, we no longer refund charge to player
	if ( decoy in stalker.decoyCreationTime )
		delete stalker.decoyCreationTime[ decoy ]
}

void function OnStalkerDecoyDieOrDissolve( entity decoy, int currentState )
{
	entity bossPlayer = decoy.GetBossPlayer()
	if ( !IsValid( bossPlayer ) )
		return
	
	entity weapon = GetStalkerHolopilotDecoyWeapon( bossPlayer )
	if ( !IsValid( weapon ) )
		return
	
	// firstly making dissolving decoy no longer takes up a slot for player
	stalker.activatedDecoys[ bossPlayer ].removebyvalue( decoy )

	// if decoy isn't damaged and gets destroyed within our period of time...
	// try to refund charge
	if ( decoy in stalker.decoyCreationTime )
	{
		// all checks passed, try refund charge
		if ( Time() - stalker.decoyCreationTime[ decoy ] <= STALKER_DECOY_REFUND_GRACE_PERIOD )
			weapon.SetWeaponPrimaryClipCount( min( weapon.GetWeaponPrimaryClipCountMax(), weapon.GetWeaponPrimaryClipCount() + weapon.GetAmmoPerShot() ) )
		delete stalker.decoyCreationTime[ decoy ] // always remember to remove it from array, otherwise it may trigger callback twice
	}
}

void function BecomeGravityMaster( entity player )
{
	thread WaitForGravityMasterLanding( player )
}

void function WaitForGravityMasterLanding( entity player )
{
	player.SetPlayerSettings( "pilot_grapple_female" ) // have a better pov model

	//WaitFrame() // wait for player being set into dropship

	string primaryWeapon = ""
	string secondaryWeapon = ""

	// player inside dropship... this case they'll need a weapon in hand
	// welp this will make weapon on player's back
	// but after waiting 1 frame crosshair will be fixed?
	// can't be fixed! let's just give player weapon upon landing, who will ever care players inside dropship?
	/*
	if ( player.GetParent().GetClassName() == "npc_dropship" )
	{
		primaryWeapon = "mp_weapon_peacekraber"
		secondaryWeapon = "mp_weapon_arc_launcher"
	}
	else // inside droppod?
	{
		// give weapon upon player landing!
		thread GravityMasterWeaponThink( player )
	}
	*/

	SimpleClassLoadout(  
		player,	
		// kinda special, peace kraber needs to be given after player landing, otherwise player won't have crosshair till they switch weapon								
		//"mp_weapon_peacekraber",											// primary weapon
		//"mp_weapon_arc_launcher",											// secondary weapon
		primaryWeapon,														// primary weapon
		secondaryWeapon,													// secondary weapon
		"",											    					// grenade
		$"models/humans/pilots/pilot_medium_geist_f.mdl",					// imc player model
		$"models/humans/pilots/pilot_medium_geist_f.mdl",					// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Gravity Master",													// title
        "Respawn as Gravity Master: One Gravity Lift usage, lifts any human inside"			// respawn notification
	)
	
	//player.SetActiveWeaponByName( "mp_weapon_peacekraber" ) // will this fix crosshair???
	// give weapon upon player landing!
	thread GravityMasterWeaponThink( player )

	player.GiveOffhandWeapon( "mp_weapon_grenade_gravity", OFFHAND_SPECIAL, ["grunt_mode", "gravity_lift", "gm_gravitymaster"] )
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	CreateIMCGruntHelmetForPlayer( player ) // give pilot model a grunt helmet

	player.SetSkin( 1 )
	player.SetCamo( 31 ) // light
}

void function GravityMasterWeaponThink( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	waitthread WaitForPlayerLanding( player )

	WaitFrame() // wait for player HUD back
	foreach ( entity mainWeapon in player.GetMainWeapons() )
		player.TakeWeaponNow( mainWeapon.GetWeaponClassName() )
	
	// give weapons
	player.GiveWeapon( "mp_weapon_peacekraber", ["disable_run_and_gun_server"] )
	player.GiveWeapon( "mp_weapon_arc_launcher" )
}

void function BecomeFortress( entity player )
{
	player.SetPlayerSettings( "pilot_geist_male" ) // have a better pov model

	SimpleClassLoadout(  
		player,
		"mp_weapon_smr",													// primary weapon
		"",																	// secondary weapon
		"",																	// grenade
		$"models/humans/grunts/imc_grunt_shield_captain.mdl",				// imc player model
		$"models/humans/grunts/imc_grunt_shield_captain.mdl",				// mlt player model
		["disable_doublejump", "only_wallclimb"],							// class mods
		"Fortress",															// title
		"Respawn as Fortress: Powerful anti-titan weapon, one Hard Cover usage"					// respawn notification
	)

	player.GetMainWeapons()[0].AddMod( "gm_fortress" ) // less damage against human, less dmage on headshot, more damage against titans
	player.GiveOffhandWeapon( "mp_weapon_hard_cover", OFFHAND_SPECIAL, ["grunt_mode", "hard_cover_always", "gm_fortress"] ) // hard cover with bit nerfed health
	//player.GetMeleeWeapon().AddMod( "fake_grunt_melee" ) // model has grunt melee activity, use it

	// specialist grunts uses pilot headshot effect
	DeathPackage_RemoveEntityHeadshotFXOverride( player )
}

///////////////////////////////////////////////
///// DEFAULT CLASS LOADOUT FUNCTIONS END /////
///////////////////////////////////////////////



///////////////////////////////////
///// CLASS UTILITY FUNCTIONS /////
///////////////////////////////////

// weapon/mods arguments are default by empty
void function SimpleClassLoadout( entity player, string primary = "", string secondary = "", string grenade = "", asset imcPlayerModel = $"", asset mltPlayerModel = $"", array<string> classMods = [], string title = "", string notification = "" )
{
	// take out fast regen before classmods applying
	if ( PlayerHasPassive( player, ePassives.PAS_FAST_HEALTH_REGEN ) )
		TakePassive( player, ePassives.PAS_FAST_HEALTH_REGEN )
	// first do resetting class
	player.SetPlayerSettingsWithMods( player.GetPlayerSettings(), classMods )
	player.SetSuitGrapplePower( 100.0 ) // recharge grapple power
	// pose mods carry through player settings change... have to reset
	player.SetPlayerSettingPosMods( PLAYERPOSE_STANDING, [] )
	player.SetPlayerSettingPosMods( PLAYERPOSE_CROUCHING, [] )

	TakeAllWeapons( player )
	if ( primary != "" )
		player.GiveWeapon( primary )
	if ( secondary != "" )
		player.GiveWeapon( secondary )
	if ( grenade != "" )
		player.GiveOffhandWeapon( grenade, OFFHAND_ORDNANCE, ["grunt_mode"] ) // grenade is limited to one use
	player.GiveOffhandWeapon( "melee_pilot_emptyhanded", OFFHAND_MELEE, ["grunt_mode", "fake_human_melee"] ) // normal melee( removed "fake_ground_execute" )

	player.Signal( "ForceStopShield" ) // always try to stop last shield captain's shield
	//player.SetTargetInfoIcon( $"ui/targetinfo_soldier_bounty" ) // will appear an error
	if ( title != "" )
		player.SetTitle( title )

	int bodyType = eBodyTypes.NPC_GRUNT
	if ( player.IsMechanical() ) // mechanical from player.SetPlayerSettings()
		bodyType = eBodyTypes.NPC_SPECTRE
	// modified function in _pain_death_sounds.gnut, overwrite death sound!
	PainDeathSounds_SetBodyTypeOverride( player, bodyType )
	if ( !player.IsMechanical() ) // player is not mechanical
		DeathPackage_SetEntityHeadshotFXOverride( player, $"P_headshot_human" ) // override headshot fx with grunt helmet drop effect
	else
		DeathPackage_RemoveEntityHeadshotFXOverride( player ) // mechanic, remove headshot fx override since robotic pilot's fx is default to be the same as spectres
	// set ragdoll impact effect to grunt version
	SetHumanRagdollImpactTable( player )
	
	thread HidePlayerNameForEnemy( player ) // sometimes detach a rodeo will show their name again, do a thread
	GivePassive( player, ePassives.PAS_STEALTH_MOVEMENT ) // hide jetpack flame
	Rodeo_SetStealthMovementDisabledForPlayer( player, true ) // disable stealth rodeo, so player will have jetpack modified only
	
	// take out passives that can still be valid for player
	if( PlayerHasPassive( player, ePassives.PAS_ENEMY_DEATH_ICONS ) )
		TakePassive( player, ePassives.PAS_ENEMY_DEATH_ICONS )
	if( PlayerHasPassive( player, ePassives.PAS_ORDNANCE_PACK ) ) // prevent regen ticks
		TakePassive( player, ePassives.PAS_ORDNANCE_PACK )

	// grunt player executions
	Melee_SetExecutionRefsOverride( 
		player, 
		// execution_face_stab_combat is a modified execution ref
		["execution_neck_snap", "execution_face_stab_combat", "execution_backshot", "execution_combo", "execution_knockout"]
	)

	// using custom utility!
	//player.SetGroundFrictionScale( 4.0 ) // prevent players getting speed from slide, but this still allow players slidehop
	SetPlayerGroundFrictionPermanent( player, 4.0 ) // permanent ground friction utility

	// default set their skin to 0 for no camo, can be reset after this defination
	player.SetSkin( 0 )
	player.SetCamo( 0 )

	// check model arguments validity
	bool imcModelValid = imcPlayerModel != $""
	bool mltModelValid = mltPlayerModel != $""

	if ( !IsFFAGame() ) // two teams modes
	{
		if ( player.GetTeam() == TEAM_MILITIA )
		{
			if ( mltModelValid )
				player.SetModel( mltPlayerModel )
		}
		else
		{
			if ( imcModelValid )
				player.SetModel( imcPlayerModel )
		}
	}
	else // ffa games
	{
		if ( imcModelValid && !mltModelValid ) // only applied imc model
			player.SetModel( imcPlayerModel )
		else if ( mltModelValid && !imcModelValid ) // only applied mlt model
			player.SetModel( mltPlayerModel )
		else // both valid
		{
			// random pick one
			if ( CoinFlip() )
				player.SetModel( imcPlayerModel )
			else
				player.SetModel( mltPlayerModel )
		}
	}

	if ( notification != "" )
		thread WaitForPlayerDropThenNotify( player, notification )
}

void function HidePlayerNameForEnemy( entity player )
{
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "OnDeath" )

	while( true )
	{
		player.SetNameVisibleToEnemy( false ) // hide name to enemy, sometimes they're re-enabled such as rodeo over, so keep setting it
		WaitFrame()
	}
}

void function WaitForPlayerDropThenNotify( entity player, string notification )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	// wait for the moment when player able to receive notifications
	waitthread WaitForPlayerDrop( player )

	// this can't handle dropships
	//player.WaitSignal( "PlayerDroppodImpact" )
	NSSendInfoMessageToPlayer( player, notification )
}

void function WaitForPlayerDrop( entity player )
{
	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )

	// first time respawn? wait for player take hold and screen fade from black
	if ( player.s.respawnCount == 1 )
		wait 1
	else
		WaitFrame() // wait this frame before player actually being set parented
	
	while( IsValid( player.GetParent() ) ) // spawning from dropship or droppod
		WaitFrame()
	
	while ( GetGameState() <= eGameState.Prematch ) // prematch will prevent notifications from showing up, and prevents player from moving
		WaitFrame()
}

void function CreateIMCGruntHelmetForPlayer( entity player )
{
	if ( player.LookupAttachment( "HEADSHOT" ) < 0 ) // invalid attachment?
		return
	// if human, remove helmet bodygroup
	if ( !player.IsMechanical() )
		player.SetBodygroup( player.FindBodyGroup( "head" ), 1 )
	entity helmet = CreatePropDynamic( $"models/humans/grunts/imc_grunt_lmg_helmet.mdl" )
	helmet.SetParent( player, "HEADSHOT" )
	helmet.Highlight_SetInheritHighlight( true ) // setup highlight
	//DeathPackage_RemoveEntityHeadshotFXOverride( player ) // remove headshotFX override. we always play helmet drop fx on death
	DeathPackage_SetEntityHeadshotFXOverride( player, $"P_headshot_pilot" )
	thread TrackHelmetLifeTime( player, helmet )
}

void function TrackHelmetLifeTime( entity player, entity helmet )
{
	helmet.EndSignal( "OnDestroy" )
	//table result = WaitSignal( player, "OnDeath", "OnDestroy", "PlayerEmbarkedTitan" )
	table result = WaitSignal( player, "OnDeath", "OnDestroy" )
	if ( result.signal == "OnDeath" )
		PlayHelmetDropFX( player )
	helmet.Destroy()
}

void function PlayHelmetDropFX( entity player )
{
	asset headshotFX = $"P_headshot_human"
	int tagID = player.LookupAttachment( "HEADSHOT" )
	vector fxOrg = player.GetAttachmentOrigin( tagID )
	vector fxAng = player.GetAttachmentAngles( tagID )
	PlayFX( headshotFX, fxOrg, fxAng, null )
}

void function CreateMechanicalHeadForPlayer( entity player )
{
	if ( player.LookupAttachment( "HEADSHOT" ) < 0 ) // invalid attachment?
		return
	// if mechanical, remove head bodygroup
	if ( player.IsMechanical() )
	{
		// get the proper head bodygroup
		int bodyGroupIndex = player.FindBodyGroup( "head" )
		if ( bodyGroupIndex == -1 )
			bodyGroupIndex = player.FindBodyGroup( "removableHead" )

		player.SetBodygroup( bodyGroupIndex, 1 )
	}

	entity head = CreatePropDynamic( $"models/humans/pilots/pilot_light_ged_m_head_gib.mdl" )
	head.SetParent( player, "HEADSHOT" )
	head.Highlight_SetInheritHighlight( true ) // setup highlight
	head.SetOrigin( < 0, 0, -6 > ) // tweak on position. should be lower because models other than phase shift pilot don't have a scaf for covering non-linking head
	// EDIT: we need to change headshot effect otherwise player will drop an extra head on being executed
	//DeathPackage_RemoveEntityHeadshotFXOverride( player ) // remove headshotFX override, we drop the head on getting headshot at
	DeathPackage_SetEntityHeadshotFXOverride( player, $"P_headshot_pilot" )

	thread TrackHeadLifeTime( player, head )
}

void function TrackHeadLifeTime( entity player, entity head )
{
	head.EndSignal( "OnDestroy" )
	//table result = WaitSignal( player, "OnDeath", "OnDestroy", "PlayerEmbarkedTitan" )
	table result = WaitSignal( player, "OnDeath", "OnDestroy" )
	if ( result.signal == "OnDeath" )
		PlayMechanicalHeadRemoveFX( player )
	head.Destroy()
}

void function PlayMechanicalHeadRemoveFX( entity player )
{
	// don't drop the head two times, just use a explosiopn fx
	// due we want to fix executions, always drop head now
	//asset headBrokeFX = $"xo_damage_exp_1"
	asset headBrokeFX = $"P_headshot_pilot_robot"
	int tagID = player.LookupAttachment( "HEADSHOT" )
	vector fxOrg = player.GetAttachmentOrigin( tagID )
	vector fxAng = player.GetAttachmentAngles( tagID )
	entity fx = PlayFX( headBrokeFX, fxOrg, fxAng, null )
	// no need to fast stop head drop effect
	//thread FastStopFX( fx, 0.5 )
}

void function FastStopFX( entity fx, float delay )
{
	wait delay
	if ( IsValid( fx ) )
		EffectStop( fx )
}

void function ApplyMLTGruntCamo( entity player )
{
	// mlt specific pov camo
	if ( player.GetTeam() == TEAM_MILITIA )
	{
		player.SetSkin( 1 )
		player.SetCamo( 1 ) // maybe more like mlt grunts
	}
}

///////////////////////////////////////
///// CLASS UTILITY FUNCTIONS END /////
///////////////////////////////////////