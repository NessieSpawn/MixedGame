untyped
global function Modded_Gamemode_GruntMode_Init

// npc counts default value
// can be modified by playlistvar
const int SQUADS_PER_TEAM = 5
//const int SQUADS_PER_TEAM_MORE_PLAYERS = 3 // maybe do reduced squad if we have more players and reached higher level
const int SQUADS_PER_TEAM_HIGH_LEVEL = 3 // maybe do reduced squad if we have reached higher level

const int MARVINS_PER_TEAM = 0
const int PROWLERS_PER_TEAM = 3
const int PROWLER_SQUADS_PER_TEAM = 0 // prowler squad: 2 cqb prowler with 3 small prowlers

const int REAPERS_PER_TEAM = 3 
const int GUNSHIPS_PER_TEAM = 0

const int PILOTS_PER_TEAM = 4
const int TITANS_PER_TEAM = 0

const float WEAPON_PACKAGE_INTERVAL = 55.0 // time for each weapon care package( gruntmode_weapon_carepackage 1 )
const float AMMO_PACKAGE_INTERVAL = 35.0 // time for each ammo care package

// escalator default value
// can be modified by playlistvar
const int LEVEL_SPECTRES = 150
const int LEVEL_STALKERS = 380
const int LEVEL_REAPERS = 600
//const int LEVEL_GUNSHIPS = 200 // has been merged to reaper spawns
const int LEVEL_TITANS = 0

// RNG default value
// can be modified by playlistvar
const float RARE_SPECIALIST_GRUNT_PICK_CHANCE = 0.15 // 15% chance of spawning a rare specialist grunt
const float BOSS_TITAN_REPLACE_CHANCE = 0.2 // was 0.25. scale down because boss titans are more powerful now

// scores
const int PLAYER_SCORE_AMOUNT = 3
const int PLAYER_SPECIALIST_SCORE_AMOUNT = 5
const int PILOT_SCORE_AMOUNT = 5
const int GUNSHIP_SCORE_AMOUNT = 5
const int MARVIN_SCORE_AMOUNT = 1
const int GRUNT_SCORE_AMOUNT = 1
const int SPECIALIST_GRUNT_SCORE_AMOUNT = 2
const int SPECTRE_SCORE_AMOUNT = 1 // was 2. spectres shouldn't have too many score
const int STALKER_SCORE_AMOUNT = 2
const int PROWLER_SCORE_AMOUNT = 2
const int SMALL_PROWLER_SCORE_AMOUNT = 1
const int REAPER_SCORE_AMOUNT = 5
const int DRONE_SCORE_AMOUNT = 0
const int TITAN_SCORE_AMOUNT = 10

// no need to hardcode playlist for now, navmeshes works really nice
// but there are some map not included in vanilla playlist...
const array<string> GRUNT_MODE_PLAYLIST =
[
	"mp_forwardbase_kodai",
	"mp_black_water_canal",
	"mp_thaw",
	"mp_glitch",
    "mp_colony02",
	"mp_angel_city",
    "mp_wargames",
    "mp_eden",
    "mp_drydock",
    "mp_grave",
    "mp_homestead",
    "mp_rise",
	"mp_relic02",
    "mp_complex3",
    "mp_crashsite3", // have really bad navmesh, removed
]

// struct used by function Escalate()
struct AITdmEscalatorstruct
{
	int scoreRequired
	void functionref( int team ) spawnSettingsFunc
	array<int> usedByTeams
}

struct
{
	// Due to team based escalation everything is an array

	// reworked to use structs
	//array< int > levels = [] //[ LEVEL_SPECTRES, LEVEL_SPECTRES ] // modified, since we added playlistvar should leave this init inside functions
	array<AITdmEscalatorstruct> levelEscalators

	// spawn contents
	array< array< string > > podEntities = [ [ "npc_soldier" ], [ "npc_soldier" ] ] // also handling spectres and stalkers
	
	array< bool > marvins = [ false, false ] // bind with spectres

	array< bool > prowlers = [ false, false ] // bind with stalkers

	array< bool > reapers = [ false, false ]
	array< bool > gunships = [ false, false ] // bind with reapers

	array< bool > titans = [ false, false ]
	array< bool > pilots = [ false, false ] // bind with titans


	// spawn settings
	int squadCount
	int squadCountHighLevel
	int prowlerCount
	int reaperCount
	int gunshipCount
	int pilotCount
	// escalator settings
	int levelSpectres
	int levelStalkers
	int levelReapers
	int levelTitans

	// in-file variables
	// for cleaning up idle npcs
	table<entity, bool> npcWaitingToBeCleanUp
	table<entity, float> npcCleanUpStartTime
	table<entity, float> npcIdleStartTime
	table<entity, vector> npcLastTickOrigin
} file


void function Modded_Gamemode_GruntMode_Init()
{
	BecomesGruntMode_Init() // init everything

	// this is incorrect. gamemode_tdm spawns are for AITdm
	//SetSpawnpointGamemodeOverride( ATTRITION ) // use bounty hunt spawns as vanilla game has no spawns explicitly defined for aitdm
	SetSpawnpointGamemodeOverride( TEAM_DEATHMATCH )

	AddCallback_GameStateEnter( eGameState.Prematch, OnPrematchStart )
	AddCallback_GameStateEnter( eGameState.Playing, OnPlaying )
	AddCallback_GameStateEnter( eGameState.Postmatch, OnGamePostmatch )

	// scoring
	ScoreEvent_Disable( GetScoreEvent( "KillPilot" ) ) // disable pilot killed event, we use grunt and spectre ones
	// no need to setup score for gruntmode
	//ScoreEvent_SetupEarnMeterValuesForMixedModes()
	AddCallback_OnPlayerKilled( HandleScoreForPlayerOrNPCKill )
	AddCallback_OnNPCKilled( HandleScoreForPlayerOrNPCKill )
	// modified callback in _score.nut: for handling doomed health loss titans
	AddCallback_TitanDoomedScoreEvent( HandleTitanDoomedScore )

	AddCallback_OnClientConnected( OnPlayerConnected )

	SetShouldPlayDefaultMusic( true ) // play music when score or time reaches some point

	ClassicMP_ForceDisableEpilogue( true )
	Riff_ForceBoostAvailability( eBoostAvailability.Disabled )
	Riff_ForceTitanAvailability( eTitanAvailability.Never )

	// so you're likely no need to wait so freaking long, !!! tempfix specific
	SetWaitingForPlayersMaxDuration( 1.0 )
    ClassicMP_SetCustomIntro( ClassicMP_GruntModeIntro_Setup, GRUNTMODE_INTRO_LENGTH )


	// init npc spawn settings
	InitModdedSpawnSettings()
}

void function InitModdedSpawnSettings()
{
	// update settings from playlistvar, with default values implemented
	file.squadCount = GetCurrentPlaylistVarInt( "modaitdm_squad_count", SQUADS_PER_TEAM )
	file.squadCountHighLevel = GetCurrentPlaylistVarInt( "modaitdm_squad_count", SQUADS_PER_TEAM_HIGH_LEVEL )
	file.prowlerCount = GetCurrentPlaylistVarInt( "modaitdm_prowler_count", PROWLERS_PER_TEAM )
	file.reaperCount = GetCurrentPlaylistVarInt( "modaitdm_reaper_count", REAPERS_PER_TEAM )
	file.gunshipCount = GetCurrentPlaylistVarInt( "modaitdm_gunship_count", GUNSHIPS_PER_TEAM )
	file.pilotCount = GetCurrentPlaylistVarInt( "modaitdm_pilot_count", PILOTS_PER_TEAM )

	file.levelSpectres = GetCurrentPlaylistVarInt( "modaitdm_spectre_spawn_score", LEVEL_SPECTRES )
	file.levelStalkers = GetCurrentPlaylistVarInt( "modaitdm_stalker_spawn_score", LEVEL_STALKERS )
	file.levelReapers = GetCurrentPlaylistVarInt( "modaitdm_reaper_spawn_score", LEVEL_REAPERS )
	file.levelTitans = GetCurrentPlaylistVarInt( "modaitdm_titan_spawn_score", LEVEL_TITANS )
	// reworked to use Escalator_Init()
	//file.levels = [ file.levelSpectres, file.levelSpectres ] // init levels

	// all values init done, start init escatator
	Escalator_Init()
}

// init the structs used in function Escalate()
void function Escalator_Init()
{
	// spectres and marvins
	AITdmEscalatorstruct spectreSpawn
	spectreSpawn.scoreRequired = file.levelSpectres
	spectreSpawn.spawnSettingsFunc = SpawnLevel_Spectre
	file.levelEscalators.append( spectreSpawn )

	// stalkers and prowlers
	AITdmEscalatorstruct stalkerSpawn
	stalkerSpawn.scoreRequired = file.levelStalkers
	stalkerSpawn.spawnSettingsFunc = SpawnLevel_Stalker
	file.levelEscalators.append( stalkerSpawn )

	// reapers and gunships
	AITdmEscalatorstruct reaperSpawn
	reaperSpawn.scoreRequired = file.levelReapers
	reaperSpawn.spawnSettingsFunc = SpawnLevel_Reaper
	file.levelEscalators.append( reaperSpawn )

	// titans and pilots
	AITdmEscalatorstruct titanSpawn
	titanSpawn.scoreRequired = file.levelTitans
	titanSpawn.spawnSettingsFunc = SpawnLevel_Titan
	file.levelEscalators.append( titanSpawn )
}

void function SpawnLevel_Spectre( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	//print( "SpawnLevel_Spectre(), team: " + string( team ) )

	// level spawn content
	file.podEntities[ index ].append( "npc_spectre" ) // add spectres into droppod and dropship
	file.marvins[ index ] = true // enable marvin spawn
	SetGlobalNetInt( defcon, 2 ) // Enemy Spectres Incoming
}

void function SpawnLevel_Stalker( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	//print( "SpawnLevel_Stalker(), team: " + string( team ) )

	// level spawn content
	//file.marvins[ index ] = false // never remove marvin spawns ;)
	file.podEntities[ index ].append( "npc_stalker" ) // add stalkers into droppod and dropship
	file.prowlers[ index ] = true // enable prowler spawn
	SetGlobalNetInt( defcon, 3 ) // Enemy Stalkers Incoming
}

void function SpawnLevel_Reaper( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	//print( "SpawnLevel_Reaper(), team: " + string( team ) )

	// level spawn content
	file.reapers[ index ] = true // enable reaper spawn
	file.gunships[ index ] = true // enable gunship spawn
	SetGlobalNetInt( defcon, 4 ) // Enemy Reapers Incoming

	// start cleanup ticks spawned by reapers( might also clean up specialist grunt ticks )
	CleanUpOverloadedTicks()
}

void function SpawnLevel_Titan( int team )
{
	int index = team == TEAM_MILITIA ? 1 : 0
	// This does the "Enemy x incoming" text
	string defcon = team == TEAM_MILITIA ? "IMCdefcon" : "MILdefcon"

	//print( "SpawnLevel_Titan(), team: " + string( team ) )

	// level spawn content
	file.titans[ index ] = true // enable titan spawn
	file.pilots[ index ] = true // enable npc pilot spawn
	SetGlobalNetInt( defcon, 6 ) // this will show nothing
}
//

//------------------------------------------------------

void function OnPrematchStart()
{
	// don't run spawning code if ains and nms aren't up to date
	if ( GetAINScriptVersion() == AIN_REV && GetNodeCount() != 0 )
	{
		thread SpawnIntroBatch( TEAM_IMC )
		thread SpawnIntroBatch( TEAM_MILITIA )
	}

	// Starts skyshow, this also requiers AINs but doesn't crash if they're missing
	if ( !Flag( "LevelHasRoof" ) )
		thread StratonHornetDogfightsIntense()
}

void function OnPlaying()
{
	// care package variant
	if ( GetCurrentPlaylistVarInt( "gruntmode_weapon_carepackage", 0 ) != 0 )
	{
		thread SpawnerWeapons( TEAM_IMC )
		thread SpawnerWeapons( TEAM_MILITIA )
	}
	else
	{
		thread SpawnerAmmoRefill( TEAM_IMC )
		thread SpawnerAmmoRefill( TEAM_MILITIA )
	}
	
	// cleaning up
	TryCleanupBoredNPCGameLong()
}

void function OnGamePostmatch()
{
	// no need to hardcode playlist for now, navmeshes works really nice
	// but there are some map not included in vanilla playlist...
	if ( GetCurrentPlaylistVarInt( "gruntmode_auto_map", 0 ) != 0 )
	{
		thread AfterDelayChangeMap()
	}
}

void function AfterDelayChangeMap()
{
	wait 6.5 // GAME_POSTMATCH_LENGTH is 7.0

	array<string> curPlayList = GRUNT_MODE_PLAYLIST
	int mapIndex = curPlayList.find( GetMapName() )
	mapIndex += 1 // next map index
	if( mapIndex == curPlayList.len() ) // reached last map?
		mapIndex = 0
	string nextMap = curPlayList[mapIndex]

	//ServerCommand( "map " + nextMap )
	GameRules_ChangeMap( nextMap, GAMETYPE )
}

void function OnPlayerConnected( entity player )
{
	Remote_CallFunction_NonReplay( player, "ServerCallback_AITDM_OnPlayerConnected" )
	Chat_ServerPrivateMessage( player, "每次以随机的兵种重生\n娱乐性质服务器，请多多包容其余玩家\n由于npc数目过多，卡顿属正常现象", false, false )
}

//------------------------------------------------------

int function GruntMode_GetScoreValue( entity ent, bool isDoomedShot = false )
{
	int scoreToAdd = 0

	if ( ent.IsPlayer() )
	{
		if ( GruntMode_IsSpecialistClass( ent ) )
			scoreToAdd = PLAYER_SPECIALIST_SCORE_AMOUNT
		else
			scoreToAdd = PLAYER_SCORE_AMOUNT
	}
	
	string className = ent.GetClassName()
	// class name override here: embarked npc titan
	if ( ent.IsTitan() && TitanHasNpcPilot( ent ) )
		className = GetTitanEmbarkedNpcClassName( ent )

	if ( className == "npc_pilot_elite" )
		scoreToAdd = PILOT_SCORE_AMOUNT
	
	if ( className == "npc_gunship" )
		scoreToAdd = GUNSHIP_SCORE_AMOUNT
	
	if ( className == "npc_marvin" )
		scoreToAdd = MARVIN_SCORE_AMOUNT

	if ( className == "npc_prowler" )
	{
		// hardcoded here: if it's a small prowler we add less score
		if ( float( ent.kv.modelscale ) < 1.0 )
			scoreToAdd = SMALL_PROWLER_SCORE_AMOUNT
		else
			scoreToAdd = PROWLER_SCORE_AMOUNT
	}

	if ( className == "npc_spectre" )
		scoreToAdd = SPECTRE_SCORE_AMOUNT

	if ( className == "npc_stalker" )
		scoreToAdd = STALKER_SCORE_AMOUNT

	if ( className == "npc_super_spectre" )
		scoreToAdd = REAPER_SCORE_AMOUNT

	if ( className == "npc_soldier" )
	{
		if ( GRUNTMODE_SPECIALIST_GRUNTS.contains( ent.GetAISettingsName() ) )
			scoreToAdd = SPECIALIST_GRUNT_SCORE_AMOUNT
		else
			scoreToAdd = GRUNT_SCORE_AMOUNT
	}
	
	if ( className == "npc_drone" )
		scoreToAdd = DRONE_SCORE_AMOUNT

	if ( ent.IsTitan() )
	{
		if ( TitanHasNpcPilot( ent ) && !isDoomedShot ) // pilot was killed without ejecting
			scoreToAdd += TITAN_SCORE_AMOUNT // base score add an extra titan score
		//else if ( ent.IsPlayer() ) // fix for player score!
		//	scoreToAdd = TITAN_SCORE_AMOUNT + PLAYER_SCORE_AMOUNT
		else // ejecting auto titan
			scoreToAdd = TITAN_SCORE_AMOUNT

		// modified function in _titan_health.gnut, recovering ttf1 behavior: we add score on doom but not on death for health loss titans
		bool removeTitanScore = !TitanHealth_GetSoulInfiniteDoomedState( ent.GetTitanSoul() )
		if ( isDoomedShot ) // doomed shot: reversed check. we don't add score on infinite doom titans
			removeTitanScore = TitanHealth_GetSoulInfiniteDoomedState( ent.GetTitanSoul() )
		if ( removeTitanScore )
			scoreToAdd -= TITAN_SCORE_AMOUNT // remove titan score on kill for doomed health loss titans
	}

	return scoreToAdd
}

void function HandleScoreForPlayerOrNPCKill( entity victim, entity attacker, var damageInfo )
{
	// if victim is a non-titan npc that owned by players, don't add score
	// currently this function is a stub
	if ( !VictimIsValidForAITdmScore( victim ) )
		return
	
	if ( !AttackerIsValidForAITdmScore( victim, attacker, damageInfo ) )
	{
		// attacker maybe invalid, but we still needs to add some score
		// welp... this should never gets hit because PlayerOrNPCKilled() won't do callbacks if attacker invalid
		if ( !IsValid( attacker ) && GamePlayingOrSuddenDeath() )
		{
			int scoreToAdd = GruntMode_GetScoreValue( victim )
			if ( scoreToAdd > 0 )
				AddTeamScore( GetOtherTeam( victim.GetTeam() ), scoreToAdd )
		}
		return
	}

	// if it's a npc with bossplayer...
	// mostly never gets hit because it's already handled by PlayerOrNPCKilled() in _base_gametype.gnut
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		attacker = GetAITdmAttackOwner( attacker )
	}

	// start adding score
	int scoreToAdd = GruntMode_GetScoreValue( victim )
	if ( scoreToAdd > 0 )
		AddAITdmTeamScore( attacker, scoreToAdd ) // this can handle both players' and npcs' kills

	// some score event for player killing each other
	if ( attacker.IsPlayer() && victim.IsPlayer() )
	{
		string scoreEvent = "KillGrunt"
		if ( victim.IsMechanical() )
			scoreEvent = "KillSpectre"
		// no need to set any other param because this gamemode don't really have earnmeter system
		AddPlayerScore( attacker, scoreEvent, victim )
	}
}

bool function AttackerIsValidForAITdmScore( entity victim, entity attacker, var damageInfo )
{
	// shouldn't be able to add score during other state after game logic fix.. just handle here
	if ( !GamePlayingOrSuddenDeath() )
		return false
	
	if( !IsValid( attacker ) )
		return false
	
	// Team filter -- don't want Friendly Fire able to influence score
	// make it a setting
	if ( victim.GetTeam() == attacker.GetTeam() && !FriendlyFire_ShouldAddScoreOnFriendlyKill() )
		return false

	if( !attacker.IsNPC() && !attacker.IsPlayer() ) // not killed by any combat character
		return false

	if ( attacker == victim ) // suicide!
		return false

	// player owned npcs filter
	// owner should be related with visibility stuffs( like synced melee ), not adding to this check
	//if ( victim.GetOwner() == attacker || victim.GetBossPlayer() == attacker )
	if ( victim.GetBossPlayer() == attacker )
		return false

	// all checks passed
	return true
}

bool function VictimIsValidForAITdmScore( entity victim )
{
	// if victim is a non-titan npc that owned by players, don't add score
	// vanilla doesn't seem to have this check, they have npc hacked mark
	// in this gamemode beast king can use prowlers for attacking, but those prowlers are pretty powerful so I think maybe good to add score to players?
	/*
	if ( victim.IsNPC() && !victim.IsTitan() )
	{
		entity bossPlayer = victim.GetBossPlayer()
		entity owner = victim.GetOwner()
		if ( IsValid( bossPlayer ) )
		{
			if ( bossPlayer.IsPlayer() )
				return false
		}
		if ( IsValid( owner ) )
		{
			if ( owner.IsPlayer() )
				return false
		}
	}
	*/

	// all checks passed
	return true
}

entity function GetAITdmAttackOwner( entity ent )
{
	entity attacker
	if ( ent.IsPlayer() ) // player always use themselves as attacker
		return ent
	if ( IsValid( ent.GetBossPlayer() ) )
		attacker = ent.GetBossPlayer()
	// owner is for visibility stuffs, never check it
	//if ( IsValid( ent.GetOwner() ) )
	//	attacker = ent.GetOwner()
	// attacker still not valid?
	if ( !IsValid( attacker ) )
		return ent // use npc or something itself
	
	return attacker
}

void function AddAITdmTeamScore( entity ent, int score )
{
	// Add score + update network int to trigger the "Score +n" popup
	AddTeamScore( ent.GetTeam(), score )
	if ( ent.IsPlayer() )
	{
		ent.AddToPlayerGameStat( PGS_ASSAULT_SCORE, score )
		AITdm_SetPlayerBonusPoints( ent, ent.GetPlayerGameStat( PGS_ASSAULT_SCORE ) )
	}
}

// networkvar updates
void function AITdm_AddPlayerBonusPoints( entity player, int amount )
{
	AITdm_SetPlayerBonusPoints( player, AITdm_GetPlayerBonusPoints( player ) + amount )
}

int function AITdm_GetPlayerBonusPoints( entity player )
{
	return player.GetPlayerNetInt( "AT_bonusPoints" ) + ( player.GetPlayerNetInt( "AT_bonusPoints256" ) * 256 )
}

void function AITdm_SetPlayerBonusPoints( entity player, int amount )
{
	// split into stacks of 256 where necessary
	int stacks = amount / 256 // automatically rounds down because int division

	player.SetPlayerNetInt( "AT_bonusPoints256", stacks )
	player.SetPlayerNetInt( "AT_bonusPoints", amount - stacks * 256 )
}

// earn points, seems not used
void function AITdm_AddPlayerEarnedPoints( entity player, int amount )
{
	AITdm_SetPlayerEarnedPoints( player, AITdm_GetPlayerEarnedPoints( player ) + amount )
}

int function AITdm_GetPlayerEarnedPoints( entity player )
{
	return player.GetPlayerNetInt( "AT_earnedPoints" ) + ( player.GetPlayerNetInt( "AT_earnedPoints256" ) * 256 )
}

void function AITdm_SetPlayerEarnedPoints( entity player, int amount )
{
	// split into stacks of 256 where necessary
	int stacks = amount / 256 // automatically rounds down because int division

	player.SetPlayerNetInt( "AT_earnedPoints256", stacks )
	player.SetPlayerNetInt( "AT_earnedPoints", amount - stacks * 256 )
}

// for handling doomed health loss titans
void function HandleTitanDoomedScore( entity victim, var damageInfo, bool firstDoom )
{
	// if victim is a non-titan npc that owned by players, don't add score
	if ( !VictimIsValidForAITdmScore( victim ) )
		return
	
	if ( !firstDoom ) // only add score on first doom
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !AttackerIsValidForAITdmScore( victim, attacker, damageInfo ) )
	{
		// attacker maybe invalid, but we still needs to add some score
		// welp... this should never gets hit because PlayerOrNPCKilled() won't do callbacks if attacker invalid
		if ( !IsValid( attacker ) && GamePlayingOrSuddenDeath() )
		{
			int scoreToAdd = GruntMode_GetScoreValue( victim, true )
			if ( scoreToAdd > 0 )
				AddTeamScore( GetOtherTeam( victim.GetTeam() ), scoreToAdd )
		}
		return
	}

	// if it's a npc with bossplayer...
	// mostly never gets hit because it's already handled by PlayerOrNPCKilled() in _base_gametype.gnut
	if ( attacker.IsNPC() )
	{
		// reassign attacker
		attacker = GetAITdmAttackOwner( attacker )
	}

	int scoreToAdd = GruntMode_GetScoreValue( victim, true )
	if ( scoreToAdd > 0 )
		AddAITdmTeamScore( attacker, TITAN_SCORE_AMOUNT )
}

//------------------------------------------------------

// CHECK FUNCTIONS

bool function ShouldSpawnSpecialistSquad( string otherSpawnWith = "" )
{
	// never spawn specialist grunt with stalkers
	// stalkers are slow and they've already got pretty high health and damage
	if ( otherSpawnWith == "npc_stalker" )
		return false
	// removed. to make game more chaotic, always spawn specialist squad
	//return RandomInt( 3 ) > 0 // 66% chance of spawning a specialist squad(??
	return true
}

bool function ShouldSpawnDropship( string entToSpawn = "" )
{
	// vanilla flag
	if ( Flag( "DisableDropships" ) )
		return false

	// stalkers can do traverse now, add dropship will be pretty cool( though their animation wasn't very nice and will do spew error on landing )
	//if ( entToSpawn == "npc_stalker" ) // stalkers has been reworked and never spawn from dropship
	//	return false
	
	array<entity> points = GetZiplineDropshipSpawns()
	if ( points.len() <= 4 ) // must have more than 4 points
		return false

	// reduced chance down to 20% because dropship spawn makes npcs spread out and can sometimes fail to spawn
	// maybe it's good to add higher chance of dropship spawn after navmesh supports traverse nodes
	// navmesh traverse nodes are implemented, and we're always allowing npc to use dropship( quick edit: welp eDropStyle.FORCED won't help us spawn npcs )
	// gets spreaded makes them harder to be mayhemed which is good, increasing chance to 35%
	// welp I can't make npc dropship always success for now...
	//return RandomInt( 3 ) == 0 // 33% chance of choose to spawn a dropship
	return RandomInt( 100 ) < 20
	//return RandomInt( 100 ) < 35
}

// hardcoded here
const array<string> GRUNTMODE_SPECIALIST_GRUNTS =
[
	"npc_soldier_shield_captain",
	"npc_soldier_drone_summoner",
	"npc_soldier_sidearm",
	"npc_soldier_pve_eliteguard",
	"npc_soldier_training_sentry",
]

const array<string> GRUNTMODE_SPECIALIST_GRUNTS_RARE = // specialist class in this array will have less picking rate
[
	"npc_soldier_shield_captain",
	"npc_soldier_training_sentry",
]

string function GetGruntModeSpecialistGruntLeader()
{
	bool spawnRareSpecialist = RandomInt( 100 ) < int( GetCurrentPlaylistVarFloat( "modaitdm_rare_specialist_chance", RARE_SPECIALIST_GRUNT_PICK_CHANCE ) * 100 )
	string leaderSet = "npc_soldier_drone_summoner"
	if ( spawnRareSpecialist )
	{
		//print( "spawning from rare specialist list!" )
		leaderSet = GRUNTMODE_SPECIALIST_GRUNTS_RARE[ RandomInt( GRUNTMODE_SPECIALIST_GRUNTS_RARE.len() ) ]
	}
	else
	{
		//print( "spawning from generic specialist list!" )
		array<string> genericSpecialist
		foreach ( aiSet in GRUNTMODE_SPECIALIST_GRUNTS )
		{
			if ( !GRUNTMODE_SPECIALIST_GRUNTS_RARE.contains( aiSet ) )
			{
				//print( "generic specialist contains: " + aiSet )
				genericSpecialist.append( aiSet )
			}
		}
		leaderSet = genericSpecialist[ RandomInt( genericSpecialist.len() ) ]
	}

	//print( "leaderAiSet: " + leaderSet )

	return leaderSet
}

// reworked here: we scale up health depending on current spawn level, not depend on the ones they spawn with
//int function GetSpecialistLeaderHealth( int team, string otherSpawnWith )
int function GetSpecialistLeaderHealth( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1
	// reworked here: we scale up health depending on current spawn level, not depend on the ones they spawn with
	//return 200 + ( 60 * file.podEntities[ index ].find( otherSpawnWith ) )
	return 200 + ( 60 * ( file.podEntities[ index ].len() - 1 ) )
}

bool function ShouldSpawnBossTitan()
{
	// now reduce chance down to 30% because we've given bosses more powerful execution
	// and allow it to be modified by playlistvar
	//return RandomInt( 2 ) == 0 // boss titans has 50% chance to spawn( was 20%, but we've added many new bosses... )
	return RandomInt( 100 ) < int( GetCurrentPlaylistVarFloat( "modaitdm_boss_replace_chance", BOSS_TITAN_REPLACE_CHANCE ) * 100 )
}

string function GetBossTitanSpawnName()
{
	const array<int> validBossSpawnTeams = [TEAM_IMC, TEAM_MILITIA]
	int team = validBossSpawnTeams[ RandomInt( validBossSpawnTeams.len() ) ]

	// team specific
	if ( team == TEAM_IMC )
	{
		const array<string> imcBossList =
		[
			"blisk",
			"kane",
			"ash",
			"richter",
			"viper",
			"slone",
		]
		return imcBossList[ RandomInt( imcBossList.len() ) ]
	}
	else if ( team == TEAM_MILITIA )
	{
		// add static chance of picking vanguard because they have various of weapons
		if ( RandomInt( 100 ) < 40 ) // 40% chance of spawning
			return "vanguard"
		
		const array<string> mltBossList =
		[
			"jack",
			"sarah",
			//"sarah_monarch",
			"gates",
			//"bear",
			"lastimosa",
			"anderson",
		]
		return mltBossList[ RandomInt( mltBossList.len() ) ]
	}

	// default case
	return "" // empty string means random
}

bool function ReachedPlayerCheckAmount()
{
	int maxPlayers = GetCurrentPlaylistVarInt( "max_players", 16 )
	if ( float ( GetPlayerArray().len() ) >= float ( maxPlayers ) * 0.6 )
		return true
	return false
}

//


void function SpawnIntroBatch( int team )
{
	//array<entity> dropPodNodes = GetDroppodStartPoints()
	array<entity> dropPodNodes = SpawnPoints_GetDropPodStart( team )
	array<entity> dropShipNodes = GetValidIntroDropShipSpawn( dropPodNodes )  
	// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
	ValidateNPCSpawnpoints( dropPodNodes, "npc_soldier" )
	ValidateNPCSpawnpoints( dropShipNodes, "npc_soldier" )

	array<entity> podNodes
	array<entity> shipNodes
	
	// mp_rise has weird droppod_start nodes, this gets around it
	// To be more specific the teams aren't setup and some nodes are scattered in narnia
	if( GetMapName() == "mp_rise" )
	{
		entity spawnPoint
		
		// Get a spawnpoint for team
		foreach ( point in GetEntArrayByClass_Expensive( "info_spawnpoint_dropship_start" ) )
		{
			if ( point.HasKey( "gamemode_tdm" ) )
				if ( point.kv[ "gamemode_tdm" ] == "0" )
					continue
			
			if ( point.GetTeam() == team )
			{
				spawnPoint = point
				break
			}
		}
		
		// Get nodes close enough to team spawnpoint
		foreach ( node in dropPodNodes )
		{
			if ( node.HasKey("teamnum") && Distance2D( node.GetOrigin(), spawnPoint.GetOrigin()) < 2000 )
				podNodes.append( node )
		}
	}
	else
	{
		// Sort per team
		foreach ( node in dropPodNodes )
		{
			if ( node.GetTeam() == team )
				podNodes.append( node )
		}
	}

	shipNodes = GetValidIntroDropShipSpawn( podNodes )

	// calculate intro spawn delay
	float introLength = ClassicMP_GetIntroLength()
	float introSpawnRequiredTime = expect float( GetDropPodAnimDuration() )

	float introSpawnWait = introLength - introSpawnRequiredTime
	if ( introSpawnWait > 0 )
		wait introSpawnWait

	// Spawn logic
	int startIndex = 0
	entity node
	string introSpawnClass = "npc_soldier"
	
	int pods = RandomInt( podNodes.len() + 1 )
	
	int ships = shipNodes.len()
	bool spawnSucceeded = false

	array<int> usedPodNodeIndex
	array<int> usedShipNodeIndex

	for ( int i = 0; i < file.squadCount; i++ )
	{
		if ( ( pods != 0 || ships == 0 ) && podNodes.len() > 0 ) // defensive fix for podNodes can sometimes be 0
		{
			spawnSucceeded = true // mark as we've done intro spawn, we'll wait before game-loop-spawn
			if ( usedPodNodeIndex.len() > podNodes.len() - 1 ) // max nodes used!
				usedPodNodeIndex.clear() // reuse nodes

			// get a random unused node
			int index
			while ( usedPodNodeIndex.contains( index ) )
				index = RandomInt( podNodes.len() )

			node = podNodes[ index ]
			usedPodNodeIndex.append( index ) // mark as node used
			UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
			if ( ShouldSpawnSpecialistSquad( introSpawnClass ) )
			{
				array< entity > points = GetZiplineDropshipSpawns()
				string leaderSet = GetGruntModeSpecialistGruntLeader()
				//int leaderHealth = GetSpecialistLeaderHealth( team, introSpawnClass )
				int leaderHealth = GetSpecialistLeaderHealth( team )
				thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, leaderSet, leaderHealth )
			}
			else
				thread ExtraSpawner_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, introSpawnClass )

			pods--
		}
		else if ( shipNodes.len() > 0 ) // defensive fix for shipNodes can sometimes be 0
		{
			spawnSucceeded = true // mark as we've done intro spawn, we'll wait before game-loop-spawn
			if ( startIndex == 0 ) 
				startIndex = i // save where we started
			
			node = shipNodes[ i - startIndex ]
			UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
			if ( ShouldSpawnSpecialistSquad( introSpawnClass ) )
			{
				array< entity > points = GetZiplineDropshipSpawns()
				string leaderSet = GetGruntModeSpecialistGruntLeader()
				//int leaderHealth = GetSpecialistLeaderHealth( team, introSpawnClass )
				int leaderHealth = GetSpecialistLeaderHealth( team )
				thread ExtraSpawner_SpawnSpecialistGruntDropShip( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, 4, leaderSet, leaderHealth )
			}
			else
				thread ExtraSpawner_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, introSpawnClass, SQUAD_SIZE )
			
			ships--
		}
		
		// add a delay after half spawn
		if ( i == ( file.squadCount / 2 ) - 1 )
			wait 4 // ~droppod landing delay
	}

	// do wait before looping spawn starts if we did intro spawn
	if ( spawnSucceeded )
		wait 8.0
	
	// intro spawn finished
	thread SpawnEscalator( team ) // handles team Escalate()
	thread SpawnerSquads( team )
	thread SpawnerHeavyArmor( team )
	thread SpawnerNPCs( team )
}

// Populates the match
void function SpawnEscalator( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		Escalate( team )
	}
}

void function SpawnerSquads( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		// TODO: this should possibly not count scripted npc spawns, probably only the ones spawned by this script
		int infantryCount = 0
		foreach ( entity npc in GetNPCArrayOfTeam( team ) )
		{
			if ( IsHumanSized( npc ) && !IsValid( npc.GetBossPlayer() ) )
				infantryCount += 1
		}
		int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()

		// NORMAL SPAWNS
		int maxSquads = file.squadCount
		//if ( ReachedPlayerCheckAmount() && file.reapers[ index ] ) // if we have pretty much players and reached reaper level
		//	maxSquads = SQUADS_PER_TEAM_MORE_PLAYERS // do reduced minions count
		if ( file.reapers[ index ] )
			maxSquads = file.squadCountHighLevel
		
		int squadsToSpawn = ( maxSquads * SQUAD_SIZE - 2 - infantryCount ) / SQUAD_SIZE
		if ( squadsToSpawn > 0 )
		{
			for ( int i = 0; i < squadsToSpawn; i++ )
			{
				if ( i > 0 )
					wait 2.0 // delay before next spawn
				
				array<entity> dropshipPoints = GetZiplineDropshipSpawns()
				array<entity> droppodPoints = SpawnPoints_GetDropPod()
				// add startpoints for fun!
				dropshipPoints.extend( GetValidIntroDropShipSpawn( GetDroppodStartPoints() ) )
				droppodPoints.extend( GetDroppodStartPoints() )
				string ent = file.podEntities[ index ][ RandomInt( file.podEntities[ index ].len() ) ]
				// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
				ValidateNPCSpawnpoints( dropshipPoints, ent )
				ValidateNPCSpawnpoints( droppodPoints, ent )

				if ( ShouldSpawnSpecialistSquad( ent ) )
				{
					string leaderSet = GetGruntModeSpecialistGruntLeader()
					// add health depending on what npc it spawning with
					//int leaderHealth = GetSpecialistLeaderHealth( team, ent )
					// add health depending on current team's spawn level
					int leaderHealth = GetSpecialistLeaderHealth( team )
					//print( "RUNNING ExtraSpawner_SpawnSpecialistGruntDropPod()" )
					//print( "leaderHealth is: " + string( leaderHealth ) )
					if ( ShouldSpawnDropship( ent ) )
					{
						entity node = FindBestSpawnForNPCDrop( dropshipPoints, team, 15 )
						UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
						thread ExtraSpawner_SpawnSpecialistGruntDropShip( node.GetOrigin(), node.GetAngles(), team, "npc_soldier", 4, leaderSet, leaderHealth )
						continue
					}
					
					entity node = FindBestSpawnForNPCDrop( droppodPoints, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					thread ExtraSpawner_SpawnSpecialistGruntDropPod( node.GetOrigin(), node.GetAngles(), team, ent, leaderSet, leaderHealth )
				}
				else
				{
					if ( ShouldSpawnDropship( ent ) )
					{
						entity node = FindBestSpawnForNPCDrop( dropshipPoints, team, 15 )
						UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
						// no longer uses playlist var because stalker explosions now has death protection, and their sustainbility have been nerfed by _becomesgrunt.gnut
						//if ( ent == "npc_stalker" && GetCurrentPlaylistVarInt( "gruntmode_overloaded_stalkers", 0 ) == 1 ) // more powerful stalker spawn
						if ( ent == "npc_stalker" )
							thread ExtraSpawner_SpawnOverloadedStalkerDropShip( node.GetOrigin(), node.GetAngles(), team, SQUAD_SIZE )
						else
							thread ExtraSpawner_SpawnDropShip( node.GetOrigin(), node.GetAngles(), team, ent, SQUAD_SIZE )
						continue
					}

					entity node = FindBestSpawnForNPCDrop( droppodPoints, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//if ( ent == "npc_stalker" && GetCurrentPlaylistVarInt( "gruntmode_overloaded_stalkers", 0 ) == 1 ) // more powerful stalker spawn
					if ( ent == "npc_stalker" )
						thread ExtraSpawner_SpawnOverloadedStalkerDropPod( node.GetOrigin(), node.GetAngles(), team )
					else
						thread ExtraSpawner_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, ent )
				}
			}

			wait 8.0 // wait after each spawn wave
		}

		// PROWLER SQUADS
		if ( file.prowlers[ index ] )
		{
			//print( "prowlerCount: " + string( prowlerCount ) )
			int squadsToSpawn = ( PROWLER_SQUADS_PER_TEAM * 4 - 2 - prowlerCount ) / 4
			if ( squadsToSpawn > 0 )
			{
				for ( int i = 0; i < squadsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetDropPod()
					points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_prowler" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//print( "RUNNING ExtraSpawner_SpawnProwlerSquadDropPod()" )
					thread ExtraSpawner_SpawnProwlerSquadDropPod( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerHeavyArmor( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		int reaperCount = GetNPCArrayEx( "npc_super_spectre", team, -1, <0,0,0>, -1 ).len()
		int gunshipCount = GetNPCArrayEx( "npc_gunship", team, -1, <0,0,0>, -1 ).len()
		int titanCount = 0
		foreach ( entity npc in GetNPCArrayEx( "npc_titan", team, -1, <0,0,0>, -1 ) )
		{
			if ( !IsValid( npc.GetBossPlayer() ) )
				titanCount += 1
		}

		// REAPERS
		if ( file.reapers[ index ] )
		{
			int reapersToSpawn = file.reaperCount - reaperCount
			if ( reapersToSpawn > 0 )
			{
				for ( int i = 0; i < reapersToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn

					array<entity> points = SpawnPoints_GetTitan()
					points.extend( GetTitanStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_super_spectre" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//thread AiGameModes_SpawnReaper( node.GetOrigin(), node.GetAngles(), team, "npc_super_spectre_aitdm", ReaperHandler )
					// crazy reaper
					string reaperSettings = "npc_super_spectre_aitdm"
					string tickSettings = "npc_frag_drone"
					if ( CoinFlip() ) // 50% change of spawning sp ticks, 50% chance spawning mp ticks
						tickSettings = "npc_frag_drone_throwable"
					
					thread ExtraSpawner_SpawnReaperCanLaunchTicks( node.GetOrigin(), node.GetAngles(), team, reaperSettings, tickSettings )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// GUNSHIPS
		if ( file.gunships[ index ] )
		{
			int gunshipsToSpawn = file.gunshipCount - gunshipCount
			if ( gunshipsToSpawn > 0 )
			{
				for ( int i = 0; i < gunshipsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetTitan()
					points.extend( GetTitanStartPoints() ) // add startpoints for fun!
					entity node = FindBestSpawnForNPCDrop( points, team, 12 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					thread ExtraSpawner_SpawnGunShip( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// TITANS
		if ( file.titans[ index ] )
		{
			int titansToSpawn = TITANS_PER_TEAM - titanCount
			if ( titansToSpawn > 0 )
			{
				for ( int i = 0; i < titansToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetTitan()
					points.extend( GetTitanStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_titan" )
					entity node = FindBestSpawnForNPCDrop( points, team, 10 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					thread ExtraSpawner_SpawnTitan( node.GetOrigin(), node.GetAngles(), team, true )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// PILOTS
		if ( file.pilots[ index ] )
		{
			int pilotsToSpawn = file.pilotCount - titanCount // count titans
			if ( pilotsToSpawn > 0 )
			{
				for ( int i = 0; i < pilotsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points
					points.extend( GetTitanStartPoints() )
					points.extend( SpawnPoints_GetTitan() ) // new added because we've made a spawnpoint search function
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_titan" )
					ValidateNPCSpawnpoints( points, "npc_pilot_elite" ) // validate points twice so we won't have any issue
					entity node = FindBestSpawnForNPCDrop( points, team, 15 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//entity titan = AiGameModes_SpawnTitanRandom( node.GetOrigin(), node.GetAngles(), team )
					if ( ShouldSpawnBossTitan() ) 
					{
						string spawnName = GetBossTitanSpawnName() // get random bosstitan spawn name
						thread ExtraSpawner_SpawnBossTitan( node.GetOrigin(), node.GetAngles(), team, spawnName )
					}
					else
						thread ExtraSpawner_SpawnPilotCanEmbark( node.GetOrigin(), node.GetAngles(), team )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerNPCs( int team )
{
	int index = team == TEAM_MILITIA ? 0 : 1

	// handle prematch spawns
	while( GetGameState() == eGameState.Prematch || GetGameState() == eGameState.Playing )
	{
		WaitFrame() // wait a frame each loop

		int marvinCount = GetNPCArrayEx( "npc_marvin", team, -1, <0,0,0>, -1 ).len()
		int prowlerCount = GetNPCArrayEx( "npc_prowler", team, -1, <0,0,0>, -1 ).len()

		// MARVINS
		if ( file.marvins[ index ] )
		{
			const int spawnAmount = 2 // spawn 2 marvins per droppod
			const string spawnEnt = "npc_marvin"
			int marvinsToSpawn = ( MARVINS_PER_TEAM * spawnAmount - 1 - marvinCount ) / spawnAmount
			if ( marvinsToSpawn > 0 )
			{
				for ( int i = 0; i < marvinsToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn
					
					array< entity > points = SpawnPoints_GetDropPod()
					points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_marvin" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt, spawnAmount )
				}

				wait 8.0 // wait after each spawn wave
			}
		}

		// PROWLERS
		if ( file.prowlers[ index ] )
		{
			const int spawnAmount = 1 // spawn 1 prowler per droppod
			const string spawnEnt = "npc_prowler"
			int prowlersToSpawn = ( file.prowlerCount * spawnAmount - 1 - prowlerCount ) / spawnAmount
			if ( prowlersToSpawn > 0 )
			{
				for ( int i = 0; i < prowlersToSpawn; i++ )
				{
					if ( i > 0 )
						wait 2.0 // delay before next spawn

					array< entity > points = SpawnPoints_GetDropPod()
					points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
					// modified function from _ai_gamemodes.gnut, remove points with no navmesh covered
					ValidateNPCSpawnpoints( points, "npc_prowler" )
					entity node = FindBestSpawnForNPCDrop( points, team, 8 )
					UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
					//thread AiGameModes_SpawnDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt )
					thread ExtraSpawner_SpawnNPCInDropPod( node.GetOrigin(), node.GetAngles(), team, spawnEnt, spawnAmount )
				}

				wait 8.0 // wait after each spawn wave
			}
		}
	}
}

void function SpawnerWeapons( int team )
{
	wait 10 // initial wait
	
	while( GetGameState() == eGameState.Playing )
	{
		wait WEAPON_PACKAGE_INTERVAL + 1.0 // add 1.0s extra delay

		foreach( entity player in GetPlayerArrayOfTeam( team ) )
		{
			NSSendLargeMessageToPlayer( player, "補給艙運送中! ", "補充重火力與武器彈藥，並獲取一把榴彈兵武器", 15, "rui/callsigns/callsign_69_col" )
			//NSSendLargeMessageToPlayer( player, "Delivering Care Package!", "Refill ordnance and weapon ammo, also get a grenadier weapon", 15, "rui/callsigns/callsign_69_col" )
		}

		array< entity > points = SpawnPoints_GetDropPod()
		points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
		entity node = FindBestSpawnForNPCDrop( points, team, WEAPON_PACKAGE_INTERVAL * 0.5 )
		UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
		//waitthread SpawnReaperDorpsWeapons( node.GetOrigin(), node.GetAngles(), WEAPONS, MODS )
		ExtraSpawner_SpawnCarePackageToGetWeapons( node.GetOrigin(), node.GetAngles(), WEAPON_PACKAGE_INTERVAL ) // carepackages will take 10s to drop( 5s wait + 5s to fall )
	}
}

// care package variant
void function SpawnerAmmoRefill( int team )
{
	wait 10 // initial wait

	while( GetGameState() == eGameState.Playing )
	{
		wait AMMO_PACKAGE_INTERVAL + 1.0 // add 1.0s extra delay

		foreach( entity player in GetPlayerArrayOfTeam( team ) )
		{
			NSSendLargeMessageToPlayer( player, "補給艙運送中! ", "補充戰術技能、重火力與武器彈藥", 15, "rui/callsigns/callsign_69_col" )
			//NSSendLargeMessageToPlayer( player, "Delivering Care Package!", "Refill tactical ability, ordnance and weapon ammo", 15, "rui/callsigns/callsign_69_col" )
		}

		array< entity > points = SpawnPoints_GetDropPod()
		points.extend( GetDroppodStartPoints() ) // add startpoints for fun!
		entity node = FindBestSpawnForNPCDrop( points, team, AMMO_PACKAGE_INTERVAL * 0.5 )
		UpdateNPCSpawnLastUsedTime( node ) // setup used time for spawn
		//waitthread SpawnReaperDorpsWeapons( node.GetOrigin(), node.GetAngles(), WEAPONS, MODS )
		ExtraSpawner_SpawnCarePackageToRefillAmmo( node.GetOrigin(), node.GetAngles(), AMMO_PACKAGE_INTERVAL ) // carepackages will take 10s to drop( 5s wait + 5s to fall )
	}
}

// Based on points tries to balance match
void function Escalate( int team )
{
	int score = GameRules_GetTeamScore( team )
	
	foreach ( AITdmEscalatorstruct escalator in file.levelEscalators )
	{
		if ( escalator.usedByTeams.contains( team ) ) // never run the same escalator for one team
			continue
		if ( score >= escalator.scoreRequired )
		{
			if ( escalator.spawnSettingsFunc != null )
				escalator.spawnSettingsFunc( team )
			escalator.usedByTeams.append( team )
		}
	}
}

//------------------------------------------------------

entity function FindBestSpawnForNPCDrop( array<entity> spawnPoints, int team, float timeSinceLastUsedCheck = 10 )
{
	array<entity> validSpawnPoints

	// modified: make a new function so ai gamemodes don't have to re-decide for each spawn
	// due to spawn points refactor, let's change back to older version
	entity zone = DecideSpawnZone_Generic( spawnPoints, team )
	//entity zone = GetCurrentSpawnZoneForTeam( team )

	if ( IsValid( zone ) )
	{
		foreach ( entity spawn in spawnPoints )
		{
			// spawn from too far shouldn't count!
			if ( Distance2D( spawn.GetOrigin(), zone.GetOrigin() ) > 4000 )
				continue
			
			// init like spawn.nut, so player can also get that
			if ( InitNPCSpawnpoint( spawn ) )
			{
				// not inited spawn must be valid. add it to array
				validSpawnPoints.append( spawn )
				continue // we continue to next point if we mark current one as valid
			}

			// only search for those are not used recently
			if ( Time() - spawn.s.lastUsedTime > timeSinceLastUsedCheck )
			{
				validSpawnPoints.append( spawn )
				continue
			}
		}
	}
	
	// no spawn zone valid or we can't find any valid point in zone...
	// let's just find from all given points!!
	if ( validSpawnPoints.len() == 0 )
	{
		foreach ( entity spawn in spawnPoints )
		{
			// init like spawn.nut, so player can also get that
			if ( InitNPCSpawnpoint( spawn ) )
			{
				// not inited spawn must be valid. add it to array
				validSpawnPoints.append( spawn )
				continue // we continue to next point if we mark current one as valid
			}

			if ( Time() - spawn.s.lastUsedTime > timeSinceLastUsedCheck )
			{
				validSpawnPoints.append( spawn )
				continue
			}
		}
	}

	// wait what... we can't find any valid point, maybe too many entities spawning together
	// let's use all points instead...
	if ( validSpawnPoints.len() == 0 )
	{
		validSpawnPoints = spawnPoints
	}

	return validSpawnPoints[ RandomInt( validSpawnPoints.len() ) ]
}

// return true if "lastUsedTime" not in point.s
bool function InitNPCSpawnpoint( entity point )
{
	if ( !( "lastUsedTime" in point.s ) )
	{
		point.s.lastUsedTime <- -999
		return true
	}

	return false
}

void function UpdateNPCSpawnLastUsedTime( entity point )
{
	InitNPCSpawnpoint( point )

	point.s.lastUsedTime = Time()
}

// this function now gets all valid start points for droppod
// for regular cases we use SpawnPoints_GetDropPodStart( team )
array<entity> function GetDroppodStartPoints()
{
	//return GetEntArrayByClass_Expensive( "info_spawnpoint_droppod_start" )
	array<entity> allDroppodStarts
	allDroppodStarts.extend( SpawnPoints_GetDropPodStart( TEAM_IMC ) )
	allDroppodStarts.extend( SpawnPoints_GetDropPodStart( TEAM_MILITIA ) )
	return allDroppodStarts
}

array<entity> function GetTitanStartPoints()
{
	array<entity> allTitanStarts
	allTitanStarts.extend( SpawnPoints_GetTitanStart( TEAM_IMC ) )
	allTitanStarts.extend( SpawnPoints_GetTitanStart( TEAM_MILITIA ) )
	return allTitanStarts
}

//------------------------------------------------------

// ticks clean up
void function CleanUpOverloadedTicks()
{
	thread CleanUpOverloadedTicks_Threaded()
}

void function CleanUpOverloadedTicks_Threaded()
{
	int maxTicks = file.reaperCount * 2 * 4 + 2 // clean up ticks spawned by reapers
	//maxTicks += int( file.squadCountHighLevel * 1.5 ) // add some space for specialist grunt spawned ticks
	
	while ( true )
	{
		array<entity> tickArray
		foreach ( entity tick in GetNPCArrayByClass( "npc_frag_drone" ) )
		{
			if ( !IsAlive( tick ) )
				continue
			
			// player owned tick?
			if ( IsValid( tick.GetBossPlayer() ) )
				continue

			// still arming up?
			if ( !tick.ai.fragDroneArmed )
				continue

			// pending explode?
			if ( tick.Anim_IsActive() )
				continue

			tickArray.append( tick )
		}

		if( tickArray.len() > maxTicks )
		{
			// clean up first spawned tick in array
			// validation checks already done
			//tickArray[0].Signal( "SuicideSpectreExploding" ) // this will make them explode
			tickArray[0].Signal( "SuicideSpectreForceExplode" ) // signal "SuicideSpectreExploding" will cause ticks already ignited to explode instantly, which makes player unable to react...
		}

		WaitFrame()
	}
}

// npc clean up
void function TryCleanupBoredNPCGameLong()
{
	thread TryCleanupBoredNPCGameLong_Threaded()
}

// npc cleanup
const float NPC_CLEANUP_INITIAL_WAIT_TIME = 20.0 // some npcs will stand still for proximity 10s... due to my bad squadhandler logic, I think
const float NPC_CLEANUP_REQUIRED_IDLE_TIME = 20.0

void function TryCleanupBoredNPCGameLong_Threaded()
{
	// keep searching new npcs and run CleanupBoredNPCThread() for them
	while ( true )
	{
		foreach ( entity npc in GetNPCArray() )
		{
			if ( npc.GetClassName() == "npc_marvin" ) // never clean up marvins
				continue

			if ( !IsAlive( npc ) )
				continue

			// first time init
			if ( !( npc in file.npcCleanUpStartTime ) )
				file.npcCleanUpStartTime[ npc ] <- Time()
			if ( !( npc in file.npcIdleStartTime ) )
				file.npcIdleStartTime[ npc ] <- -1
			if ( !( npc in file.npcLastTickOrigin ) )
				file.npcLastTickOrigin[ npc ] <- npc.GetOrigin()

			if ( !( npc in file.npcWaitingToBeCleanUp ) )
			{
				file.npcWaitingToBeCleanUp[ npc ] <- false
				continue // first time init -- always skip because npc needs to be set into dropship/pod
			}

			if ( file.npcWaitingToBeCleanUp[ npc ] ) // this means our think for this npc is already done
				continue

			// cover spawning time from dropship/pod + before we start cleaning up
			if ( IsValid( npc.GetParent() ) || npc.e.isHotDropping )
				continue

			// init time
			float timeSinceCleanUpStart = Time() - file.npcCleanUpStartTime[ npc ]
			if ( timeSinceCleanUpStart < NPC_CLEANUP_INITIAL_WAIT_TIME )
				continue
			
			// npc already damaged, never clean up them( I guess? )
			// they can still get stuck after taking damage, I think...
			/*
			if ( npc.GetHealth() != npc.GetMaxHealth() )
			{
				file.npcWaitingToBeCleanUp[ npc ] = true // this npc will skip all checks
				continue
			}
			*/

			// start thinking
			if ( npc.Anim_IsActive() ) // anim active, such as marvin doing a job or npc being executed
				continue
			
			if ( npc.IsFrozen() ) // frozen guy, no need to clean them up
				continue

			// if the npc is owned by anyone, or has a bossplayer, we skip checks
			entity owner = npc.GetOwner()
			entity bossPlayer = npc.GetBossPlayer()
			if ( IsValid( owner ) )
				continue
			if ( IsValid( bossPlayer ) )
				continue

			// if npc is a titan with bubbleshield, we skip checks
			// also skip if titan already doomed
			if ( npc.IsTitan() )
			{
				entity soul = npc.GetTitanSoul()
				if( IsValid( soul ) )
				{
					// they can still get stuck after doomed, I think...
					/*
					if ( GetDoomedState( npc ) )
					{
						file.npcWaitingToBeCleanUp[ npc ] = true // this npc will skip all checks
						continue
					}
					*/

					entity bubbleShield = soul.soul.bubbleShield
					if ( IsValid( bubbleShield ) )
						continue
				}
			}

			array<entity> otherGuys = GetPlayerArray()
			otherGuys.extend( GetNPCArrayOfEnemies( npc.GetTeam() ) )

			bool failedChecks = false
			foreach ( entity otherGuy in otherGuys )
			{
				// skip dead people
				if ( !IsAlive( otherGuy ) )
					continue

				// don't kill if too close to anything
				if ( Distance( otherGuy.GetOrigin(), npc.GetOrigin() ) < 2000.0 )
					break

				// don't kill if ai or players can see them
				if ( otherGuy.IsPlayer() )
				{
					if ( PlayerCanSee( otherGuy, npc, true, 135 ) )
						break
				}
				else
				{
					if ( otherGuy.CanSee( npc ) )
						break
				}

				// don't kill if they can see any ai
				if ( npc.CanSee( otherGuy ) )
					break

				failedChecks = true
			}

			if ( !IsAlive( npc.GetEnemy() ) 
				&& Distance( npc.GetOrigin(), file.npcLastTickOrigin[ npc ] ) <= 64 
				) // assume they're not moving nor combating
				failedChecks = true // mark as checks failed

			// record last tick origin
			file.npcLastTickOrigin[ npc ] = npc.GetOrigin()

			if ( failedChecks )
			{
				if ( file.npcIdleStartTime[ npc ] == -1 )
				{
					file.npcIdleStartTime[ npc ] = Time()
					continue
				}
			}
			else // idle invalid!
			{
				file.npcIdleStartTime[ npc ] = -1
				continue
			}

			// idle time not enough!
			float timeSinceIdleStart = Time() - file.npcIdleStartTime[ npc ]
			if ( timeSinceIdleStart < NPC_CLEANUP_REQUIRED_IDLE_TIME )
				continue

			// all checks done!
			file.npcWaitingToBeCleanUp[ npc ] = true // no longer run thinks on this npc
			//print( "cleaning up bored npc: " + npc + " from team " + npc.GetTeam() )

			HideName( npc ) // prevent their title or health bar from showing
			TakeAllWeapons( npc ) // so they won't have a weapon floating
			
			npc.EnableNPCFlag( NPC_IGNORE_ALL ) // disable any sensing
			if ( IsValid( npc.GetEnemy() ) ) // clear out current enemy( basically for prowlers because they aren't affected by NPC_IGNORE_ALL )
				npc.ClearEnemy()
			
			// add invulnerability
			npc.SetNoTarget( true ) // disable npc targeting
			npc.SetNoTargetSmartAmmo( true ) // disable smart ammo targeting
			npc.NotSolid() // disable collision
			npc.SetInvulnerable()

			// clean up highlights
			npc.e.hasDefaultEnemyHighlight = false // no longer runs default highlight function!
			Highlight_ClearEnemyHighlight( npc )
			Highlight_ClearFriendlyHighlight( npc )

			// titan being dissolved
			if ( npc.IsTitan() )
			{
				TitanBoredToCleanUp( npc )
			}
			// reaper being dissolved
			if ( npc.GetClassName() == "npc_super_spectre" )
			{
				ReaperBoredToCleanUp( npc )
			}

			// remove any attack behavior
			npc.SetCapabilityFlag( bits_CAP_MOVE_SHOOT, false )
			npc.SetCapabilityFlag( bits_CAP_AIM_GUN, false )
			npc.SetCapabilityFlag( bits_CAP_WEAPON_RANGE_ATTACK1, false )
			npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK1, false )
			npc.SetCapabilityFlag( bits_CAP_INNATE_MELEE_ATTACK2, false )
			npc.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false )
			npc.SetCapabilityFlag( bits_CAP_MOVE_TRAVERSE, false )

			npc.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 ) // dissolve them to have better visual

			// prowler being dissolved
			// prowler being fully dissolved can crash the game?????
			// like changing hullType for them... too bad!
			// we try to destroy them while they not getting fully dissolved
			// tested something, without this check things still go right...
			// don't know why it was crashing so often
			if ( npc.GetClassName() == "npc_prowler" )
			{
				thread DelayedDestroyProwler( npc )
			}
		}
		WaitFrame()
	}
}

void function TitanBoredToCleanUp( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if( IsValid( soul ) )
	{
		// end any rodeo on it
		ForceTitanRodeoToEnd( titan )
		DisableTitanRodeo( titan )
		// try to hide a cleaning up titan's batteryContainer
		entity batteryContainer = soul.soul.batteryContainer
		if ( IsValid( batteryContainer ) )
			batteryContainer.Hide()
	}
}

void function ReaperBoredToCleanUp( entity reaper )
{
	// detonate all frag drones they owned
	if ( reaper.ai.activeMinionEntArrayID > 0 )
	{
		foreach ( entity ent in GetScriptManagedEntArray( reaper.ai.activeMinionEntArrayID ) )
		{
			if ( IsValid( ent ) ) 
			{
				if ( ent.IsNPC() && ent.ai.fragDroneArmed )
					ent.Signal( "SuicideSpectreForceExplode" ) // signal "SuicideSpectreExploding" will cause ticks already ignited to explode instantly, which makes player unable to react...
				else // minion still a grenade, or not armed ready yet... just destroy
				{
					if ( ent.IsProjectile() )
						ent.Destroy()
					else if ( ent.IsNPC() && !ent.ai.fragDroneArmed )
					{
						ent.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
						ent.SetNoTarget( true )
						ent.EnableNPCFlag( NPC_IGNORE_ALL )
						ent.NotSolid()
						ent.SetInvulnerable() // can still take radius damage after nonsolid!
					}
				}
			}
		}
	}
}

void function DelayedDestroyProwler( entity prowler )
{
	// needs to be thread off
	// try to destroy them while they not getting fully dissolved
	prowler.EndSignal( "OnDestroy" )

	wait 1.0
	prowler.DissolveStop() // prevent it crashes server
	prowler.Destroy()
}